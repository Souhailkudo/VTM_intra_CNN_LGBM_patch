diff --git a/CMakeLists.txt b/CMakeLists.txt
index 10a86aa..ee2876f 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,6 +1,11 @@
 # minimum required cmake version
 cmake_minimum_required( VERSION 3.5 FATAL_ERROR )
 
+include_directories(../LightGBM/include)
+link_directories(../LightGBM)
+
+link_libraries(_lightgbm)
+
 # project name
 if( EXTENSION_360_VIDEO )
   project( NextSoftware360 )
@@ -37,7 +42,7 @@ if( CMAKE_COMPILER_IS_GNUCC )
 endif()
 
 # set c++11
-set( CMAKE_CXX_STANDARD 11 )
+set( CMAKE_CXX_STANDARD 14 )
 set( CMAKE_CXX_STANDARD_REQUIRED ON )
 
 # compile everything position independent (even static libraries)
@@ -75,6 +80,9 @@ endif()
 # for gcc 8.2:
 bb_enable_warnings( gcc warnings-as-errors -Wno-sign-compare -Wno-class-memaccess)
 
+# Added by Souhaiel
+bb_enable_warnings( gcc -Wno-unknown-pragmas )
+
 if( XCODE )
   bb_enable_warnings( clang warnings-as-errors
                             -Wno-deprecated-declarations
@@ -93,6 +101,7 @@ else()
 endif()
 #bb_enable_warnings( clang warnings-as-errors )
 
+
 # enable warnings
 bb_enable_warnings( msvc warnings-as-errors "/wd4996" )
 
diff --git a/cfg/encoder_intra_vtm.cfg b/cfg/encoder_intra_vtm.cfg
index 685d9d1..ddd7c7a 100644
--- a/cfg/encoder_intra_vtm.cfg
+++ b/cfg/encoder_intra_vtm.cfg
@@ -1,3 +1,7 @@
+#======== Extra Settings ===============
+PredictPartition              : 1
+# WritePartition                : 1
+# ReadPartition                 : 1
 #======== File I/O =====================
 BitstreamFile                 : str.bin
 ReconFile                     : rec.yuv
diff --git a/cfg/encoder_randomaccess_vtm.cfg b/cfg/encoder_randomaccess_vtm.cfg
index 745812f..7c865f8 100644
--- a/cfg/encoder_randomaccess_vtm.cfg
+++ b/cfg/encoder_randomaccess_vtm.cfg
@@ -1,6 +1,9 @@
 #======== File I/O =====================
 BitstreamFile                 : str.bin
-ReconFile                     : rec.yuv
+# ReconFile                     : rec.yuv
+# WritePartition                : 1
+# PredictPartition                : 1
+PredictPartitionInter           : 1
 
 #======== Profile ================
 Profile                       : auto
diff --git a/cmake-build-debug/.ninja_deps b/cmake-build-debug/.ninja_deps
index 7e31309..ce7f010 100644
Binary files a/cmake-build-debug/.ninja_deps and b/cmake-build-debug/.ninja_deps differ
diff --git a/cmake-build-debug/.ninja_log b/cmake-build-debug/.ninja_log
index 438afa4..6374b79 100644
--- a/cmake-build-debug/.ninja_log
+++ b/cmake-build-debug/.ninja_log
@@ -1,218 +1,218 @@
 # ninja log v5
-6147	9108	1663579243671610433	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecLib.cpp.o	50111fc400811dab
-10175	19828	1663579192968146658	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionUtils.cpp.o	423c95f0e09d5dc9
-10600	12306	1663579185448226057	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/VLCWriter.cpp.o	77cf99b0db0f2115
-10279	11817	1663579184960231208	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/SEIwrite.cpp.o	adac3f02c81daa42
-987	2118	1663579236687684381	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/IntraPrediction.cpp.o	3bb4481150f0e352
-1854	3195	1663579237763672990	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Quant.cpp.o	1fc93ca8e35b6f4c
-4680	6147	1663579240715641735	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/Buffer_avx.cpp.o	a7182d4d39d4423b
-5815	5855	1663579240423644827	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/__/libmd5/libmd5.cpp.o	d0229136775b67b2
-3	1146	1663579235711694713	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/AdaptiveLoopFilter.cpp.o	973314dca17d0a5
-7018	7929	1663579181072272244	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/BinEncoder.cpp.o	efe7510afe690053
-6292	8791	1663579243355613780	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/VLCReader.cpp.o	df23b442daa82989
-3068	4444	1663579239011659777	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Unit.cpp.o	594eb9e253897d04
-6146	7800	1663579242367624242	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/CABACReader.cpp.o	efcb878218e2f663
-12104	14483	1663579187624203085	source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncApp.cpp.o	4e4805da5e35422b
-3	987	1663579235555696365	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Buffer.cpp.o	aa612b1490ddc431
-2587	5271	1663579239835651053	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Slice.cpp.o	e6a6a9d844fefa20
-8314	9513	1663579182656255527	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncSampleAdaptiveOffset.cpp.o	9abdc07e295c9f52
-9513	10600	1663579183740244086	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/RateCtrl.cpp.o	bf0eb1579c4fe82b
-7393	10496	1663579183632245225	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncLib.cpp.o	501c7ca44314b5f3
-3167	4680	1663579239247657278	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/UnitPartitioner.cpp.o	3b13313bec99f28
-7640	7812	1663579180944273595	../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a	5099f0365f56fd44
-2890	3912	1663579238479665410	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/SampleAdaptiveOffset.cpp.o	c9c21b828e2b3245
-11122	12623	1663579185764222721	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/WeightPredAnalysis.cpp.o	9c87fa6b0b2971d6
-4324	5817	1663579240383645250	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/AdaptiveLoopFilter_avx.cpp.o	5e4bbd12ea571b9d
-499	2384	1663579236951681586	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/LoopFilter.cpp.o	34d5ac4a9e2facbc
-3102	4677	1663579239243657320	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/UnitTools.cpp.o	fc0ef2a3c72fed9
-11817	12544	1663579185684223566	source/Lib/Utilities/CMakeFiles/Utilities.dir/program_options_lite.cpp.o	f92c171f27087096
-3420	4324	1663579238891661048	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/InitX86.cpp.o	4518b0b8e9450c2c
-746	2493	1663579237059680443	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/InterPrediction.cpp.o	85f1cbc237dd937a
-3625	4277	1663579238847661514	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/CommonDefX86.cpp.o	ab725b9d9f727e23
-4677	6284	1663579240851640295	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/InterpolationFilter_avx.cpp.o	890690fd53193054
-6243	7316	1663579241883629367	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecSlice.cpp.o	3a39dd7249d446ea
-2493	3102	1663579237671673964	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RomTr.cpp.o	6334d574f89acf46
-5817	7192	1663579241759630681	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecCu.cpp.o	69120889dbd17999
-5360	7367	1663579241935628817	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/Buffer_avx2.cpp.o	1b0677b93345258d
-1146	2037	1663579236603685270	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/PicYuvMD5.cpp.o	d24d52e9423a735f
-4919	6292	1663579240859640211	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/RdCost_avx.cpp.o	325b7e323ea5f466
-26955	28387	1663579033149825769	../bin/ninja/gcc-9.4/x86_64/debug/EncoderApp	91aa5ffe7d3eab0
-4258	5622	1663579240191647283	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/InterpolationFilter_sse41.cpp.o	b0b6c57a505a1820
-7249	9991	1663579183132250503	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncAdaptiveLoopFilter.cpp.o	d29058eba2aac019
-9372	13531	1663579186668213178	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/InterSearch.cpp.o	3bfa595dff18441d
-4218	4919	1663579239487654738	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/AffineGradientSearch_sse41.cpp.o	bc804c68d98af589
-9468	12266	1663579185404226521	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/IntraSearch.cpp.o	1762f9ab4419e3e9
-10677	12104	1663579185244228210	source/Lib/Utilities/CMakeFiles/Utilities.dir/VideoIOYuv.cpp.o	b35f4ffd4c34e363
-7849	8970	1663579182112261268	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncLibCommon.cpp.o	c0ac240a68b778d7
-0	50	1663579653647232619	build.ninja	1425761435139abd
-10497	12663	1663579185804222299	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/SEIEncoder.cpp.o	bb2d1eafdf487d31
-1448	2921	1663579237487675912	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Picture.cpp.o	e0b0a4d2e6539f1c
-2584	3167	1663579237735673286	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/SEI.cpp.o	9bbc6a40e192c6f4
-2118	3420	1663579237987670619	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Reshape.cpp.o	e43c69d684018b19
-3054	4218	1663579238787662149	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/TrQuant_EMT.cpp.o	e610376d229c4693
-5855	6363	1663579240931639449	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/AnnexBread.cpp.o	8e1ebb796da39602
-3499	4762	1663579239331656389	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/dtrace_blockstatistics.cpp.o	ca46ffc86f4801e4
-9583	10158	1663579183300248730	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionManager.cpp.o	bab8c6a216132dbe
-409	1854	1663579236419687218	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/IbcHashMap.cpp.o	48104f43cd13286d
-6363	7187	1663579241755630723	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/AQp.cpp.o	1552bc08e2acdc7
-10099	10175	1663579183312248604	../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a	4e7a83902e57d5ef
-1240	2587	1663579237155679426	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/MatrixIntraPrediction.cpp.o	73dd2aa2c9073507
-5622	6769	1663579241335635170	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/RdCost_avx2.cpp.o	6086039f7447255c
-1446	2584	1663579237151679469	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ParameterSetManager.cpp.o	239d18bb262fd4f2
-4762	6292	1663579240859640211	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/AdaptiveLoopFilter_avx2.cpp.o	cdac8c3dca38d418
-7352	8169	1663579181312269711	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncHRD.cpp.o	458609fd2082cf2
-6128	7283	1663579241851629707	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/BinDecoder.cpp.o	2b145bfb74a45e00
-3	499	1663579235067701529	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/AffineGradientSearch.cpp.o	4ec7b6daf733f42a
-2293	3324	1663579237891671634	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RdCostWeightPrediction.cpp.o	d49f4020dd12ce57
-8169	9234	1663579182376258482	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncReshape.cpp.o	4e9c40af8985772e
-6292	8164	1663579242731620388	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/SEIread.cpp.o	5093869b1209560
-4	1448	1663579236015691495	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/DepQuant.cpp.o	84cf858212c69eb1
-1900	2890	1663579237459676208	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ProfileLevelTier.cpp.o	1319d38a8cc2be6f
-1287	2293	1663579236863682518	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Mv.cpp.o	828edc44bf082a6a
-4444	6146	1663579240715641735	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/RdCost_sse41.cpp.o	64a2e3aad2a3cb56
-25832	26167	1663579199268080114	../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a	e359b55857f01f51
-7054	9372	1663579182512257047	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/CABACWriter.cpp.o	2bf532261081a57d
-8970	9583	1663579182724254809	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/NALwrite.cpp.o	c3aab821896f979
-12306	21602	1663579194740127944	source/App/EncoderApp/CMakeFiles/EncoderApp.dir/encmain.cpp.o	9701365b62576e84
-3913	5293	1663579239859650799	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/AdaptiveLoopFilter_sse41.cpp.o	44bc051c582ddcef
-12266	19501	1663579192640150122	source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncAppCfg.cpp.o	3c520dcdc1ba11f5
-2454	3054	1663579237623674472	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RomLFNST.cpp.o	ee1787d8bc3e3888
-6980	20055	1663579193192144293	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncCu.cpp.o	778d647b05aebaac
-912	1900	1663579236467686710	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/InterpolationFilter.cpp.o	84ce23663f51c1d0
-3	1287	1663579235855693189	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/CacheModel.cpp.o	2cae647bb5b8a0c1
-2384	3625	1663579238191668459	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Rom.cpp.o	29930f9aaf4fc8b9
-4277	6243	1663579240811640719	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/Buffer_sse41.cpp.o	c5998f7042f80c20
-10000	25832	1663579198948083494	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionPrediction.cpp.o	58370675c7c6b5cc
-10158	10677	1663579183820243241	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionTree.cpp.o	4d5a0184b5dafaab
-4	1446	1663579236015691495	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ContextModelling.cpp.o	2a55550588ba5737
-7813	18883	1663579192020156670	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncSlice.cpp.o	394793d27dee3df3
-4	1240	1663579235807693696	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Hash.cpp.o	5efb64f978b8eac7
-3	1127	1663579235695694882	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ChromaFormat.cpp.o	273b8326dfef33f
-5271	6128	1663579240695641947	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/AffineGradientSearch_avx2.cpp.o	8f55453ac8f090fd
-2037	3068	1663579237635674345	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/QuantRDOQ.cpp.o	e9c8559d270fd59f
-3	912	1663579235479697169	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Contexts.cpp.o	eb36065ab7100f4d
-3	2056	1663579236623685059	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/CodingStructure.cpp.o	f69b6e795aac69e4
-7323	19580	1663579192716149319	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncGOP.cpp.o	2733e0ca8334119e
-5293	6986	1663579241555632841	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/InterpolationFilter_avx2.cpp.o	24b76a406233915
-3324	4258	1663579238827661725	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/WeightPrediction.cpp.o	6742dd62077ee7e0
-7929	9468	1663579182608256033	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncModeCtrl.cpp.o	a4acd0b7fec24c1e
-1127	2454	1663579237023680824	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/MCTS.cpp.o	dc123b6a3b69ae6f
-2056	3499	1663579238067669771	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RdCost.cpp.o	18641921a55c6e9d
-2921	4485	1663579239051659354	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/TrQuant.cpp.o	6d12f26a8538cdee
-6284	7076	1663579241643631909	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/NALread.cpp.o	62c8fe5391d5acde
-4	408	1663579234975702504	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/HRD.cpp.o	5e8031e7d3dbb012
-4485	5360	1663579239927650078	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/AffineGradientSearch_avx.cpp.o	5a53eb9fc989b54a
-9991	10279	1663579183420247463	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionParam.cpp.o	f4bf79f345df7017
-3195	4485	1663579239051659354	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/dtrace.cpp.o	5f27f82f462fa99c
-2	746	1663579235315698904	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/BitStream.cpp.o	f99c3943d9597e3c
-9234	11122	1663579184264238555	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncTemporalFilter.cpp.o	671aa32363a04fed
-12544	12555	1663579185696223439	../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a	91e040709dfd6b72
-4485	5815	1663579240383645250	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse42/IbcHashmap_sse42.cpp.o	ec8ea3ad8795da31
-2	319	1663579654923218907	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/AffineGradientSearch.cpp.o	d27119baec417dcb
-2	526	1663579655127216714	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/BitStream.cpp.o	a9d2cd13abbcc841
-3	639	1663579655239215510	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/HRD.cpp.o	fd6dd8a6ec9e59
-3	826	1663579655427213490	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/CacheModel.cpp.o	9e89feb48c621908
-3	1124	1663579655727210267	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ChromaFormat.cpp.o	b2726ddb3723f8a5
-3	1160	1663579655763209880	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ContextModelling.cpp.o	11d41a0f2470982c
-2	1295	1663579655895208461	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Buffer.cpp.o	ceaa1dafac4bf193
-3	1380	1663579655983207516	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Contexts.cpp.o	5539180d287cbfcf
-3	1458	1663579656059206699	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/DepQuant.cpp.o	1abd4c5fd824ee34
-3	1459	1663579656059206699	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Hash.cpp.o	456766115e7a82da
-320	1471	1663579656071206570	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/IbcHashMap.cpp.o	fda24b8ebbd26daf
-2	1761	1663579656363203432	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/AdaptiveLoopFilter.cpp.o	9babdd9d00982f2f
-3	1923	1663579656523201712	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/CodingStructure.cpp.o	599c76c09590f166
-826	2020	1663579656623200638	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/InterpolationFilter.cpp.o	d13cca609812ab3d
-639	2081	1663579656683199993	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/InterPrediction.cpp.o	6811d42ce0a9f3ae
-526	2087	1663579656687199950	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/LoopFilter.cpp.o	b0c5673fa2f1c66c
-1295	2402	1663579657003196555	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/PicYuvMD5.cpp.o	98b4ee5dff462d5d
-1160	2438	1663579657039196168	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/MCTS.cpp.o	68a8c382823024cd
-1459	2477	1663579657079195737	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Mv.cpp.o	3c67d3437ce01bc9
-1380	2483	1663579657083195694	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/MatrixIntraPrediction.cpp.o	563a46530009c12a
-1459	2573	1663579657175194706	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ParameterSetManager.cpp.o	934d935d34b1dd5f
-1124	2578	1663579657179194663	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/IntraPrediction.cpp.o	d4e5db875f88e00d
-1923	2602	1663579657203194405	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ProfileLevelTier.cpp.o	7a533112ca054e05
-1471	2948	1663579657547190708	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Picture.cpp.o	8f23b38afebd87a5
-1761	3023	1663579657623189891	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Quant.cpp.o	6a95122c15e3405
-2477	3086	1663579657687189204	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RomLFNST.cpp.o	d842f954d3435697
-2483	3088	1663579657691189161	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RomTr.cpp.o	3390f83796fcf809
-2402	3163	1663579657763188386	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RdCostWeightPrediction.cpp.o	7435489241d0b9a5
-2573	3255	1663579657855187399	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/SEI.cpp.o	6d393ece0e868be2
-2087	3409	1663579658011185722	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Reshape.cpp.o	21ef1ba06f2968c8
-2020	3454	1663579658055185249	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/QuantRDOQ.cpp.o	efb36011b683682a
-2602	3652	1663579658255183100	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/SampleAdaptiveOffset.cpp.o	d39d474a4207fa97
-2438	3696	1663579658295182670	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Rom.cpp.o	313b35a21fb17eb9
-2081	3765	1663579658367181896	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RdCost.cpp.o	8bbf7d848693fa28
-3255	4157	1663579658759177683	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/dtrace.cpp.o	27aa8b77851949f8
-3023	4162	1663579658763177641	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/TrQuant_EMT.cpp.o	fb4f9bf096ccd22e
-3454	4349	1663579658951175620	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/InitX86.cpp.o	b7fa6672f59428b7
-3696	4356	1663579658959175533	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/CommonDefX86.cpp.o	739a5c62755cb7d1
-3086	4516	1663579659119173814	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Unit.cpp.o	95cec30203f93a06
-2948	4561	1663579659163173342	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/TrQuant.cpp.o	4f9a2ab94f4bdf23
-3652	4589	1663579659191173041	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/dtrace_blockstatistics.cpp.o	b7f36d127483a376
-3163	4595	1663579659195172998	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/UnitPartitioner.cpp.o	b01675c28632b2bd
-3409	4657	1663579659259172310	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/WeightPrediction.cpp.o	7e01a9088469d985
-4157	4759	1663579659359171235	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/AffineGradientSearch_sse41.cpp.o	fb30cefa4cf90ff0
-3088	5061	1663579659663167968	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/UnitTools.cpp.o	bb6547aa73cadd17
-3765	5216	1663579659819166291	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/AdaptiveLoopFilter_sse41.cpp.o	15e41bf14e143bf0
-4589	5284	1663579659887165561	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/AffineGradientSearch_avx.cpp.o	aec7471350cfcf94
-2578	5311	1663579659907165345	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Slice.cpp.o	5ce048067111a04c
-4516	5571	1663579660171162509	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/RdCost_sse41.cpp.o	25f915ca5708bc8e
-5216	5750	1663579660351160574	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/AffineGradientSearch_avx2.cpp.o	9bc8d47286f61e5a
-5750	5776	1663579660379160273	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/__/libmd5/libmd5.cpp.o	3b0406d5db8e70d9
-4162	5933	1663579660535158596	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/InterpolationFilter_sse41.cpp.o	50d66684af4e286f
-4356	6047	1663579660647157393	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/AdaptiveLoopFilter_avx.cpp.o	6813ffc1ed9f31f9
-4657	6210	1663579660811155630	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/Buffer_avx.cpp.o	1f5e80ae62cad1aa
-4349	6232	1663579660835155371	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/Buffer_sse41.cpp.o	c6f1115e167c1366
-4561	6240	1663579660843155286	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse42/IbcHashmap_sse42.cpp.o	506b5fa7394c66aa
-4759	6388	1663579660991153696	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/AdaptiveLoopFilter_avx2.cpp.o	13e5d60aff7f9d6d
-5933	6462	1663579661063152921	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/AnnexBread.cpp.o	c3554603d3dbae97
-4595	6474	1663579661075152793	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/InterpolationFilter_avx.cpp.o	efd64265bde730c0
-5061	6533	1663579661135152148	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/RdCost_avx.cpp.o	bf3f3cef1ab55464
-5571	6701	1663579661303150341	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/RdCost_avx2.cpp.o	7883cfd77124022a
-6388	6901	1663579661503148192	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/NALread.cpp.o	511ebde3a3e3e2e3
-5284	6908	1663579661507148149	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/InterpolationFilter_avx2.cpp.o	998f438fc7b9f11f
-6047	7217	1663579661819144796	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/BinDecoder.cpp.o	4238d33f1e1ec1a9
-5776	7261	1663579661863144324	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecCu.cpp.o	60af9767fcafed2a
-5311	7427	1663579662027142561	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/Buffer_avx2.cpp.o	93094877aaf2622a
-6533	7444	1663579662047142346	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/AQp.cpp.o	5c52f78806b74b2d
-7427	7603	1663579662195140755	../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a	5099f0365f56fd44
-6210	7901	1663579662503137445	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/CABACReader.cpp.o	1f01e3ec033a887e
-6240	7921	1663579662523137230	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecSlice.cpp.o	4d44865a59b684ed
-6901	8291	1663579662891133274	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/BinEncoder.cpp.o	171f54f78ec05e7e
-6462	8600	1663579663199129964	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/SEIread.cpp.o	377bec605c0824e0
-7444	8682	1663579663283129062	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncHRD.cpp.o	9fdf88543a064d46
-7217	9072	1663579663671124891	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncAdaptiveLoopFilter.cpp.o	253043e593abf676
-7921	9174	1663579663775123773	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncLibCommon.cpp.o	984ee08a9045cafe
-6474	9461	1663579664059120721	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/VLCReader.cpp.o	a6e37e569c55fcdb
-9072	9465	1663579664067120635	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/NALwrite.cpp.o	9a25376fbf5d20a6
-6908	9545	1663579664147119775	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/CABACWriter.cpp.o	389e1850a43375f3
-6232	9664	1663579664263118528	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecLib.cpp.o	4b5f8b49c662bd79
-9664	9715	1663579664315117969	../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a	4e7a83902e57d5ef
-8600	9774	1663579664375117324	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncReshape.cpp.o	102db204fdadf08c
-9775	9953	1663579664555115390	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionParam.cpp.o	3cad4e3c06d0d495
-9715	10287	1663579664887111821	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionManager.cpp.o	2b08647288bb1ad2
-9545	10498	1663579665099109542	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/RateCtrl.cpp.o	3d8f92b377c44636
-8682	10548	1663579665147109027	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncSampleAdaptiveOffset.cpp.o	bdbc550d35b79a1f
-8291	10565	1663579665167108811	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncModeCtrl.cpp.o	6bbd7b7f7b50af92
-10287	10796	1663579665399106318	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionTree.cpp.o	a7886e625fddf608
-9174	11038	1663579665639103738	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncTemporalFilter.cpp.o	856b5445220a9759
-7603	11741	1663579666339096214	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncLib.cpp.o	a5ed8297bdadd6d3
-9465	11860	1663579666459094924	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/IntraSearch.cpp.o	d80c087544763814
-10548	12125	1663579666727092044	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/SEIwrite.cpp.o	9f6f9e9efd36ff76
-11038	12329	1663579666931089850	source/Lib/Utilities/CMakeFiles/Utilities.dir/VideoIOYuv.cpp.o	1e4ba4ebe142a4d8
-10565	12334	1663579666935089808	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/SEIEncoder.cpp.o	55cc1698a31aeb05
-11860	12335	1663579666939089765	source/Lib/Utilities/CMakeFiles/Utilities.dir/program_options_lite.cpp.o	cd9c3e3841ce7c25
-12335	12343	1663579666947089679	../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a	91e040709dfd6b72
-9461	12887	1663579667487083874	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/InterSearch.cpp.o	5aa56d3d724f9da1
-10796	12956	1663579667555083144	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/VLCWriter.cpp.o	a2ae9f82079ccbd2
-11741	13139	1663579667739081166	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/WeightPredAnalysis.cpp.o	4d777dd2e0ba6909
-12125	14617	1663579669215065300	source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncApp.cpp.o	af6f0f883014030a
-7901	17873	1663579672471030298	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncSlice.cpp.o	c566fcd72ad1775
-6701	19441	1663579674039013441	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncCu.cpp.o	64df35b39f555b8e
-12329	19819	1663579674419009356	source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncAppCfg.cpp.o	d60a2ec4af5b2492
-7261	19988	1663579674583007593	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncGOP.cpp.o	8c994cd232c7f997
-10498	20923	1663579675522997487	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionUtils.cpp.o	9eae50a4e46997ec
-12334	21468	1663579676066991638	source/App/EncoderApp/CMakeFiles/EncoderApp.dir/encmain.cpp.o	feec56a119ee44e9
-9953	25765	1663579680342945664	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionPrediction.cpp.o	68cc6966d26e748d
-25765	26089	1663579680654942310	../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a	e359b55857f01f51
-2	1446	1663580062810819675	../bin/ninja/gcc-9.4/x86_64/debug/EncoderApp	cd0df1414ffcdb7b
+5968	9869	1663768488208464986	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecLib.cpp.o	6c8aff8b59894c54
+10391	21053	1663768499392323572	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionUtils.cpp.o	8e4150027324412c
+10887	13385	1663768491724420553	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/VLCWriter.cpp.o	9d4ef92374665f5e
+10412	11409	1663768489752445476	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/SEIwrite.cpp.o	82502c6caf9e6c14
+953	2515	1663768480856557826	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/IntraPrediction.cpp.o	706dca45518b0e73
+1593	2593	1663768480936556817	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Quant.cpp.o	41727b0572215c53
+4755	6609	1663768484948506165	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/Buffer_avx.cpp.o	d5408472c8402715
+5668	5708	1663768484052517479	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/__/libmd5/libmd5.cpp.o	2e2b2387ab4ddb82
+2	1593	1663768479936569437	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/AdaptiveLoopFilter.cpp.o	32044f27d0953785
+7070	8428	1663768486768483178	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/BinEncoder.cpp.o	4aae987ec64e5ac9
+6470	9901	1663768488240464581	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/VLCReader.cpp.o	f79289d3cb6aa7a8
+2859	4027	1663768482368538740	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Unit.cpp.o	cfe23a96ca4a6f1
+5959	7283	1663768485624497627	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/CABACReader.cpp.o	b24b1b4a48a9a41d
+11877	14120	1663768492460411249	source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncApp.cpp.o	f31cf5ec505ba7a9
+2	1497	1663768479840570649	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Buffer.cpp.o	4a062da464c99b7f
+2669	5483	1663768483820520408	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Slice.cpp.o	11fb3df565545e23
+8540	10391	1663768488732458366	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncSampleAdaptiveOffset.cpp.o	25523dd89d77eba1
+9869	11317	1663768489660446639	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/RateCtrl.cpp.o	4dbcd44eea706bb5
+7305	10548	1663768488884456445	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncLib.cpp.o	2699c5f708e6e182
+3231	4449	1663768482788533438	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/UnitPartitioner.cpp.o	934db02f1686560b
+7401	7530	1663768485864494596	../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a	5099f0365f56fd44
+2731	4144	1663768482484537276	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/SampleAdaptiveOffset.cpp.o	67b1390900cf6a6b
+11317	12577	1663768490920430715	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/WeightPredAnalysis.cpp.o	ee2eced151d46b91
+4144	5668	1663768484008518035	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/AdaptiveLoopFilter_avx.cpp.o	4cb48e21901cbd4e
+553	2275	1663768480616560855	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/LoopFilter.cpp.o	dc4758ffdb39415a
+3120	4627	1663768482968531166	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/UnitTools.cpp.o	8ee148fb00f4e537
+11409	11877	1663768490220439562	source/Lib/Utilities/CMakeFiles/Utilities.dir/program_options_lite.cpp.o	d935d7c1c375e435
+3473	4814	1663768483156528792	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/InitX86.cpp.o	cb376b95723f5090
+756	2428	1663768480768558937	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/InterPrediction.cpp.o	22d120bbff3cd189
+3702	4375	1663768482716534347	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/CommonDefX86.cpp.o	4cb3cb6802311d4d
+4654	5958	1663768484300514347	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/InterpolationFilter_avx.cpp.o	1471f920ae33cfc2
+6005	7305	1663768485644497374	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecSlice.cpp.o	419a2d87529a9798
+2515	3120	1663768481464550151	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RomTr.cpp.o	1a9a3c189eadbf01
+5708	7242	1663768485584498132	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecCu.cpp.o	9dde845a7b583b17
+5483	7401	1663768485744496112	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/Buffer_avx2.cpp.o	3919ac42851851ab
+1217	2100	1663768480440563076	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/PicYuvMD5.cpp.o	70b95e700c69a0e8
+4884	6316	1663768484656509852	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/RdCost_avx.cpp.o	f1fa9a5d54eec68
+8048	9433	1663769541586601957	../bin/ninja/gcc-9.4/x86_64/debug/EncoderApp	91aa5ffe7d3eab0
+4086	5903	1663768484244515055	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/InterpolationFilter_sse41.cpp.o	62c2a36d74b953e1
+7108	9378	1663768487716471202	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncAdaptiveLoopFilter.cpp.o	d61fb9fd61daf971
+9435	12175	1663768490512435872	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/InterSearch.cpp.o	834653aeb8cbeb76
+4039	4884	1663768483224527933	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/AffineGradientSearch_sse41.cpp.o	d7876aec82af5d1f
+9508	12313	1663768490652434102	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/IntraSearch.cpp.o	184013c9457d7da6
+10982	11932	1663768490272438905	source/Lib/Utilities/CMakeFiles/Utilities.dir/VideoIOYuv.cpp.o	7f951f72880505b6
+7643	8469	1663768486812482621	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncLibCommon.cpp.o	2f861c225af37cfe
+0	50	1663769640561271598	build.ninja	1425761435139abd
+10548	13156	1663768491496423434	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/SEIEncoder.cpp.o	df78822b381c3525
+1497	2731	1663768481072555099	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Picture.cpp.o	af79410b2745bdde
+2593	3391	1663768481732546769	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/SEI.cpp.o	af8e6e857b6c42cf
+2275	3473	1663768481816545708	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Reshape.cpp.o	cbc8c65113095f68
+2849	4039	1663768482380538588	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/TrQuant_EMT.cpp.o	4e7616b3110d21b1
+5893	6459	1663768484800508034	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/AnnexBread.cpp.o	5394eac17cc67fd8
+3518	4755	1663768483096529550	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/dtrace_blockstatistics.cpp.o	c195989f8e8b0da6
+9952	10412	1663768488756458062	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionManager.cpp.o	f8947f96017aa8dd
+374	1904	1663768480244565550	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/IbcHashMap.cpp.o	93a11d93c5524dba
+6609	7643	1663768485984493080	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/AQp.cpp.o	5f0b6fc1c52a16e
+9901	9951	1663768488288463975	../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a	4e7a83902e57d5ef
+1377	2669	1663768481012555857	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/MatrixIntraPrediction.cpp.o	8cde8f77f41e1fb1
+5635	7099	1663768485440499951	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/RdCost_avx2.cpp.o	3f9bdf31a5ea93f9
+1443	2849	1663768481192553585	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ParameterSetManager.cpp.o	4df38f9f9f9a7b2
+4814	6469	1663768484812507882	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/AdaptiveLoopFilter_avx2.cpp.o	9af76a2f1328e051
+7283	8540	1663768486880481763	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncHRD.cpp.o	7327f8459cbe3e52
+5903	7108	1663768485448499850	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/BinDecoder.cpp.o	5d13dab62b5fa24e
+2	374	1663768478716584832	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/AffineGradientSearch.cpp.o	e198025002cc278a
+2388	3231	1663768481572548788	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RdCostWeightPrediction.cpp.o	4d46cef78acb75fd
+8469	10124	1663768488464461751	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncReshape.cpp.o	a1b6944108cc9a17
+6459	8927	1663768487264476912	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/SEIread.cpp.o	27a107aadfb4f209
+3	1217	1663768479560574182	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/DepQuant.cpp.o	2a8988f235a61d44
+1800	2766	1663768481108554645	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ProfileLevelTier.cpp.o	cb91af3726237cf2
+1407	2388	1663768480728559442	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Mv.cpp.o	f23c89141bc1e962
+4375	5968	1663768484308514246	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/RdCost_sse41.cpp.o	87b897e364829ff0
+26143	26459	1663768504760255620	../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a	e359b55857f01f51
+7100	9435	1663768487776470444	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/CABACWriter.cpp.o	1b6b15eb83e1e840
+8927	9508	1663768487848469534	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/NALwrite.cpp.o	54bf7185322140ab
+2	8048	1663769540254619846	source/App/EncoderApp/CMakeFiles/EncoderApp.dir/encmain.cpp.o	bcdef65d1f24851
+4027	5453	1663768483796520711	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/AdaptiveLoopFilter_sse41.cpp.o	5e74f2b780a7bee
+11939	19211	1663768497548346903	source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncAppCfg.cpp.o	f93bb356db128e4
+2460	2859	1663768481200553484	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RomLFNST.cpp.o	e472dd97bb45218f
+6832	19438	1663768497772344070	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncCu.cpp.o	ea2a9d83d17e7ea7
+819	1800	1663768480140566863	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/InterpolationFilter.cpp.o	5f0f0451b1ca0125
+3	819	1663768479160579229	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/CacheModel.cpp.o	ee4e75ca31208911
+2428	3702	1663768482044542831	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Rom.cpp.o	c4931932ed248015
+4137	5635	1663768483976518439	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/Buffer_sse41.cpp.o	23c46d6381f38a89
+10124	26143	1663768504464259369	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionPrediction.cpp.o	fbe03dbf4c7fa3cf
+10367	10887	1663768489228452098	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionTree.cpp.o	c6de4399e553b32c
+3	1443	1663768479784571355	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ContextModelling.cpp.o	d73e03d2ecef5fcf
+7530	19251	1663768497588346397	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncSlice.cpp.o	728dcdc326b0476d
+3	953	1663768479296577514	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Hash.cpp.o	feb1c3052ab4ca6e
+3	1085	1663768479428575848	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ChromaFormat.cpp.o	4435ceff52f318c1
+5256	5893	1663768484236515156	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/AffineGradientSearch_avx2.cpp.o	7253e3e9c28716e6
+1904	3245	1663768481588548586	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/QuantRDOQ.cpp.o	89faea097924820b
+3	1377	1663768479720572163	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Contexts.cpp.o	7decd6c0e6b93b83
+3	1407	1663768479748571810	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/CodingStructure.cpp.o	25175105a561d22
+7242	19165	1663768497500347511	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncGOP.cpp.o	96f0cf595091fd9a
+5453	7070	1663768485412500305	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/InterpolationFilter_avx2.cpp.o	972d3fbd3e3fc694
+3391	4654	1663768482996530812	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/WeightPrediction.cpp.o	970f42345139dc0c
+8428	10085	1663768488424462257	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncModeCtrl.cpp.o	fe30f5f2288843db
+1085	2460	1663768480800558533	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/MCTS.cpp.o	ff4b2ceddc628835
+2100	3518	1663768481860545153	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RdCost.cpp.o	186a6c0f0c1ab787
+2766	4086	1663768482428537983	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/TrQuant.cpp.o	42b19bd519157947
+6316	6832	1663768485176503285	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/NALread.cpp.o	d14509aa9fe0063e
+3	553	1663768478896582560	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/HRD.cpp.o	1adf99a1c7ab68c9
+4627	5256	1663768483596523237	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/AffineGradientSearch_avx.cpp.o	854b8fc5855c4ba3
+10085	10366	1663768488708458668	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionParam.cpp.o	e49c3a2e7d06f2a2
+3245	4137	1663768482476537377	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/dtrace.cpp.o	834a1596fb0c7f02
+2	755	1663768479096580037	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/BitStream.cpp.o	3d57300b173bc457
+9378	10982	1663768489324450886	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncTemporalFilter.cpp.o	f8f221b43b31cb4f
+11932	11939	1663768490280438804	../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a	91e040709dfd6b72
+4449	6005	1663768484348513741	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse42/IbcHashmap_sse42.cpp.o	ea19f398d10eca8c
+2	315	1663769644353220590	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/AffineGradientSearch.cpp.o	c0b41c14dad1064f
+3	628	1663769644665216393	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/HRD.cpp.o	2a79f581c2af802
+2	741	1663769644781214833	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/BitStream.cpp.o	77a260cac28e0652
+2	859	1663769644897213272	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/CacheModel.cpp.o	2e101833343c30c1
+2	1015	1663769645053211173	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Contexts.cpp.o	5d42be48388398e8
+3	1058	1663769645097210581	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Hash.cpp.o	a611094bf950559f
+2	1122	1663769645161209721	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ChromaFormat.cpp.o	92a2c1b4c97f86ab
+2	1246	1663769645285208053	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Buffer.cpp.o	88d4cae15074a7e6
+315	1389	1663769645429206116	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/IbcHashMap.cpp.o	53ce7012d5faf033
+3	1390	1663769645429206116	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/DepQuant.cpp.o	bf1af5c24870991c
+3	1442	1663769645481205416	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ContextModelling.cpp.o	61e6705534c3c73e
+2	1629	1663769645669202887	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/AdaptiveLoopFilter.cpp.o	2525b72a6f195e96
+2	1948	1663769645985198637	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/CodingStructure.cpp.o	da4842c77701a5af
+1058	2063	1663769646101197076	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/MCTS.cpp.o	d8c8b9ab08f82840
+1246	2174	1663769646213195569	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/MatrixIntraPrediction.cpp.o	6812867035f5cd36
+859	2202	1663769646241195193	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/InterpolationFilter.cpp.o	bafc444895f14c64
+1390	2336	1663769646373193418	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ParameterSetManager.cpp.o	3232e76449c00641
+1122	2352	1663769646389193202	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/PicYuvMD5.cpp.o	60477b1ec62d04f
+628	2359	1663769646397193094	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/LoopFilter.cpp.o	961d89b8d819a223
+1389	2377	1663769646417192826	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Mv.cpp.o	183de159a2ba6aae
+741	2553	1663769646589190512	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/InterPrediction.cpp.o	972cf26dbe32f5d5
+1015	2598	1663769646637189865	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/IntraPrediction.cpp.o	2d6dbdc5b2c7f36c
+2377	2749	1663769646789187821	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RomTr.cpp.o	531bc315a021659
+1442	2866	1663769646905186260	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Picture.cpp.o	3006342d0c1726d8
+2359	2943	1663769646981185238	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RomLFNST.cpp.o	56dceee47037e692
+1948	2987	1663769647025184646	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ProfileLevelTier.cpp.o	d41c310d903c6a35
+1629	3019	1663769647057184216	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Quant.cpp.o	b4051fa0b2ecfc3a
+2336	3150	1663769647189182440	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RdCostWeightPrediction.cpp.o	576ff5d0b6a752da
+2174	3248	1663769647285181148	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RdCost.cpp.o	a3400911b808ef47
+2553	3439	1663769647477178566	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/SEI.cpp.o	233f273800b9741b
+2063	3600	1663769647637176413	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/QuantRDOQ.cpp.o	4b6deafb7e85588a
+2352	3610	1663769647649176253	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Rom.cpp.o	b2ed7f5e16015d98
+2943	3661	1663769647701175552	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/TrQuant_EMT.cpp.o	d9ee835e191b4635
+2202	3676	1663769647713175391	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Reshape.cpp.o	9a8d2321e2509ad1
+2749	3773	1663769647813174046	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/SampleAdaptiveOffset.cpp.o	ba51aa94821c0cb0
+3661	4079	1663769648117169956	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/CommonDefX86.cpp.o	70a1fa4c941fdc13
+3773	4351	1663769648389166297	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/AffineGradientSearch_sse41.cpp.o	ddecb394cd8acd30
+2987	4397	1663769648437165651	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Unit.cpp.o	260ffdb81c300fb0
+3600	4496	1663769648533164359	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/InitX86.cpp.o	f932baac5649ca7a
+3248	4501	1663769648537164306	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/dtrace.cpp.o	dd02d698868f04e3
+3610	4510	1663769648549164145	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/dtrace_blockstatistics.cpp.o	684476b0882fea9e
+2866	4526	1663769648565163930	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/TrQuant.cpp.o	f36520a5ec9df95a
+3440	4678	1663769648717161885	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/WeightPrediction.cpp.o	48a4f968f0394173
+3150	4819	1663769648857160001	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/UnitPartitioner.cpp.o	5aa1aa8c481bb4a2
+3019	4859	1663769648897159463	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/UnitTools.cpp.o	79c00f8093821aa
+3676	5182	1663769649221155104	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/AdaptiveLoopFilter_sse41.cpp.o	63616e1cf95cbf4e
+2598	5224	1663769649261154566	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Slice.cpp.o	10cef9938c8268f6
+4510	5253	1663769649293154136	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/AffineGradientSearch_avx.cpp.o	8b94a1532d873af6
+4397	5576	1663769649613149832	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/AdaptiveLoopFilter_avx.cpp.o	df40b500dbecc346
+4079	5711	1663769649749148001	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/InterpolationFilter_sse41.cpp.o	72e50383fef84255
+5711	5751	1663769649789147463	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/__/libmd5/libmd5.cpp.o	b16dd726da8c7732
+5182	5982	1663769650021144343	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/AffineGradientSearch_avx2.cpp.o	d726e62ef8f12ea9
+4859	6047	1663769650085143481	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/RdCost_avx.cpp.o	9a31da56b6694d21
+4501	6134	1663769650173142297	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse42/IbcHashmap_sse42.cpp.o	837bbff8820fc999
+4497	6172	1663769650209141813	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/RdCost_sse41.cpp.o	a662e4a13c93bdd0
+4678	6247	1663769650285140791	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/Buffer_avx.cpp.o	dfe425e1b7199aa5
+4352	6310	1663769650349139930	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/Buffer_sse41.cpp.o	8ef6da9ff9047337
+4819	6368	1663769650405139176	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/AdaptiveLoopFilter_avx2.cpp.o	c63d5a171cd98c35
+4526	6430	1663769650469138316	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/InterpolationFilter_avx.cpp.o	4cce44663ed80309
+5982	6555	1663769650593136647	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/AnnexBread.cpp.o	77eb937c01bba502
+6310	6830	1663769650869132934	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/NALread.cpp.o	ba239136d26f2cfc
+5576	6847	1663769650885132719	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/RdCost_avx2.cpp.o	88f282f0d04cc37e
+5224	6879	1663769650917132289	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/InterpolationFilter_avx2.cpp.o	4e3db12eeac4e1ae
+6047	7084	1663769651121129544	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/BinDecoder.cpp.o	e17e6458e0227167
+5253	7185	1663769651221128198	source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/Buffer_avx2.cpp.o	5f821765742dee3d
+5751	7219	1663769651257127715	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecCu.cpp.o	842d8331e958f121
+7185	7304	1663769651337126639	../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a	5099f0365f56fd44
+6247	7404	1663769651441125239	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecSlice.cpp.o	8d467f7c6c71e56a
+6134	7824	1663769651861119589	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/CABACReader.cpp.o	bdcf95a5d2dbab75
+6555	7847	1663769651885119266	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/AQp.cpp.o	416506985ffe210f
+6847	8094	1663769652133115930	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/BinEncoder.cpp.o	133d716fa268e373
+7304	8116	1663769652157115606	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncHRD.cpp.o	abb0853a32ef29b4
+6368	8829	1663769652865106082	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/SEIread.cpp.o	9e89b7cd50e63f09
+7084	8897	1663769652933105167	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncAdaptiveLoopFilter.cpp.o	d02866dc94663fe0
+6879	8941	1663769652977104575	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/CABACWriter.cpp.o	96b30114b56813fa
+7847	9116	1663769653153102207	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncLibCommon.cpp.o	bf831f3fda7f6cd4
+8116	9196	1663769653233101131	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncReshape.cpp.o	e049571034b8ccb7
+8897	9300	1663769653337099732	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/NALwrite.cpp.o	cff116bbca9f4b3f
+8094	9930	1663769653969091229	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncModeCtrl.cpp.o	39ae2c2929721bbd
+6430	10024	1663769654057090045	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/VLCReader.cpp.o	a912777e0aac2edf
+9300	10233	1663769654273087140	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/RateCtrl.cpp.o	f4107ad0bfd9687f
+6172	10253	1663769654285086978	source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecLib.cpp.o	5456cb670682b760
+10024	10310	1663769654349086117	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionParam.cpp.o	ff719519737f3247
+10253	10324	1663769654361085955	../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a	4e7a83902e57d5ef
+9930	10387	1663769654425085095	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionManager.cpp.o	929f243191ffb263
+8829	10563	1663769654601082726	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncSampleAdaptiveOffset.cpp.o	bd66476083425da3
+10310	10821	1663769654861079229	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionTree.cpp.o	941b9cd3c11645f3
+8941	11109	1663769655145075407	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncTemporalFilter.cpp.o	d8caeee57f869980
+7404	11306	1663769655341072771	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncLib.cpp.o	a9f6c7e5d2aef7f8
+10387	11527	1663769655565069757	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/SEIwrite.cpp.o	266463af7a1497a8
+9196	11724	1663769655761067120	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/IntraSearch.cpp.o	132d332cef95f23a
+11527	12260	1663769656297059909	source/Lib/Utilities/CMakeFiles/Utilities.dir/program_options_lite.cpp.o	c1228a1a39138fab
+11109	12426	1663769656465057649	source/Lib/Utilities/CMakeFiles/Utilities.dir/VideoIOYuv.cpp.o	bdccd81d7abb4467
+12426	12433	1663769656473057542	../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a	91e040709dfd6b72
+10563	12539	1663769656573056195	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/SEIEncoder.cpp.o	82781acf16c201ab
+9116	12654	1663769656689054635	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/InterSearch.cpp.o	91180cb700fedb18
+11306	12829	1663769656869052213	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/WeightPredAnalysis.cpp.o	223955bd441e2cf1
+10821	12992	1663769657029050060	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/VLCWriter.cpp.o	e5ee5e4d993640eb
+11724	13889	1663769657925038005	source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncApp.cpp.o	bf78651a3a723234
+6830	18494	1663769662524976114	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncCu.cpp.o	2a177f5193d61e36
+7824	19037	1663769663072968740	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncSlice.cpp.o	71fa844613d02bff
+7220	19331	1663769663364964811	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncGOP.cpp.o	fc94da3ac9b40cb5
+12260	19756	1663769663792959054	source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncAppCfg.cpp.o	bfa00743aecca506
+10324	20728	1663769664764945974	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionUtils.cpp.o	2e0aea5bfbf9901f
+12433	21520	1663769665556935317	source/App/EncoderApp/CMakeFiles/EncoderApp.dir/encmain.cpp.o	33888973bc207282
+10233	26333	1663769670348870836	source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionPrediction.cpp.o	8d00deae3dbd16c6
+26333	26660	1663769670652866745	../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a	e359b55857f01f51
+26660	28038	1663769672020848336	../bin/ninja/gcc-9.4/x86_64/debug/EncoderApp	ae9de9dc8295bdfb
diff --git a/cmake-build-debug/Testing/Temporary/LastTest.log b/cmake-build-debug/Testing/Temporary/LastTest.log
index 843e8a5..b64692d 100644
--- a/cmake-build-debug/Testing/Temporary/LastTest.log
+++ b/cmake-build-debug/Testing/Temporary/LastTest.log
@@ -1,3 +1,3 @@
-Start testing: Sep 19 11:34 CEST
+Start testing: Sep 21 16:14 CEST
 ----------------------------------------------------------
-End testing: Sep 19 11:34 CEST
+End testing: Sep 21 16:14 CEST
diff --git a/cmake-build-debug/build.ninja b/cmake-build-debug/build.ninja
index a251ad9..7d5fcff 100644
--- a/cmake-build-debug/build.ninja
+++ b/cmake-build-debug/build.ninja
@@ -81,315 +81,315 @@ build cmake_object_order_depends_target_CommonLib: phony || source/Lib/CommonLib
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/AdaptiveLoopFilter.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/AdaptiveLoopFilter.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/AdaptiveLoopFilter.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/AffineGradientSearch.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/AffineGradientSearch.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/AffineGradientSearch.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/BitStream.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/BitStream.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/BitStream.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Buffer.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/Buffer.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Buffer.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/CacheModel.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/CacheModel.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/CacheModel.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ChromaFormat.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/ChromaFormat.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ChromaFormat.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/CodingStructure.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/CodingStructure.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/CodingStructure.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ContextModelling.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/ContextModelling.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ContextModelling.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Contexts.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/Contexts.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Contexts.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/DepQuant.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/DepQuant.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/DepQuant.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/HRD.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/HRD.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/HRD.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Hash.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/Hash.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Hash.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/IbcHashMap.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/IbcHashMap.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/IbcHashMap.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/InterPrediction.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/InterPrediction.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/InterPrediction.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/InterpolationFilter.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/InterpolationFilter.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/InterpolationFilter.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/IntraPrediction.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/IntraPrediction.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/IntraPrediction.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/LoopFilter.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/LoopFilter.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/LoopFilter.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/MCTS.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/MCTS.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/MCTS.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/MatrixIntraPrediction.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/MatrixIntraPrediction.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/MatrixIntraPrediction.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Mv.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/Mv.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Mv.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ParameterSetManager.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/ParameterSetManager.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ParameterSetManager.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/PicYuvMD5.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/PicYuvMD5.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/PicYuvMD5.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Picture.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/Picture.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Picture.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ProfileLevelTier.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/ProfileLevelTier.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/ProfileLevelTier.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Quant.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/Quant.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Quant.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/QuantRDOQ.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/QuantRDOQ.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/QuantRDOQ.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RdCost.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/RdCost.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RdCost.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RdCostWeightPrediction.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/RdCostWeightPrediction.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RdCostWeightPrediction.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Reshape.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/Reshape.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Reshape.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Rom.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/Rom.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Rom.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RomLFNST.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/RomLFNST.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RomLFNST.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RomTr.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/RomTr.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/RomTr.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/SEI.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/SEI.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/SEI.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/SampleAdaptiveOffset.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/SampleAdaptiveOffset.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/SampleAdaptiveOffset.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Slice.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/Slice.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Slice.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/TrQuant.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/TrQuant.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/TrQuant.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/TrQuant_EMT.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/TrQuant_EMT.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/TrQuant_EMT.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Unit.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/Unit.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/Unit.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/UnitPartitioner.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/UnitPartitioner.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/UnitPartitioner.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/UnitTools.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/UnitTools.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/UnitTools.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/WeightPrediction.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/WeightPrediction.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/WeightPrediction.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/dtrace.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/dtrace.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/dtrace.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/dtrace_blockstatistics.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/dtrace_blockstatistics.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/dtrace_blockstatistics.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/CommonDefX86.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/x86/CommonDefX86.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/CommonDefX86.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/InitX86.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/x86/InitX86.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/InitX86.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86
 
@@ -397,7 +397,7 @@ build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/AdaptiveLoopFilter
   DEFINES = -DUSE_SSE41
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/AdaptiveLoopFilter_sse41.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -msse4.1
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41
 
@@ -405,7 +405,7 @@ build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/AffineGradientSear
   DEFINES = -DUSE_SSE41
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/AffineGradientSearch_sse41.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -msse4.1
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41
 
@@ -413,7 +413,7 @@ build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/Buffer_sse41.cpp.o
   DEFINES = -DUSE_SSE41
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/Buffer_sse41.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -msse4.1
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41
 
@@ -421,7 +421,7 @@ build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/InterpolationFilte
   DEFINES = -DUSE_SSE41
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/InterpolationFilter_sse41.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -msse4.1
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41
 
@@ -429,7 +429,7 @@ build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/RdCost_sse41.cpp.o
   DEFINES = -DUSE_SSE41
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41/RdCost_sse41.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -msse4.1
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse41
 
@@ -437,7 +437,7 @@ build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse42/IbcHashmap_sse42.c
   DEFINES = -DUSE_SSE42
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse42/IbcHashmap_sse42.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -msse4.2
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/sse42
 
@@ -445,7 +445,7 @@ build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/AdaptiveLoopFilter_a
   DEFINES = -DUSE_AVX
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/AdaptiveLoopFilter_avx.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx
 
@@ -453,7 +453,7 @@ build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/AffineGradientSearch
   DEFINES = -DUSE_AVX
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/AffineGradientSearch_avx.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx
 
@@ -461,7 +461,7 @@ build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/Buffer_avx.cpp.o: CX
   DEFINES = -DUSE_AVX
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/Buffer_avx.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx
 
@@ -469,7 +469,7 @@ build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/InterpolationFilter_
   DEFINES = -DUSE_AVX
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/InterpolationFilter_avx.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx
 
@@ -477,7 +477,7 @@ build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/RdCost_avx.cpp.o: CX
   DEFINES = -DUSE_AVX
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx/RdCost_avx.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx
 
@@ -485,7 +485,7 @@ build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/AdaptiveLoopFilter_
   DEFINES = -DUSE_AVX2
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/AdaptiveLoopFilter_avx2.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx2
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2
 
@@ -493,7 +493,7 @@ build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/AffineGradientSearc
   DEFINES = -DUSE_AVX2
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/AffineGradientSearch_avx2.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx2
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2
 
@@ -501,7 +501,7 @@ build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/Buffer_avx2.cpp.o:
   DEFINES = -DUSE_AVX2
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/Buffer_avx2.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx2
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2
 
@@ -509,7 +509,7 @@ build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/InterpolationFilter
   DEFINES = -DUSE_AVX2
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/InterpolationFilter_avx2.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx2
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2
 
@@ -517,14 +517,14 @@ build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/RdCost_avx2.cpp.o:
   DEFINES = -DUSE_AVX2
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2/RdCost_avx2.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx2
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/x86/avx2
 
 build source/Lib/CommonLib/CMakeFiles/CommonLib.dir/__/libmd5/libmd5.cpp.o: CXX_COMPILER__CommonLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/libmd5/libmd5.cpp || cmake_object_order_depends_target_CommonLib
   DEP_FILE = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/__/libmd5/libmd5.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonLib/CMakeFiles/CommonLib.dir/__/libmd5
 
@@ -586,7 +586,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/AdaptiveLoopFilter.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -594,7 +594,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/AffineGradientSearch.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -602,7 +602,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/BitStream.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -610,7 +610,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/Buffer.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -618,7 +618,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/CacheModel.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -626,7 +626,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/ChromaFormat.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -634,7 +634,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/CodingStructure.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -642,7 +642,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/ContextModelling.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -650,7 +650,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/Contexts.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -658,7 +658,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/DepQuant.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -666,7 +666,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/HRD.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -674,7 +674,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/Hash.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -682,7 +682,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/IbcHashMap.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -690,7 +690,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/InterPrediction.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -698,7 +698,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/InterpolationFilter.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -706,7 +706,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/IntraPrediction.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -714,7 +714,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/LoopFilter.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -722,7 +722,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/MCTS.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -730,7 +730,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/MatrixIntraPrediction.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -738,7 +738,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/Mv.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -746,7 +746,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/ParameterSetManager.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -754,7 +754,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/PicYuvMD5.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -762,7 +762,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/Picture.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -770,7 +770,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/ProfileLevelTier.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -778,7 +778,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/Quant.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -786,7 +786,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/QuantRDOQ.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -794,7 +794,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/RdCost.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -802,7 +802,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/RdCostWeightPrediction.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -810,7 +810,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/Reshape.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -818,7 +818,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/Rom.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -826,7 +826,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/RomLFNST.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -834,7 +834,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/RomTr.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -842,7 +842,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/SEI.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -850,7 +850,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/SampleAdaptiveOffset.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -858,7 +858,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/Slice.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -866,7 +866,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/TrQuant.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -874,7 +874,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/TrQuant_EMT.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -882,7 +882,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/Unit.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -890,7 +890,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/UnitPartitioner.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -898,7 +898,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/UnitTools.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -906,7 +906,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/WeightPrediction.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -914,7 +914,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/dtrace.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -922,7 +922,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/dtrace_blockstatistics.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
 
@@ -930,7 +930,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/CommonDefX86.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86
 
@@ -938,7 +938,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/InitX86.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86
 
@@ -946,7 +946,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1 -DUSE_SSE41
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/sse41/AdaptiveLoopFilter_sse41.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -msse4.1
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/sse41
 
@@ -954,7 +954,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1 -DUSE_SSE41
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/sse41/AffineGradientSearch_sse41.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -msse4.1
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/sse41
 
@@ -962,7 +962,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1 -DUSE_SSE41
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/sse41/Buffer_sse41.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -msse4.1
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/sse41
 
@@ -970,7 +970,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1 -DUSE_SSE41
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/sse41/InterpolationFilter_sse41.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -msse4.1
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/sse41
 
@@ -978,7 +978,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1 -DUSE_SSE41
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/sse41/RdCost_sse41.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -msse4.1
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/sse41
 
@@ -986,7 +986,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1 -DUSE_SSE42
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/sse42/IbcHashmap_sse42.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -msse4.2
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/sse42
 
@@ -994,7 +994,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1 -DUSE_AVX
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx/AdaptiveLoopFilter_avx.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx
 
@@ -1002,7 +1002,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1 -DUSE_AVX
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx/AffineGradientSearch_avx.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx
 
@@ -1010,7 +1010,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1 -DUSE_AVX
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx/Buffer_avx.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx
 
@@ -1018,7 +1018,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1 -DUSE_AVX
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx/InterpolationFilter_avx.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx
 
@@ -1026,7 +1026,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1 -DUSE_AVX
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx/RdCost_avx.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx
 
@@ -1034,7 +1034,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1 -DUSE_AVX2
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx2/AdaptiveLoopFilter_avx2.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx2
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx2
 
@@ -1042,7 +1042,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1 -DUSE_AVX2
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx2/AffineGradientSearch_avx2.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx2
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx2
 
@@ -1050,7 +1050,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1 -DUSE_AVX2
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx2/Buffer_avx2.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx2
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx2
 
@@ -1058,7 +1058,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1 -DUSE_AVX2
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx2/InterpolationFilter_avx2.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx2
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx2
 
@@ -1066,7 +1066,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1 -DUSE_AVX2
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx2/RdCost_avx2.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -mavx2
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/CommonLib/x86/avx2
 
@@ -1074,7 +1074,7 @@ build source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/libmd5/li
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/libmd5/libmd5.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/CommonAnalyserLib/CMakeFiles/CommonAnalyserLib.dir/__/libmd5
 
@@ -1136,7 +1136,7 @@ build source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/Decoder
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib/AnnexBread.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib
 
@@ -1144,7 +1144,7 @@ build source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/Decoder
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib/BinDecoder.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib
 
@@ -1152,7 +1152,7 @@ build source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/Decoder
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib/CABACReader.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib
 
@@ -1160,7 +1160,7 @@ build source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/Decoder
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib/DecCu.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib
 
@@ -1168,7 +1168,7 @@ build source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/Decoder
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib/DecLib.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib
 
@@ -1176,7 +1176,7 @@ build source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/Decoder
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib/DecSlice.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib
 
@@ -1184,7 +1184,7 @@ build source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/Decoder
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib/NALread.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib
 
@@ -1192,7 +1192,7 @@ build source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/Decoder
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib/SEIread.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib
 
@@ -1200,7 +1200,7 @@ build source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/Decoder
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib/VLCReader.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderAnalyserLib/CMakeFiles/DecoderAnalyserLib.dir/__/DecoderLib
 
@@ -1261,63 +1261,63 @@ build cmake_object_order_depends_target_DecoderLib: phony || cmake_object_order_
 build source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/AnnexBread.cpp.o: CXX_COMPILER__DecoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/AnnexBread.cpp || cmake_object_order_depends_target_DecoderLib
   DEP_FILE = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/AnnexBread.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
 
 build source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/BinDecoder.cpp.o: CXX_COMPILER__DecoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/BinDecoder.cpp || cmake_object_order_depends_target_DecoderLib
   DEP_FILE = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/BinDecoder.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
 
 build source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/CABACReader.cpp.o: CXX_COMPILER__DecoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/CABACReader.cpp || cmake_object_order_depends_target_DecoderLib
   DEP_FILE = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/CABACReader.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
 
 build source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecCu.cpp.o: CXX_COMPILER__DecoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/DecCu.cpp || cmake_object_order_depends_target_DecoderLib
   DEP_FILE = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecCu.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
 
 build source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecLib.cpp.o: CXX_COMPILER__DecoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/DecLib.cpp || cmake_object_order_depends_target_DecoderLib
   DEP_FILE = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecLib.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
 
 build source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecSlice.cpp.o: CXX_COMPILER__DecoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/DecSlice.cpp || cmake_object_order_depends_target_DecoderLib
   DEP_FILE = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/DecSlice.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
 
 build source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/NALread.cpp.o: CXX_COMPILER__DecoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/NALread.cpp || cmake_object_order_depends_target_DecoderLib
   DEP_FILE = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/NALread.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
 
 build source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/SEIread.cpp.o: CXX_COMPILER__DecoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/SEIread.cpp || cmake_object_order_depends_target_DecoderLib
   DEP_FILE = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/SEIread.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
 
 build source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/VLCReader.cpp.o: CXX_COMPILER__DecoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/VLCReader.cpp || cmake_object_order_depends_target_DecoderLib
   DEP_FILE = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir/VLCReader.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
   OBJECT_FILE_DIR = source/Lib/DecoderLib/CMakeFiles/DecoderLib.dir
 
@@ -1378,189 +1378,189 @@ build cmake_object_order_depends_target_EncoderLib: phony || cmake_object_order_
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/AQp.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/AQp.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/AQp.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/BinEncoder.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/BinEncoder.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/BinEncoder.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/CABACWriter.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/CABACWriter.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/CABACWriter.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncAdaptiveLoopFilter.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/EncAdaptiveLoopFilter.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncAdaptiveLoopFilter.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncCu.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/EncCu.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncCu.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14 -Wno-array-bounds
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncGOP.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/EncGOP.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncGOP.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncHRD.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/EncHRD.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncHRD.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncLib.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/EncLib.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncLib.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncLibCommon.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/EncLibCommon.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncLibCommon.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncModeCtrl.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/EncModeCtrl.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncModeCtrl.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncReshape.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/EncReshape.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncReshape.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncSampleAdaptiveOffset.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/EncSampleAdaptiveOffset.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncSampleAdaptiveOffset.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncSlice.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/EncSlice.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncSlice.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncTemporalFilter.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/EncTemporalFilter.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncTemporalFilter.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/InterSearch.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/InterSearch.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/InterSearch.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/IntraSearch.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/IntraSearch.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/IntraSearch.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/NALwrite.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/NALwrite.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/NALwrite.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionManager.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/PartitionManager.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionManager.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionParam.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/PartitionParam.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionParam.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionPrediction.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/PartitionPrediction.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionPrediction.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionTree.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/PartitionTree.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionTree.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionUtils.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/PartitionUtils.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionUtils.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/RateCtrl.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/RateCtrl.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/RateCtrl.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/SEIEncoder.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/SEIEncoder.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/SEIEncoder.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/SEIwrite.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/SEIwrite.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/SEIwrite.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/VLCWriter.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/VLCWriter.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/VLCWriter.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
 build source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/WeightPredAnalysis.cpp.o: CXX_COMPILER__EncoderLib_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/WeightPredAnalysis.cpp || cmake_object_order_depends_target_EncoderLib
   DEP_FILE = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/WeightPredAnalysis.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
   OBJECT_FILE_DIR = source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir
 
@@ -1621,14 +1621,14 @@ build cmake_object_order_depends_target_Utilities: phony || cmake_object_order_d
 build source/Lib/Utilities/CMakeFiles/Utilities.dir/VideoIOYuv.cpp.o: CXX_COMPILER__Utilities_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/VideoIOYuv.cpp || cmake_object_order_depends_target_Utilities
   DEP_FILE = source/Lib/Utilities/CMakeFiles/Utilities.dir/VideoIOYuv.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/Utilities/CMakeFiles/Utilities.dir
   OBJECT_FILE_DIR = source/Lib/Utilities/CMakeFiles/Utilities.dir
 
 build source/Lib/Utilities/CMakeFiles/Utilities.dir/program_options_lite.cpp.o: CXX_COMPILER__Utilities_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/program_options_lite.cpp || cmake_object_order_depends_target_Utilities
   DEP_FILE = source/Lib/Utilities/CMakeFiles/Utilities.dir/program_options_lite.cpp.o.d
   FLAGS = -fopenmp -g -fPIC -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/Lib/Utilities/CMakeFiles/Utilities.dir
   OBJECT_FILE_DIR = source/Lib/Utilities/CMakeFiles/Utilities.dir
 
@@ -1690,7 +1690,7 @@ build source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir/__/Decoder
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir/__/DecoderApp/DecApp.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/DecoderAnalyserApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/DecoderAnalyserApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir
   OBJECT_FILE_DIR = source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir/__/DecoderApp
 
@@ -1698,7 +1698,7 @@ build source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir/__/Decoder
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir/__/DecoderApp/DecAppCfg.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/DecoderAnalyserApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/DecoderAnalyserApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir
   OBJECT_FILE_DIR = source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir/__/DecoderApp
 
@@ -1706,7 +1706,7 @@ build source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir/__/Decoder
   DEFINES = -DRExt__DECODER_DEBUG_BIT_STATISTICS=1 -DRExt__DECODER_DEBUG_TOOL_STATISTICS=1
   DEP_FILE = source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir/__/DecoderApp/decmain.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/DecoderAnalyserApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/DecoderAnalyserApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../CommonLib/x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonAnalyserLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderAnalyserLib/../DecoderLib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5
   OBJECT_DIR = source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir
   OBJECT_FILE_DIR = source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir/__/DecoderApp
 
@@ -1720,8 +1720,8 @@ build source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir/__/Decoder
 
 build ../bin/ninja/gcc-9.4/x86_64/debug/DecoderAnalyserApp: CXX_EXECUTABLE_LINKER__DecoderAnalyserApp_Debug source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir/__/DecoderApp/DecApp.cpp.o source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir/__/DecoderApp/DecAppCfg.cpp.o source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir/__/DecoderApp/decmain.cpp.o | ../lib/ninja/gcc-9.4/x86_64/debug/libCommonAnalyserLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderAnalyserLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a ../lib/ninja/gcc-9.4/x86_64/debug/libCommonAnalyserLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so /usr/lib/x86_64-linux-gnu/libpthread.so || ../lib/ninja/gcc-9.4/x86_64/debug/libCommonAnalyserLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderAnalyserLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a
   FLAGS = -fopenmp -g
-  LINK_LIBRARIES = -Wl,-rpath,/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM  -l_lightgbm  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonAnalyserLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderAnalyserLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonAnalyserLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  -l_lightgbm  -pthread  /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so  /usr/lib/x86_64-linux-gnu/libpthread.so
-  LINK_PATH = -L/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM
+  LINK_LIBRARIES = -Wl,-rpath,/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM  -l_lightgbm  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonAnalyserLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderAnalyserLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonAnalyserLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  -l_lightgbm  -pthread  /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so  /usr/lib/x86_64-linux-gnu/libpthread.so
+  LINK_PATH = -L/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM
   OBJECT_DIR = source/App/DecoderAnalyserApp/CMakeFiles/DecoderAnalyserApp.dir
   POST_BUILD = cd /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/DecoderAnalyserApp && /home/sbelhadj/clion-2022.1.1/bin/cmake/linux/bin/cmake -E copy /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/bin/ninja/gcc-9.4/x86_64/debug/DecoderAnalyserApp    /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/bin/DecoderAnalyserAppStaticd
   PRE_LINK = :
@@ -1769,21 +1769,21 @@ build cmake_object_order_depends_target_DecoderApp: phony || cmake_object_order_
 build source/App/DecoderApp/CMakeFiles/DecoderApp.dir/DecApp.cpp.o: CXX_COMPILER__DecoderApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/DecoderApp/DecApp.cpp || cmake_object_order_depends_target_DecoderApp
   DEP_FILE = source/App/DecoderApp/CMakeFiles/DecoderApp.dir/DecApp.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/DecoderApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/DecoderApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/DecoderApp/CMakeFiles/DecoderApp.dir
   OBJECT_FILE_DIR = source/App/DecoderApp/CMakeFiles/DecoderApp.dir
 
 build source/App/DecoderApp/CMakeFiles/DecoderApp.dir/DecAppCfg.cpp.o: CXX_COMPILER__DecoderApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/DecoderApp/DecAppCfg.cpp || cmake_object_order_depends_target_DecoderApp
   DEP_FILE = source/App/DecoderApp/CMakeFiles/DecoderApp.dir/DecAppCfg.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/DecoderApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/DecoderApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/DecoderApp/CMakeFiles/DecoderApp.dir
   OBJECT_FILE_DIR = source/App/DecoderApp/CMakeFiles/DecoderApp.dir
 
 build source/App/DecoderApp/CMakeFiles/DecoderApp.dir/decmain.cpp.o: CXX_COMPILER__DecoderApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/DecoderApp/decmain.cpp || cmake_object_order_depends_target_DecoderApp
   DEP_FILE = source/App/DecoderApp/CMakeFiles/DecoderApp.dir/decmain.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/DecoderApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/DecoderApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/DecoderApp/CMakeFiles/DecoderApp.dir
   OBJECT_FILE_DIR = source/App/DecoderApp/CMakeFiles/DecoderApp.dir
 
@@ -1797,8 +1797,8 @@ build source/App/DecoderApp/CMakeFiles/DecoderApp.dir/decmain.cpp.o: CXX_COMPILE
 
 build ../bin/ninja/gcc-9.4/x86_64/debug/DecoderApp: CXX_EXECUTABLE_LINKER__DecoderApp_Debug source/App/DecoderApp/CMakeFiles/DecoderApp.dir/DecApp.cpp.o source/App/DecoderApp/CMakeFiles/DecoderApp.dir/DecAppCfg.cpp.o source/App/DecoderApp/CMakeFiles/DecoderApp.dir/decmain.cpp.o | ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so /usr/lib/x86_64-linux-gnu/libpthread.so || ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a
   FLAGS = -fopenmp -g
-  LINK_LIBRARIES = -Wl,-rpath,/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM  -l_lightgbm  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  -l_lightgbm  /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so  /usr/lib/x86_64-linux-gnu/libpthread.so  -pthread
-  LINK_PATH = -L/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM
+  LINK_LIBRARIES = -Wl,-rpath,/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM  -l_lightgbm  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  -l_lightgbm  /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so  /usr/lib/x86_64-linux-gnu/libpthread.so  -pthread
+  LINK_PATH = -L/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM
   OBJECT_DIR = source/App/DecoderApp/CMakeFiles/DecoderApp.dir
   POST_BUILD = cd /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/DecoderApp && /home/sbelhadj/clion-2022.1.1/bin/cmake/linux/bin/cmake -E copy /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/bin/ninja/gcc-9.4/x86_64/debug/DecoderApp    /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/bin/DecoderAppStaticd
   PRE_LINK = :
@@ -1846,21 +1846,21 @@ build cmake_object_order_depends_target_EncoderApp: phony || cmake_object_order_
 build source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncApp.cpp.o: CXX_COMPILER__EncoderApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/EncoderApp/EncApp.cpp || cmake_object_order_depends_target_EncoderApp
   DEP_FILE = source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncApp.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/EncoderApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/EncoderApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/EncoderApp/CMakeFiles/EncoderApp.dir
   OBJECT_FILE_DIR = source/App/EncoderApp/CMakeFiles/EncoderApp.dir
 
 build source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncAppCfg.cpp.o: CXX_COMPILER__EncoderApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/EncoderApp/EncAppCfg.cpp || cmake_object_order_depends_target_EncoderApp
   DEP_FILE = source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncAppCfg.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/EncoderApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/EncoderApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/EncoderApp/CMakeFiles/EncoderApp.dir
   OBJECT_FILE_DIR = source/App/EncoderApp/CMakeFiles/EncoderApp.dir
 
 build source/App/EncoderApp/CMakeFiles/EncoderApp.dir/encmain.cpp.o: CXX_COMPILER__EncoderApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/EncoderApp/encmain.cpp || cmake_object_order_depends_target_EncoderApp
   DEP_FILE = source/App/EncoderApp/CMakeFiles/EncoderApp.dir/encmain.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/EncoderApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/EncoderApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/EncoderApp/CMakeFiles/EncoderApp.dir
   OBJECT_FILE_DIR = source/App/EncoderApp/CMakeFiles/EncoderApp.dir
 
@@ -1874,8 +1874,8 @@ build source/App/EncoderApp/CMakeFiles/EncoderApp.dir/encmain.cpp.o: CXX_COMPILE
 
 build ../bin/ninja/gcc-9.4/x86_64/debug/EncoderApp: CXX_EXECUTABLE_LINKER__EncoderApp_Debug source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncApp.cpp.o source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncAppCfg.cpp.o source/App/EncoderApp/CMakeFiles/EncoderApp.dir/encmain.cpp.o | ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so /usr/lib/x86_64-linux-gnu/libpthread.so || ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a
   FLAGS = -fopenmp -g
-  LINK_LIBRARIES = -Wl,-rpath,/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM  -l_lightgbm  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  -l_lightgbm  /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so  /usr/lib/x86_64-linux-gnu/libpthread.so  -pthread
-  LINK_PATH = -L/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM
+  LINK_LIBRARIES = -Wl,-rpath,/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM  -l_lightgbm  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  -l_lightgbm  /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so  /usr/lib/x86_64-linux-gnu/libpthread.so  -pthread
+  LINK_PATH = -L/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM
   OBJECT_DIR = source/App/EncoderApp/CMakeFiles/EncoderApp.dir
   POST_BUILD = cd /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/EncoderApp && /home/sbelhadj/clion-2022.1.1/bin/cmake/linux/bin/cmake -E copy /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/bin/ninja/gcc-9.4/x86_64/debug/EncoderApp    /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/bin/EncoderAppStaticd
   PRE_LINK = :
@@ -1923,21 +1923,21 @@ build cmake_object_order_depends_target_SEIRemovalApp: phony || cmake_object_ord
 build source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir/SEIRemovalApp.cpp.o: CXX_COMPILER__SEIRemovalApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/SEIRemovalApp/SEIRemovalApp.cpp || cmake_object_order_depends_target_SEIRemovalApp
   DEP_FILE = source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir/SEIRemovalApp.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/SEIRemovalApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/SEIRemovalApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir
   OBJECT_FILE_DIR = source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir
 
 build source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir/SEIRemovalAppCfg.cpp.o: CXX_COMPILER__SEIRemovalApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/SEIRemovalApp/SEIRemovalAppCfg.cpp || cmake_object_order_depends_target_SEIRemovalApp
   DEP_FILE = source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir/SEIRemovalAppCfg.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/SEIRemovalApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/SEIRemovalApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir
   OBJECT_FILE_DIR = source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir
 
 build source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir/seiremovalmain.cpp.o: CXX_COMPILER__SEIRemovalApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/SEIRemovalApp/seiremovalmain.cpp || cmake_object_order_depends_target_SEIRemovalApp
   DEP_FILE = source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir/seiremovalmain.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/SEIRemovalApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/SEIRemovalApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir
   OBJECT_FILE_DIR = source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir
 
@@ -1951,8 +1951,8 @@ build source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir/seiremovalmain.cpp.o
 
 build ../bin/ninja/gcc-9.4/x86_64/debug/SEIRemovalApp: CXX_EXECUTABLE_LINKER__SEIRemovalApp_Debug source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir/SEIRemovalApp.cpp.o source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir/SEIRemovalAppCfg.cpp.o source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir/seiremovalmain.cpp.o | ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so /usr/lib/x86_64-linux-gnu/libpthread.so || ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a
   FLAGS = -fopenmp -g
-  LINK_LIBRARIES = -Wl,-rpath,/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM  -l_lightgbm  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  -l_lightgbm  /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so  /usr/lib/x86_64-linux-gnu/libpthread.so  -pthread
-  LINK_PATH = -L/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM
+  LINK_LIBRARIES = -Wl,-rpath,/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM  -l_lightgbm  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  -l_lightgbm  /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so  /usr/lib/x86_64-linux-gnu/libpthread.so  -pthread
+  LINK_PATH = -L/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM
   OBJECT_DIR = source/App/SEIRemovalApp/CMakeFiles/SEIRemovalApp.dir
   POST_BUILD = cd /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/SEIRemovalApp && /home/sbelhadj/clion-2022.1.1/bin/cmake/linux/bin/cmake -E copy /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/bin/ninja/gcc-9.4/x86_64/debug/SEIRemovalApp    /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/bin/SEIRemovalAppStaticd
   PRE_LINK = :
@@ -2000,7 +2000,7 @@ build cmake_object_order_depends_target_parcat: phony || cmake_object_order_depe
 build source/App/Parcat/CMakeFiles/parcat.dir/parcat.cpp.o: CXX_COMPILER__parcat_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/Parcat/parcat.cpp || cmake_object_order_depends_target_parcat
   DEP_FILE = source/App/Parcat/CMakeFiles/parcat.dir/parcat.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/Parcat -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/Parcat -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/Parcat/CMakeFiles/parcat.dir
   OBJECT_FILE_DIR = source/App/Parcat/CMakeFiles/parcat.dir
 
@@ -2014,8 +2014,8 @@ build source/App/Parcat/CMakeFiles/parcat.dir/parcat.cpp.o: CXX_COMPILER__parcat
 
 build ../bin/ninja/gcc-9.4/x86_64/debug/parcat: CXX_EXECUTABLE_LINKER__parcat_Debug source/App/Parcat/CMakeFiles/parcat.dir/parcat.cpp.o | ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so /usr/lib/x86_64-linux-gnu/libpthread.so || ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a
   FLAGS = -fopenmp -g
-  LINK_LIBRARIES = -Wl,-rpath,/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM  -l_lightgbm  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  -l_lightgbm  /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so  /usr/lib/x86_64-linux-gnu/libpthread.so  -pthread
-  LINK_PATH = -L/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM
+  LINK_LIBRARIES = -Wl,-rpath,/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM  -l_lightgbm  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  -l_lightgbm  /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so  /usr/lib/x86_64-linux-gnu/libpthread.so  -pthread
+  LINK_PATH = -L/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM
   OBJECT_DIR = source/App/Parcat/CMakeFiles/parcat.dir
   POST_BUILD = cd /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/Parcat && /home/sbelhadj/clion-2022.1.1/bin/cmake/linux/bin/cmake -E copy /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/bin/ninja/gcc-9.4/x86_64/debug/parcat    /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/bin/parcatStaticd
   PRE_LINK = :
@@ -2063,21 +2063,21 @@ build cmake_object_order_depends_target_StreamMergeApp: phony || cmake_object_or
 build source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir/StreamMergeApp.cpp.o: CXX_COMPILER__StreamMergeApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/StreamMergeApp/StreamMergeApp.cpp || cmake_object_order_depends_target_StreamMergeApp
   DEP_FILE = source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir/StreamMergeApp.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/StreamMergeApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/StreamMergeApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir
   OBJECT_FILE_DIR = source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir
 
 build source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir/StreamMergeAppCfg.cpp.o: CXX_COMPILER__StreamMergeApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/StreamMergeApp/StreamMergeAppCfg.cpp || cmake_object_order_depends_target_StreamMergeApp
   DEP_FILE = source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir/StreamMergeAppCfg.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/StreamMergeApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/StreamMergeApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir
   OBJECT_FILE_DIR = source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir
 
 build source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir/StreamMergeMain.cpp.o: CXX_COMPILER__StreamMergeApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/StreamMergeApp/StreamMergeMain.cpp || cmake_object_order_depends_target_StreamMergeApp
   DEP_FILE = source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir/StreamMergeMain.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/StreamMergeApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/StreamMergeApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir
   OBJECT_FILE_DIR = source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir
 
@@ -2091,8 +2091,8 @@ build source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir/StreamMergeMain.cp
 
 build ../bin/ninja/gcc-9.4/x86_64/debug/StreamMergeApp: CXX_EXECUTABLE_LINKER__StreamMergeApp_Debug source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir/StreamMergeApp.cpp.o source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir/StreamMergeAppCfg.cpp.o source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir/StreamMergeMain.cpp.o | ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so /usr/lib/x86_64-linux-gnu/libpthread.so || ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a
   FLAGS = -fopenmp -g
-  LINK_LIBRARIES = -Wl,-rpath,/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM  -l_lightgbm  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  -l_lightgbm  /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so  /usr/lib/x86_64-linux-gnu/libpthread.so  -pthread
-  LINK_PATH = -L/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM
+  LINK_LIBRARIES = -Wl,-rpath,/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM  -l_lightgbm  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  -l_lightgbm  /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so  /usr/lib/x86_64-linux-gnu/libpthread.so  -pthread
+  LINK_PATH = -L/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM
   OBJECT_DIR = source/App/StreamMergeApp/CMakeFiles/StreamMergeApp.dir
   POST_BUILD = cd /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/StreamMergeApp && /home/sbelhadj/clion-2022.1.1/bin/cmake/linux/bin/cmake -E copy /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/bin/ninja/gcc-9.4/x86_64/debug/StreamMergeApp    /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/bin/StreamMergeAppStaticd
   PRE_LINK = :
@@ -2140,21 +2140,21 @@ build cmake_object_order_depends_target_BitstreamExtractorApp: phony || cmake_ob
 build source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir/BitstreamExtractorApp.cpp.o: CXX_COMPILER__BitstreamExtractorApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp || cmake_object_order_depends_target_BitstreamExtractorApp
   DEP_FILE = source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir/BitstreamExtractorApp.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/BitstreamExtractorApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/BitstreamExtractorApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir
   OBJECT_FILE_DIR = source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir
 
 build source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir/BitstreamExtractorAppCfg.cpp.o: CXX_COMPILER__BitstreamExtractorApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/BitstreamExtractorApp/BitstreamExtractorAppCfg.cpp || cmake_object_order_depends_target_BitstreamExtractorApp
   DEP_FILE = source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir/BitstreamExtractorAppCfg.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/BitstreamExtractorApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/BitstreamExtractorApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir
   OBJECT_FILE_DIR = source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir
 
 build source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir/bitstreamextractormain.cpp.o: CXX_COMPILER__BitstreamExtractorApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/BitstreamExtractorApp/bitstreamextractormain.cpp || cmake_object_order_depends_target_BitstreamExtractorApp
   DEP_FILE = source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir/bitstreamextractormain.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/BitstreamExtractorApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/BitstreamExtractorApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir
   OBJECT_FILE_DIR = source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir
 
@@ -2168,8 +2168,8 @@ build source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir/bits
 
 build ../bin/ninja/gcc-9.4/x86_64/debug/BitstreamExtractorApp: CXX_EXECUTABLE_LINKER__BitstreamExtractorApp_Debug source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir/BitstreamExtractorApp.cpp.o source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir/BitstreamExtractorAppCfg.cpp.o source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir/bitstreamextractormain.cpp.o | ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so /usr/lib/x86_64-linux-gnu/libpthread.so || ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a
   FLAGS = -fopenmp -g
-  LINK_LIBRARIES = -Wl,-rpath,/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM  -l_lightgbm  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  -l_lightgbm  /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so  /usr/lib/x86_64-linux-gnu/libpthread.so  -pthread
-  LINK_PATH = -L/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM
+  LINK_LIBRARIES = -Wl,-rpath,/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM  -l_lightgbm  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  -l_lightgbm  /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so  /usr/lib/x86_64-linux-gnu/libpthread.so  -pthread
+  LINK_PATH = -L/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM
   OBJECT_DIR = source/App/BitstreamExtractorApp/CMakeFiles/BitstreamExtractorApp.dir
   POST_BUILD = cd /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/BitstreamExtractorApp && /home/sbelhadj/clion-2022.1.1/bin/cmake/linux/bin/cmake -E copy /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/bin/ninja/gcc-9.4/x86_64/debug/BitstreamExtractorApp    /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/bin/BitstreamExtractorAppStaticd
   PRE_LINK = :
@@ -2217,14 +2217,14 @@ build cmake_object_order_depends_target_SubpicMergeApp: phony || cmake_object_or
 build source/App/SubpicMergeApp/CMakeFiles/SubpicMergeApp.dir/SubpicMergeApp.cpp.o: CXX_COMPILER__SubpicMergeApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/SubpicMergeApp/SubpicMergeApp.cpp || cmake_object_order_depends_target_SubpicMergeApp
   DEP_FILE = source/App/SubpicMergeApp/CMakeFiles/SubpicMergeApp.dir/SubpicMergeApp.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/SubpicMergeApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/SubpicMergeApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/SubpicMergeApp/CMakeFiles/SubpicMergeApp.dir
   OBJECT_FILE_DIR = source/App/SubpicMergeApp/CMakeFiles/SubpicMergeApp.dir
 
 build source/App/SubpicMergeApp/CMakeFiles/SubpicMergeApp.dir/SubpicMergeMain.cpp.o: CXX_COMPILER__SubpicMergeApp_Debug /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/App/SubpicMergeApp/SubpicMergeMain.cpp || cmake_object_order_depends_target_SubpicMergeApp
   DEP_FILE = source/App/SubpicMergeApp/CMakeFiles/SubpicMergeApp.dir/SubpicMergeMain.cpp.o.d
   FLAGS = -fopenmp -g -fPIE -Wall -fdiagnostics-show-option -Werror -Wno-sign-compare -Wno-class-memaccess -Wno-unknown-pragmas -msse4.1 -pthread -std=gnu++14
-  INCLUDES = -I/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/SubpicMergeApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
+  INCLUDES = -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM/include -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/SubpicMergeApp -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/.. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/./x86 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/CommonLib/../libmd5 -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/EncoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/DecoderLib/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/. -I/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/source/Lib/Utilities/..
   OBJECT_DIR = source/App/SubpicMergeApp/CMakeFiles/SubpicMergeApp.dir
   OBJECT_FILE_DIR = source/App/SubpicMergeApp/CMakeFiles/SubpicMergeApp.dir
 
@@ -2238,8 +2238,8 @@ build source/App/SubpicMergeApp/CMakeFiles/SubpicMergeApp.dir/SubpicMergeMain.cp
 
 build ../bin/ninja/gcc-9.4/x86_64/debug/SubpicMergeApp: CXX_EXECUTABLE_LINKER__SubpicMergeApp_Debug source/App/SubpicMergeApp/CMakeFiles/SubpicMergeApp.dir/SubpicMergeApp.cpp.o source/App/SubpicMergeApp/CMakeFiles/SubpicMergeApp.dir/SubpicMergeMain.cpp.o | ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so /usr/lib/x86_64-linux-gnu/libpthread.so || ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a
   FLAGS = -fopenmp -g
-  LINK_LIBRARIES = -Wl,-rpath,/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM  -l_lightgbm  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  -l_lightgbm  /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so  /usr/lib/x86_64-linux-gnu/libpthread.so  -pthread
-  LINK_PATH = -L/home/sbelhadj/Downloads/LGBM_2.3.2/LightGBM
+  LINK_LIBRARIES = -Wl,-rpath,/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM  -l_lightgbm  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libEncoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libDecoderLib.a  ../lib/ninja/gcc-9.4/x86_64/debug/libUtilities.a  ../lib/ninja/gcc-9.4/x86_64/debug/libCommonLib.a  -l_lightgbm  /usr/lib/gcc/x86_64-linux-gnu/9/libgomp.so  /usr/lib/x86_64-linux-gnu/libpthread.so  -pthread
+  LINK_PATH = -L/home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/../LightGBM
   OBJECT_DIR = source/App/SubpicMergeApp/CMakeFiles/SubpicMergeApp.dir
   POST_BUILD = cd /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/cmake-build-debug/source/App/SubpicMergeApp && /home/sbelhadj/clion-2022.1.1/bin/cmake/linux/bin/cmake -E copy /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/bin/ninja/gcc-9.4/x86_64/debug/SubpicMergeApp    /home/sbelhadj/workspaces/cworkspace/VVCSoftware_10/bin/SubpicMergeAppStaticd
   PRE_LINK = :
diff --git a/cmake-build-debug/source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncApp.cpp.o b/cmake-build-debug/source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncApp.cpp.o
index 9fa6916..d24c6f4 100644
Binary files a/cmake-build-debug/source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncApp.cpp.o and b/cmake-build-debug/source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncApp.cpp.o differ
diff --git a/cmake-build-debug/source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncAppCfg.cpp.o b/cmake-build-debug/source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncAppCfg.cpp.o
index b06b7e7..1aa1b22 100644
Binary files a/cmake-build-debug/source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncAppCfg.cpp.o and b/cmake-build-debug/source/App/EncoderApp/CMakeFiles/EncoderApp.dir/EncAppCfg.cpp.o differ
diff --git a/cmake-build-debug/source/App/EncoderApp/CMakeFiles/EncoderApp.dir/encmain.cpp.o b/cmake-build-debug/source/App/EncoderApp/CMakeFiles/EncoderApp.dir/encmain.cpp.o
index 918127c..2a3bb25 100644
Binary files a/cmake-build-debug/source/App/EncoderApp/CMakeFiles/EncoderApp.dir/encmain.cpp.o and b/cmake-build-debug/source/App/EncoderApp/CMakeFiles/EncoderApp.dir/encmain.cpp.o differ
diff --git a/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncCu.cpp.o b/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncCu.cpp.o
index 51bd29e..9ce5677 100644
Binary files a/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncCu.cpp.o and b/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncCu.cpp.o differ
diff --git a/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncGOP.cpp.o b/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncGOP.cpp.o
index 69cb916..ec7881b 100644
Binary files a/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncGOP.cpp.o and b/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncGOP.cpp.o differ
diff --git a/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncSlice.cpp.o b/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncSlice.cpp.o
index 7b7c716..4671e37 100644
Binary files a/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncSlice.cpp.o and b/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/EncSlice.cpp.o differ
diff --git a/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionPrediction.cpp.o b/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionPrediction.cpp.o
index 640e71c..2068719 100644
Binary files a/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionPrediction.cpp.o and b/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionPrediction.cpp.o differ
diff --git a/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionUtils.cpp.o b/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionUtils.cpp.o
index 67802df..4f069d1 100644
Binary files a/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionUtils.cpp.o and b/cmake-build-debug/source/Lib/EncoderLib/CMakeFiles/EncoderLib.dir/PartitionUtils.cpp.o differ
diff --git a/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp b/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp
index 4aa974b..643b7b4 100644
--- a/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp
+++ b/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp
@@ -123,9 +123,9 @@ Slice BitstreamExtractorApp::xParseSliceHeader(InputNALUnit &nalu)
 bool BitstreamExtractorApp::xCheckSliceSubpicture(Slice &slice, int targetSubPicId)
 {
   PPS *pps = m_parameterSetManager.getPPS(m_picHeader.getPPSId());
-  CHECK(nullptr == pps, "referenced PPS not found");
+  CHECK_VTM(nullptr == pps, "referenced PPS not found");
   SPS *sps = m_parameterSetManager.getSPS(pps->getSPSId());
-  CHECK(nullptr == sps, "referenced SPS not found");
+  CHECK_VTM(nullptr == sps, "referenced SPS not found");
 
   if (sps->getSubPicInfoPresentFlag())
   {
@@ -319,7 +319,7 @@ void BitstreamExtractorApp::xRewritePPS(PPS &targetPPS, const PPS &sourcePPS, co
     }
   }
   numTileCols=(int)tileColBd.size() - 1;
-  CHECK (numTileCols < 1, "After extraction there should be at least one tile horizonally.");
+  CHECK_VTM(numTileCols < 1, "After extraction there should be at least one tile horizonally.");
   tileColWidth.resize(numTileCols);
   for (int i=0; i<numTileCols; i++)
   {
@@ -424,7 +424,7 @@ void BitstreamExtractorApp::xWriteVPS(VPS *vps, std::ostream& out, int layerId,
 {
   // create a new NAL unit for output
   OutputNALUnit naluOut (NAL_UNIT_VPS, layerId, temporalId);
-  CHECK( naluOut.m_temporalId, "The value of TemporalId of VPS NAL units shall be equal to 0" );
+  CHECK_VTM( naluOut.m_temporalId, "The value of TemporalId of VPS NAL units shall be equal to 0" );
 
   // write the VPS to the newly created NAL unit buffer
   m_hlSyntaxWriter.setBitstream( &naluOut.m_Bitstream );
@@ -438,7 +438,7 @@ void BitstreamExtractorApp::xWriteSPS(SPS *sps, std::ostream& out, int layerId,
 {
   // create a new NAL unit for output
   OutputNALUnit naluOut (NAL_UNIT_SPS, layerId, temporalId);
-  CHECK( naluOut.m_temporalId, "The value of TemporalId of SPS NAL units shall be equal to 0" );
+  CHECK_VTM( naluOut.m_temporalId, "The value of TemporalId of SPS NAL units shall be equal to 0" );
 
   // write the SPS to the newly created NAL unit buffer
   m_hlSyntaxWriter.setBitstream( &naluOut.m_Bitstream );
@@ -483,8 +483,8 @@ bool BitstreamExtractorApp::xCheckSEIsSubPicture(SEIMessages& SEIs, InputNALUnit
   SEIMessages scalableNestingSEIs = getSeisByType(SEIs, SEI::SCALABLE_NESTING);
   if (scalableNestingSEIs.size())
   {
-    CHECK ( scalableNestingSEIs.size() > 1, "There shall be only one Scalable Nesting SEI in one NAL unit" );
-    CHECK ( scalableNestingSEIs.size() != SEIs.size(), "Scalable Nesting SEI shall not be in the same NAL unit as other SEIs" );
+    CHECK_VTM( scalableNestingSEIs.size() > 1, "There shall be only one Scalable Nesting SEI in one NAL unit" );
+    CHECK_VTM( scalableNestingSEIs.size() != SEIs.size(), "Scalable Nesting SEI shall not be in the same NAL unit as other SEIs" );
     // check, if the scalable nesting SEI applies to the target subpicture
     SEIScalableNesting *sei = (SEIScalableNesting*) scalableNestingSEIs.front();
 
@@ -638,7 +638,7 @@ uint32_t BitstreamExtractorApp::decode()
         // if there is no VPS nal unit, there shall be one OLS and one layer.
         if (m_vpsId == 0)
         {
-          CHECK(m_targetOlsIdx != 0, "only one OLS and one layer exist, but target olsIdx is not equal to zero");
+          CHECK_VTM(m_targetOlsIdx != 0, "only one OLS and one layer exist, but target olsIdx is not equal to zero");
         }
         // Remove NAL units with nal_unit_type not equal to any of VPS_NUT, DPS_NUT, and EOB_NUT and with nuh_layer_id not included in the list LayerIdInOls[targetOlsIdx].
         NalUnitType t = nalu.m_nalUnitType;
@@ -650,8 +650,8 @@ uint32_t BitstreamExtractorApp::decode()
           vps->deriveOutputLayerSets();
         }
         uint32_t numOlss = vps->getTotalNumOLSs();
-        CHECK(m_targetOlsIdx <0  || m_targetOlsIdx >= numOlss, "target Ols shall be in the range of OLSs specified by the VPS");
-        CHECK(m_maxTemporalLayer < -1 || m_maxTemporalLayer > vps->getPtlMaxTemporalId(vps->getOlsPtlIdx(m_targetOlsIdx)), "MaxTemporalLayer shall either be equal -1 (for diabled) or in the range of 0 to vps_ptl_max_tid[ vps_ols_ptl_idx[ targetOlsIdx ] ], inclusive");
+        CHECK_VTM(m_targetOlsIdx <0  || m_targetOlsIdx >= numOlss, "target Ols shall be in the range of OLSs specified by the VPS");
+        CHECK_VTM(m_maxTemporalLayer < -1 || m_maxTemporalLayer > vps->getPtlMaxTemporalId(vps->getOlsPtlIdx(m_targetOlsIdx)), "MaxTemporalLayer shall either be equal -1 (for diabled) or in the range of 0 to vps_ptl_max_tid[ vps_ols_ptl_idx[ targetOlsIdx ] ], inclusive");
         std::vector<int> layerIdInOls = vps->getLayerIdsInOls(m_targetOlsIdx);
         bool isIncludedInTargetOls = std::find(layerIdInOls.begin(), layerIdInOls.end(), nalu.m_nuhLayerId) != layerIdInOls.end();
         writeInpuNalUnitToStream &= (isSpecialNalTypes || isIncludedInTargetOls);
@@ -681,8 +681,8 @@ uint32_t BitstreamExtractorApp::decode()
         }
         if (m_subPicIdx >= 0 && isMultiSubpicLayer[nalu.m_nuhLayerId])
         {
-          CHECK(m_subPicIdx >= sps->getNumSubPics(), "Target subpicture not found");
-          CHECK(!sps->getSubPicTreatedAsPicFlag(m_subPicIdx), "sps_subpic_treated_as_pic_flag[subpicIdxTarget] should be equal to 1 for subpicture extraction");
+          CHECK_VTM(m_subPicIdx >= sps->getNumSubPics(), "Target subpicture not found");
+          CHECK_VTM(!sps->getSubPicTreatedAsPicFlag(m_subPicIdx), "sps_subpic_treated_as_pic_flag[subpicIdxTarget] should be equal to 1 for subpicture extraction");
           xSetSPSUpdated(sps->getSPSId());
           writeInpuNalUnitToStream = false;
         }
diff --git a/source/App/DecoderApp/DecApp.cpp b/source/App/DecoderApp/DecApp.cpp
index b0af3fd..286769f 100644
--- a/source/App/DecoderApp/DecApp.cpp
+++ b/source/App/DecoderApp/DecApp.cpp
@@ -197,10 +197,10 @@ uint32_t DecApp::decode()
         // parse NAL unit syntax if within target decoding layer
         if( ( m_iMaxTemporalLayer < 0 || nalu.m_temporalId <= m_iMaxTemporalLayer ) && xIsNaluWithinTargetDecLayerIdSet( &nalu ) )
         {
-          CHECK(nalu.m_temporalId > m_iMaxTemporalLayer, "bitstream shall not include any NAL unit with TemporalId greater than HighestTid");
+          CHECK_VTM(nalu.m_temporalId > m_iMaxTemporalLayer, "bitstream shall not include any NAL unit with TemporalId greater than HighestTid");
           if (m_targetDecLayerIdSet.size())
           {
-            CHECK(std::find(m_targetDecLayerIdSet.begin(), m_targetDecLayerIdSet.end(), nalu.m_nuhLayerId) == m_targetDecLayerIdSet.end(), "bitstream shall not contain any other layers than included in the OLS with OlsIdx");
+            CHECK_VTM(std::find(m_targetDecLayerIdSet.begin(), m_targetDecLayerIdSet.end(), nalu.m_nuhLayerId) == m_targetDecLayerIdSet.end(), "bitstream shall not contain any other layers than included in the OLS with OlsIdx");
           }
           if (bPicSkipped)
           {
@@ -237,7 +237,7 @@ uint32_t DecApp::decode()
       // within the current PU, only EOS and EOB are allowed to be sent after an EOS nal unit
       if(isEosPresentInPu)
       {
-        CHECK(nalu.m_nalUnitType != NAL_UNIT_EOS && nalu.m_nalUnitType != NAL_UNIT_EOB, "When an EOS NAL unit is present in a PU, it shall be the last NAL unit among all NAL units within the PU other than other EOS NAL units or an EOB NAL unit");
+        CHECK_VTM(nalu.m_nalUnitType != NAL_UNIT_EOS && nalu.m_nalUnitType != NAL_UNIT_EOB, "When an EOS NAL unit is present in a PU, it shall be the last NAL unit among all NAL units within the PU other than other EOS NAL units or an EOB NAL unit");
       }
     }
 
@@ -354,7 +354,7 @@ uint32_t DecApp::decode()
   }
   // May need to check again one more time as in case one the bitstream has only one picture, the first check may miss it
   setOutputPicturePresentInStream();
-  CHECK(!outputPicturePresentInBitstream, "It is required that there shall be at least one picture with PictureOutputFlag equal to 1 in the bitstream")
+  CHECK_VTM(!outputPicturePresentInBitstream, "It is required that there shall be at least one picture with PictureOutputFlag equal to 1 in the bitstream")
 
   xFlushOutput( pcListPic );
 
diff --git a/source/App/EncoderApp/EncApp.cpp b/source/App/EncoderApp/EncApp.cpp
index 06012eb..604cd1e 100644
--- a/source/App/EncoderApp/EncApp.cpp
+++ b/source/App/EncoderApp/EncApp.cpp
@@ -182,7 +182,7 @@ void EncApp::xInitLibCfg()
       }
     }
   }
-  CHECK( m_numPtlsInVps == 0, "There has to be at least one PTL structure in the VPS." );
+  CHECK_VTM( m_numPtlsInVps == 0, "There has to be at least one PTL structure in the VPS." );
   vps.setNumPtls                                                 ( m_numPtlsInVps );
   vps.setPtPresentFlag                                           (0, 1);
   for (int i = 0; i < vps.getNumPtls(); i++)
@@ -203,7 +203,7 @@ void EncApp::xInitLibCfg()
   ptls[0].setTierFlag                                            ( m_levelTier );
   ptls[0].setFrameOnlyConstraintFlag                             ( m_frameOnlyConstraintFlag);
   ptls[0].setMultiLayerEnabledFlag                               ( m_multiLayerEnabledFlag);
-  CHECK((m_profile == Profile::MAIN_10 || m_profile == Profile::MAIN_10_444
+  CHECK_VTM((m_profile == Profile::MAIN_10 || m_profile == Profile::MAIN_10_444
          || m_profile == Profile::MAIN_10_STILL_PICTURE || m_profile == Profile::MAIN_10_444_STILL_PICTURE)
           && m_multiLayerEnabledFlag,
         "ptl_multilayer_enabled_flag shall be equal to 0 for non-multilayer profiles");
@@ -259,16 +259,16 @@ void EncApp::xInitLibCfg()
     m_cEncLib.setPicHeaderInSliceHeaderConstraintFlag(m_picHeaderInSliceHeaderConstraintFlag);
     m_cEncLib.setOneSlicePerPicConstraintFlag(m_oneSlicePerPicConstraintFlag);
     m_cEncLib.setNoIdrRplConstraintFlag(m_noIdrRplConstraintFlag);
-    CHECK(m_noIdrRplConstraintFlag&& m_idrRefParamList, "IDR RPL shall be deactivated when gci_no_idr_rpl_constraint_flag equal to 1");
+    CHECK_VTM(m_noIdrRplConstraintFlag&& m_idrRefParamList, "IDR RPL shall be deactivated when gci_no_idr_rpl_constraint_flag equal to 1");
 
     m_cEncLib.setNoRectSliceConstraintFlag(m_noRectSliceConstraintFlag);
-    CHECK(m_noRectSliceConstraintFlag && !m_rasterSliceFlag, "Rectangular slice shall be deactivated when gci_no_rectangular_slice_constraint_flag equal to 1");
+    CHECK_VTM(m_noRectSliceConstraintFlag && !m_rasterSliceFlag, "Rectangular slice shall be deactivated when gci_no_rectangular_slice_constraint_flag equal to 1");
 
     m_cEncLib.setOneSlicePerSubpicConstraintFlag(m_oneSlicePerSubpicConstraintFlag);
-    CHECK(m_oneSlicePerSubpicConstraintFlag && !m_singleSlicePerSubPicFlag, "Each picture shall consist of one and only one rectangular slice when gci_one_slice_per_subpic_constraint_flag equal to 1");
+    CHECK_VTM(m_oneSlicePerSubpicConstraintFlag && !m_singleSlicePerSubPicFlag, "Each picture shall consist of one and only one rectangular slice when gci_one_slice_per_subpic_constraint_flag equal to 1");
 
     m_cEncLib.setNoSubpicInfoConstraintFlag(m_noSubpicInfoConstraintFlag);
-    CHECK(m_noSubpicInfoConstraintFlag&& m_subPicInfoPresentFlag, "Subpicture information shall not present when gci_no_subpic_info_constraint_flag equal to 1");
+    CHECK_VTM(m_noSubpicInfoConstraintFlag&& m_subPicInfoPresentFlag, "Subpicture information shall not present when gci_no_subpic_info_constraint_flag equal to 1");
     m_cEncLib.setOnePictureOnlyConstraintFlag(m_onePictureOnlyConstraintFlag);
     m_cEncLib.setIntraOnlyConstraintFlag(m_intraOnlyConstraintFlag);
     m_cEncLib.setNoIdrConstraintFlag(m_noIdrConstraintFlag);
@@ -277,160 +277,160 @@ void EncApp::xInitLibCfg()
     m_cEncLib.setNoCuQpDeltaConstraintFlag(m_noCuQpDeltaConstraintFlag);
 
     m_cEncLib.setNoTrailConstraintFlag(m_noTrailConstraintFlag);
-    CHECK(m_noTrailConstraintFlag && m_iIntraPeriod != 1, "TRAIL shall be deactivated when m_noTrailConstraintFlag is equal to 1");
+    CHECK_VTM(m_noTrailConstraintFlag && m_iIntraPeriod != 1, "TRAIL shall be deactivated when m_noTrailConstraintFlag is equal to 1");
 
     m_cEncLib.setNoStsaConstraintFlag(m_noStsaConstraintFlag);
-    CHECK(m_noStsaConstraintFlag && (m_iIntraPeriod != 1 || xHasNonZeroTemporalID()), "STSA shall be deactivated when m_noStsaConstraintFlag is equal to 1");
+    CHECK_VTM(m_noStsaConstraintFlag && (m_iIntraPeriod != 1 || xHasNonZeroTemporalID()), "STSA shall be deactivated when m_noStsaConstraintFlag is equal to 1");
 
     m_cEncLib.setNoRaslConstraintFlag(m_noRaslConstraintFlag);
-    CHECK(m_noRaslConstraintFlag && (m_iIntraPeriod != 1 || xHasLeadingPicture()), "RASL shall be deactivated when m_noRaslConstraintFlag is equal to 1");
+    CHECK_VTM(m_noRaslConstraintFlag && (m_iIntraPeriod != 1 || xHasLeadingPicture()), "RASL shall be deactivated when m_noRaslConstraintFlag is equal to 1");
 
     m_cEncLib.setNoRadlConstraintFlag(m_noRadlConstraintFlag);
-    CHECK(m_noRadlConstraintFlag && (m_iIntraPeriod != 1 || xHasLeadingPicture()), "RADL shall be deactivated when m_noRadlConstraintFlag is equal to 1");
+    CHECK_VTM(m_noRadlConstraintFlag && (m_iIntraPeriod != 1 || xHasLeadingPicture()), "RADL shall be deactivated when m_noRadlConstraintFlag is equal to 1");
 
     m_cEncLib.setNoCraConstraintFlag(m_noCraConstraintFlag);
-    CHECK(m_noCraConstraintFlag && (m_iDecodingRefreshType == 1), "CRA shall be deactivated when m_noCraConstraintFlag is equal to 1");
+    CHECK_VTM(m_noCraConstraintFlag && (m_iDecodingRefreshType == 1), "CRA shall be deactivated when m_noCraConstraintFlag is equal to 1");
 
     m_cEncLib.setNoRprConstraintFlag(m_noRprConstraintFlag);
-    CHECK(m_noRprConstraintFlag && m_rprEnabledFlag, "Reference picture resampling shall be deactivated when m_noRprConstraintFlag is equal to 1");
+    CHECK_VTM(m_noRprConstraintFlag && m_rprEnabledFlag, "Reference picture resampling shall be deactivated when m_noRprConstraintFlag is equal to 1");
 
     m_cEncLib.setNoResChangeInClvsConstraintFlag(m_noResChangeInClvsConstraintFlag);
-    CHECK(m_noResChangeInClvsConstraintFlag && m_resChangeInClvsEnabled, "Resolution change in CLVS shall be deactivated when m_noResChangeInClvsConstraintFlag is equal to 1");
+    CHECK_VTM(m_noResChangeInClvsConstraintFlag && m_resChangeInClvsEnabled, "Resolution change in CLVS shall be deactivated when m_noResChangeInClvsConstraintFlag is equal to 1");
 
     m_cEncLib.setMaxBitDepthConstraintIdc(m_maxBitDepthConstraintIdc);
-    CHECK(m_internalBitDepth[CHANNEL_TYPE_LUMA] > m_maxBitDepthConstraintIdc, "Internal bit depth shall be less than or equal to m_maxBitDepthConstraintIdc");
+    CHECK_VTM(m_internalBitDepth[CHANNEL_TYPE_LUMA] > m_maxBitDepthConstraintIdc, "Internal bit depth shall be less than or equal to m_maxBitDepthConstraintIdc");
 
     m_cEncLib.setMaxChromaFormatConstraintIdc(m_maxChromaFormatConstraintIdc);
-    CHECK(m_chromaFormatIDC > m_maxChromaFormatConstraintIdc, "Chroma format Idc shall be less than or equal to m_maxBitDepthConstraintIdc");
+    CHECK_VTM(m_chromaFormatIDC > m_maxChromaFormatConstraintIdc, "Chroma format Idc shall be less than or equal to m_maxBitDepthConstraintIdc");
 
     m_cEncLib.setNoMttConstraintFlag(m_noMttConstraintFlag);
-    CHECK(m_noMttConstraintFlag && (m_uiMaxMTTHierarchyDepth || m_uiMaxMTTHierarchyDepthI || m_uiMaxMTTHierarchyDepthIChroma), "Mtt shall be deactivated when m_bNoMttConstraintFlag is equal to 1");
+    CHECK_VTM(m_noMttConstraintFlag && (m_uiMaxMTTHierarchyDepth || m_uiMaxMTTHierarchyDepthI || m_uiMaxMTTHierarchyDepthIChroma), "Mtt shall be deactivated when m_bNoMttConstraintFlag is equal to 1");
 
     m_cEncLib.setNoQtbttDualTreeIntraConstraintFlag(m_noQtbttDualTreeIntraConstraintFlag);
-    CHECK(m_noQtbttDualTreeIntraConstraintFlag && m_dualTree, "Dual tree shall be deactivated when m_bNoQtbttDualTreeIntraConstraintFlag is equal to 1");
+    CHECK_VTM(m_noQtbttDualTreeIntraConstraintFlag && m_dualTree, "Dual tree shall be deactivated when m_bNoQtbttDualTreeIntraConstraintFlag is equal to 1");
 
     m_cEncLib.setMaxLog2CtuSizeConstraintIdc(m_maxLog2CtuSizeConstraintIdc);
-    CHECK( m_uiCTUSize > (1<<(m_maxLog2CtuSizeConstraintIdc)), "CTUSize shall be less than or equal to 1 << m_maxLog2CtuSize");
+    CHECK_VTM( m_uiCTUSize > (1<<(m_maxLog2CtuSizeConstraintIdc)), "CTUSize shall be less than or equal to 1 << m_maxLog2CtuSize");
 
     m_cEncLib.setNoPartitionConstraintsOverrideConstraintFlag(m_noPartitionConstraintsOverrideConstraintFlag);
-    CHECK(m_noPartitionConstraintsOverrideConstraintFlag && m_SplitConsOverrideEnabledFlag, "Partition override shall be deactivated when m_noPartitionConstraintsOverrideConstraintFlag is equal to 1");
+    CHECK_VTM(m_noPartitionConstraintsOverrideConstraintFlag && m_SplitConsOverrideEnabledFlag, "Partition override shall be deactivated when m_noPartitionConstraintsOverrideConstraintFlag is equal to 1");
 
     m_cEncLib.setNoSaoConstraintFlag(m_noSaoConstraintFlag);
-    CHECK(m_noSaoConstraintFlag && m_bUseSAO, "SAO shall be deactivated when m_bNoSaoConstraintFlag is equal to 1");
+    CHECK_VTM(m_noSaoConstraintFlag && m_bUseSAO, "SAO shall be deactivated when m_bNoSaoConstraintFlag is equal to 1");
 
     m_cEncLib.setNoAlfConstraintFlag(m_noAlfConstraintFlag);
-    CHECK(m_noAlfConstraintFlag && m_alf, "ALF shall be deactivated when m_bNoAlfConstraintFlag is equal to 1");
+    CHECK_VTM(m_noAlfConstraintFlag && m_alf, "ALF shall be deactivated when m_bNoAlfConstraintFlag is equal to 1");
 
     m_cEncLib.setNoCCAlfConstraintFlag(m_noCCAlfConstraintFlag);
-    CHECK(m_noCCAlfConstraintFlag && m_ccalf, "CCALF shall be deactivated when m_noCCAlfConstraintFlag is equal to 1");
+    CHECK_VTM(m_noCCAlfConstraintFlag && m_ccalf, "CCALF shall be deactivated when m_noCCAlfConstraintFlag is equal to 1");
 
     m_cEncLib.setNoWeightedPredictionConstraintFlag(m_noWeightedPredictionConstraintFlag);
-    CHECK(m_noWeightedPredictionConstraintFlag && (m_useWeightedPred || m_useWeightedBiPred), "Weighted Prediction shall be deactivated when m_bNoWeightedPredictionConstraintFlag is equal to 1");
+    CHECK_VTM(m_noWeightedPredictionConstraintFlag && (m_useWeightedPred || m_useWeightedBiPred), "Weighted Prediction shall be deactivated when m_bNoWeightedPredictionConstraintFlag is equal to 1");
 
     m_cEncLib.setNoRefWraparoundConstraintFlag(m_noRefWraparoundConstraintFlag);
-    CHECK(m_noRefWraparoundConstraintFlag && m_wrapAround, "Wrap around shall be deactivated when m_bNoRefWraparoundConstraintFlag is equal to 1");
+    CHECK_VTM(m_noRefWraparoundConstraintFlag && m_wrapAround, "Wrap around shall be deactivated when m_bNoRefWraparoundConstraintFlag is equal to 1");
 
     m_cEncLib.setNoTemporalMvpConstraintFlag(m_noTemporalMvpConstraintFlag);
-    CHECK(m_noTemporalMvpConstraintFlag && m_TMVPModeId, "Temporal MVP shall be deactivated when m_bNoTemporalMvpConstraintFlag is equal to 1");
+    CHECK_VTM(m_noTemporalMvpConstraintFlag && m_TMVPModeId, "Temporal MVP shall be deactivated when m_bNoTemporalMvpConstraintFlag is equal to 1");
 
     m_cEncLib.setNoSbtmvpConstraintFlag(m_noSbtmvpConstraintFlag);
-    CHECK(m_noSbtmvpConstraintFlag && m_sbTmvpEnableFlag,
+    CHECK_VTM(m_noSbtmvpConstraintFlag && m_sbTmvpEnableFlag,
           "SbTMVP shall be deactivated when m_bNoSbtmvpConstraintFlag is equal to 1");
 
     m_cEncLib.setNoAmvrConstraintFlag(m_noAmvrConstraintFlag);
-    CHECK(m_noAmvrConstraintFlag && (m_ImvMode != IMV_OFF || m_AffineAmvr), "AMVR shall be deactivated when m_bNoAmvrConstraintFlag is equal to 1");
+    CHECK_VTM(m_noAmvrConstraintFlag && (m_ImvMode != IMV_OFF || m_AffineAmvr), "AMVR shall be deactivated when m_bNoAmvrConstraintFlag is equal to 1");
 
     m_cEncLib.setNoBdofConstraintFlag(m_noBdofConstraintFlag);
-    CHECK(m_noBdofConstraintFlag && m_BIO, "BIO shall be deactivated when m_bNoBdofConstraintFlag is equal to 1");
+    CHECK_VTM(m_noBdofConstraintFlag && m_BIO, "BIO shall be deactivated when m_bNoBdofConstraintFlag is equal to 1");
 
     m_cEncLib.setNoDmvrConstraintFlag(m_noDmvrConstraintFlag);
-    CHECK(m_noDmvrConstraintFlag && m_DMVR, "DMVR shall be deactivated when m_noDmvrConstraintFlag is equal to 1");
+    CHECK_VTM(m_noDmvrConstraintFlag && m_DMVR, "DMVR shall be deactivated when m_noDmvrConstraintFlag is equal to 1");
 
     m_cEncLib.setNoCclmConstraintFlag(m_noCclmConstraintFlag);
-    CHECK(m_noCclmConstraintFlag && m_LMChroma, "CCLM shall be deactivated when m_bNoCclmConstraintFlag is equal to 1");
+    CHECK_VTM(m_noCclmConstraintFlag && m_LMChroma, "CCLM shall be deactivated when m_bNoCclmConstraintFlag is equal to 1");
 
     m_cEncLib.setNoMtsConstraintFlag(m_noMtsConstraintFlag);
-    CHECK(m_noMtsConstraintFlag && (m_MTS || m_MTSImplicit), "MTS shall be deactivated when m_bNoMtsConstraintFlag is equal to 1");
+    CHECK_VTM(m_noMtsConstraintFlag && (m_MTS || m_MTSImplicit), "MTS shall be deactivated when m_bNoMtsConstraintFlag is equal to 1");
 
     m_cEncLib.setNoSbtConstraintFlag(m_noSbtConstraintFlag);
-    CHECK(m_noSbtConstraintFlag && m_SBT, "SBT shall be deactivated when mm_noSbtConstraintFlag_nonPackedConstraintFlag is equal to 1");
+    CHECK_VTM(m_noSbtConstraintFlag && m_SBT, "SBT shall be deactivated when mm_noSbtConstraintFlag_nonPackedConstraintFlag is equal to 1");
 
     m_cEncLib.setNoAffineMotionConstraintFlag(m_noAffineMotionConstraintFlag);
-    CHECK(m_noAffineMotionConstraintFlag && m_Affine, "Affine shall be deactivated when m_bNoAffineMotionConstraintFlag is equal to 1");
+    CHECK_VTM(m_noAffineMotionConstraintFlag && m_Affine, "Affine shall be deactivated when m_bNoAffineMotionConstraintFlag is equal to 1");
 
     m_cEncLib.setNoBcwConstraintFlag(m_noBcwConstraintFlag);
-    CHECK(m_noBcwConstraintFlag && m_bcw, "BCW shall be deactivated when m_bNoBcwConstraintFlag is equal to 1");
+    CHECK_VTM(m_noBcwConstraintFlag && m_bcw, "BCW shall be deactivated when m_bNoBcwConstraintFlag is equal to 1");
 
     m_cEncLib.setNoIbcConstraintFlag(m_noIbcConstraintFlag);
-    CHECK(m_noIbcConstraintFlag && m_IBCMode, "IBC shall be deactivated when m_noIbcConstraintFlag is equal to 1");
+    CHECK_VTM(m_noIbcConstraintFlag && m_IBCMode, "IBC shall be deactivated when m_noIbcConstraintFlag is equal to 1");
 
     m_cEncLib.setNoCiipConstraintFlag(m_noCiipConstraintFlag);
-    CHECK(m_noCiipConstraintFlag && m_ciip, "CIIP shall be deactivated when m_bNoCiipConstraintFlag is equal to 1");
+    CHECK_VTM(m_noCiipConstraintFlag && m_ciip, "CIIP shall be deactivated when m_bNoCiipConstraintFlag is equal to 1");
 
     m_cEncLib.setNoGeoConstraintFlag(m_noGeoConstraintFlag);
-    CHECK(m_noGeoConstraintFlag && m_Geo, "GEO shall be deactivated when m_noGeoConstraintFlag is equal to 1");
+    CHECK_VTM(m_noGeoConstraintFlag && m_Geo, "GEO shall be deactivated when m_noGeoConstraintFlag is equal to 1");
 
     m_cEncLib.setNoLadfConstraintFlag(m_noLadfConstraintFlag);
-    CHECK(m_noLadfConstraintFlag && m_LadfEnabed, "LADF shall be deactivated when m_bNoLadfConstraintFlag is equal to 1");
+    CHECK_VTM(m_noLadfConstraintFlag && m_LadfEnabed, "LADF shall be deactivated when m_bNoLadfConstraintFlag is equal to 1");
 
     m_cEncLib.setNoTransformSkipConstraintFlag(m_noTransformSkipConstraintFlag);
-    CHECK(m_noTransformSkipConstraintFlag && m_useTransformSkip, "Transform skip shall be deactivated when m_noTransformSkipConstraintFlag is equal to 1");
+    CHECK_VTM(m_noTransformSkipConstraintFlag && m_useTransformSkip, "Transform skip shall be deactivated when m_noTransformSkipConstraintFlag is equal to 1");
 
     m_cEncLib.setNoLumaTransformSize64ConstraintFlag(m_noLumaTransformSize64ConstraintFlag);
-    CHECK(m_noLumaTransformSize64ConstraintFlag && m_log2MaxTbSize > 5, "Max transform size shall be less than 64 when m_noLumaTransformSize64ConstraintFlag is equal to 1");
+    CHECK_VTM(m_noLumaTransformSize64ConstraintFlag && m_log2MaxTbSize > 5, "Max transform size shall be less than 64 when m_noLumaTransformSize64ConstraintFlag is equal to 1");
 
     m_cEncLib.setNoBDPCMConstraintFlag(m_noBDPCMConstraintFlag);
-    CHECK(m_noBDPCMConstraintFlag && m_useBDPCM, "BDPCM shall be deactivated when m_noBDPCMConstraintFlag is equal to 1");
+    CHECK_VTM(m_noBDPCMConstraintFlag && m_useBDPCM, "BDPCM shall be deactivated when m_noBDPCMConstraintFlag is equal to 1");
 
     m_cEncLib.setNoJointCbCrConstraintFlag(m_noJointCbCrConstraintFlag);
-    CHECK(m_noJointCbCrConstraintFlag && m_JointCbCrMode, "JCCR shall be deactivated when m_noJointCbCrConstraintFlag is equal to 1");
+    CHECK_VTM(m_noJointCbCrConstraintFlag && m_JointCbCrMode, "JCCR shall be deactivated when m_noJointCbCrConstraintFlag is equal to 1");
 
     m_cEncLib.setNoDepQuantConstraintFlag(m_noDepQuantConstraintFlag);
-    CHECK(m_noDepQuantConstraintFlag && m_depQuantEnabledFlag, "DQ shall be deactivated when m_bNoDepQuantConstraintFlag is equal to 1");
+    CHECK_VTM(m_noDepQuantConstraintFlag && m_depQuantEnabledFlag, "DQ shall be deactivated when m_bNoDepQuantConstraintFlag is equal to 1");
 
     m_cEncLib.setNoSignDataHidingConstraintFlag(m_noSignDataHidingConstraintFlag);
-    CHECK(m_noSignDataHidingConstraintFlag && m_signDataHidingEnabledFlag, "SDH shall be deactivated when m_bNoSignDataHidingConstraintFlag is equal to 1");
+    CHECK_VTM(m_noSignDataHidingConstraintFlag && m_signDataHidingEnabledFlag, "SDH shall be deactivated when m_bNoSignDataHidingConstraintFlag is equal to 1");
 
     m_cEncLib.setNoApsConstraintFlag(m_noApsConstraintFlag);
-    CHECK(m_noApsConstraintFlag && (m_lmcsEnabled || (m_useScalingListId != SCALING_LIST_OFF)), "LMCS and explict scaling list shall be deactivated when m_noApsConstraintFlag is equal to 1");
+    CHECK_VTM(m_noApsConstraintFlag && (m_lmcsEnabled || (m_useScalingListId != SCALING_LIST_OFF)), "LMCS and explict scaling list shall be deactivated when m_noApsConstraintFlag is equal to 1");
 
     m_cEncLib.setNoMrlConstraintFlag(m_noMrlConstraintFlag);
-    CHECK(m_noMrlConstraintFlag && m_MRL, "MRL shall be deactivated when m_noMrlConstraintFlag is equal to 1");
+    CHECK_VTM(m_noMrlConstraintFlag && m_MRL, "MRL shall be deactivated when m_noMrlConstraintFlag is equal to 1");
 
     m_cEncLib.setNoIspConstraintFlag(m_noIspConstraintFlag);
-    CHECK(m_noIspConstraintFlag && m_ISP, "ISP shall be deactivated when m_noIspConstraintFlag is equal to 1");
+    CHECK_VTM(m_noIspConstraintFlag && m_ISP, "ISP shall be deactivated when m_noIspConstraintFlag is equal to 1");
 
     m_cEncLib.setNoMipConstraintFlag(m_noMipConstraintFlag);
-    CHECK(m_noMipConstraintFlag && m_MIP, "MIP shall be deactivated when m_noMipConstraintFlag is equal to 1");
+    CHECK_VTM(m_noMipConstraintFlag && m_MIP, "MIP shall be deactivated when m_noMipConstraintFlag is equal to 1");
 
     m_cEncLib.setNoLfnstConstraintFlag(m_noLfnstConstraintFlag);
-    CHECK(m_noLfnstConstraintFlag && m_LFNST, "LFNST shall be deactivated when m_noLfnstConstraintFlag is equal to 1");
+    CHECK_VTM(m_noLfnstConstraintFlag && m_LFNST, "LFNST shall be deactivated when m_noLfnstConstraintFlag is equal to 1");
 
     m_cEncLib.setNoMmvdConstraintFlag(m_noMmvdConstraintFlag);
-    CHECK(m_noMmvdConstraintFlag && m_MMVD, "MMVD shall be deactivated when m_noMmvdConstraintFlag is equal to 1");
+    CHECK_VTM(m_noMmvdConstraintFlag && m_MMVD, "MMVD shall be deactivated when m_noMmvdConstraintFlag is equal to 1");
 
     m_cEncLib.setNoSmvdConstraintFlag(m_noSmvdConstraintFlag);
-    CHECK(m_noSmvdConstraintFlag && m_SMVD, "SMVD shall be deactivated when m_noSmvdConstraintFlag is equal to 1");
+    CHECK_VTM(m_noSmvdConstraintFlag && m_SMVD, "SMVD shall be deactivated when m_noSmvdConstraintFlag is equal to 1");
 
     m_cEncLib.setNoProfConstraintFlag(m_noProfConstraintFlag);
-    CHECK(m_noProfConstraintFlag && m_PROF, "PROF shall be deactivated when m_noProfConstraintFlag is equal to 1");
+    CHECK_VTM(m_noProfConstraintFlag && m_PROF, "PROF shall be deactivated when m_noProfConstraintFlag is equal to 1");
 
     m_cEncLib.setNoPaletteConstraintFlag(m_noPaletteConstraintFlag);
-    CHECK(m_noPaletteConstraintFlag && m_PLTMode, "Palette shall be deactivated when m_noPaletteConstraintFlag is equal to 1");
+    CHECK_VTM(m_noPaletteConstraintFlag && m_PLTMode, "Palette shall be deactivated when m_noPaletteConstraintFlag is equal to 1");
 
     m_cEncLib.setNoActConstraintFlag(m_noActConstraintFlag);
-    CHECK(m_noActConstraintFlag && m_useColorTrans, "ACT shall be deactivated when m_noActConstraintFlag is equal to 1");
+    CHECK_VTM(m_noActConstraintFlag && m_useColorTrans, "ACT shall be deactivated when m_noActConstraintFlag is equal to 1");
 
     m_cEncLib.setNoLmcsConstraintFlag(m_noLmcsConstraintFlag);
-    CHECK(m_noLmcsConstraintFlag && m_lmcsEnabled, "LMCS shall be deactivated when m_noLmcsConstraintFlag is equal to 1");
+    CHECK_VTM(m_noLmcsConstraintFlag && m_lmcsEnabled, "LMCS shall be deactivated when m_noLmcsConstraintFlag is equal to 1");
 
     m_cEncLib.setNoExplicitScaleListConstraintFlag(m_noExplicitScaleListConstraintFlag);
-    CHECK(m_noExplicitScaleListConstraintFlag && m_useScalingListId != SCALING_LIST_OFF, "Explicit scaling list shall be deactivated when m_noExplicitScaleListConstraintFlag is equal to 1");
+    CHECK_VTM(m_noExplicitScaleListConstraintFlag && m_useScalingListId != SCALING_LIST_OFF, "Explicit scaling list shall be deactivated when m_noExplicitScaleListConstraintFlag is equal to 1");
 
     m_cEncLib.setNoVirtualBoundaryConstraintFlag(m_noVirtualBoundaryConstraintFlag);
-    CHECK(m_noVirtualBoundaryConstraintFlag && m_virtualBoundariesEnabledFlag, "Virtuall boundaries shall be deactivated when m_noVirtualBoundaryConstraintFlag is equal to 1");
+    CHECK_VTM(m_noVirtualBoundaryConstraintFlag && m_virtualBoundariesEnabledFlag, "Virtuall boundaries shall be deactivated when m_noVirtualBoundaryConstraintFlag is equal to 1");
     m_cEncLib.setNoChromaQpOffsetConstraintFlag(m_noChromaQpOffsetConstraintFlag);
-    CHECK(m_noChromaQpOffsetConstraintFlag && m_cuChromaQpOffsetSubdiv, "Chroma Qp offset shall be 0 when m_noChromaQpOffsetConstraintFlag is equal to 1");
+    CHECK_VTM(m_noChromaQpOffsetConstraintFlag && m_cuChromaQpOffsetSubdiv, "Chroma Qp offset shall be 0 when m_noChromaQpOffsetConstraintFlag is equal to 1");
   }
   else
   {
diff --git a/source/App/EncoderApp/EncAppCfg.cpp b/source/App/EncoderApp/EncAppCfg.cpp
index 652d572..d9381d2 100644
--- a/source/App/EncoderApp/EncAppCfg.cpp
+++ b/source/App/EncoderApp/EncAppCfg.cpp
@@ -698,6 +698,18 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   ("InputPathPrefix,-ipp",                            inputPathPrefix,                             string(""), "pathname to prepend to input filename")
   ("BitstreamFile,b",                                 m_bitstreamFileName,                         string(""), "Bitstream output file name")
   ("ReconFile,o",                                     m_reconFileName,                             string(""), "Reconstructed YUV output file name")
+
+  //altissie added
+  ("WritePartition,wp",                               m_writePartition,                                 false, "Write partition decision into dat file")
+  ("ReadPartition,rp",                                m_readPartition,                                  false, "Read partition decision of dat file")
+  ("DatFolder,-df",                                   m_datFolder,                                 string(""), "Folder for dat file (partition file)")
+  ("PredictPartition,pp",                             m_predictPartition,                               false, "Predict partition decision with cnn+ml in intra coding")
+  ("PredictPartitionInter,ppi",                       m_predictPartitionInter,                          false, "Predict partition decision with cnn+ml in inter coding")
+  //sbelhadj added
+  ("ModelFolder,-mf",                                   m_modelFolder,                                 string(""), "Folder containing model files")
+
+
+
   ("SourceWidth,-wdt",                                m_iSourceWidth,                                       0, "Source picture width")
   ("SourceHeight,-hgt",                               m_iSourceHeight,                                      0, "Source picture height")
   ("InputBitDepth",                                   m_inputBitDepth[CHANNEL_TYPE_LUMA],                   8, "Bit-depth of input file")
@@ -1595,26 +1607,26 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   }
   if ( m_subPicInfoPresentFlag )
   {
-    CHECK( m_numSubPics > MAX_NUM_SUB_PICS || m_numSubPics < 1, "Number of subpicture must be within 1 to 2^16" )
+    CHECK_VTM( m_numSubPics > MAX_NUM_SUB_PICS || m_numSubPics < 1, "Number of subpicture must be within 1 to 2^16" )
     if (!m_subPicSameSizeFlag)
     {
-      CHECK(cfg_subPicCtuTopLeftX.values.size() != m_numSubPics, "Number of SubPicCtuTopLeftX values must be equal to NumSubPics");
-      CHECK(cfg_subPicCtuTopLeftY.values.size() != m_numSubPics, "Number of SubPicCtuTopLeftY values must be equal to NumSubPics");
-      CHECK(cfg_subPicWidth.values.size() != m_numSubPics, "Number of SubPicWidth values must be equal to NumSubPics");
-      CHECK(cfg_subPicHeight.values.size() != m_numSubPics, "Number of SubPicHeight values must be equal to NumSubPics");
+      CHECK_VTM(cfg_subPicCtuTopLeftX.values.size() != m_numSubPics, "Number of SubPicCtuTopLeftX values must be equal to NumSubPics");
+      CHECK_VTM(cfg_subPicCtuTopLeftY.values.size() != m_numSubPics, "Number of SubPicCtuTopLeftY values must be equal to NumSubPics");
+      CHECK_VTM(cfg_subPicWidth.values.size() != m_numSubPics, "Number of SubPicWidth values must be equal to NumSubPics");
+      CHECK_VTM(cfg_subPicHeight.values.size() != m_numSubPics, "Number of SubPicHeight values must be equal to NumSubPics");
     }
     else
     {
-      CHECK(cfg_subPicCtuTopLeftX.values.size() != 0, "Number of SubPicCtuTopLeftX values must be equal to 0");
-      CHECK(cfg_subPicCtuTopLeftY.values.size() != 0, "Number of SubPicCtuTopLeftY values must be equal to 0");
-      CHECK(cfg_subPicWidth.values.size() != 1, "Number of SubPicWidth values must be equal to 1");
-      CHECK(cfg_subPicHeight.values.size() != 1, "Number of SubPicHeight values must be equal to 1");
+      CHECK_VTM(cfg_subPicCtuTopLeftX.values.size() != 0, "Number of SubPicCtuTopLeftX values must be equal to 0");
+      CHECK_VTM(cfg_subPicCtuTopLeftY.values.size() != 0, "Number of SubPicCtuTopLeftY values must be equal to 0");
+      CHECK_VTM(cfg_subPicWidth.values.size() != 1, "Number of SubPicWidth values must be equal to 1");
+      CHECK_VTM(cfg_subPicHeight.values.size() != 1, "Number of SubPicHeight values must be equal to 1");
     }
-    CHECK( cfg_subPicTreatedAsPicFlag.values.size() != m_numSubPics, "Number of SubPicTreatedAsPicFlag values must be equal to NumSubPics");
-    CHECK( cfg_loopFilterAcrossSubpicEnabledFlag.values.size() != m_numSubPics, "Number of LoopFilterAcrossSubpicEnabledFlag values must be equal to NumSubPics");
+    CHECK_VTM( cfg_subPicTreatedAsPicFlag.values.size() != m_numSubPics, "Number of SubPicTreatedAsPicFlag values must be equal to NumSubPics");
+    CHECK_VTM( cfg_loopFilterAcrossSubpicEnabledFlag.values.size() != m_numSubPics, "Number of LoopFilterAcrossSubpicEnabledFlag values must be equal to NumSubPics");
     if (m_subPicIdMappingExplicitlySignalledFlag)
     {
-      CHECK( cfg_subPicId.values.size() != m_numSubPics, "Number of SubPicId values must be equal to NumSubPics");
+      CHECK_VTM( cfg_subPicId.values.size() != m_numSubPics, "Number of SubPicId values must be equal to NumSubPics");
     }
     m_subPicCtuTopLeftX                 = cfg_subPicCtuTopLeftX.values;
     m_subPicCtuTopLeftY                 = cfg_subPicCtuTopLeftY.values;
@@ -1635,16 +1647,16 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
     {
       for (int i = 0; i < m_numSubPics; i++)
       {
-        CHECK(m_subPicCtuTopLeftX[i] + m_subPicWidth[i] > tmpWidthVal, "Subpicture must not exceed picture boundary");
-        CHECK(m_subPicCtuTopLeftY[i] + m_subPicHeight[i] > tmpHeightVal, "Subpicture must not exceed picture boundary");
+        CHECK_VTM(m_subPicCtuTopLeftX[i] + m_subPicWidth[i] > tmpWidthVal, "Subpicture must not exceed picture boundary");
+        CHECK_VTM(m_subPicCtuTopLeftY[i] + m_subPicHeight[i] > tmpHeightVal, "Subpicture must not exceed picture boundary");
       }
     }
     else
     {
       uint32_t numSubpicCols = tmpWidthVal / m_subPicWidth[0];
-      CHECK(tmpWidthVal % m_subPicWidth[0] != 0, "sps_subpic_width_minus1[0] is invalid.");
-      CHECK(tmpHeightVal % m_subPicHeight[0] != 0, "sps_subpic_height_minus1[0] is invalid.");
-      CHECK(numSubpicCols * (tmpHeightVal / m_subPicHeight[0]) != m_numSubPics, "when sps_subpic_same_size_flag is equal to, sps_num_subpics_minus1 is invalid");
+      CHECK_VTM(tmpWidthVal % m_subPicWidth[0] != 0, "sps_subpic_width_minus1[0] is invalid.");
+      CHECK_VTM(tmpHeightVal % m_subPicHeight[0] != 0, "sps_subpic_height_minus1[0] is invalid.");
+      CHECK_VTM(numSubpicCols * (tmpHeightVal / m_subPicHeight[0]) != m_numSubPics, "when sps_subpic_same_size_flag is equal to, sps_num_subpics_minus1 is invalid");
     }
     // automatically determine subpicture ID lenght in case it is not specified
     if (m_subPicIdLen == 0)
@@ -1662,26 +1674,26 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
       }
     }
 
-    CHECK( m_subPicIdLen > 16, "SubPicIdLen must not exceed 16 bits" );
-    CHECK(m_resChangeInClvsEnabled, "resolution change in CLVS and subpictures cannot be enabled together");
+    CHECK_VTM( m_subPicIdLen > 16, "SubPicIdLen must not exceed 16 bits" );
+    CHECK_VTM(m_resChangeInClvsEnabled, "resolution change in CLVS and subpictures cannot be enabled together");
   }
 
   if (m_virtualBoundariesPresentFlag)
   {
     if (m_iSourceWidth <= 8)
-      CHECK(m_numVerVirtualBoundaries != 0, "The number of vertical virtual boundaries shall be 0 when the picture width is less than or equal to 8");
+      CHECK_VTM(m_numVerVirtualBoundaries != 0, "The number of vertical virtual boundaries shall be 0 when the picture width is less than or equal to 8");
 
     if (m_iSourceHeight <= 8)
-      CHECK(m_numHorVirtualBoundaries != 0, "The number of horizontal virtual boundaries shall be 0 when the picture height is less than or equal to 8");
+      CHECK_VTM(m_numHorVirtualBoundaries != 0, "The number of horizontal virtual boundaries shall be 0 when the picture height is less than or equal to 8");
   }
 
   if (m_cfgSubpictureLevelInfoSEI.m_enabled)
   {
-    CHECK (m_numSubPics != m_cfgSubpictureLevelInfoSEI.m_numSubpictures, "NumSubPics must be equal to SEISubpicLevelInfoNumSubpics" );
-    CHECK (m_cfgSubpictureLevelInfoSEI.m_sliMaxSublayers != m_maxSublayers, "SEISubpicLevelInfoMaxSublayers must be equal to vps_max_sublayers");
+    CHECK_VTM(m_numSubPics != m_cfgSubpictureLevelInfoSEI.m_numSubpictures, "NumSubPics must be equal to SEISubpicLevelInfoNumSubpics" );
+    CHECK_VTM(m_cfgSubpictureLevelInfoSEI.m_sliMaxSublayers != m_maxSublayers, "SEISubpicLevelInfoMaxSublayers must be equal to vps_max_sublayers");
     if (m_cfgSubpictureLevelInfoSEI.m_sliSublayerInfoPresentFlag)
     {
-      CHECK(cfg_sliRefLevels.values.size() < m_maxSublayers, "when sliSublayerInfoPresentFlag = 1, the number of reference levels must be greater than or equal to sublayers");
+      CHECK_VTM(cfg_sliRefLevels.values.size() < m_maxSublayers, "when sliSublayerInfoPresentFlag = 1, the number of reference levels must be greater than or equal to sublayers");
     }
     if (m_cfgSubpictureLevelInfoSEI.m_explicitFraction)
     {
@@ -1689,23 +1701,23 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
       m_cfgSubpictureLevelInfoSEI.m_refLevels = cfg_sliRefLevels.values;
       if (m_cfgSubpictureLevelInfoSEI.m_sliSublayerInfoPresentFlag)
       {
-        CHECK((int)cfg_sliRefLevels.values.size() / m_maxSublayers * m_cfgSubpictureLevelInfoSEI.m_numSubpictures * m_cfgSubpictureLevelInfoSEI.m_sliMaxSublayers != cfg_sliFractions.values.size(),
+        CHECK_VTM((int)cfg_sliRefLevels.values.size() / m_maxSublayers * m_cfgSubpictureLevelInfoSEI.m_numSubpictures * m_cfgSubpictureLevelInfoSEI.m_sliMaxSublayers != cfg_sliFractions.values.size(),
           "when sliSublayerInfoPresentFlag = 1, the number  of subpicture level fractions must be equal to the numer of subpictures times the number of reference levels times the number of sublayers");
       }
       else
       {
-        CHECK((int)cfg_sliRefLevels.values.size() * m_cfgSubpictureLevelInfoSEI.m_numSubpictures != cfg_sliFractions.values.size(), "when sliSublayerInfoPresentFlag = 0, the number  of subpicture level fractions must be equal to the numer of subpictures times the number of reference levels");
+        CHECK_VTM((int)cfg_sliRefLevels.values.size() * m_cfgSubpictureLevelInfoSEI.m_numSubpictures != cfg_sliFractions.values.size(), "when sliSublayerInfoPresentFlag = 0, the number  of subpicture level fractions must be equal to the numer of subpictures times the number of reference levels");
       }
     }
     m_cfgSubpictureLevelInfoSEI.m_nonSubpicLayersFraction = cfg_sliNonSubpicLayersFractions.values;
     if (m_cfgSubpictureLevelInfoSEI.m_sliSublayerInfoPresentFlag)
     {
-      CHECK((int)cfg_sliNonSubpicLayersFractions.values.size() != ( cfg_sliRefLevels.values.size() * m_cfgSubpictureLevelInfoSEI.m_numSubpictures ),
+      CHECK_VTM((int)cfg_sliNonSubpicLayersFractions.values.size() != ( cfg_sliRefLevels.values.size() * m_cfgSubpictureLevelInfoSEI.m_numSubpictures ),
         "when sliSublayerInfoPresentFlag = 1, the number  of non-subpicture level fractions must be equal to the numer of reference levels times the number of sublayers");
     }
     else
     {
-      CHECK((int)cfg_sliNonSubpicLayersFractions.values.size() != ( cfg_sliRefLevels.values.size() ),
+      CHECK_VTM((int)cfg_sliNonSubpicLayersFractions.values.size() != ( cfg_sliRefLevels.values.size() ),
         "when sliSublayerInfoPresentFlag = 0, the number  of non-subpicture level fractions must be equal to the numer of reference levels");
     }
   }
@@ -1821,13 +1833,13 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   m_ext360.processOptions(ext360CfgContext);
 #endif
 
-  CHECK( !( tmpWeightedPredictionMethod >= 0 && tmpWeightedPredictionMethod <= WP_PER_PICTURE_WITH_HISTOGRAM_AND_PER_COMPONENT_AND_CLIPPING_AND_EXTENSION ), "Error in cfg" );
+  CHECK_VTM( !( tmpWeightedPredictionMethod >= 0 && tmpWeightedPredictionMethod <= WP_PER_PICTURE_WITH_HISTOGRAM_AND_PER_COMPONENT_AND_CLIPPING_AND_EXTENSION ), "Error in cfg" );
   m_weightedPredictionMethod = WeightedPredictionMethod(tmpWeightedPredictionMethod);
 
-  CHECK( tmpFastInterSearchMode<0 || tmpFastInterSearchMode>FASTINTERSEARCH_MODE3, "Error in cfg" );
+  CHECK_VTM( tmpFastInterSearchMode<0 || tmpFastInterSearchMode>FASTINTERSEARCH_MODE3, "Error in cfg" );
   m_fastInterSearchMode = FastInterSearchMode(tmpFastInterSearchMode);
 
-  CHECK( tmpMotionEstimationSearchMethod < 0 || tmpMotionEstimationSearchMethod >= MESEARCH_NUMBER_OF_METHODS, "Error in cfg" );
+  CHECK_VTM( tmpMotionEstimationSearchMethod < 0 || tmpMotionEstimationSearchMethod >= MESEARCH_NUMBER_OF_METHODS, "Error in cfg" );
   m_motionEstimationSearchMethod=MESearchMethod(tmpMotionEstimationSearchMethod);
 
   if (extendedProfile == ExtendedProfileName::AUTO)
@@ -1865,7 +1877,7 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
       if (m_profile != Profile::NONE)
       {
         const ProfileFeatures *features = ProfileFeatures::getProfileFeatures(m_profile);
-        CHECK(features->profile != m_profile, "Profile not found");
+        CHECK_VTM(features->profile != m_profile, "Profile not found");
         m_bitDepthConstraint = features->maxBitDepth;
       }
       else // m_profile == Profile::NONE
@@ -1873,11 +1885,11 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
         m_bitDepthConstraint = 16; // max value - unconstrained.
       }
     }
-    CHECK(m_bitDepthConstraint < m_internalBitDepth[CHANNEL_TYPE_LUMA], "MaxBitDepthConstraint setting does not allow the specified luma bit depth to be coded.");
-    CHECK(m_bitDepthConstraint < m_internalBitDepth[CHANNEL_TYPE_CHROMA], "MaxBitDepthConstraint setting does not allow the specified chroma bit depth to be coded.");
-    CHECK(m_chromaFormatConstraint < m_chromaFormatIDC, "MaxChromaFormatConstraint setting does not allow the specified chroma format to be coded.");
-    CHECK(m_chromaFormatConstraint >= NUM_CHROMA_FORMAT, "Bad value given for MaxChromaFormatConstraint setting.")
-    CHECK(m_bitDepthConstraint < 8 || m_bitDepthConstraint>16, "MaxBitDepthConstraint setting must be in the range 8 to 16 (inclusive)");
+    CHECK_VTM(m_bitDepthConstraint < m_internalBitDepth[CHANNEL_TYPE_LUMA], "MaxBitDepthConstraint setting does not allow the specified luma bit depth to be coded.");
+    CHECK_VTM(m_bitDepthConstraint < m_internalBitDepth[CHANNEL_TYPE_CHROMA], "MaxBitDepthConstraint setting does not allow the specified chroma bit depth to be coded.");
+    CHECK_VTM(m_chromaFormatConstraint < m_chromaFormatIDC, "MaxChromaFormatConstraint setting does not allow the specified chroma format to be coded.");
+    CHECK_VTM(m_chromaFormatConstraint >= NUM_CHROMA_FORMAT, "Bad value given for MaxChromaFormatConstraint setting.")
+    CHECK_VTM(m_bitDepthConstraint < 8 || m_bitDepthConstraint>16, "MaxBitDepthConstraint setting must be in the range 8 to 16 (inclusive)");
   }
 
 
@@ -1886,7 +1898,7 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
 
   // Picture width and height must be multiples of 8 and minCuSize
   const int minResolutionMultiple = std::max(8, 1 << m_log2MinCuSize);
-  CHECK(((m_iSourceWidth% minResolutionMultiple) || (m_iSourceHeight % minResolutionMultiple)) && m_conformanceWindowMode != 1, "Picture width or height is not a multiple of 8 or minCuSize, please use ConformanceMode 1!");
+  CHECK_VTM(((m_iSourceWidth% minResolutionMultiple) || (m_iSourceHeight % minResolutionMultiple)) && m_conformanceWindowMode != 1, "Picture width or height is not a multiple of 8 or minCuSize, please use ConformanceMode 1!");
   switch (m_conformanceWindowMode)
   {
   case 0:
@@ -1953,13 +1965,13 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   {
     for(int i = 0; i < m_numSubPics; i++)
     {
-      CHECK( (m_subPicCtuTopLeftX[i] * m_uiCTUSize) >= (m_iSourceWidth - m_confWinRight * SPS::getWinUnitX(m_chromaFormatIDC)),
+      CHECK_VTM( (m_subPicCtuTopLeftX[i] * m_uiCTUSize) >= (m_iSourceWidth - m_confWinRight * SPS::getWinUnitX(m_chromaFormatIDC)),
           "No subpicture can be located completely outside of the conformance cropping window");
-      CHECK( ((m_subPicCtuTopLeftX[i] + m_subPicWidth[i]) * m_uiCTUSize) <= (m_confWinLeft * SPS::getWinUnitX(m_chromaFormatIDC)),
+      CHECK_VTM( ((m_subPicCtuTopLeftX[i] + m_subPicWidth[i]) * m_uiCTUSize) <= (m_confWinLeft * SPS::getWinUnitX(m_chromaFormatIDC)),
 	  "No subpicture can be located completely outside of the conformance cropping window" );
-      CHECK( (m_subPicCtuTopLeftY[i] * m_uiCTUSize) >= (m_iSourceHeight  - m_confWinBottom * SPS::getWinUnitY(m_chromaFormatIDC)),
+      CHECK_VTM( (m_subPicCtuTopLeftY[i] * m_uiCTUSize) >= (m_iSourceHeight  - m_confWinBottom * SPS::getWinUnitY(m_chromaFormatIDC)),
           "No subpicture can be located completely outside of the conformance cropping window");
-      CHECK( ((m_subPicCtuTopLeftY[i] + m_subPicHeight[i]) * m_uiCTUSize) <= (m_confWinTop * SPS::getWinUnitY(m_chromaFormatIDC)),
+      CHECK_VTM( ((m_subPicCtuTopLeftY[i] + m_subPicHeight[i]) * m_uiCTUSize) <= (m_confWinTop * SPS::getWinUnitY(m_chromaFormatIDC)),
           "No subpicture can be located completely outside of the conformance cropping window");
     }
   }
@@ -2024,13 +2036,13 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
 
 
 #if SHARP_LUMA_DELTA_QP
-  CHECK( lumaLevelToDeltaQPMode >= LUMALVL_TO_DQP_NUM_MODES, "Error in cfg" );
+  CHECK_VTM( lumaLevelToDeltaQPMode >= LUMALVL_TO_DQP_NUM_MODES, "Error in cfg" );
 
   m_lumaLevelToDeltaQPMapping.mode=LumaLevelToDQPMode(lumaLevelToDeltaQPMode);
 
   if (m_lumaLevelToDeltaQPMapping.mode)
   {
-    CHECK(  cfg_lumaLeveltoDQPMappingLuma.values.size() != cfg_lumaLeveltoDQPMappingQP.values.size(), "Error in cfg" );
+    CHECK_VTM(  cfg_lumaLeveltoDQPMappingLuma.values.size() != cfg_lumaLeveltoDQPMappingQP.values.size(), "Error in cfg" );
     m_lumaLevelToDeltaQPMapping.mapping.resize(cfg_lumaLeveltoDQPMappingLuma.values.size());
     for(uint32_t i=0; i<cfg_lumaLeveltoDQPMappingLuma.values.size(); i++)
     {
@@ -2039,9 +2051,9 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   }
 #endif
 
-  CHECK(cfg_qpInValCb.values.size() != cfg_qpOutValCb.values.size(), "Chroma QP table for Cb is incomplete.");
-  CHECK(cfg_qpInValCr.values.size() != cfg_qpOutValCr.values.size(), "Chroma QP table for Cr is incomplete.");
-  CHECK(cfg_qpInValCbCr.values.size() != cfg_qpOutValCbCr.values.size(), "Chroma QP table for CbCr is incomplete.");
+  CHECK_VTM(cfg_qpInValCb.values.size() != cfg_qpOutValCb.values.size(), "Chroma QP table for Cb is incomplete.");
+  CHECK_VTM(cfg_qpInValCr.values.size() != cfg_qpOutValCr.values.size(), "Chroma QP table for Cr is incomplete.");
+  CHECK_VTM(cfg_qpInValCbCr.values.size() != cfg_qpOutValCbCr.values.size(), "Chroma QP table for CbCr is incomplete.");
   if (m_useIdentityTableForNon420Chroma && m_chromaFormatIDC != CHROMA_420)
   {
     m_chromaQpMappingTableParams.m_sameCQPTableForAllChromaFlag = true;
@@ -2076,12 +2088,12 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   m_chromaQpMappingTableParams.m_deltaQpOutVal[0].resize(cfg_qpOutValCb.values.size());
   m_chromaQpMappingTableParams.m_numPtsInCQPTableMinus1[0] = (int) cfg_qpOutValCb.values.size() - 2;
   m_chromaQpMappingTableParams.m_qpTableStartMinus26[0]    = -26 + cfg_qpInValCb.values[0];
-  CHECK(m_chromaQpMappingTableParams.m_qpTableStartMinus26[0] < -26 - qpBdOffsetC || m_chromaQpMappingTableParams.m_qpTableStartMinus26[0] > 36, "qpTableStartMinus26[0] is out of valid range of -26 -qpBdOffsetC to 36, inclusive.")
-  CHECK(cfg_qpInValCb.values[0] != cfg_qpOutValCb.values[0], "First qpInValCb value should be equal to first qpOutValCb value");
+  CHECK_VTM(m_chromaQpMappingTableParams.m_qpTableStartMinus26[0] < -26 - qpBdOffsetC || m_chromaQpMappingTableParams.m_qpTableStartMinus26[0] > 36, "qpTableStartMinus26[0] is out of valid range of -26 -qpBdOffsetC to 36, inclusive.")
+  CHECK_VTM(cfg_qpInValCb.values[0] != cfg_qpOutValCb.values[0], "First qpInValCb value should be equal to first qpOutValCb value");
   for (int i = 0; i < cfg_qpInValCb.values.size() - 1; i++)
   {
-    CHECK(cfg_qpInValCb.values[i] < -qpBdOffsetC || cfg_qpInValCb.values[i] > MAX_QP, "Some entries cfg_qpInValCb are out of valid range of -qpBdOffsetC to 63, inclusive.");
-    CHECK(cfg_qpOutValCb.values[i] < -qpBdOffsetC || cfg_qpOutValCb.values[i] > MAX_QP, "Some entries cfg_qpOutValCb are out of valid range of -qpBdOffsetC to 63, inclusive.");
+    CHECK_VTM(cfg_qpInValCb.values[i] < -qpBdOffsetC || cfg_qpInValCb.values[i] > MAX_QP, "Some entries cfg_qpInValCb are out of valid range of -qpBdOffsetC to 63, inclusive.");
+    CHECK_VTM(cfg_qpOutValCb.values[i] < -qpBdOffsetC || cfg_qpOutValCb.values[i] > MAX_QP, "Some entries cfg_qpOutValCb are out of valid range of -qpBdOffsetC to 63, inclusive.");
     m_chromaQpMappingTableParams.m_deltaQpInValMinus1[0][i] = cfg_qpInValCb.values[i + 1] - cfg_qpInValCb.values[i] - 1;
     m_chromaQpMappingTableParams.m_deltaQpOutVal[0][i] = cfg_qpOutValCb.values[i + 1] - cfg_qpOutValCb.values[i];
   }
@@ -2091,12 +2103,12 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
     m_chromaQpMappingTableParams.m_deltaQpOutVal[1].resize(cfg_qpOutValCr.values.size());
     m_chromaQpMappingTableParams.m_numPtsInCQPTableMinus1[1] = (int) cfg_qpOutValCr.values.size() - 2;
     m_chromaQpMappingTableParams.m_qpTableStartMinus26[1]    = -26 + cfg_qpInValCr.values[0];
-    CHECK(m_chromaQpMappingTableParams.m_qpTableStartMinus26[1] < -26 - qpBdOffsetC || m_chromaQpMappingTableParams.m_qpTableStartMinus26[1] > 36, "qpTableStartMinus26[1] is out of valid range of -26 -qpBdOffsetC to 36, inclusive.")
-    CHECK(cfg_qpInValCr.values[0] != cfg_qpOutValCr.values[0], "First qpInValCr value should be equal to first qpOutValCr value");
+    CHECK_VTM(m_chromaQpMappingTableParams.m_qpTableStartMinus26[1] < -26 - qpBdOffsetC || m_chromaQpMappingTableParams.m_qpTableStartMinus26[1] > 36, "qpTableStartMinus26[1] is out of valid range of -26 -qpBdOffsetC to 36, inclusive.")
+    CHECK_VTM(cfg_qpInValCr.values[0] != cfg_qpOutValCr.values[0], "First qpInValCr value should be equal to first qpOutValCr value");
     for (int i = 0; i < cfg_qpInValCr.values.size() - 1; i++)
     {
-      CHECK(cfg_qpInValCr.values[i] < -qpBdOffsetC || cfg_qpInValCr.values[i] > MAX_QP, "Some entries cfg_qpInValCr are out of valid range of -qpBdOffsetC to 63, inclusive.");
-      CHECK(cfg_qpOutValCr.values[i] < -qpBdOffsetC || cfg_qpOutValCr.values[i] > MAX_QP, "Some entries cfg_qpOutValCr are out of valid range of -qpBdOffsetC to 63, inclusive.");
+      CHECK_VTM(cfg_qpInValCr.values[i] < -qpBdOffsetC || cfg_qpInValCr.values[i] > MAX_QP, "Some entries cfg_qpInValCr are out of valid range of -qpBdOffsetC to 63, inclusive.");
+      CHECK_VTM(cfg_qpOutValCr.values[i] < -qpBdOffsetC || cfg_qpOutValCr.values[i] > MAX_QP, "Some entries cfg_qpOutValCr are out of valid range of -qpBdOffsetC to 63, inclusive.");
       m_chromaQpMappingTableParams.m_deltaQpInValMinus1[1][i] = cfg_qpInValCr.values[i + 1] - cfg_qpInValCr.values[i] - 1;
       m_chromaQpMappingTableParams.m_deltaQpOutVal[1][i] = cfg_qpOutValCr.values[i + 1] - cfg_qpOutValCr.values[i];
     }
@@ -2104,12 +2116,12 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
     m_chromaQpMappingTableParams.m_deltaQpOutVal[2].resize(cfg_qpOutValCbCr.values.size());
     m_chromaQpMappingTableParams.m_numPtsInCQPTableMinus1[2] = (int) cfg_qpOutValCbCr.values.size() - 2;
     m_chromaQpMappingTableParams.m_qpTableStartMinus26[2]    = -26 + cfg_qpInValCbCr.values[0];
-    CHECK(m_chromaQpMappingTableParams.m_qpTableStartMinus26[2] < -26 - qpBdOffsetC || m_chromaQpMappingTableParams.m_qpTableStartMinus26[2] > 36, "qpTableStartMinus26[2] is out of valid range of -26 -qpBdOffsetC to 36, inclusive.")
-    CHECK(cfg_qpInValCbCr.values[0] != cfg_qpInValCbCr.values[0], "First qpInValCbCr value should be equal to first qpOutValCbCr value");
+    CHECK_VTM(m_chromaQpMappingTableParams.m_qpTableStartMinus26[2] < -26 - qpBdOffsetC || m_chromaQpMappingTableParams.m_qpTableStartMinus26[2] > 36, "qpTableStartMinus26[2] is out of valid range of -26 -qpBdOffsetC to 36, inclusive.")
+    CHECK_VTM(cfg_qpInValCbCr.values[0] != cfg_qpInValCbCr.values[0], "First qpInValCbCr value should be equal to first qpOutValCbCr value");
     for (int i = 0; i < cfg_qpInValCbCr.values.size() - 1; i++)
     {
-      CHECK(cfg_qpInValCbCr.values[i] < -qpBdOffsetC || cfg_qpInValCbCr.values[i] > MAX_QP, "Some entries cfg_qpInValCbCr are out of valid range of -qpBdOffsetC to 63, inclusive.");
-      CHECK(cfg_qpOutValCbCr.values[i] < -qpBdOffsetC || cfg_qpOutValCbCr.values[i] > MAX_QP, "Some entries cfg_qpOutValCbCr are out of valid range of -qpBdOffsetC to 63, inclusive.");
+      CHECK_VTM(cfg_qpInValCbCr.values[i] < -qpBdOffsetC || cfg_qpInValCbCr.values[i] > MAX_QP, "Some entries cfg_qpInValCbCr are out of valid range of -qpBdOffsetC to 63, inclusive.");
+      CHECK_VTM(cfg_qpOutValCbCr.values[i] < -qpBdOffsetC || cfg_qpOutValCbCr.values[i] > MAX_QP, "Some entries cfg_qpOutValCbCr are out of valid range of -qpBdOffsetC to 63, inclusive.");
       m_chromaQpMappingTableParams.m_deltaQpInValMinus1[2][i] = cfg_qpInValCbCr.values[i + 1] - cfg_qpInValCbCr.values[i] - 1;
       m_chromaQpMappingTableParams.m_deltaQpOutVal[2][i] = cfg_qpInValCbCr.values[i + 1] - cfg_qpInValCbCr.values[i];
     }
@@ -2118,8 +2130,8 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
 #if LUMA_ADAPTIVE_DEBLOCKING_FILTER_QP_OFFSET
   if ( m_LadfEnabed )
   {
-    CHECK( m_LadfNumIntervals != cfg_LadfQpOffset.values.size(), "size of LadfQpOffset must be equal to LadfNumIntervals");
-    CHECK( m_LadfNumIntervals - 1 != cfg_LadfIntervalLowerBound.values.size(), "size of LadfIntervalLowerBound must be equal to LadfNumIntervals - 1");
+    CHECK_VTM( m_LadfNumIntervals != cfg_LadfQpOffset.values.size(), "size of LadfQpOffset must be equal to LadfNumIntervals");
+    CHECK_VTM( m_LadfNumIntervals - 1 != cfg_LadfIntervalLowerBound.values.size(), "size of LadfIntervalLowerBound must be equal to LadfNumIntervals - 1");
     m_LadfQpOffset = cfg_LadfQpOffset.values;
     m_LadfIntervalLowerBound[0] = 0;
     for (int k = 1; k < m_LadfNumIntervals; k++)
@@ -2156,14 +2168,14 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
 
   if( m_virtualBoundariesEnabledFlag )
   {
-    CHECK( m_subPicInfoPresentFlag && m_virtualBoundariesPresentFlag != 1, "When subpicture signalling is present, the signalling of virtual boundaries, if present, shall be in the SPS" );
+    CHECK_VTM( m_subPicInfoPresentFlag && m_virtualBoundariesPresentFlag != 1, "When subpicture signalling is present, the signalling of virtual boundaries, if present, shall be in the SPS" );
 
     if( m_virtualBoundariesPresentFlag )
     {
-      CHECK( m_numVerVirtualBoundaries > 3, "Number of vertical virtual boundaries must be comprised between 0 and 3 included" );
-      CHECK( m_numHorVirtualBoundaries > 3, "Number of horizontal virtual boundaries must be comprised between 0 and 3 included" );
-      CHECK( m_numVerVirtualBoundaries != cfg_virtualBoundariesPosX.values.size(), "Size of VirtualBoundariesPosX must be equal to NumVerVirtualBoundaries");
-      CHECK( m_numHorVirtualBoundaries != cfg_virtualBoundariesPosY.values.size(), "Size of VirtualBoundariesPosY must be equal to NumHorVirtualBoundaries");
+      CHECK_VTM( m_numVerVirtualBoundaries > 3, "Number of vertical virtual boundaries must be comprised between 0 and 3 included" );
+      CHECK_VTM( m_numHorVirtualBoundaries > 3, "Number of horizontal virtual boundaries must be comprised between 0 and 3 included" );
+      CHECK_VTM( m_numVerVirtualBoundaries != cfg_virtualBoundariesPosX.values.size(), "Size of VirtualBoundariesPosX must be equal to NumVerVirtualBoundaries");
+      CHECK_VTM( m_numHorVirtualBoundaries != cfg_virtualBoundariesPosY.values.size(), "Size of VirtualBoundariesPosY must be equal to NumHorVirtualBoundaries");
       m_virtualBoundariesPosX = cfg_virtualBoundariesPosX.values;
       if (m_numVerVirtualBoundaries > 1)
       {
@@ -2171,11 +2183,11 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
       }
       for (unsigned i = 0; i < m_numVerVirtualBoundaries; i++)
       {
-        CHECK( m_virtualBoundariesPosX[i] == 0 || m_virtualBoundariesPosX[i] >= m_iSourceWidth, "The vertical virtual boundary must be within the picture" );
-        CHECK( m_virtualBoundariesPosX[i] % 8, "The vertical virtual boundary must be a multiple of 8 luma samples" );
+        CHECK_VTM( m_virtualBoundariesPosX[i] == 0 || m_virtualBoundariesPosX[i] >= m_iSourceWidth, "The vertical virtual boundary must be within the picture" );
+        CHECK_VTM( m_virtualBoundariesPosX[i] % 8, "The vertical virtual boundary must be a multiple of 8 luma samples" );
         if (i > 0)
         {
-          CHECK( m_virtualBoundariesPosX[i] - m_virtualBoundariesPosX[i-1] < m_uiCTUSize, "The distance between any two vertical virtual boundaries shall be greater than or equal to the CTU size" );
+          CHECK_VTM( m_virtualBoundariesPosX[i] - m_virtualBoundariesPosX[i-1] < m_uiCTUSize, "The distance between any two vertical virtual boundaries shall be greater than or equal to the CTU size" );
         }
       }
       m_virtualBoundariesPosY = cfg_virtualBoundariesPosY.values;
@@ -2185,11 +2197,11 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
       }
       for (unsigned i = 0; i < m_numHorVirtualBoundaries; i++)
       {
-        CHECK( m_virtualBoundariesPosY[i] == 0 || m_virtualBoundariesPosY[i] >= m_iSourceHeight, "The horizontal virtual boundary must be within the picture" );
-        CHECK( m_virtualBoundariesPosY[i] % 8, "The horizontal virtual boundary must be a multiple of 8 luma samples" );
+        CHECK_VTM( m_virtualBoundariesPosY[i] == 0 || m_virtualBoundariesPosY[i] >= m_iSourceHeight, "The horizontal virtual boundary must be within the picture" );
+        CHECK_VTM( m_virtualBoundariesPosY[i] % 8, "The horizontal virtual boundary must be a multiple of 8 luma samples" );
         if (i > 0)
         {
-          CHECK( m_virtualBoundariesPosY[i] - m_virtualBoundariesPosY[i-1] < m_uiCTUSize, "The distance between any two horizontal virtual boundaries shall be greater than or equal to the CTU size" );
+          CHECK_VTM( m_virtualBoundariesPosY[i] - m_virtualBoundariesPosY[i-1] < m_uiCTUSize, "The distance between any two horizontal virtual boundaries shall be greater than or equal to the CTU size" );
         }
       }
     }
@@ -2197,7 +2209,7 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
 
   if ( m_alf )
   {
-    CHECK( m_maxNumAlfAlternativesChroma < 1 || m_maxNumAlfAlternativesChroma > MAX_NUM_ALF_ALTERNATIVES_CHROMA, std::string("The maximum number of ALF Chroma filter alternatives must be in the range (1-") + std::to_string(MAX_NUM_ALF_ALTERNATIVES_CHROMA) + std::string (", inclusive)") );
+    CHECK_VTM( m_maxNumAlfAlternativesChroma < 1 || m_maxNumAlfAlternativesChroma > MAX_NUM_ALF_ALTERNATIVES_CHROMA, std::string("The maximum number of ALF Chroma filter alternatives must be in the range (1-") + std::to_string(MAX_NUM_ALF_ALTERNATIVES_CHROMA) + std::string (", inclusive)") );
   }
 
   // reading external dQP description from file
@@ -2234,7 +2246,7 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   }
   if ( m_omniViewportSEIEnabled && !m_omniViewportSEICancelFlag )
   {
-    CHECK (!( m_omniViewportSEICntMinus1 >= 0 && m_omniViewportSEICntMinus1 < 16 ), "SEIOmniViewportCntMinus1 must be in the range of 0 to 16");
+    CHECK_VTM(!( m_omniViewportSEICntMinus1 >= 0 && m_omniViewportSEICntMinus1 < 16 ), "SEIOmniViewportCntMinus1 must be in the range of 0 to 16");
     m_omniViewportSEIAzimuthCentre.resize  (m_omniViewportSEICntMinus1+1);
     m_omniViewportSEIElevationCentre.resize(m_omniViewportSEICntMinus1+1);
     m_omniViewportSEITiltCentre.resize     (m_omniViewportSEICntMinus1+1);
@@ -2252,17 +2264,17 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
 
   if(!m_rwpSEIRwpCancelFlag && m_rwpSEIEnabled)
   {
-    CHECK (!( m_rwpSEINumPackedRegions > 0 && m_rwpSEINumPackedRegions <= std::numeric_limits<uint8_t>::max() ), "SEIRwpNumPackedRegions must be in the range of 1 to 255");
-    CHECK (!(cfg_rwpSEIRwpTransformType.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIRwpTransformType values be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIRwpGuardBandFlag.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIRwpGuardBandFlag values must be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIProjRegionWidth.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIProjRegionWidth values must be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIProjRegionHeight.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIProjRegionHeight values must be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIRwpSEIProjRegionTop.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIRwpSEIProjRegionTop values must be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIProjRegionLeft.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIProjRegionLeft values must be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIPackedRegionWidth.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIPackedRegionWidth values must be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIPackedRegionHeight.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIPackedRegionHeight values must be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIPackedRegionTop.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIPackedRegionTop values must be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIPackedRegionLeft.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIPackedRegionLeft values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!( m_rwpSEINumPackedRegions > 0 && m_rwpSEINumPackedRegions <= std::numeric_limits<uint8_t>::max() ), "SEIRwpNumPackedRegions must be in the range of 1 to 255");
+    CHECK_VTM(!(cfg_rwpSEIRwpTransformType.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIRwpTransformType values be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIRwpGuardBandFlag.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIRwpGuardBandFlag values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIProjRegionWidth.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIProjRegionWidth values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIProjRegionHeight.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIProjRegionHeight values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIRwpSEIProjRegionTop.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIRwpSEIProjRegionTop values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIProjRegionLeft.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIProjRegionLeft values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIPackedRegionWidth.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIPackedRegionWidth values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIPackedRegionHeight.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIPackedRegionHeight values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIPackedRegionTop.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIPackedRegionTop values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIPackedRegionLeft.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIPackedRegionLeft values must be equal to SEIRwpNumPackedRegions");
 
     m_rwpSEIRwpTransformType.resize(m_rwpSEINumPackedRegions);
     m_rwpSEIRwpGuardBandFlag.resize(m_rwpSEINumPackedRegions);
@@ -2283,7 +2295,7 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
     for( int i=0; i < m_rwpSEINumPackedRegions; i++ )
     {
       m_rwpSEIRwpTransformType[i]                     = cfg_rwpSEIRwpTransformType.values[i];
-      CHECK (!( m_rwpSEIRwpTransformType[i] >= 0 && m_rwpSEIRwpTransformType[i] <= 7 ), "SEIRwpTransformType must be in the range of 0 to 7");
+      CHECK_VTM(!( m_rwpSEIRwpTransformType[i] >= 0 && m_rwpSEIRwpTransformType[i] <= 7 ), "SEIRwpTransformType must be in the range of 0 to 7");
       m_rwpSEIRwpGuardBandFlag[i]                     = cfg_rwpSEIRwpGuardBandFlag.values[i];
       m_rwpSEIProjRegionWidth[i]                      = cfg_rwpSEIProjRegionWidth.values[i];
       m_rwpSEIProjRegionHeight[i]                     = cfg_rwpSEIProjRegionHeight.values[i];
@@ -2299,7 +2311,7 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
         m_rwpSEIRwpRightGuardBandWidth[i]             =  cfg_rwpSEIRwpRightGuardBandWidth.values[i];
         m_rwpSEIRwpTopGuardBandHeight[i]              =  cfg_rwpSEIRwpTopGuardBandHeight.values[i];
         m_rwpSEIRwpBottomGuardBandHeight[i]           =  cfg_rwpSEIRwpBottomGuardBandHeight.values[i];
-        CHECK (! ( m_rwpSEIRwpLeftGuardBandWidth[i] > 0 || m_rwpSEIRwpRightGuardBandWidth[i] > 0 || m_rwpSEIRwpTopGuardBandHeight[i] >0 || m_rwpSEIRwpBottomGuardBandHeight[i] >0 ), "At least one of the RWP guard band parameters mut be greater than zero");
+        CHECK_VTM(! ( m_rwpSEIRwpLeftGuardBandWidth[i] > 0 || m_rwpSEIRwpRightGuardBandWidth[i] > 0 || m_rwpSEIRwpTopGuardBandHeight[i] >0 || m_rwpSEIRwpBottomGuardBandHeight[i] >0 ), "At least one of the RWP guard band parameters mut be greater than zero");
         m_rwpSEIRwpGuardBandNotUsedForPredFlag[i]     =  cfg_rwpSEIRwpGuardBandNotUsedForPredFlag.values[i];
         for( int j=0; j < 4; j++ )
         {
@@ -2312,16 +2324,16 @@ bool EncAppCfg::parseCfg( int argc, char* argv[] )
   if (m_gcmpSEIEnabled && !m_gcmpSEICancelFlag)
   {
     int numFace = m_gcmpSEIPackingType == 4 || m_gcmpSEIPackingType == 5 ? 5 : 6;
-    CHECK (!(cfg_gcmpSEIFaceIndex.values.size()                  == numFace), "Number of SEIGcmpFaceIndex must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
-    CHECK (!(cfg_gcmpSEIFaceRotation.values.size()               == numFace), "Number of SEIGcmpFaceRotation must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
+    CHECK_VTM(!(cfg_gcmpSEIFaceIndex.values.size()                  == numFace), "Number of SEIGcmpFaceIndex must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
+    CHECK_VTM(!(cfg_gcmpSEIFaceRotation.values.size()               == numFace), "Number of SEIGcmpFaceRotation must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
     m_gcmpSEIFaceIndex.resize(numFace);
     m_gcmpSEIFaceRotation.resize(numFace);
     if (m_gcmpSEIMappingFunctionType == 2)
     {
-      CHECK (!(cfg_gcmpSEIFunctionCoeffU.values.size()           == numFace), "Number of SEIGcmpFunctionCoeffU must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
-      CHECK (!(cfg_gcmpSEIFunctionUAffectedByVFlag.values.size() == numFace), "Number of SEIGcmpFunctionUAffectedByVFlag must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
-      CHECK (!(cfg_gcmpSEIFunctionCoeffV.values.size()           == numFace), "Number of SEIGcmpFunctionCoeffV must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
-      CHECK (!(cfg_gcmpSEIFunctionVAffectedByUFlag.values.size() == numFace), "Number of SEIGcmpFunctionVAffectedByUFlag must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
+      CHECK_VTM(!(cfg_gcmpSEIFunctionCoeffU.values.size()           == numFace), "Number of SEIGcmpFunctionCoeffU must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
+      CHECK_VTM(!(cfg_gcmpSEIFunctionUAffectedByVFlag.values.size() == numFace), "Number of SEIGcmpFunctionUAffectedByVFlag must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
+      CHECK_VTM(!(cfg_gcmpSEIFunctionCoeffV.values.size()           == numFace), "Number of SEIGcmpFunctionCoeffV must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
+      CHECK_VTM(!(cfg_gcmpSEIFunctionVAffectedByUFlag.values.size() == numFace), "Number of SEIGcmpFunctionVAffectedByUFlag must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
       m_gcmpSEIFunctionCoeffU.resize(numFace);
       m_gcmpSEIFunctionUAffectedByVFlag.resize(numFace);
       m_gcmpSEIFunctionCoeffV.resize(numFace);
@@ -2647,7 +2659,7 @@ bool EncAppCfg::xCheckParameter()
   if (m_profile != Profile::NONE)
   {
     const ProfileFeatures *features = ProfileFeatures::getProfileFeatures(m_profile);
-    CHECK(features->profile != m_profile, "Profile not found");
+    CHECK_VTM(features->profile != m_profile, "Profile not found");
     xConfirmPara(m_level == Level::LEVEL15_5 && !features->canUseLevel15p5, "Profile does not support level 15.5");
   }
 
diff --git a/source/App/EncoderApp/EncAppCfg.h b/source/App/EncoderApp/EncAppCfg.h
index ff82dd0..7214671 100644
--- a/source/App/EncoderApp/EncAppCfg.h
+++ b/source/App/EncoderApp/EncAppCfg.h
@@ -86,6 +86,15 @@ protected:
   std::string m_bitstreamFileName;                            ///< output bitstream file
   std::string m_reconFileName;                                ///< output reconstruction file
 
+  // altissie added
+  bool      m_writePartition;                                 ///< write the perfect partition
+  bool      m_readPartition;                                  ///< read the partition saved in dat file. Reinject the best partition
+  bool      m_predictPartition;                               ///< predict the partition with cnn+ml model in intra
+  bool      m_predictPartitionInter;                               ///< predict the partition with cnn+ml model in inter
+  std::string m_datFolder;                                   ///< dat folder to save and load partition
+  //sbelhadj added
+  std::string m_modelFolder;                                 ///< folder containing DL and ML models
+
   // Lambda modifiers
   double    m_adLambdaModifier[ MAX_TLAYER ];                 ///< Lambda modifier array for each temporal layer
   std::vector<double> m_adIntraLambdaModifier;                ///< Lambda modifier for Intra pictures, one for each temporal layer. If size>temporalLayer, then use [temporalLayer], else if size>0, use [size()-1], else use m_adLambdaModifier.
@@ -773,6 +782,21 @@ public:
   void  destroy   ();                                         ///< destroy option handling class
   bool  parseCfg  ( int argc, char* argv[] );                ///< parse configuration file to fill member variables
 
+  //altissie added
+  unsigned int getM_uiCTUSize() const {return m_uiCTUSize;};
+  const bool is_writePartition() const {return m_writePartition;};
+  const bool is_readPartition() const {return m_readPartition;};
+  const bool is_predictPartition() const {return m_predictPartition;};
+  const bool is_predictPartitionInter() const {return m_predictPartitionInter;};
+  const std::string &get_filenameInput() const {return m_inputFileName;};
+  const std::string &get_datFolder() const {return m_datFolder;};
+  const unsigned int get_qp() const {return m_iQP;};
+  int get_sourceWidth() const {return m_iSourceWidth;};
+  int get_sourceHeight() const {return m_iSourceHeight;};
+
+  //sbelhadj added
+  const std::string &get_modelFolder() const {return m_modelFolder;};
+
 };// END CLASS DEFINITION EncAppCfg
 
 //! \}
diff --git a/source/App/EncoderApp/encmain.cpp b/source/App/EncoderApp/encmain.cpp
index 0dfefeb..9a56583 100644
--- a/source/App/EncoderApp/encmain.cpp
+++ b/source/App/EncoderApp/encmain.cpp
@@ -43,6 +43,8 @@
 #include "EncoderLib/EncLibCommon.h"
 #include "EncApp.h"
 #include "Utilities/program_options_lite.h"
+#include <EncoderLib/PartitionManager.h>
+#include <EncoderLib/PartitionPrediction.h>
 
 //! \ingroup EncoderApp
 //! \{
@@ -51,6 +53,22 @@ static const uint32_t settingNameWidth = 66;
 static const uint32_t settingHelpWidth = 84;
 static const uint32_t settingValueWidth = 3;
 // --------------------------------------------------------------------------------------------------------------------- //
+// Extern pointer to store and load the partition + current parameter
+PartitionManager * store_partition;
+PartitionManager * load_partition;
+PartitionParam * param_partition;
+PartitionPrediction * predict_partition;
+PartitionPrediction * predict_partitionInter;
+
+
+
+//fdeep::model *model = static_cast<fdeep::model *>(malloc(sizeof(fdeep::model)));
+//std::unique_ptr<fdeep::model> model;
+
+//string folder_model = "MODEL_DIRECTORY_HERE/cnn_model/" ;
+
+
+float time_cnn = 0;
 
 //macro value printing function
 
@@ -121,6 +139,8 @@ int main(int argc, char* argv[])
   bool resized = false;
   int layerIdx = 0;
 
+
+
   initROM();
   TComHash::initBlockSizeToIndex();
 
@@ -213,9 +233,9 @@ int main(int argc, char* argv[])
         if (vps->getDirectRefLayerFlag(i, j))
         {
           int refLayerChromaFormatIdcInVPS = pcEncApp[j]->getChromaFormatIDC();
-          CHECK(curLayerChromaFormatIdc != refLayerChromaFormatIdcInVPS, "The chroma formats of the current layer and the reference layer are different");
+          CHECK_VTM(curLayerChromaFormatIdc != refLayerChromaFormatIdcInVPS, "The chroma formats of the current layer and the reference layer are different");
           int refLayerBitDepthInVPS = pcEncApp[j]->getBitDepth();
-          CHECK(curLayerBitDepth != refLayerBitDepthInVPS, "The bit-depth of the current layer and the reference layer are different");
+          CHECK_VTM(curLayerBitDepth != refLayerBitDepthInVPS, "The bit-depth of the current layer and the reference layer are different");
         }
       }
     }
@@ -225,6 +245,67 @@ int main(int argc, char* argv[])
   printMacroSettings();
 #endif
 
+  // Get partition param from config file
+  param_partition = new PartitionParam(pcEncApp.at(0)->getM_uiCTUSize(), 6*3/*Because I decided to use 6*3 bits to encode MTT in dat file*/, pcEncApp.at(0)->is_writePartition(), pcEncApp.at(0)->is_readPartition(), pcEncApp.at(0)->is_predictPartition(), pcEncApp.at(0)->is_predictPartitionInter());
+
+  //sbelhadj added
+  string folder_model = pcEncApp.at(0)->get_modelFolder() ;
+  if (folder_model.substr(folder_model.length()-1) != "/") folder_model += "/" ;
+
+  if(param_partition->is_writePartition()){
+      //Get name of the input video to create dat file to save partition
+      std::size_t posEnd = pcEncApp.at(0)->get_filenameInput().find_last_of("/");
+      string filenameFeatures = pcEncApp.at(0)->get_filenameInput().substr(posEnd+1);
+      std::size_t pos = filenameFeatures.find(".yuv");
+      filenameFeatures = filenameFeatures.substr(0,pos);
+      filenameFeatures += "_partition_" + to_string(pcEncApp.at(0)->get_qp()) + ".dat";
+      filenameFeatures = pcEncApp.at(0)->get_datFolder() + "/" + filenameFeatures;
+      // Create pointer to store partition
+      store_partition = new PartitionManager(param_partition, (u_int16_t) pcEncApp.at(0)->get_sourceWidth(),
+                                             (u_int16_t) pcEncApp.at(0)->get_sourceHeight(), filenameFeatures, !param_partition->is_writePartition());
+      store_partition->store_params();
+  }
+
+  if(param_partition->is_readPartition()){
+      //Get name of the input video to create dat file to save partition
+      std::size_t posEnd = pcEncApp.at(0)->get_filenameInput().find_last_of("/");
+      string filenameFeatures = pcEncApp.at(0)->get_filenameInput().substr(posEnd+1);
+      std::size_t pos = filenameFeatures.find(".yuv");
+      filenameFeatures = filenameFeatures.substr(0,pos);
+      filenameFeatures += "_partition_" + to_string(pcEncApp.at(0)->get_qp()) + ".dat";
+      filenameFeatures = pcEncApp.at(0)->get_datFolder() + "/" + filenameFeatures;
+      // Create pointer to load partition
+      load_partition = new PartitionManager(param_partition, (u_int16_t) pcEncApp.at(0)->get_sourceWidth(),
+                                            (u_int16_t) pcEncApp.at(0)->get_sourceHeight(), filenameFeatures, param_partition->is_readPartition());
+      load_partition->load_params();
+  }
+
+  // load the model if we predict intra partition
+  if(param_partition->is_predictPartition() ){
+    clock_t start = clock();
+    //*model = fdeep::load_model(folder_model+"my_model_tech_db_filtered2020-05-13_15-05-43_0.094_0.094.json");
+
+    predict_partition = new PartitionPrediction(folder_model+"cnn_model/intra/model.json", pcEncApp.at(0)->get_qp(), true);
+
+    predict_partition->initializeModels("intra", folder_model);
+
+    time_cnn += ((double) clock() - start) / CLOCKS_PER_SEC;
+  }
+
+  // load the model if we predict inter partition
+  if(param_partition->is_predictPartitionInter() ){
+    clock_t start = clock();
+    // *model = fdeep::load_model(folder_model+"my_model_tech_db_filtered2020-05-13_15-05-43_0.094_0.094.json");
+
+//    predict_partitionInter = new PartitionPrediction(folder_model+"inter/20220228_145317_benchmark_mobileNetV2_filteredData.json", pcEncApp.at(0)->get_qp(), false);
+    predict_partitionInter = new PartitionPrediction(folder_model+"cnn_model/inter/my_model_inter_3dim_mobilenetv2_batch256_100epoch_dbfilteredaugmented_gooddim_2021-04-19_15-31-43_0.04_0.044.json", pcEncApp.at(0)->get_qp(), false);
+
+    predict_partitionInter->initializeModels("inter", folder_model);
+
+    time_cnn += ((double) clock() - start) / CLOCKS_PER_SEC;
+  }
+
+
   // starting time
   auto startTime  = std::chrono::steady_clock::now();
   std::time_t startTime2 = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
@@ -337,6 +418,17 @@ int main(int argc, char* argv[])
          encTime / 1000.0);
 #endif
 
+  if(param_partition->is_predictPartition() || param_partition->is_predictPartitionInter()){
+    std::cout<<"Time in the CNN + utilization of result: "<<time_cnn<<std::endl;
+  }
+
+  // Delete pointer
+  delete param_partition;
+  delete store_partition;
+  delete load_partition;
+  delete predict_partition;
+  delete predict_partitionInter;
+
   return 0;
 }
 
diff --git a/source/App/Parcat/parcat.cpp b/source/App/Parcat/parcat.cpp
index 8de2b4b..cdfb846 100644
--- a/source/App/Parcat/parcat.cpp
+++ b/source/App/Parcat/parcat.cpp
@@ -81,9 +81,9 @@ void ParcatHLSyntaxReader::parsePictureHeaderUpToPoc ( ParameterSetManager *para
   // parameter sets
   READ_UVLC(uiCode, "ph_pic_parameter_set_id");
   pps = parameterSetManager->getPPS(uiCode);
-  CHECK(pps == 0, "Invalid PPS");
+  CHECK_VTM(pps == 0, "Invalid PPS");
   sps = parameterSetManager->getSPS(pps->getSPSId());
-  CHECK(sps == 0, "Invalid SPS");
+  CHECK_VTM(sps == 0, "Invalid SPS");
   return;
 }
 
diff --git a/source/App/StreamMergeApp/StreamMergeApp.cpp b/source/App/StreamMergeApp/StreamMergeApp.cpp
index b9943e8..ca261df 100644
--- a/source/App/StreamMergeApp/StreamMergeApp.cpp
+++ b/source/App/StreamMergeApp/StreamMergeApp.cpp
@@ -126,7 +126,7 @@ _byteStreamNALUnit(
 #if RExt__DECODER_DEBUG_BIT_STATISTICS
     statBits.bits += 8; statBits.count++;
 #endif
-    CHECK(zero_byte != 0, "Zero byte not '0'");
+    CHECK_VTM(zero_byte != 0, "Zero byte not '0'");
     stats.m_numZeroByteBytes++;
   }
 
@@ -192,7 +192,7 @@ _byteStreamNALUnit(
 #if RExt__DECODER_DEBUG_BIT_STATISTICS
     statBits.bits += 8; statBits.count++;
 #endif
-    CHECK(trailing_zero_8bits != 0, "Trailing zero bits not '0'");
+    CHECK_VTM(trailing_zero_8bits != 0, "Trailing zero bits not '0'");
     stats.m_numTrailingZero8BitsBytes++;
   }
 }
diff --git a/source/App/StreamMergeApp/StreamMergeApp.h b/source/App/StreamMergeApp/StreamMergeApp.h
index b4dc15a..7193aec 100644
--- a/source/App/StreamMergeApp/StreamMergeApp.h
+++ b/source/App/StreamMergeApp/StreamMergeApp.h
@@ -111,7 +111,7 @@ public:
   */
   bool eofBeforeNBytes(uint32_t n, std::istream& m_Input)
   {
-    CHECK(n > 4, "Unsupported look-ahead value");
+    CHECK_VTM(n > 4, "Unsupported look-ahead value");
     if (m_numFutureBytes >= n)
     {
       return false;
diff --git a/source/App/SubpicMergeApp/SubpicMergeApp.cpp b/source/App/SubpicMergeApp/SubpicMergeApp.cpp
index b6bc029..d486b21 100644
--- a/source/App/SubpicMergeApp/SubpicMergeApp.cpp
+++ b/source/App/SubpicMergeApp/SubpicMergeApp.cpp
@@ -321,7 +321,7 @@ void SubpicMergeApp::parseSliceHeader(HLSyntaxReader &hlsReader, InputNALUnit &n
   slice.setSPS(psManager.getSPS(picHeader.getSPSId()));
 
   InputBitstream &inBs = nalu.getBitstream();
-  CHECK(inBs.getNumBitsLeft() & 7, "Slicedata must be byte aligned");
+  CHECK_VTM(inBs.getNumBitsLeft() & 7, "Slicedata must be byte aligned");
   int numDataBytes = inBs.getNumBitsLeft() / 8;
   for (int i = 0; i < numDataBytes; i++ )
   {
@@ -482,7 +482,7 @@ void SubpicMergeApp::generateMergedStreamSPSes(std::vector<SPS*> &spsList)
   {
     for (auto spsId : subpic.spsIds)
     {
-      CHECK(subpic.psManager.getSPS(spsId)->getSubPicInfoPresentFlag(), "Input streams containing subpictures not supported")
+      CHECK_VTM(subpic.psManager.getSPS(spsId)->getSubPicInfoPresentFlag(), "Input streams containing subpictures not supported")
     }
   }
 
@@ -504,10 +504,10 @@ void SubpicMergeApp::generateMergedStreamSPSes(std::vector<SPS*> &spsList)
     int subPicId = 0;
     for (auto &subpic : *m_subpics)
     {
-      CHECK(subpic.topLeftCornerX % sps.getCTUSize(), "Subpicture top-left X is not multiple of CTU size");
-      CHECK(subpic.topLeftCornerY % sps.getCTUSize(), "Subpicture top-left Y is not multiple of CTU size");
-      CHECK(subpic.width % sps.getCTUSize(), "Subpicture width is not multiple of CTU size");
-      CHECK(subpic.height % sps.getCTUSize(), "Subpicture height is not multiple of CTU size");
+      CHECK_VTM(subpic.topLeftCornerX % sps.getCTUSize(), "Subpicture top-left X is not multiple of CTU size");
+      CHECK_VTM(subpic.topLeftCornerY % sps.getCTUSize(), "Subpicture top-left Y is not multiple of CTU size");
+      CHECK_VTM(subpic.width % sps.getCTUSize(), "Subpicture width is not multiple of CTU size");
+      CHECK_VTM(subpic.height % sps.getCTUSize(), "Subpicture height is not multiple of CTU size");
       sps.setSubPicCtuTopLeftX(subPicId, (uint32_t)(subpic.topLeftCornerX / sps.getCTUSize()));
       sps.setSubPicCtuTopLeftY(subPicId, (uint32_t)(subpic.topLeftCornerY / sps.getCTUSize()));
       sps.setSubPicWidth(subPicId, (uint32_t)(subpic.width / sps.getCTUSize()));
@@ -588,7 +588,7 @@ void SubpicMergeApp::generateMergedStreamPPSes(ParameterSetManager &psManager, s
   {
     for (auto ppsId : subpic.ppsIds)
     {
-      CHECK(subpic.psManager.getPPS(ppsId)->getScalingWindow().getWindowEnabledFlag(), "Scaling window in input streams not supported")
+      CHECK_VTM(subpic.psManager.getPPS(ppsId)->getScalingWindow().getWindowEnabledFlag(), "Scaling window in input streams not supported")
     }
   }
 
@@ -647,14 +647,14 @@ void SubpicMergeApp::generateMergedStreamPPSes(ParameterSetManager &psManager, s
       {
         tileY += tileHeights[tileIdxY];
       }
-      CHECK(tileIdxY == tileHeights.size(), "Could not find subpicture to tile border match");
+      CHECK_VTM(tileIdxY == tileHeights.size(), "Could not find subpicture to tile border match");
 
       unsigned int tileIdxX = 0;
       for (unsigned int tileX = 0; tileX != subpic.topLeftCornerX && tileIdxX < tileWidths.size(); tileIdxX++)
       {
         tileX += tileWidths[tileIdxX];
       }
-      CHECK(tileIdxX == tileWidths.size(), "Could not find subpicture to tile border match")
+      CHECK_VTM(tileIdxX == tileWidths.size(), "Could not find subpicture to tile border match")
 
       const PPS &subpicPPS = *subpic.slices[0].getPPS();
 
@@ -703,8 +703,8 @@ void SubpicMergeApp::updateSliceHeadersForMergedStream(ParameterSetManager &psMa
       // Update slice headers to use new SPSes and PPSes
       int ppsId = slice.getPPS()->getPPSId();
       int spsId = slice.getSPS()->getSPSId();
-      CHECK(!psManager.getSPS(spsId), "Invaldi SPS");
-      CHECK(!psManager.getSPS(ppsId), "Invaldi PPS");
+      CHECK_VTM(!psManager.getSPS(spsId), "Invaldi SPS");
+      CHECK_VTM(!psManager.getSPS(ppsId), "Invaldi PPS");
       slice.setSPS(psManager.getSPS(spsId));
       slice.setPPS(psManager.getPPS(ppsId));
 
@@ -776,7 +776,7 @@ bool SubpicMergeApp::getMixedNalPicFlag()
     prevNaluType = subpic.slices[0].getNalUnitType();
   }
 
-  CHECK(IRAPFound && nonIRAPNonTrailingFound, "IRAP subpictures can only be mixed with trailing subpictures");
+  CHECK_VTM(IRAPFound && nonIRAPNonTrailingFound, "IRAP subpictures can only be mixed with trailing subpictures");
 
   return mixedNaluTypesFlag;
 }
@@ -809,7 +809,7 @@ Subpicture &SubpicMergeApp::selectSubpicForPicHeader(bool isMixedNaluPic)
     }
   }
 
-  CHECK(subpicToReturn == NULL, "Could not find non-IRAP subpicture when mixed NALU types in enabled");
+  CHECK_VTM(subpicToReturn == NULL, "Could not find non-IRAP subpicture when mixed NALU types in enabled");
 
   if (IRAPFound)
   {
@@ -924,7 +924,7 @@ void SubpicMergeApp::generateMergedPic(ParameterSetManager &psManager, bool mixe
   }
 
   bool isMixedNaluPic = getMixedNalPicFlag();
-  CHECK(!mixedNaluFlag && isMixedNaluPic, "Mixed NALU types is disabled but picture contains mixed NALU types");
+  CHECK_VTM(!mixedNaluFlag && isMixedNaluPic, "Mixed NALU types is disabled but picture contains mixed NALU types");
 
   Subpicture &subpicForPicHeader = selectSubpicForPicHeader(isMixedNaluPic);
   bool writePicHeader = true;
@@ -990,7 +990,7 @@ void SubpicMergeApp::validateSubpics()
       else
       {
         int jointCbCrSignFlagCurr = subpic.picHeader.getJointCbCrSignFlag() ? 1 : 0;
-        CHECK(jointCbCrSignFlag != jointCbCrSignFlagCurr, "ph_joint_cbcr_sign_flag must have indentical value in all input subpictures");
+        CHECK_VTM(jointCbCrSignFlag != jointCbCrSignFlagCurr, "ph_joint_cbcr_sign_flag must have indentical value in all input subpictures");
       }
     }
   }
@@ -1012,7 +1012,7 @@ void SubpicMergeApp::validateSubpics()
               if (APSIdType == APSIdType2)
               {
                 bool sameContent = nal.getBitstream().getFifo() == nal2.getBitstream().getFifo();
-                CHECK(!sameContent, "Two APS with the same ID and the same type must have identical content");
+                CHECK_VTM(!sameContent, "Two APS with the same ID and the same type must have identical content");
               }
             }
           }
diff --git a/source/Lib/CommonLib/AdaptiveLoopFilter.cpp b/source/Lib/CommonLib/AdaptiveLoopFilter.cpp
index 91b0490..74353ab 100644
--- a/source/Lib/CommonLib/AdaptiveLoopFilter.cpp
+++ b/source/Lib/CommonLib/AdaptiveLoopFilter.cpp
@@ -631,7 +631,7 @@ void AdaptiveLoopFilter::reconstructCoeffAPSs(CodingStructure& cs, bool luma, bo
     {
       int apsIdx = cs.slice->getTileGroupApsIdLuma()[i];
       curAPS = aps[apsIdx];
-      CHECK(curAPS == NULL, "invalid APS");
+      CHECK_VTM(curAPS == NULL, "invalid APS");
       alfParamTmp = curAPS->getAlfAPSParam();
       reconstructCoeff(alfParamTmp, CHANNEL_TYPE_LUMA, isRdo, true);
       memcpy(m_coeffApsLuma[i], m_coeffFinal, sizeof(m_coeffFinal));
@@ -686,7 +686,7 @@ void AdaptiveLoopFilter::reconstructCoeff( AlfParam& alfParam, ChannelType chann
     {
       int filterIdx = alfParam.filterCoeffDeltaIdx[classIdx];
 
-      CHECK(!(filterIdx >= 0 && filterIdx < alfParam.numLumaFilters), "Bad coeff delta idx in ALF");
+      CHECK_VTM(!(filterIdx >= 0 && filterIdx < alfParam.numLumaFilters), "Bad coeff delta idx in ALF");
       for (int coeffIdx = 0; coeffIdx < numCoeffMinus1; ++coeffIdx)
       {
         m_coeffFinal[classIdx * MAX_NUM_ALF_LUMA_COEFF + coeffIdx] = coeff[filterIdx * MAX_NUM_ALF_LUMA_COEFF + coeffIdx];
@@ -696,7 +696,7 @@ void AdaptiveLoopFilter::reconstructCoeff( AlfParam& alfParam, ChannelType chann
       for( int coeffIdx = 0; coeffIdx < numCoeffMinus1; ++coeffIdx )
       {
         int clipIdx = alfParam.nonLinearFlag[channel] ? clipp[filterIdx * MAX_NUM_ALF_LUMA_COEFF + coeffIdx] : 0;
-        CHECK(!(clipIdx >= 0 && clipIdx < MaxAlfNumClippingValues), "Bad clip idx in ALF");
+        CHECK_VTM(!(clipIdx >= 0 && clipIdx < MaxAlfNumClippingValues), "Bad clip idx in ALF");
         m_clippFinal[classIdx * MAX_NUM_ALF_LUMA_COEFF + coeffIdx] = isRdo ? clipIdx : m_alfClippingValues[channel][clipIdx];
       }
       m_clippFinal[classIdx* MAX_NUM_ALF_LUMA_COEFF + numCoeffMinus1] =
@@ -849,7 +849,7 @@ void AdaptiveLoopFilter::deriveClassificationBlk(AlfClassifier **classifier, int
                                                  const CPelBuf &srcLuma, const Area &blkDst, const Area &blk,
                                                  const int shift, const int vbCTUHeight, int vbPos)
 {
-  CHECK((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
+  CHECK_VTM((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
 
   static const int th[16] = { 0, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4 };
   const int stride = srcLuma.stride;
@@ -1062,12 +1062,12 @@ void AdaptiveLoopFilter::filterBlk(AlfClassifier **classifier, const PelUnitBuf
                                    const short *filterSet, const Pel *fClipSet, const ClpRng &clpRng,
                                    CodingStructure &cs, const int vbCTUHeight, int vbPos)
 {
-  CHECK((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
+  CHECK_VTM((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
 
   const bool bChroma = isChroma( compId );
   if( bChroma )
   {
-    CHECK( filtType != 0, "Chroma needs to have filtType == 0" );
+    CHECK_VTM( filtType != 0, "Chroma needs to have filtType == 0" );
   }
 
   const CPelBuf srcLuma = recSrc.get( compId );
@@ -1097,10 +1097,10 @@ void AdaptiveLoopFilter::filterBlk(AlfClassifier **classifier, const PelUnitBuf
   const int clsSizeY = 4;
   const int clsSizeX = 4;
 
-  CHECK( startHeight % clsSizeY, "Wrong startHeight in filtering" );
-  CHECK( startWidth % clsSizeX, "Wrong startWidth in filtering" );
-  CHECK( ( endHeight - startHeight ) % clsSizeY, "Wrong endHeight in filtering" );
-  CHECK( ( endWidth - startWidth ) % clsSizeX, "Wrong endWidth in filtering" );
+  CHECK_VTM( startHeight % clsSizeY, "Wrong startHeight in filtering" );
+  CHECK_VTM( startWidth % clsSizeX, "Wrong startWidth in filtering" );
+  CHECK_VTM( ( endHeight - startHeight ) % clsSizeY, "Wrong endHeight in filtering" );
+  CHECK_VTM( ( endWidth - startWidth ) % clsSizeX, "Wrong endWidth in filtering" );
 
   AlfClassifier *pClass = nullptr;
 
@@ -1293,9 +1293,9 @@ void AdaptiveLoopFilter::filterBlkCcAlf(const PelBuf &dstBuf, const CPelUnitBuf
                                         const Area &blkSrc, const ComponentID compId, const int16_t *filterCoeff,
                                         const ClpRngs &clpRngs, CodingStructure &cs, int vbCTUHeight, int vbPos)
 {
-  CHECK(1 << floorLog2(vbCTUHeight) != vbCTUHeight, "Not a power of 2");
+  CHECK_VTM(1 << floorLog2(vbCTUHeight) != vbCTUHeight, "Not a power of 2");
 
-  CHECK(!isChroma(compId), "Must be chroma");
+  CHECK_VTM(!isChroma(compId), "Must be chroma");
 
   const SPS*     sps           = cs.slice->getSPS();
   ChromaFormat nChromaFormat   = sps->getChromaFormatIdc();
@@ -1308,10 +1308,10 @@ void AdaptiveLoopFilter::filterBlkCcAlf(const PelBuf &dstBuf, const CPelUnitBuf
   const int scaleX             = getComponentScaleX(compId, nChromaFormat);
   const int scaleY             = getComponentScaleY(compId, nChromaFormat);
 
-  CHECK( startHeight % clsSizeY, "Wrong startHeight in filtering" );
-  CHECK( startWidth % clsSizeX, "Wrong startWidth in filtering" );
-  CHECK( ( endHeight - startHeight ) % clsSizeY, "Wrong endHeight in filtering" );
-  CHECK( ( endWidth - startWidth ) % clsSizeX, "Wrong endWidth in filtering" );
+  CHECK_VTM( startHeight % clsSizeY, "Wrong startHeight in filtering" );
+  CHECK_VTM( startWidth % clsSizeX, "Wrong startWidth in filtering" );
+  CHECK_VTM( ( endHeight - startHeight ) % clsSizeY, "Wrong endHeight in filtering" );
+  CHECK_VTM( ( endWidth - startWidth ) % clsSizeX, "Wrong endWidth in filtering" );
 
   CPelBuf     srcBuf     = recSrc.get(COMPONENT_Y);
   const int   lumaStride = srcBuf.stride;
diff --git a/source/Lib/CommonLib/AlfParameters.h b/source/Lib/CommonLib/AlfParameters.h
index 3bf050d..e28bb35 100644
--- a/source/Lib/CommonLib/AlfParameters.h
+++ b/source/Lib/CommonLib/AlfParameters.h
@@ -112,7 +112,7 @@ struct AlfFilterShape
     else
     {
       filterType = ALF_NUM_OF_FILTER_TYPES;
-      CHECK( 0, "Wrong ALF filter shape" );
+      CHECK_VTM( 0, "Wrong ALF filter shape" );
     }
   }
 
diff --git a/source/Lib/CommonLib/BitStream.cpp b/source/Lib/CommonLib/BitStream.cpp
index 58a3360..5ab0b71 100644
--- a/source/Lib/CommonLib/BitStream.cpp
+++ b/source/Lib/CommonLib/BitStream.cpp
@@ -109,8 +109,8 @@ void OutputBitstream::clear()
 
 void OutputBitstream::write   ( uint32_t uiBits, uint32_t uiNumberOfBits )
 {
-  CHECK( uiNumberOfBits > 32, "Number of bits is exceeds '32'" );
-  CHECK( uiNumberOfBits != 32 && (uiBits & (~0 << uiNumberOfBits)) != 0, "Unsupported parameters" );
+  CHECK_VTM( uiNumberOfBits > 32, "Number of bits is exceeds '32'" );
+  CHECK_VTM( uiNumberOfBits != 32 && (uiBits & (~0 << uiNumberOfBits)) != 0, "Unsupported parameters" );
 
   /* any modulo 8 remainder of num_total_bits cannot be written this time,
    * and will be held until next time. */
@@ -253,7 +253,7 @@ void InputBitstream::pseudoRead ( uint32_t uiNumberOfBits, uint32_t& ruiBits )
 
 void InputBitstream::read (uint32_t uiNumberOfBits, uint32_t& ruiBits)
 {
-  CHECK( uiNumberOfBits > 32, "Too many bits read" );
+  CHECK_VTM( uiNumberOfBits > 32, "Too many bits read" );
 
   m_numBitsRead += uiNumberOfBits;
 
@@ -290,7 +290,7 @@ void InputBitstream::read (uint32_t uiNumberOfBits, uint32_t& ruiBits)
    */
   uint32_t aligned_word = 0;
   uint32_t num_bytes_to_load = (uiNumberOfBits - 1) >> 3;
-  CHECK(m_fifo_idx + num_bytes_to_load >= m_fifo.size(), "Exceeded FIFO size");
+  CHECK_VTM(m_fifo_idx + num_bytes_to_load >= m_fifo.size(), "Exceeded FIFO size");
 
   switch (num_bytes_to_load)
   {
@@ -319,7 +319,7 @@ void InputBitstream::read (uint32_t uiNumberOfBits, uint32_t& ruiBits)
  */
 void OutputBitstream::insertAt(const OutputBitstream& src, uint32_t pos)
 {
-  CHECK(0 != src.getNumberOfWrittenBits() % 8, "Number of written bits is not a multiple of 8");
+  CHECK_VTM(0 != src.getNumberOfWrittenBits() % 8, "Number of written bits is not a multiple of 8");
 
   vector<uint8_t>::iterator at = m_fifo.begin() + pos;
   m_fifo.insert(at, src.m_fifo.begin(), src.m_fifo.end());
@@ -396,14 +396,14 @@ uint32_t InputBitstream::readByteAlignment()
 {
   uint32_t code = 0;
   read( 1, code );
-  CHECK(code != 1, "Code is not '1'");
+  CHECK_VTM(code != 1, "Code is not '1'");
 
   uint32_t numBits = getNumBitsUntilByteAligned();
   if(numBits)
   {
-    CHECK(numBits > getNumBitsLeft(), "More bits available than left");
+    CHECK_VTM(numBits > getNumBitsLeft(), "More bits available than left");
     read( numBits, code );
-    CHECK(code != 0, "Code not '0'");
+    CHECK_VTM(code != 0, "Code not '0'");
   }
   return numBits+1;
 }
diff --git a/source/Lib/CommonLib/BitStream.h b/source/Lib/CommonLib/BitStream.h
index bce5fea..34fc70d 100644
--- a/source/Lib/CommonLib/BitStream.h
+++ b/source/Lib/CommonLib/BitStream.h
@@ -171,7 +171,7 @@ public:
   void        read            ( uint32_t uiNumberOfBits, uint32_t& ruiBits );
   void        readByte        ( uint32_t &ruiBits )
   {
-    CHECK( m_fifo_idx >= m_fifo.size(), "FIFO exceeded" );
+    CHECK_VTM( m_fifo_idx >= m_fifo.size(), "FIFO exceeded" );
     ruiBits = m_fifo[m_fifo_idx++];
 #if ENABLE_TRACING
     m_numBitsRead += 8;
@@ -180,7 +180,7 @@ public:
 
   void        peekPreviousByte( uint32_t &byte )
   {
-    CHECK( m_fifo_idx == 0, "FIFO empty" );
+    CHECK_VTM( m_fifo_idx == 0, "FIFO empty" );
     byte = m_fifo[m_fifo_idx - 1];
   }
 
diff --git a/source/Lib/CommonLib/Buffer.cpp b/source/Lib/CommonLib/Buffer.cpp
index b691f54..fd5533d 100644
--- a/source/Lib/CommonLib/Buffer.cpp
+++ b/source/Lib/CommonLib/Buffer.cpp
@@ -684,7 +684,7 @@ void PelStorage::create( const UnitArea &_UnitArea )
 
 void PelStorage::create( const ChromaFormat &_chromaFormat, const Area& _area, const unsigned _maxCUSize, const unsigned _margin, const unsigned _alignment, const bool _scaleChromaMargin )
 {
-  CHECK( !bufs.empty(), "Trying to re-create an already initialized buffer" );
+  CHECK_VTM( !bufs.empty(), "Trying to re-create an already initialized buffer" );
 
   chromaFormat = _chromaFormat;
 
@@ -715,11 +715,11 @@ void PelStorage::create( const ChromaFormat &_chromaFormat, const Area& _area, c
     if( _alignment )
     {
       // make sure buffer lines are align
-      CHECK( _alignment != MEMORY_ALIGN_DEF_SIZE, "Unsupported alignment" );
+      CHECK_VTM( _alignment != MEMORY_ALIGN_DEF_SIZE, "Unsupported alignment" );
       totalWidth = ( ( totalWidth + _alignment - 1 ) / _alignment ) * _alignment;
     }
     uint32_t area = totalWidth * totalHeight;
-    CHECK( !area, "Trying to create a buffer with zero area" );
+    CHECK_VTM( !area, "Trying to create a buffer with zero area" );
 
     m_origin[i] = ( Pel* ) xMalloc( Pel, area );
     Pel* topLeft = m_origin[i] + totalWidth * ymargin + xmargin;
@@ -749,9 +749,9 @@ void PelStorage::swap( PelStorage& other )
   for( uint32_t i = 0; i < numCh; i++ )
   {
     // check this otherwise it would turn out to get very weird
-    CHECK( chromaFormat                   != other.chromaFormat                  , "Incompatible formats" );
-    CHECK( get( ComponentID( i ) )        != other.get( ComponentID( i ) )       , "Incompatible formats" );
-    CHECK( get( ComponentID( i ) ).stride != other.get( ComponentID( i ) ).stride, "Incompatible formats" );
+    CHECK_VTM( chromaFormat                   != other.chromaFormat                  , "Incompatible formats" );
+    CHECK_VTM( get( ComponentID( i ) )        != other.get( ComponentID( i ) )       , "Incompatible formats" );
+    CHECK_VTM( get( ComponentID( i ) ).stride != other.get( ComponentID( i ) ).stride, "Incompatible formats" );
 
     std::swap( bufs[i].buf,    other.bufs[i].buf );
     std::swap( bufs[i].stride, other.bufs[i].stride );
@@ -827,9 +827,9 @@ void UnitBuf<Pel>::colorSpaceConvert(const UnitBuf<Pel> &other, const bool forwa
   int r, g, b;
   int y0, cg, co;
 
-  CHECK(bufs[COMPONENT_Y].stride != bufs[COMPONENT_Cb].stride || bufs[COMPONENT_Y].stride != bufs[COMPONENT_Cr].stride, "unequal stride for 444 content");
-  CHECK(other.bufs[COMPONENT_Y].stride != other.bufs[COMPONENT_Cb].stride || other.bufs[COMPONENT_Y].stride != other.bufs[COMPONENT_Cr].stride, "unequal stride for 444 content");
-  CHECK(bufs[COMPONENT_Y].width != other.bufs[COMPONENT_Y].width || bufs[COMPONENT_Y].height != other.bufs[COMPONENT_Y].height, "unequal block size")
+  CHECK_VTM(bufs[COMPONENT_Y].stride != bufs[COMPONENT_Cb].stride || bufs[COMPONENT_Y].stride != bufs[COMPONENT_Cr].stride, "unequal stride for 444 content");
+  CHECK_VTM(other.bufs[COMPONENT_Y].stride != other.bufs[COMPONENT_Cb].stride || other.bufs[COMPONENT_Y].stride != other.bufs[COMPONENT_Cr].stride, "unequal stride for 444 content");
+  CHECK_VTM(bufs[COMPONENT_Y].width != other.bufs[COMPONENT_Y].width || bufs[COMPONENT_Y].height != other.bufs[COMPONENT_Y].height, "unequal block size")
 
     if (forward)
     {
diff --git a/source/Lib/CommonLib/Buffer.h b/source/Lib/CommonLib/Buffer.h
index 4f79060..f85a25c 100644
--- a/source/Lib/CommonLib/Buffer.h
+++ b/source/Lib/CommonLib/Buffer.h
@@ -317,8 +317,8 @@ void AreaBuf<T>::copyFrom( const AreaBuf<const T> &other )
   static_assert( std::is_trivially_copyable<T>::value, "Type T is not trivially_copyable" );
 #endif
 
-  CHECK( width  != other.width,  "Incompatible size" );
-  CHECK( height != other.height, "Incompatible size" );
+  CHECK_VTM( width  != other.width,  "Incompatible size" );
+  CHECK_VTM( height != other.height, "Incompatible size" );
 
   if( buf == other.buf )
   {
@@ -349,8 +349,8 @@ void AreaBuf<T>::copyFrom( const AreaBuf<const T> &other )
 template<typename T>
 void AreaBuf<T>::subtract( const AreaBuf<const T> &other )
 {
-  CHECK( width  != other.width,  "Incompatible size" );
-  CHECK( height != other.height, "Incompatible size" );
+  CHECK_VTM( width  != other.width,  "Incompatible size" );
+  CHECK_VTM( height != other.height, "Incompatible size" );
 
         T* dest =       buf;
   const T* subs = other.buf;
@@ -434,7 +434,7 @@ void AreaBuf<T>::removeWeightHighFreq(const AreaBuf<T>& other, const bool bClip,
     else if(!(width & 3))
       g_pelBufOP.removeWeightHighFreq4(dst, dstStride, src, srcStride, width, height, 16, bcwWeight);
     else
-      CHECK(true, "Not supported");
+      CHECK_VTM(true, "Not supported");
   }
   else
   {
@@ -483,7 +483,7 @@ void AreaBuf<T>::removeHighFreq( const AreaBuf<T>& other, const bool bClip, cons
     else if (!(width & 3))
       g_pelBufOP.removeHighFreq4(dst, dstStride, src, srcStride, width, height);
     else
-      CHECK(true, "Not supported");
+      CHECK_VTM(true, "Not supported");
   }
   else
   {
@@ -536,7 +536,7 @@ void AreaBuf<T>::extendBorderPel(unsigned marginX, unsigned marginY)
   int w = width;
   int s = stride;
 
-  CHECK((w + 2 * marginX) > s, "Size of buffer too small to extend");
+  CHECK_VTM((w + 2 * marginX) > s, "Size of buffer too small to extend");
   // do left and right margins
   for (int y = 0; y < h; y++)
   {
@@ -573,7 +573,7 @@ void AreaBuf<T>::padBorderPel( unsigned marginX, unsigned marginY, int dir )
   int h = height;
   int w = width;
 
-  CHECK( w  > s, "Size of buffer too small to extend" );
+  CHECK_VTM( w  > s, "Size of buffer too small to extend" );
 
   // top-left margin
   if ( dir == 1 )
@@ -612,7 +612,7 @@ void AreaBuf<T>::extendBorderPel( unsigned margin )
   int w = width;
   int s = stride;
 
-  CHECK( ( w + 2 * margin ) > s, "Size of buffer too small to extend" );
+  CHECK_VTM( ( w + 2 * margin ) > s, "Size of buffer too small to extend" );
   // do left and right margins
   for( int y = 0; y < h; y++ )
   {
@@ -646,8 +646,8 @@ T AreaBuf<T>::meanDiff( const AreaBuf<const T> &other ) const
 {
   int64_t acc = 0;
 
-  CHECK( width  != other.width,  "Incompatible size" );
-  CHECK( height != other.height, "Incompatible size" );
+  CHECK_VTM( width  != other.width,  "Incompatible size" );
+  CHECK_VTM( height != other.height, "Incompatible size" );
 
   const T* src1 =       buf;
   const T* src2 = other.buf;
@@ -687,7 +687,7 @@ void AreaBuf<T>::subtract( const T val )
 template<typename T>
 void AreaBuf<T>::transposedFrom( const AreaBuf<const T> &other )
 {
-  CHECK( width * height != other.width * other.height, "Incompatible size" );
+  CHECK_VTM( width * height != other.width * other.height, "Incompatible size" );
 
         T* dst  =       buf;
   const T* src  = other.buf;
@@ -802,9 +802,9 @@ void UnitBuf<T>::fill( const T &val )
 template<typename T>
 void UnitBuf<T>::copyFrom(const UnitBuf<const T> &other, const bool lumaOnly, const bool chromaOnly )
 {
-  CHECK( chromaFormat != other.chromaFormat, "Incompatible formats" );
+  CHECK_VTM( chromaFormat != other.chromaFormat, "Incompatible formats" );
 
-  CHECK( lumaOnly && chromaOnly, "Not allowed to have both lumaOnly and chromaOnly selected" );
+  CHECK_VTM( lumaOnly && chromaOnly, "Not allowed to have both lumaOnly and chromaOnly selected" );
   const size_t compStart = chromaOnly ? 1 : 0;
   const size_t compEnd   = lumaOnly ? 1 : (unsigned) bufs.size();
   for( size_t i = compStart; i < compEnd; i++ )
@@ -818,7 +818,7 @@ void UnitBuf<T>::copyFrom(const UnitBuf<const T> &other, const bool lumaOnly, co
 template<typename T>
 void UnitBuf<T>::subtract( const UnitBuf<const T> &other )
 {
-  CHECK( chromaFormat != other.chromaFormat, "Incompatible formats" );
+  CHECK_VTM( chromaFormat != other.chromaFormat, "Incompatible formats" );
 
   for( unsigned i = 0; i < bufs.size(); i++ )
   {
@@ -829,9 +829,9 @@ void UnitBuf<T>::subtract( const UnitBuf<const T> &other )
 template<typename T>
 void UnitBuf<T>::copyClip(const UnitBuf<const T> &src, const ClpRngs &clpRngs, const bool lumaOnly, const bool chromaOnly )
 {
-  CHECK( chromaFormat != src.chromaFormat, "Incompatible formats" );
+  CHECK_VTM( chromaFormat != src.chromaFormat, "Incompatible formats" );
 
-  CHECK( lumaOnly && chromaOnly, "Not allowed to have both lumaOnly and chromaOnly selected" );
+  CHECK_VTM( lumaOnly && chromaOnly, "Not allowed to have both lumaOnly and chromaOnly selected" );
   const size_t compStart = chromaOnly ? 1 : 0;
   const size_t compEnd   = lumaOnly ? 1 : bufs.size();
   for( size_t i = compStart; i < compEnd; i++ )
@@ -844,7 +844,7 @@ void UnitBuf<T>::copyClip(const UnitBuf<const T> &src, const ClpRngs &clpRngs, c
 template<typename T>
 void UnitBuf<T>::roundToOutputBitdepth(const UnitBuf<const T> &src, const ClpRngs& clpRngs)
 {
-  CHECK(chromaFormat != src.chromaFormat, "Incompatible formats");
+  CHECK_VTM(chromaFormat != src.chromaFormat, "Incompatible formats");
 
   for (unsigned i = 0; i < bufs.size(); i++)
   {
@@ -855,8 +855,8 @@ void UnitBuf<T>::roundToOutputBitdepth(const UnitBuf<const T> &src, const ClpRng
 template<typename T>
 void UnitBuf<T>::reconstruct(const UnitBuf<const T> &pred, const UnitBuf<const T> &resi, const ClpRngs& clpRngs)
 {
-  CHECK( chromaFormat != pred.chromaFormat, "Incompatible formats" );
-  CHECK( chromaFormat != resi.chromaFormat, "Incompatible formats" );
+  CHECK_VTM( chromaFormat != pred.chromaFormat, "Incompatible formats" );
+  CHECK_VTM( chromaFormat != resi.chromaFormat, "Incompatible formats" );
 
   for( unsigned i = 0; i < bufs.size(); i++ )
   {
@@ -870,7 +870,7 @@ void UnitBuf<T>::addWeightedAvg(const UnitBuf<const T> &other1, const UnitBuf<co
   const size_t istart = chromaOnly ? 1 : 0;
   const size_t iend = lumaOnly ? 1 : bufs.size();
 
-  CHECK(lumaOnly && chromaOnly, "should not happen");
+  CHECK_VTM(lumaOnly && chromaOnly, "should not happen");
 
   for(size_t i = istart; i < iend; i++)
   {
@@ -884,7 +884,7 @@ void UnitBuf<T>::addAvg(const UnitBuf<const T> &other1, const UnitBuf<const T> &
   const size_t istart = chromaOnly ? 1 : 0;
   const size_t iend   = lumaOnly   ? 1 : bufs.size();
 
-  CHECK( lumaOnly && chromaOnly, "should not happen" );
+  CHECK_VTM( lumaOnly && chromaOnly, "should not happen" );
 
   for( size_t i = istart; i < iend; i++)
   {
@@ -1024,7 +1024,7 @@ struct CompStorage : public PelBuf
 
   void create( const Size& size )
   {
-    CHECK( m_memory, "Trying to re-create an already initialized buffer" );
+    CHECK_VTM( m_memory, "Trying to re-create an already initialized buffer" );
     m_memory = new Pel [ size.area() ];
     *static_cast<PelBuf*>(this) = PelBuf( m_memory, size );
   }
diff --git a/source/Lib/CommonLib/CodingStatistics.h b/source/Lib/CommonLib/CodingStatistics.h
index 2cbb789..059d5af 100644
--- a/source/Lib/CommonLib/CodingStatistics.h
+++ b/source/Lib/CommonLib/CodingStatistics.h
@@ -219,7 +219,7 @@ static inline const char* getName(CodingStatisticsType name)
     "TOOL_LFNST",
     "TOOL_TOTAL"
   };
-  CHECK( STATS__NUM_STATS != sizeof( statNames ) / sizeof( char* ) || name >= STATS__NUM_STATS, "stats out of range" );
+  CHECK_VTM( STATS__NUM_STATS != sizeof( statNames ) / sizeof( char* ) || name >= STATS__NUM_STATS, "stats out of range" );
   return statNames[name];
 }
 
@@ -281,7 +281,7 @@ public:
 
   static const char *GetSubClassString( const uint32_t subClass )
   {
-    CHECK( subClass >= CODING_STATS_NUM_SUBCLASSES, "Subclass does not exist" );
+    CHECK_VTM( subClass >= CODING_STATS_NUM_SUBCLASSES, "Subclass does not exist" );
     static const char *strings[1 + MAX_NUM_COMPONENT + MAX_NUM_CHANNEL_TYPE] = { "-", "Y", "Cb", "Cr", "Luma", "Chroma" };
     return strings[subClass / CODING_STATS_NUM_SIZES];
   }
@@ -807,7 +807,7 @@ public:
 
   static int getNumOnes( int bins )
   {
-    CHECK( bins < 0, "Bins should not be nagative" );
+    CHECK_VTM( bins < 0, "Bins should not be nagative" );
 
     int count = 0;
     while( bins )
@@ -820,7 +820,7 @@ public:
 
   static void IncrementStatisticEP( const CodingStatisticsClassType &stat, const int numBits, const int value )
   {
-    CHECK( stat.type == STATS__CABAC_BITS__INVALID, "Should never be used." );
+    CHECK_VTM( stat.type == STATS__CABAC_BITS__INVALID, "Should never be used." );
     SStat &s = GetStatisticEP( stat );
     s.bits  += numBits;
 #if EPBINCOUNT_FIX
@@ -857,7 +857,7 @@ public:
 
   static void IncrementStatisticTool( const CodingStatisticsClassType &stat )
   {
-    CHECK( stat.type < STATS__TOOL_TOTAL_FRAME || stat.type >= STATS__TOOL_TOTAL, "Should never be used." );
+    CHECK_VTM( stat.type < STATS__TOOL_TOTAL_FRAME || stat.type >= STATS__TOOL_TOTAL, "Should never be used." );
     StatTool &s = GetStatisticTool( stat );
     s.count++;
 
@@ -871,7 +871,7 @@ public:
 
   static void UpdateCABACStat( const CodingStatisticsClassType &stat, uint32_t uiRangeBefore, uint32_t uiRangeAfter, int val )
   {
-    CHECK( stat.type == STATS__CABAC_BITS__INVALID, "Should never be used." );
+    CHECK_VTM( stat.type == STATS__CABAC_BITS__INVALID, "Should never be used." );
     CodingStatistics &inst = GetSingletonInstance();
     // doing rangeBefore*p(x)=rangeAfter
     // p(x)=rangeAfter/rangeBefore
diff --git a/source/Lib/CommonLib/CodingStructure.cpp b/source/Lib/CommonLib/CodingStructure.cpp
index b655d44..bc6c935 100644
--- a/source/Lib/CommonLib/CodingStructure.cpp
+++ b/source/Lib/CommonLib/CodingStructure.cpp
@@ -270,7 +270,7 @@ CodingUnit* CodingStructure::getLumaCU( const Position &pos )
 {
   const ChannelType effChType = CHANNEL_TYPE_LUMA;
   const CompArea &_blk = area.blocks[effChType];
-  CHECK( !_blk.contains( pos ), "must contain the pos" );
+  CHECK_VTM( !_blk.contains( pos ), "must contain the pos" );
 
   const unsigned idx = m_cuIdx[effChType][rsAddr( pos, _blk.pos(), _blk.width, unitScale[effChType] )];
 
@@ -293,8 +293,8 @@ CodingUnit* CodingStructure::getCU( const Position &pos, const ChannelType effCh
     //keep this check, which is helpful to identify bugs
     if( treeType == TREE_C && effChType == CHANNEL_TYPE_LUMA )
     {
-      CHECK( parent == nullptr, "parent shall be valid; consider using function getLumaCU()" );
-      CHECK( parent->treeType != TREE_D, "wrong parent treeType " );
+      CHECK_VTM( parent == nullptr, "parent shall be valid; consider using function getLumaCU()" );
+      CHECK_VTM( parent->treeType != TREE_D, "wrong parent treeType " );
     }
     if (parent)
     {
@@ -328,8 +328,8 @@ const CodingUnit* CodingStructure::getCU( const Position &pos, const ChannelType
   {
     if( treeType == TREE_C && effChType == CHANNEL_TYPE_LUMA )
     {
-      CHECK( parent == nullptr, "parent shall be valid; consider using function getLumaCU()" );
-      CHECK( parent->treeType != TREE_D, "wrong parent treeType" );
+      CHECK_VTM( parent == nullptr, "parent shall be valid; consider using function getLumaCU()" );
+      CHECK_VTM( parent->treeType != TREE_D, "wrong parent treeType" );
     }
     if (parent)
     {
@@ -453,8 +453,8 @@ TransformUnit* CodingStructure::getTU( const Position &pos, const ChannelType ef
             while( !tus[idx - 1 + extraIdx]->blocks[getFirstComponentOfChannel( effChType )].contains( pos ) )
             {
               extraIdx++;
-              CHECK( tus[idx - 1 + extraIdx]->cu->treeType == TREE_C, "tu searched by position points to a chroma tree CU" );
-              CHECK( extraIdx > 3, "extraIdx > 3" );
+              CHECK_VTM( tus[idx - 1 + extraIdx]->cu->treeType == TREE_C, "tu searched by position points to a chroma tree CU" );
+              CHECK_VTM( extraIdx > 3, "extraIdx > 3" );
             }
           }
         }
@@ -508,8 +508,8 @@ const TransformUnit * CodingStructure::getTU( const Position &pos, const Channel
             while ( !tus[idx - 1 + extraIdx]->blocks[getFirstComponentOfChannel( effChType )].contains(pos) )
             {
               extraIdx++;
-              CHECK( tus[idx - 1 + extraIdx]->cu->treeType == TREE_C, "tu searched by position points to a chroma tree CU" );
-              CHECK( extraIdx > 3, "extraIdx > 3" );
+              CHECK_VTM( tus[idx - 1 + extraIdx]->cu->treeType == TREE_C, "tu searched by position points to a chroma tree CU" );
+              CHECK_VTM( extraIdx > 3, "extraIdx > 3" );
             }
           }
         }
@@ -576,7 +576,7 @@ CodingUnit& CodingStructure::addCU( const UnitArea &unit, const ChannelType chTy
     const Area scaledSelf  = scale.scale( _selfBlk );
     const Area scaledBlk   = scale.scale(     _blk );
     unsigned *idxPtr       = m_cuIdx[i] + rsAddr( scaledBlk.pos(), scaledSelf.pos(), scaledSelf.width );
-    CHECK( *idxPtr, "Overwriting a pre-existing value, should be '0'!" );
+    CHECK_VTM( *idxPtr, "Overwriting a pre-existing value, should be '0'!" );
     AreaBuf<uint32_t>( idxPtr, scaledSelf.width, scaledBlk.size() ).fill( idx );
   }
 
@@ -636,7 +636,7 @@ PredictionUnit& CodingStructure::addPU( const UnitArea &unit, const ChannelType
     const Area scaledSelf  = scale.scale( _selfBlk );
     const Area scaledBlk   = scale.scale(     _blk );
     unsigned *idxPtr       = m_puIdx[i] + rsAddr( scaledBlk.pos(), scaledSelf.pos(), scaledSelf.width );
-    CHECK( *idxPtr, "Overwriting a pre-existing value, should be '0'!" );
+    CHECK_VTM( *idxPtr, "Overwriting a pre-existing value, should be '0'!" );
     AreaBuf<uint32_t>( idxPtr, scaledSelf.width, scaledBlk.size() ).fill( idx );
   }
 
@@ -721,7 +721,7 @@ TransformUnit& CodingStructure::addTU( const UnitArea &unit, const ChannelType c
         const Area scaledSelf = scale.scale(_selfBlk);
         const Area scaledBlk = isIspTu ? scale.scale(tu->cu->blocks[i]) : scale.scale(_blk);
         unsigned *idxPtr = m_tuIdx[i] + rsAddr(scaledBlk.pos(), scaledSelf.pos(), scaledSelf.width);
-        CHECK(*idxPtr, "Overwriting a pre-existing value, should be '0'!");
+        CHECK_VTM(*idxPtr, "Overwriting a pre-existing value, should be '0'!");
         AreaBuf<uint32_t>(idxPtr, scaledSelf.width, scaledBlk.size()).fill(idx);
       }
     }
@@ -1035,7 +1035,7 @@ void CodingStructure::reorderPrevPLT(PLTBuf& prevPLT, uint8_t curPLTSize[MAX_NUM
     ComponentID comID = jointPLT ? (ComponentID)compBegin : ((i > 0) ? COMPONENT_Cb : COMPONENT_Y);
     prevPLT.curPLTSize[comID] = curPLTSize[comID] + stuffPLTsize[comID];
     memcpy(prevPLT.curPLT[i], stuffedPLT[i], prevPLT.curPLTSize[comID] * sizeof(Pel));
-    CHECK(prevPLT.curPLTSize[comID] > maxPredPltSize, " Maximum palette predictor size exceed limit");
+    CHECK_VTM(prevPLT.curPLTSize[comID] > maxPredPltSize, " Maximum palette predictor size exceed limit");
   }
 }
 
@@ -1064,7 +1064,7 @@ void CodingStructure::storePrevPLT(PLTBuf& predictor)
 
 void CodingStructure::rebindPicBufs()
 {
-  CHECK( parent, "rebindPicBufs can only be used for the top level CodingStructure" );
+  CHECK_VTM( parent, "rebindPicBufs can only be used for the top level CodingStructure" );
 
   if (!picture->M_BUFS(0, PIC_RECONSTRUCTION).bufs.empty())
   {
@@ -1154,7 +1154,7 @@ void CodingStructure::destroyCoeffs()
 
 void CodingStructure::initSubStructure( CodingStructure& subStruct, const ChannelType _chType, const UnitArea &subArea, const bool &isTuEnc )
 {
-  CHECK( this == &subStruct, "Trying to init self as sub-structure" );
+  CHECK_VTM( this == &subStruct, "Trying to init self as sub-structure" );
 
   subStruct.useDbCost = false;
   subStruct.costDbOffset = 0;
@@ -1603,7 +1603,7 @@ PelBuf CodingStructure::getBuf( const CompArea &blk, const PictureType &type )
 
   PelStorage* buf = type == PIC_PREDICTION ? &m_pred : ( type == PIC_RESIDUAL ? &m_resi : ( type == PIC_RECONSTRUCTION ? &m_reco : ( type == PIC_ORG_RESI ? &m_orgr : nullptr ) ) );
 
-  CHECK( !buf, "Unknown buffer requested" );
+  CHECK_VTM( !buf, "Unknown buffer requested" );
 
   CHECKD( !area.blocks[compID].contains( blk ), "Buffer not contained in self requested" );
 
@@ -1637,7 +1637,7 @@ const CPelBuf CodingStructure::getBuf( const CompArea &blk, const PictureType &t
 
   const PelStorage* buf = type == PIC_PREDICTION ? &m_pred : ( type == PIC_RESIDUAL ? &m_resi : ( type == PIC_RECONSTRUCTION ? &m_reco : ( type == PIC_ORG_RESI ? &m_orgr : nullptr ) ) );
 
-  CHECK( !buf, "Unknown buffer requested" );
+  CHECK_VTM( !buf, "Unknown buffer requested" );
 
   CHECKD( !area.blocks[compID].contains( blk ), "Buffer not contained in self requested" );
 
diff --git a/source/Lib/CommonLib/CommonDef.h b/source/Lib/CommonLib/CommonDef.h
index bcd8e80..3a12061 100644
--- a/source/Lib/CommonLib/CommonDef.h
+++ b/source/Lib/CommonLib/CommonDef.h
@@ -512,7 +512,7 @@ template <typename T> inline T ClipPel (const T a, const ClpRng& clpRng)
 
 template <typename T> inline void Check3( T minVal, T maxVal, T a)
 {
-  CHECK( ( a > maxVal ) || ( a < minVal ), "ERROR: Range check " << minVal << " >= " << a << " <= " << maxVal << " failed" );
+  CHECK_VTM( ( a > maxVal ) || ( a < minVal ), "ERROR: Range check " << minVal << " >= " << a << " <= " << maxVal << " failed" );
 }  ///< general min/max clip
 
 extern MsgLevel g_verbosity;
diff --git a/source/Lib/CommonLib/ContextModelling.cpp b/source/Lib/CommonLib/ContextModelling.cpp
index 3e1a44b..c3b7c70 100644
--- a/source/Lib/CommonLib/ContextModelling.cpp
+++ b/source/Lib/CommonLib/ContextModelling.cpp
@@ -348,7 +348,7 @@ unsigned DeriveCtx::CtxIBCFlag(const CodingUnit& cu)
 
 void MergeCtx::setMergeInfo( PredictionUnit& pu, int candIdx )
 {
-  CHECK( candIdx >= numValidMergeCand, "Merge candidate does not exist" );
+  CHECK_VTM( candIdx >= numValidMergeCand, "Merge candidate does not exist" );
   pu.regularMergeFlag        = !(pu.ciipFlag || pu.cu->geoFlag);
   pu.mergeFlag               = true;
   pu.mmvdMergeFlag = false;
diff --git a/source/Lib/CommonLib/Contexts.cpp b/source/Lib/CommonLib/Contexts.cpp
index f3acf16..0a70e07 100644
--- a/source/Lib/CommonLib/Contexts.cpp
+++ b/source/Lib/CommonLib/Contexts.cpp
@@ -153,7 +153,7 @@ CtxSet::CtxSet( std::initializer_list<CtxSet> ctxSets )
 
 const std::vector<uint8_t>& ContextSetCfg::getInitTable( unsigned initId )
 {
-  CHECK( initId >= (unsigned)sm_InitTables.size(),
+  CHECK_VTM( initId >= (unsigned)sm_InitTables.size(),
          "Invalid initId (" << initId << "), only " << sm_InitTables.size() << " tables defined." );
   return sm_InitTables[initId];
 }
@@ -168,7 +168,7 @@ CtxSet ContextSetCfg::addCtxSet( std::initializer_list<std::initializer_list<uin
   {
     const std::initializer_list<uint8_t>& initSet   = *setIter;
     std::vector<uint8_t>&           initTable = sm_InitTables[setId];
-    CHECK( initSet.size() != numValues,
+    CHECK_VTM( initSet.size() != numValues,
            "Number of init values do not match for all sets (" << initSet.size() << " != " << numValues << ")." );
     initTable.resize( startIdx + numValues );
     std::size_t elemId = startIdx;
@@ -912,10 +912,10 @@ template <class BinProbModel>
 void CtxStore<BinProbModel>::init( int qp, int initId )
 {
   const std::vector<uint8_t>& initTable = ContextSetCfg::getInitTable( initId );
-  CHECK( m_CtxBuffer.size() != initTable.size(),
+  CHECK_VTM( m_CtxBuffer.size() != initTable.size(),
         "Size of init table (" << initTable.size() << ") does not match size of context buffer (" << m_CtxBuffer.size() << ")." );
   const std::vector<uint8_t> &rateInitTable = ContextSetCfg::getInitTable(NUMBER_OF_SLICE_TYPES);
-  CHECK(m_CtxBuffer.size() != rateInitTable.size(),
+  CHECK_VTM(m_CtxBuffer.size() != rateInitTable.size(),
         "Size of rate init table (" << rateInitTable.size() << ") does not match size of context buffer ("
                                     << m_CtxBuffer.size() << ").");
   int clippedQP = Clip3( 0, MAX_QP, qp );
@@ -929,7 +929,7 @@ void CtxStore<BinProbModel>::init( int qp, int initId )
 template <class BinProbModel>
 void CtxStore<BinProbModel>::setWinSizes( const std::vector<uint8_t>& log2WindowSizes )
 {
-  CHECK( m_CtxBuffer.size() != log2WindowSizes.size(),
+  CHECK_VTM( m_CtxBuffer.size() != log2WindowSizes.size(),
         "Size of window size table (" << log2WindowSizes.size() << ") does not match size of context buffer (" << m_CtxBuffer.size() << ")." );
   for( std::size_t k = 0; k < m_CtxBuffer.size(); k++ )
   {
@@ -940,7 +940,7 @@ void CtxStore<BinProbModel>::setWinSizes( const std::vector<uint8_t>& log2Window
 template <class BinProbModel>
 void CtxStore<BinProbModel>::loadPStates( const std::vector<uint16_t>& probStates )
 {
-  CHECK( m_CtxBuffer.size() != probStates.size(),
+  CHECK_VTM( m_CtxBuffer.size() != probStates.size(),
         "Size of prob states table (" << probStates.size() << ") does not match size of context buffer (" << m_CtxBuffer.size() << ")." );
   for( std::size_t k = 0; k < m_CtxBuffer.size(); k++ )
   {
diff --git a/source/Lib/CommonLib/Contexts.h b/source/Lib/CommonLib/Contexts.h
index 5a94a2d..fb3d392 100644
--- a/source/Lib/CommonLib/Contexts.h
+++ b/source/Lib/CommonLib/Contexts.h
@@ -115,7 +115,7 @@ public:
     int rate0 = 2 + ((log2WindowSize >> 2) & 3);
     int rate1 = 3 + rate0 + (log2WindowSize & 3);
     m_rate    = 16 * rate0 + rate1;
-    CHECK(rate1 > 9, "Second window size is too large!");
+    CHECK_VTM(rate1 > 9, "Second window size is too large!");
   }
   void estFracBitsUpdate(unsigned bin, uint64_t &b)
   {
diff --git a/source/Lib/CommonLib/DepQuant.cpp b/source/Lib/CommonLib/DepQuant.cpp
index 85c0718..e18d46d 100644
--- a/source/Lib/CommonLib/DepQuant.cpp
+++ b/source/Lib/CommonLib/DepQuant.cpp
@@ -285,7 +285,7 @@ namespace DQIntern
           const int  begSbb = scanId - ( scanId & (groupSize-1) ); // first pos in current subblock
           for( int k = 0; k < nbOut.num; k++ )
           {
-            CHECK(begSbb > nbOut.outPos[k], "Position must be past sub block begin");
+            CHECK_VTM(begSbb > nbOut.outPos[k], "Position must be past sub block begin");
             nbOut.outPos[k] -= begSbb;
           }
           nbOut.maxDist -= scanId;
@@ -1174,7 +1174,7 @@ namespace DQIntern
       const State* prvState = 0;
       if( decision.prevId  >= 4 )
       {
-        CHECK( decision.absLevel != 0, "cannot happen" );
+        CHECK_VTM( decision.absLevel != 0, "cannot happen" );
         prvState    = skipStates + ( decision.prevId - 4 );
         m_numSigSbb = 0;
         ::memset( m_absLevelsAndCtxInit, 0, 16*sizeof(uint8_t) );
@@ -1558,7 +1558,7 @@ namespace DQIntern
 DepQuant::DepQuant( const Quant* other, bool enc ) : QuantRDOQ( other )
 {
   const DepQuant* dq = dynamic_cast<const DepQuant*>( other );
-  CHECK( other && !dq, "The DepQuant cast must be successfull!" );
+  CHECK_VTM( other && !dq, "The DepQuant cast must be successfull!" );
   p = new DQIntern::DepQuant();
   if( enc )
   {
@@ -1584,7 +1584,7 @@ void DepQuant::quant( TransformUnit &tu, const ComponentID &compID, const CCoeff
     const int         width           = rect.width;
     const int         height          = rect.height;
     uint32_t          scalingListType = getScalingListType(tu.cu->predMode, compID);
-    CHECK(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
+    CHECK_VTM(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
     const uint32_t    log2TrWidth     = floorLog2(width);
     const uint32_t    log2TrHeight    = floorLog2(height);
 
@@ -1612,7 +1612,7 @@ void DepQuant::dequant( const TransformUnit &tu, CoeffBuf &dstCoeff, const Compo
     const int         width           = rect.width;
     const int         height          = rect.height;
     uint32_t          scalingListType = getScalingListType(tu.cu->predMode, compID);
-    CHECK(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
+    CHECK_VTM(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
     const uint32_t    log2TrWidth  = floorLog2(width);
     const uint32_t    log2TrHeight = floorLog2(height);
 
diff --git a/source/Lib/CommonLib/HRD.h b/source/Lib/CommonLib/HRD.h
index 0730578..0ae9ef7 100644
--- a/source/Lib/CommonLib/HRD.h
+++ b/source/Lib/CommonLib/HRD.h
@@ -178,7 +178,7 @@ public:
 
 inline void checkBPSyntaxElementLength(const SEIBufferingPeriod* bp1, const SEIBufferingPeriod* bp2)
 {
-  CHECK(bp1->m_initialCpbRemovalDelayLength != bp2->m_initialCpbRemovalDelayLength ||
+  CHECK_VTM(bp1->m_initialCpbRemovalDelayLength != bp2->m_initialCpbRemovalDelayLength ||
         bp1->m_cpbRemovalDelayLength != bp2->m_cpbRemovalDelayLength ||
         bp1->m_dpbOutputDelayLength != bp2->m_dpbOutputDelayLength ||
         bp1->m_duCpbRemovalDelayIncrementLength != bp2->m_duCpbRemovalDelayIncrementLength ||
diff --git a/source/Lib/CommonLib/Hash.cpp b/source/Lib/CommonLib/Hash.cpp
index a6e7844..bbd09f3 100644
--- a/source/Lib/CommonLib/Hash.cpp
+++ b/source/Lib/CommonLib/Hash.cpp
@@ -339,7 +339,7 @@ void TComHash::addToHashMapByRowWithPrecalData(uint32_t* picHash[2], bool* picIs
   uint32_t* srcHash[2] = { picHash[0], picHash[1] };
 
   int addValue = m_blockSizeToIndex[width][height];
-  CHECK(addValue < 0, "Wrong")
+  CHECK_VTM(addValue < 0, "Wrong")
   addValue <<= m_CRCBits;
   int crcMask = 1 << m_CRCBits;
   crcMask -= 1;
@@ -536,7 +536,7 @@ bool TComHash::getBlockHashValue(const PelUnitBuf &curPicBuf, int width, int hei
 {
   int addValue = m_blockSizeToIndex[width][height];
 
-  CHECK(addValue < 0, "Wrong")
+  CHECK_VTM(addValue < 0, "Wrong")
   addValue <<= m_CRCBits;
   int crcMask = 1 << m_CRCBits;
   crcMask -= 1;
@@ -623,7 +623,7 @@ bool TComHash::getBlockHashValue(const PelUnitBuf &curPicBuf, int width, int hei
 
   if (width != height)//currently support 1:2 or 2:1 block size
   {
-    CHECK(width != (height << 1) && (width << 1) != height, "Wrong")
+    CHECK_VTM(width != (height << 1) && (width << 1) != height, "Wrong")
     bool isHorizontal = width == (height << 1) ? true : false;
     length = 2 * sizeof(uint32_t);
     srcIdx = 1 - srcIdx;
@@ -641,7 +641,7 @@ bool TComHash::getBlockHashValue(const PelUnitBuf &curPicBuf, int width, int hei
     }
     else
     {
-      CHECK(srcSubBlockInWidth != 1, "Wrong")
+      CHECK_VTM(srcSubBlockInWidth != 1, "Wrong")
       toHash[0] = hashValueBuffer[0][srcIdx][0];
       toHash[1] = hashValueBuffer[0][srcIdx][srcSubBlockInWidth];
 
diff --git a/source/Lib/CommonLib/IbcHashMap.cpp b/source/Lib/CommonLib/IbcHashMap.cpp
index 3b0b2d2..6ebc8c6 100644
--- a/source/Lib/CommonLib/IbcHashMap.cpp
+++ b/source/Lib/CommonLib/IbcHashMap.cpp
@@ -316,7 +316,7 @@ bool IbcHashMap::ibcHashMatch(const Area& lumaArea, std::vector<Position>& cand,
       }
       else
       {
-        CHECK(topLeft != *refBlockPos, "4x4 target block should not have offset!");
+        CHECK_VTM(topLeft != *refBlockPos, "4x4 target block should not have offset!");
         if (abs(topLeft.x - lumaArea.x) > searchRange4SmallBlk || abs(topLeft.y - lumaArea.y) > searchRange4SmallBlk || !cs.isDecomp(bottomRight, CHANNEL_TYPE_LUMA))
         {
           continue;
diff --git a/source/Lib/CommonLib/InterPrediction.cpp b/source/Lib/CommonLib/InterPrediction.cpp
index 6956165..4e63fb4 100644
--- a/source/Lib/CommonLib/InterPrediction.cpp
+++ b/source/Lib/CommonLib/InterPrediction.cpp
@@ -456,14 +456,14 @@ void InterPrediction::xPredInterUni(const PredictionUnit &pu, const RefPicList &
   int iRefIdx = pu.refIdx[eRefPicList];
   Mv mv[3];
   bool isIBC = false;
-  CHECK( !CU::isIBC( *pu.cu ) && pu.lwidth() == 4 && pu.lheight() == 4, "invalid 4x4 inter blocks" );
+  CHECK_VTM( !CU::isIBC( *pu.cu ) && pu.lwidth() == 4 && pu.lheight() == 4, "invalid 4x4 inter blocks" );
   if (CU::isIBC(*pu.cu))
   {
     isIBC = true;
   }
   if( pu.cu->affine )
   {
-    CHECK( iRefIdx < 0, "iRefIdx incorrect." );
+    CHECK_VTM( iRefIdx < 0, "iRefIdx incorrect." );
 
     mv[0] = pu.mvAffi[eRefPicList][0];
     mv[1] = pu.mvAffi[eRefPicList][1];
@@ -498,7 +498,7 @@ void InterPrediction::xPredInterUni(const PredictionUnit &pu, const RefPicList &
     }
     if ( pu.cu->affine )
     {
-      CHECK( bioApplied, "BIO is not allowed with affine" );
+      CHECK_VTM( bioApplied, "BIO is not allowed with affine" );
       m_iRefListIdx = eRefPicList;
       bool genChromaMv = (!luma && chroma && compID == COMPONENT_Cb);
       xPredAffineBlk( compID, pu, pu.cu->slice->getRefPic( eRefPicList, iRefIdx )->unscaledPic, mv, pcYuvPred, bi, pu.cu->slice->clpRng( compID ), genChromaMv, pu.cu->slice->getScalingRatio( eRefPicList, iRefIdx ));
@@ -522,7 +522,7 @@ void InterPrediction::xPredInterBi(PredictionUnit &pu, PelUnitBuf &pcYuvPred, co
 {
   const PPS   &pps   = *pu.cs->pps;
   const Slice &slice = *pu.cs->slice;
-  CHECK( !pu.cu->affine && pu.refIdx[0] >= 0 && pu.refIdx[1] >= 0 && ( pu.lwidth() + pu.lheight() == 12 ), "invalid 4x8/8x4 bi-predicted blocks" );
+  CHECK_VTM( !pu.cu->affine && pu.refIdx[0] >= 0 && pu.refIdx[1] >= 0 && ( pu.lwidth() + pu.lheight() == 12 ), "invalid 4x8/8x4 bi-predicted blocks" );
 
   int refIdx0 = pu.refIdx[REF_PIC_LIST_0];
   int refIdx1 = pu.refIdx[REF_PIC_LIST_1];
@@ -590,9 +590,9 @@ void InterPrediction::xPredInterBi(PredictionUnit &pu, PelUnitBuf &pcYuvPred, co
 
     RefPicList eRefPicList = (refList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
 
-    CHECK(CU::isIBC(*pu.cu) && eRefPicList != REF_PIC_LIST_0, "Invalid interdir for ibc mode");
-    CHECK(CU::isIBC(*pu.cu) && pu.refIdx[refList] != MAX_NUM_REF, "Invalid reference index for ibc mode");
-    CHECK((CU::isInter(*pu.cu) && pu.refIdx[refList] >= slice.getNumRefIdx(eRefPicList)), "Invalid reference index");
+    CHECK_VTM(CU::isIBC(*pu.cu) && eRefPicList != REF_PIC_LIST_0, "Invalid interdir for ibc mode");
+    CHECK_VTM(CU::isIBC(*pu.cu) && pu.refIdx[refList] != MAX_NUM_REF, "Invalid reference index for ibc mode");
+    CHECK_VTM((CU::isInter(*pu.cu) && pu.refIdx[refList] >= slice.getNumRefIdx(eRefPicList)), "Invalid reference index");
     m_iRefListIdx = refList;
 
     PelUnitBuf pcMbBuf = ( pu.chromaFormat == CHROMA_400 ?
@@ -693,8 +693,8 @@ void InterPrediction::xPredInterBlk ( const ComponentID& compID, const Predictio
 
   if( !isIBC && xPredInterBlkRPR( scalingRatio, *pu.cs->pps, CompArea( compID, chFmt, pu.blocks[compID], Size( dstPic.bufs[compID].width, dstPic.bufs[compID].height ) ), refPic, mv, dstPic.bufs[compID].buf, dstPic.bufs[compID].stride, bi, wrapRef, clpRng, 0, useAltHpelIf ) )
   {
-    CHECK( bilinearMC, "DMVR should be disabled with RPR" );
-    CHECK( bioApplied, "BDOF should be disabled with RPR" );
+    CHECK_VTM( bilinearMC, "DMVR should be disabled with RPR" );
+    CHECK_VTM( bioApplied, "BDOF should be disabled with RPR" );
   }
   else
   {
@@ -887,8 +887,8 @@ void InterPrediction::xPredAffineBlk(const ComponentID &compID, const Prediction
   int blockWidth = AFFINE_MIN_BLOCK_SIZE;
   int blockHeight = AFFINE_MIN_BLOCK_SIZE;
 
-  CHECK(blockWidth  > (width >> iScaleX ), "Sub Block width  > Block width");
-  CHECK(blockHeight > (height >> iScaleY), "Sub Block height > Block height");
+  CHECK_VTM(blockWidth  > (width >> iScaleX ), "Sub Block width  > Block width");
+  CHECK_VTM(blockHeight > (height >> iScaleY), "Sub Block height > Block height");
   const int MVBUFFER_SIZE = MAX_CU_SIZE / MIN_PU_SIZE;
 
   const int cxWidth  = width  >> iScaleX;
@@ -1004,12 +1004,12 @@ void InterPrediction::xPredAffineBlk(const ComponentID &compID, const Prediction
 
   if (genChromaMv && pu.chromaFormat != CHROMA_444)
   {
-    CHECK(compID == COMPONENT_Y, "Chroma only subblock MV calculation should not apply to Luma");
+    CHECK_VTM(compID == COMPONENT_Y, "Chroma only subblock MV calculation should not apply to Luma");
     int lumaBlockWidth  = AFFINE_MIN_BLOCK_SIZE;
     int lumaBlockHeight = AFFINE_MIN_BLOCK_SIZE;
 
-    CHECK(lumaBlockWidth > (width >> scaleXLuma), "Sub Block width  > Block width");
-    CHECK(lumaBlockHeight > (height >> scaleYLuma), "Sub Block height > Block height");
+    CHECK_VTM(lumaBlockWidth > (width >> scaleXLuma), "Sub Block width  > Block width");
+    CHECK_VTM(lumaBlockHeight > (height >> scaleYLuma), "Sub Block height > Block height");
 
     const int cxWidthLuma  = width >> scaleXLuma;
     const int cxHeightLuma = height >> scaleYLuma;
@@ -1128,7 +1128,7 @@ void InterPrediction::xPredAffineBlk(const ComponentID &compID, const Prediction
 
       if( xPredInterBlkRPR( scalingRatio, *pu.cs->pps, CompArea( compID, chFmt, pu.blocks[compID].offset( w, h ), Size( blockWidth, blockHeight ) ), refPic, Mv( iMvScaleTmpHor, iMvScaleTmpVer ), dstBuf.buf + w + h * dstBuf.stride, dstBuf.stride, bi, wrapRef, clpRng, 2 ) )
       {
-        CHECK( enablePROF, "PROF should be disabled with RPR" );
+        CHECK_VTM( enablePROF, "PROF should be disabled with RPR" );
       }
       else
       {
@@ -1355,7 +1355,7 @@ void InterPrediction::xCalcBlkGradient(int sx, int sy, int    *arraysGx2, int
 
 void InterPrediction::xWeightedAverage(const PredictionUnit& pu, const CPelUnitBuf& pcYuvSrc0, const CPelUnitBuf& pcYuvSrc1, PelUnitBuf& pcYuvDst, const BitDepths& clipBitDepths, const ClpRngs& clpRngs, const bool& bioApplied, bool lumaOnly, bool chromaOnly, PelUnitBuf* yuvDstTmp /*= NULL*/)
 {
-  CHECK( (chromaOnly && lumaOnly), "should not happen" );
+  CHECK_VTM( (chromaOnly && lumaOnly), "should not happen" );
 
   const int iRefIdx0 = pu.refIdx[0];
   const int iRefIdx1 = pu.refIdx[1];
@@ -1364,7 +1364,7 @@ void InterPrediction::xWeightedAverage(const PredictionUnit& pu, const CPelUnitB
   {
     if( pu.cu->BcwIdx != BCW_DEFAULT && (yuvDstTmp || !pu.ciipFlag) )
     {
-      CHECK(bioApplied, "Bcw is disallowed with BIO");
+      CHECK_VTM(bioApplied, "Bcw is disallowed with BIO");
       pcYuvDst.addWeightedAvg(pcYuvSrc0, pcYuvSrc1, clpRngs, pu.cu->BcwIdx, chromaOnly, lumaOnly);
       if (yuvDstTmp)
         yuvDstTmp->addAvg(pcYuvSrc0, pcYuvSrc1, clpRngs, chromaOnly, lumaOnly);
@@ -1456,13 +1456,13 @@ void InterPrediction::motionCompensation( PredictionUnit &pu, PelUnitBuf &predBu
   // Note: there appears to be an interaction with weighted prediction that
   // makes the code follow different paths if chroma is on or off (in the encoder).
   // Therefore for 4:0:0, "chroma" is not changed to false.
-  CHECK(predBufWOBIO && pu.ciipFlag, "the case should not happen!");
+  CHECK_VTM(predBufWOBIO && pu.ciipFlag, "the case should not happen!");
 
   if (!pu.cs->pcv->isEncoder)
   {
     if (CU::isIBC(*pu.cu))
     {
-      CHECK(!luma, "IBC only for Chroma is not allowed.");
+      CHECK_VTM(!luma, "IBC only for Chroma is not allowed.");
       xIntraBlockCopy(pu, predBuf, COMPONENT_Y);
       if (chroma && isChromaEnabled(pu.chromaFormat))
       {
@@ -1485,7 +1485,7 @@ void InterPrediction::motionCompensation( PredictionUnit &pu, PelUnitBuf &predBu
 
   if( eRefPicList != REF_PIC_LIST_X )
   {
-    CHECK(predBufWOBIO != NULL, "the case should not happen!");
+    CHECK_VTM(predBufWOBIO != NULL, "the case should not happen!");
     if ((CU::isIBC(*pu.cu) == false) && ((sliceType == P_SLICE && pps.getUseWP()) || (sliceType == B_SLICE && pps.getWPBiPred())))
     {
       xPredInterUni(pu, eRefPicList, predBuf, true, false, luma, chroma);
@@ -1499,7 +1499,7 @@ void InterPrediction::motionCompensation( PredictionUnit &pu, PelUnitBuf &predBu
   }
   else
   {
-    CHECK( !pu.cu->affine && pu.refIdx[0] >= 0 && pu.refIdx[1] >= 0 && ( pu.lwidth() + pu.lheight() == 12 ), "invalid 4x8/8x4 bi-predicted blocks" );
+    CHECK_VTM( !pu.cu->affine && pu.refIdx[0] >= 0 && pu.refIdx[1] >= 0 && ( pu.lwidth() + pu.lheight() == 12 ), "invalid 4x8/8x4 bi-predicted blocks" );
     int refIdx0 = pu.refIdx[REF_PIC_LIST_0];
     int refIdx1 = pu.refIdx[REF_PIC_LIST_1];
 
@@ -1563,7 +1563,7 @@ void InterPrediction::motionCompensation( PredictionUnit &pu, PelUnitBuf &predBu
     {
       if (pu.mergeType != MRG_TYPE_DEFAULT_N && pu.mergeType != MRG_TYPE_IBC)
       {
-        CHECK(predBufWOBIO != NULL, "the case should not happen!");
+        CHECK_VTM(predBufWOBIO != NULL, "the case should not happen!");
         xSubPuMC(pu, predBuf, eRefPicList, luma, chroma);
       }
       else if (xCheckIdenticalMotion(pu))
@@ -1898,7 +1898,7 @@ void InterPrediction::xFinalPaddedMCForDMVR(PredictionUnit &pu, PelUnitBuf &pcYu
         deltaIntMvX    = (cMv.getHor() >> mvshiftTempHor) - (startMv.getHor() >> mvshiftTempHor);
         deltaIntMvY    = (cMv.getVer() >> mvshiftTempVer) - (startMv.getVer() >> mvshiftTempVer);
 
-        CHECK((abs(deltaIntMvX) > DMVR_NUM_ITERATION) || (abs(deltaIntMvY) > DMVR_NUM_ITERATION), "not expected DMVR movement");
+        CHECK_VTM((abs(deltaIntMvX) > DMVR_NUM_ITERATION) || (abs(deltaIntMvY) > DMVR_NUM_ITERATION), "not expected DMVR movement");
 
         offset = (DMVR_NUM_ITERATION + leftPixelExtra) * (pcPadTemp.bufs[compID].stride + 1);
         offset += (deltaIntMvY)* pcPadTemp.bufs[compID].stride;
@@ -2429,7 +2429,7 @@ bool InterPrediction::xPredInterBlkRPR( const std::pair<int, int>& scalingRatio,
     int refHeight = ((((int32_t)y0Int + (height-1) * stepY) + offY ) >> posShift) - ((((int32_t)y0Int + 0 * stepY) + offY ) >> posShift) + 1;
     refHeight = std::max<int>( 1, refHeight );
 
-    CHECK( MAX_CU_SIZE * MAX_SCALING_RATIO + 16 < refHeight + vFilterSize - 1 + extSize, "Buffer is not large enough, increase MAX_SCALING_RATIO" );
+    CHECK_VTM( MAX_CU_SIZE * MAX_SCALING_RATIO + 16 < refHeight + vFilterSize - 1 + extSize, "Buffer is not large enough, increase MAX_SCALING_RATIO" );
 
     Pel buffer[( MAX_CU_SIZE + 16 ) * ( MAX_CU_SIZE * MAX_SCALING_RATIO + 16 )];
     int tmpStride = width;
@@ -2442,7 +2442,7 @@ bool InterPrediction::xPredInterBlkRPR( const std::pair<int, int>& scalingRatio,
       xInt = std::min( std::max( -(NTAPS_LUMA / 2), xInt ), ( refPicWidth >> ::getComponentScaleX( compID, chFmt ) ) + (NTAPS_LUMA / 2) );
       int xFrac = ( ( posX + offX ) >> ( posShift - shiftHor ) ) & ( ( 1 << shiftHor ) - 1 );
 
-      CHECK( xInt0 > xInt, "Wrong horizontal starting point" );
+      CHECK_VTM( xInt0 > xInt, "Wrong horizontal starting point" );
 
       Position offset = Position( xInt, yInt0 );
       refBuf = refPic->getRecoBuf( CompArea( compID, chFmt, offset, Size( 1, refHeight ) ), wrapRef );
@@ -2458,7 +2458,7 @@ bool InterPrediction::xPredInterBlkRPR( const std::pair<int, int>& scalingRatio,
       yInt = std::min( std::max( -(NTAPS_LUMA / 2), yInt ), ( refPicHeight >> ::getComponentScaleY( compID, chFmt ) ) + (NTAPS_LUMA / 2) );
       int yFrac = ( ( posY + offY ) >> ( posShift - shiftVer ) ) & ( ( 1 << shiftVer ) - 1 );
 
-      CHECK( yInt0 > yInt, "Wrong vertical starting point" );
+      CHECK_VTM( yInt0 > yInt, "Wrong vertical starting point" );
 
       Pel* tempBuf = buffer + ( yInt - yInt0 ) * tmpStride;
 
diff --git a/source/Lib/CommonLib/InterpolationFilter.cpp b/source/Lib/CommonLib/InterpolationFilter.cpp
index cfbd190..f2a62b7 100644
--- a/source/Lib/CommonLib/InterpolationFilter.cpp
+++ b/source/Lib/CommonLib/InterpolationFilter.cpp
@@ -573,7 +573,7 @@ void InterpolationFilter::filter(const ClpRng& clpRng, Pel const *src, int srcSt
   int shift    = IF_FILTER_PREC;
   // with the current settings (IF_INTERNAL_PREC = 14 and IF_FILTER_PREC = 6), though headroom can be
   // negative for bit depths greater than 14, shift will remain non-negative for bit depths of 8->20
-  CHECK(shift < 0, "Negative shift");
+  CHECK_VTM(shift < 0, "Negative shift");
 
   if ( isLast )
   {
@@ -744,7 +744,7 @@ void InterpolationFilter::filterHor(const ComponentID compID, Pel const *src, in
   }
   else if( isLuma( compID ) )
   {
-    CHECK( frac < 0 || frac >= LUMA_INTERPOLATION_FILTER_SUB_SAMPLE_POSITIONS, "Invalid fraction" );
+    CHECK_VTM( frac < 0 || frac >= LUMA_INTERPOLATION_FILTER_SUB_SAMPLE_POSITIONS, "Invalid fraction" );
     if( nFilterIdx == 1 )
     {
       filterHor<NTAPS_BILINEAR>( clpRng, src, srcStride, dst, dstStride, width, height, isLast, m_bilinearFilterPrec4[frac], biMCForDMVR );
@@ -785,7 +785,7 @@ void InterpolationFilter::filterHor(const ComponentID compID, Pel const *src, in
   else
   {
     const uint32_t csx = getComponentScaleX( compID, fmt );
-    CHECK( frac < 0 || csx >= 2 || ( frac << ( 1 - csx ) ) >= CHROMA_INTERPOLATION_FILTER_SUB_SAMPLE_POSITIONS, "Invalid fraction" );
+    CHECK_VTM( frac < 0 || csx >= 2 || ( frac << ( 1 - csx ) ) >= CHROMA_INTERPOLATION_FILTER_SUB_SAMPLE_POSITIONS, "Invalid fraction" );
     if( nFilterIdx == 3 )
     {
       filterHor<NTAPS_CHROMA>( clpRng, src, srcStride, dst, dstStride, width, height, isLast, m_chromaFilterRPR1[frac << ( 1 - csx )], biMCForDMVR );
@@ -826,7 +826,7 @@ void InterpolationFilter::filterVer(const ComponentID compID, Pel const *src, in
   }
   else if( isLuma( compID ) )
   {
-    CHECK( frac < 0 || frac >= LUMA_INTERPOLATION_FILTER_SUB_SAMPLE_POSITIONS, "Invalid fraction" );
+    CHECK_VTM( frac < 0 || frac >= LUMA_INTERPOLATION_FILTER_SUB_SAMPLE_POSITIONS, "Invalid fraction" );
     if( nFilterIdx == 1 )
     {
       filterVer<NTAPS_BILINEAR>( clpRng, src, srcStride, dst, dstStride, width, height, isFirst, isLast, m_bilinearFilterPrec4[frac], biMCForDMVR );
@@ -867,7 +867,7 @@ void InterpolationFilter::filterVer(const ComponentID compID, Pel const *src, in
   else
   {
     const uint32_t csy = getComponentScaleY( compID, fmt );
-    CHECK( frac < 0 || csy >= 2 || ( frac << ( 1 - csy ) ) >= CHROMA_INTERPOLATION_FILTER_SUB_SAMPLE_POSITIONS, "Invalid fraction" );
+    CHECK_VTM( frac < 0 || csy >= 2 || ( frac << ( 1 - csy ) ) >= CHROMA_INTERPOLATION_FILTER_SUB_SAMPLE_POSITIONS, "Invalid fraction" );
     if( nFilterIdx == 3 )
     {
       filterVer<NTAPS_CHROMA>( clpRng, src, srcStride, dst, dstStride, width, height, isFirst, isLast, m_chromaFilterRPR1[frac << ( 1 - csy )], biMCForDMVR );
diff --git a/source/Lib/CommonLib/IntraPrediction.cpp b/source/Lib/CommonLib/IntraPrediction.cpp
index c70917b..32bc354 100644
--- a/source/Lib/CommonLib/IntraPrediction.cpp
+++ b/source/Lib/CommonLib/IntraPrediction.cpp
@@ -151,7 +151,7 @@ void IntraPrediction::init(ChromaFormat chromaFormatIDC, const unsigned bitDepth
 //NOTE: Bit-Limit - 25-bit source
 Pel IntraPrediction::xGetPredValDc( const CPelBuf &pSrc, const Size &dstSize )
 {
-  CHECK( dstSize.width == 0 || dstSize.height == 0, "Empty area provided" );
+  CHECK_VTM( dstSize.width == 0 || dstSize.height == 0, "Empty area provided" );
 
   int idx, sum = 0;
   Pel dcVal;
@@ -218,12 +218,12 @@ void IntraPrediction::predIntraAng( const ComponentID compId, PelBuf &piPred, co
   const ChannelType    channelType  = toChannelType( compID );
   const int            iWidth       = piPred.width;
   const int            iHeight      = piPred.height;
-  CHECK(iWidth == 2, "Width of 2 is not supported");
-  CHECK(PU::isMIP(pu, toChannelType(compId)), "We should not get here for MIP.");
+  CHECK_VTM(iWidth == 2, "Width of 2 is not supported");
+  CHECK_VTM(PU::isMIP(pu, toChannelType(compId)), "We should not get here for MIP.");
   const uint32_t       uiDirMode    = isLuma( compId ) && pu.cu->bdpcmMode ? BDPCM_IDX : !isLuma(compId) && pu.cu->bdpcmModeChroma ? BDPCM_IDX : PU::getFinalIntraMode(pu, channelType);
 
-  CHECK( floorLog2(iWidth) < 2 && pu.cs->pcv->noChroma2x2, "Size not allowed" );
-  CHECK( floorLog2(iWidth) > 7, "Size not allowed" );
+  CHECK_VTM( floorLog2(iWidth) < 2 && pu.cs->pcv->noChroma2x2, "Size not allowed" );
+  CHECK_VTM( floorLog2(iWidth) > 7, "Size not allowed" );
 
   const int srcStride  = m_refBufferStride[compID];
   const int srcHStride = 2;
@@ -243,7 +243,7 @@ void IntraPrediction::predIntraAng( const ComponentID compId, PelBuf &piPred, co
   {
     PelBuf dstBuf = piPred;
     const int scale = ((floorLog2(iWidth) - 2 + floorLog2(iHeight) - 2 + 2) >> 2);
-    CHECK(scale < 0 || scale > 31, "PDPC: scale < 0 || scale > 31");
+    CHECK_VTM(scale < 0 || scale > 31, "PDPC: scale < 0 || scale > 31");
 
     if (uiDirMode == PLANAR_IDX || uiDirMode == DC_IDX)
     {
@@ -301,13 +301,13 @@ void IntraPrediction::xPredIntraPlanar( const CPelBuf &pSrc, PelBuf &pDst )
   const uint32_t offset = 1 << (log2W + log2H);
 
   // Get left and above reference column and row
-  CHECK(width > MAX_CU_SIZE, "width greater than limit");
+  CHECK_VTM(width > MAX_CU_SIZE, "width greater than limit");
   for( int k = 0; k < width + 1; k++ )
   {
     topRow[k] = pSrc.at( k + 1, 0 );
   }
 
-  CHECK(height > MAX_CU_SIZE, "height greater than limit");
+  CHECK_VTM(height > MAX_CU_SIZE, "height greater than limit");
   for( int k = 0; k < height + 1; k++ )
   {
     leftColumn[k] = pSrc.at(k + 1, 1);
@@ -429,7 +429,7 @@ void IntraPrediction::initPredIntraParams(const PredictionUnit & pu, const CompA
     {
       const int diff = std::min<int>( abs( predMode - HOR_IDX ), abs( predMode - VER_IDX ) );
       const int log2Size = ((floorLog2(puSize.width) + floorLog2(puSize.height)) >> 1);
-      CHECK( log2Size >= MAX_INTRA_FILTER_DEPTHS, "Size not supported" );
+      CHECK_VTM( log2Size >= MAX_INTRA_FILTER_DEPTHS, "Size not supported" );
       filterFlag = (diff > m_aucIntraFilter[log2Size]);
     }
 
@@ -437,7 +437,7 @@ void IntraPrediction::initPredIntraParams(const PredictionUnit & pu, const CompA
     if (filterFlag)
     {
       const bool isRefFilter       =  isIntegerSlope(absAng);
-      CHECK( puSize.width * puSize.height <= 32, "DCT-IF interpolation filter is always used for 4x4, 4x8, and 8x4 luma CB" );
+      CHECK_VTM( puSize.width * puSize.height <= 32, "DCT-IF interpolation filter is always used for 4x4, 4x8, and 8x4 luma CB" );
       m_ipaParam.refFilterFlag     =  isRefFilter;
       m_ipaParam.interpolationFlag = !isRefFilter;
     }
@@ -651,7 +651,7 @@ void IntraPrediction::xPredIntraBDPCM(const CPelBuf &pSrc, PelBuf &pDst, const u
   const int strideP = pDst.stride;
   const int strideS = pSrc.stride;
 
-  CHECK( !( dirMode == 1 || dirMode == 2 ), "Incorrect BDPCM mode parameter." );
+  CHECK_VTM( !( dirMode == 1 || dirMode == 2 ), "Incorrect BDPCM mode parameter." );
 
   Pel* pred = &pDst.buf[0];
   if( dirMode == 1 )
@@ -683,7 +683,7 @@ void IntraPrediction::xPredIntraBDPCM(const CPelBuf &pSrc, PelBuf &pDst, const u
 void IntraPrediction::geneWeightedPred(const ComponentID compId, PelBuf &pred, const PredictionUnit &pu, Pel *srcBuf)
 {
   const int            width = pred.width;
-  CHECK(width == 2, "Width of 2 is not supported");
+  CHECK_VTM(width == 2, "Width of 2 is not supported");
   const int            height = pred.height;
   const int            srcStride = width;
   const int            dstStride = pred.stride;
@@ -779,7 +779,7 @@ inline int  isBelowLeftAvailable  ( const CodingUnit &cu, const ChannelType &chT
 
 void IntraPrediction::initIntraPatternChType(const CodingUnit &cu, const CompArea &area, const bool forceRefFilterFlag)
 {
-  CHECK(area.width == 2, "Width of 2 is not supported");
+  CHECK_VTM(area.width == 2, "Width of 2 is not supported");
   const CodingStructure& cs   = *cu.cs;
 
   if (!forceRefFilterFlag)
@@ -946,7 +946,7 @@ void IntraPrediction::xFillReferenceSamples( const CPelBuf &recoBuf, Pel* refBuf
   const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
   const int  numLeftBelowUnits  = totalLeftUnits - numLeftUnits;
 
-  CHECK( numAboveUnits <= 0 || numLeftUnits <= 0 || numAboveRightUnits <= 0 || numLeftBelowUnits <= 0, "Size not supported" );
+  CHECK_VTM( numAboveUnits <= 0 || numLeftUnits <= 0 || numAboveRightUnits <= 0 || numLeftBelowUnits <= 0, "Size not supported" );
 
   // ----- Step 1: analyze neighborhood -----
   const Position posLT          = area;
@@ -1343,8 +1343,8 @@ void IntraPrediction::xGetLumaRecPixels(const PredictionUnit &pu, CompArea chrom
   //assert 420 chroma subsampling
   CompArea lumaArea = CompArea( COMPONENT_Y, pu.chromaFormat, chromaArea.lumaPos(), recalcSize( pu.chromaFormat, CHANNEL_TYPE_CHROMA, CHANNEL_TYPE_LUMA, chromaArea.size() ) );//needed for correct pos/size (4x4 Tus)
 
-  CHECK(lumaArea.width == chromaArea.width && CHROMA_444 != pu.chromaFormat, "");
-  CHECK(lumaArea.height == chromaArea.height && CHROMA_444 != pu.chromaFormat && CHROMA_422 != pu.chromaFormat, "");
+  CHECK_VTM(lumaArea.width == chromaArea.width && CHROMA_444 != pu.chromaFormat, "");
+  CHECK_VTM(lumaArea.height == chromaArea.height && CHROMA_444 != pu.chromaFormat && CHROMA_422 != pu.chromaFormat, "");
 
   const SizeType uiCWidth = chromaArea.width;
   const SizeType uiCHeight = chromaArea.height;
@@ -1563,7 +1563,7 @@ void IntraPrediction::xGetLumaRecPixels(const PredictionUnit &pu, CompArea chrom
       }
       else
       {
-        CHECK(pu.chromaFormat != CHROMA_420, "Chroma format must be 4:2:0 for vertical filtering");
+        CHECK_VTM(pu.chromaFormat != CHROMA_420, "Chroma format must be 4:2:0 for vertical filtering");
         const bool leftPadding = i == 0 && !leftIsAvailable;
 
         int s = 4;
@@ -1585,7 +1585,7 @@ void IntraPrediction::xGetLMParameters(const PredictionUnit &pu, const Component
                                               const CompArea &chromaArea,
                                               int &a, int &b, int &iShift)
 {
-  CHECK(compID == COMPONENT_Y, "");
+  CHECK_VTM(compID == COMPONENT_Y, "");
 
   const SizeType cWidth  = chromaArea.width;
   const SizeType cHeight = chromaArea.height;
@@ -1811,10 +1811,10 @@ void IntraPrediction::xGetLMParameters(const PredictionUnit &pu, const Component
 
 void IntraPrediction::initIntraMip( const PredictionUnit &pu, const CompArea &area )
 {
-  CHECK( area.width > MIP_MAX_WIDTH || area.height > MIP_MAX_HEIGHT, "Error: block size not supported for MIP" );
+  CHECK_VTM( area.width > MIP_MAX_WIDTH || area.height > MIP_MAX_HEIGHT, "Error: block size not supported for MIP" );
 
   // prepare input (boundary) data for prediction
-  CHECK( m_ipaParam.refFilterFlag, "ERROR: unfiltered refs expected for MIP" );
+  CHECK_VTM( m_ipaParam.refFilterFlag, "ERROR: unfiltered refs expected for MIP" );
   Pel       *ptrSrc     = getPredictorPtr(area.compID);
   const int  srcStride  = m_refBufferStride[area.compID];
   const int  srcHStride = 2;
@@ -1825,8 +1825,8 @@ void IntraPrediction::initIntraMip( const PredictionUnit &pu, const CompArea &ar
 
 void IntraPrediction::predIntraMip( const ComponentID compId, PelBuf &piPred, const PredictionUnit &pu )
 {
-  CHECK( piPred.width > MIP_MAX_WIDTH || piPred.height > MIP_MAX_HEIGHT, "Error: block size not supported for MIP" );
-  CHECK( piPred.width != (1 << floorLog2(piPred.width)) || piPred.height != (1 << floorLog2(piPred.height)), "Error: expecting blocks of size 2^M x 2^N" );
+  CHECK_VTM( piPred.width > MIP_MAX_WIDTH || piPred.height > MIP_MAX_HEIGHT, "Error: block size not supported for MIP" );
+  CHECK_VTM( piPred.width != (1 << floorLog2(piPred.width)) || piPred.height != (1 << floorLog2(piPred.height)), "Error: expecting blocks of size 2^M x 2^N" );
 
   // generate mode-specific prediction
   uint32_t modeIdx       = MAX_NUM_MIP_MODE;
@@ -1840,15 +1840,15 @@ void IntraPrediction::predIntraMip( const ComponentID compId, PelBuf &piPred, co
   {
     const PredictionUnit &coLocatedLumaPU = PU::getCoLocatedLumaPU(pu);
 
-    CHECK(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "Error: MIP is only supported for chroma with DM_CHROMA.");
-    CHECK(!coLocatedLumaPU.cu->mipFlag, "Error: Co-located luma CU should use MIP.");
+    CHECK_VTM(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "Error: MIP is only supported for chroma with DM_CHROMA.");
+    CHECK_VTM(!coLocatedLumaPU.cu->mipFlag, "Error: Co-located luma CU should use MIP.");
 
     modeIdx       = coLocatedLumaPU.intraDir[CHANNEL_TYPE_LUMA];
     transposeFlag = coLocatedLumaPU.mipTransposedFlag;
   }
   const int bitDepth = pu.cu->slice->getSPS()->getBitDepth(toChannelType(compId));
 
-  CHECK(modeIdx >= getNumModesMip(piPred), "Error: Wrong MIP mode index");
+  CHECK_VTM(modeIdx >= getNumModesMip(piPred), "Error: Wrong MIP mode index");
 
   static_vector<int, MIP_MAX_WIDTH* MIP_MAX_HEIGHT> predMip( piPred.width * piPred.height );
   m_matrixIntraPred.predBlock(predMip.data(), modeIdx, transposeFlag, bitDepth, compId);
diff --git a/source/Lib/CommonLib/LoopFilter.cpp b/source/Lib/CommonLib/LoopFilter.cpp
index 46b268f..2bfde46 100644
--- a/source/Lib/CommonLib/LoopFilter.cpp
+++ b/source/Lib/CommonLib/LoopFilter.cpp
@@ -886,8 +886,8 @@ unsigned LoopFilter::xGetBoundaryStrengthSingle ( const CodingUnit& cu, const De
 
 
   // pcSlice->isInterP()
-  CHECK(CU::isInter(cuP) && 0 > miP.refIdx[0], "Invalid reference picture list index");
-  CHECK(CU::isInter(cuP) && 0 > miQ.refIdx[0], "Invalid reference picture list index");
+  CHECK_VTM(CU::isInter(cuP) && 0 > miP.refIdx[0], "Invalid reference picture list index");
+  CHECK_VTM(CU::isInter(cuP) && 0 > miQ.refIdx[0], "Invalid reference picture list index");
   const Picture *piRefP0 = (CU::isIBC(cuP) ? sliceP.getPic() : sliceP.getRefPic(REF_PIC_LIST_0, miP.refIdx[0]));
   const Picture *piRefQ0 = (CU::isIBC(cuQ) ? sliceQ.getPic() : sliceQ.getRefPic(REF_PIC_LIST_0, miQ.refIdx[0]));
   if (piRefP0 != piRefQ0)
@@ -1276,12 +1276,12 @@ void LoopFilter::xEdgeFilterChroma(const CodingUnit& cu, const DeblockEdgeDir ed
 
       if (edgeDir == EDGE_VER)
       {
-        CHECK(!isAvailableLeft(cu, cuP, !pps.getLoopFilterAcrossSlicesEnabledFlag(), !pps.getLoopFilterAcrossTilesEnabledFlag(),
+        CHECK_VTM(!isAvailableLeft(cu, cuP, !pps.getLoopFilterAcrossSlicesEnabledFlag(), !pps.getLoopFilterAcrossTilesEnabledFlag(),
           !( pps.getSubPicFromCU(cu).getloopFilterAcrossEnabledFlag() && pps.getSubPicFromCU(cuP).getloopFilterAcrossEnabledFlag())), "Neighbour not available");
       }
       else  // (iDir == EDGE_HOR)
       {
-        CHECK(!isAvailableAbove(cu, cuP, !pps.getLoopFilterAcrossSlicesEnabledFlag(), !pps.getLoopFilterAcrossTilesEnabledFlag(),
+        CHECK_VTM(!isAvailableAbove(cu, cuP, !pps.getLoopFilterAcrossSlicesEnabledFlag(), !pps.getLoopFilterAcrossTilesEnabledFlag(),
           !( pps.getSubPicFromCU(cu).getloopFilterAcrossEnabledFlag() && pps.getSubPicFromCU(cuP).getloopFilterAcrossEnabledFlag())), "Neighbour not available");
       }
 
@@ -1432,7 +1432,7 @@ inline void LoopFilter::xBilinearFilter(Pel* srcP, Pel* srcQ, int offset, int re
 
 inline void LoopFilter::xFilteringPandQ(Pel* src, int offset, int numberPSide, int numberQSide, int tc) const
 {
-  CHECK(numberPSide <= 3 && numberQSide <= 3, "Short filtering in long filtering function");
+  CHECK_VTM(numberPSide <= 3 && numberQSide <= 3, "Short filtering in long filtering function");
   Pel* srcP = src-offset;
   Pel* srcQ = src;
 
diff --git a/source/Lib/CommonLib/MatrixIntraPrediction.cpp b/source/Lib/CommonLib/MatrixIntraPrediction.cpp
index b8296b1..5527d4c 100644
--- a/source/Lib/CommonLib/MatrixIntraPrediction.cpp
+++ b/source/Lib/CommonLib/MatrixIntraPrediction.cpp
@@ -120,7 +120,7 @@ void MatrixIntraPrediction::prepareInputForPred(const CPelBuf &pSrc, const Area
 void MatrixIntraPrediction::predBlock(int *const result, const int modeIdx, const bool transpose, const int bitDepth,
                                       const ComponentID compId)
 {
-  CHECK(m_component != compId, "Boundary has not been prepared for this component.");
+  CHECK_VTM(m_component != compId, "Boundary has not been prepared for this component.");
 
   const bool needUpsampling = ( m_upsmpFactorHor > 1 ) || ( m_upsmpFactorVer > 1 );
 
@@ -293,7 +293,7 @@ void MatrixIntraPrediction::computeReducedPred( int*const result, const int* con
   int sum = 0;
   for( int i = 0; i < inputSize; i++ ) { sum += input[i]; }
   const int offset = (1 << (MIP_SHIFT_MATRIX - 1)) - MIP_OFFSET_MATRIX * sum;
-  CHECK( inputSize != 4 * (inputSize >> 2), "Error, input size not divisible by four" );
+  CHECK_VTM( inputSize != 4 * (inputSize >> 2), "Error, input size not divisible by four" );
 
   const uint8_t *weight = matrix;
   const int   inputOffset = transpose ? m_inputOffsetTransp : m_inputOffset;
diff --git a/source/Lib/CommonLib/MotionInfo.h b/source/Lib/CommonLib/MotionInfo.h
index 20059c2..5c880cc 100644
--- a/source/Lib/CommonLib/MotionInfo.h
+++ b/source/Lib/CommonLib/MotionInfo.h
@@ -79,21 +79,21 @@ struct MvField
 
   void setMvField( Mv const & cMv, const int iRefIdx )
   {
-    CHECK( iRefIdx == -1 && cMv != Mv(0,0), "Must not happen." );
+    CHECK_VTM( iRefIdx == -1 && cMv != Mv(0,0), "Must not happen." );
     mv     = cMv;
     refIdx = iRefIdx;
   }
 
   bool operator==( const MvField& other ) const
   {
-    CHECK( refIdx == -1 && mv != Mv(0,0), "Error in operator== of MvField." );
-    CHECK( other.refIdx == -1 && other.mv != Mv(0,0), "Error in operator== of MvField." );
+    CHECK_VTM( refIdx == -1 && mv != Mv(0,0), "Error in operator== of MvField." );
+    CHECK_VTM( other.refIdx == -1 && other.mv != Mv(0,0), "Error in operator== of MvField." );
     return refIdx == other.refIdx && mv == other.mv;
   }
   bool operator!=( const MvField& other ) const
   {
-    CHECK( refIdx == -1 && mv != Mv(0,0), "Error in operator!= of MvField." );
-    CHECK( other.refIdx == -1 && other.mv != Mv(0,0), "Error in operator!= of MvField." );
+    CHECK_VTM( refIdx == -1 && mv != Mv(0,0), "Error in operator!= of MvField." );
+    CHECK_VTM( other.refIdx == -1 && other.mv != Mv(0,0), "Error in operator!= of MvField." );
     return refIdx != other.refIdx || mv != other.mv;
   }
 };
diff --git a/source/Lib/CommonLib/ParameterSetManager.h b/source/Lib/CommonLib/ParameterSetManager.h
index 6f3a0b6..dfd9900 100644
--- a/source/Lib/CommonLib/ParameterSetManager.h
+++ b/source/Lib/CommonLib/ParameterSetManager.h
@@ -71,7 +71,7 @@ public:
 
   T *allocatePS(const int psId)
   {
-    CHECK( psId >= m_maxId, "Invalid PS id" );
+    CHECK_VTM( psId >= m_maxId, "Invalid PS id" );
     if ( m_paramsetMap.find(psId) == m_paramsetMap.end() )
     {
       m_paramsetMap[psId].bChanged = true;
@@ -88,7 +88,7 @@ public:
   }
   void storePS( int psId, T *ps )
   {
-    CHECK( psId >= m_maxId, "Invalid PS id" );
+    CHECK_VTM( psId >= m_maxId, "Invalid PS id" );
     if( m_paramsetMap.find( psId ) != m_paramsetMap.end() )
     {
       delete m_paramsetMap[psId].parameterSet;
@@ -98,7 +98,7 @@ public:
   }
   void storePS(int psId, T *ps, const std::vector<uint8_t> *pNaluData)
   {
-    CHECK( psId >= m_maxId, "Invalid PS id" );
+    CHECK_VTM( psId >= m_maxId, "Invalid PS id" );
     if ( m_paramsetMap.find(psId) != m_paramsetMap.end() )
     {
       MapData<T> &mapData=m_paramsetMap[psId];
@@ -144,25 +144,25 @@ public:
 
     if( std::find( accessUnitApsNals.begin(), accessUnitApsNals.end(), apsId ) != accessUnitApsNals.end() )
     {
-      CHECK( m_paramsetMap.find( apsId ) == m_paramsetMap.end(), "APS does not exist" );
+      CHECK_VTM( m_paramsetMap.find( apsId ) == m_paramsetMap.end(), "APS does not exist" );
       APS* existedAPS = m_paramsetMap[apsId].parameterSet;
       bool sameNalUnitType = aps->getHasPrefixNalUnitType() == existedAPS->getHasPrefixNalUnitType();
       bool samePU = aps->getLayerId() == existedAPS->getLayerId();
       if( aps->getAPSType() == LMCS_APS )
       {
-        CHECK( samePU && sameNalUnitType && aps->getReshaperAPSInfo() != existedAPS->getReshaperAPSInfo(), "All APS NAL units with a particular value of nal_unit_type, a particular value of aps_adaptation_parameter_set_id, and a particular value of aps_params_type within a PU shall have the same content" );
+        CHECK_VTM( samePU && sameNalUnitType && aps->getReshaperAPSInfo() != existedAPS->getReshaperAPSInfo(), "All APS NAL units with a particular value of nal_unit_type, a particular value of aps_adaptation_parameter_set_id, and a particular value of aps_params_type within a PU shall have the same content" );
       }
       else if( aps->getAPSType() == ALF_APS )
       {
-        CHECK( samePU && sameNalUnitType && aps->getAlfAPSParam() != existedAPS->getAlfAPSParam(), "All APS NAL units with a particular value of nal_unit_type, a particular value of aps_adaptation_parameter_set_id, and a particular value of aps_params_type within a PU shall have the same content" );
+        CHECK_VTM( samePU && sameNalUnitType && aps->getAlfAPSParam() != existedAPS->getAlfAPSParam(), "All APS NAL units with a particular value of nal_unit_type, a particular value of aps_adaptation_parameter_set_id, and a particular value of aps_params_type within a PU shall have the same content" );
       }
       else if( aps->getAPSType() == SCALING_LIST_APS )
       {
-        CHECK( samePU && sameNalUnitType && aps->getScalingList() != existedAPS->getScalingList(), "All APS NAL units with a particular value of nal_unit_type, a particular value of aps_adaptation_parameter_set_id, and a particular value of aps_params_type within a PU shall have the same content" );
+        CHECK_VTM( samePU && sameNalUnitType && aps->getScalingList() != existedAPS->getScalingList(), "All APS NAL units with a particular value of nal_unit_type, a particular value of aps_adaptation_parameter_set_id, and a particular value of aps_params_type within a PU shall have the same content" );
       }
       else
       {
-        CHECK( true, "Wrong APS type" );
+        CHECK_VTM( true, "Wrong APS type" );
       }
     }
     else
diff --git a/source/Lib/CommonLib/Picture.cpp b/source/Lib/CommonLib/Picture.cpp
index a7205ba..94f41a5 100644
--- a/source/Lib/CommonLib/Picture.cpp
+++ b/source/Lib/CommonLib/Picture.cpp
@@ -427,17 +427,17 @@ void Picture::fillSliceLossyLosslessArray(std::vector<uint16_t> sliceLosslessInd
   m_lossylosslessSliceArray.assign(numSlices, true); // initialize to all slices are lossless 
   if (mixedLossyLossless)
   {
-    m_lossylosslessSliceArray.assign(numSlices, false); // initialize to all slices are lossless 
-    CHECK(numElementsinsliceLosslessIndexArray == 0 , "sliceLosslessArray is empty, must need to configure for mixed lossy/lossless");
+    m_lossylosslessSliceArray.assign(numSlices, false); // initialize to all slices are lossless
+    CHECK_VTM(numElementsinsliceLosslessIndexArray == 0 , "sliceLosslessArray is empty, must need to configure for mixed lossy/lossless");
 
     // mixed lossy/lossless slices, set only lossless slices;
     for (uint16_t i = 0; i < numElementsinsliceLosslessIndexArray; i++)
     {
-        CHECK(sliceLosslessIndexArray[i] >= numSlices || sliceLosslessIndexArray[i] < 0, "index of lossless slice is out of slice index bound");
+      CHECK_VTM(sliceLosslessIndexArray[i] >= numSlices || sliceLosslessIndexArray[i] < 0, "index of lossless slice is out of slice index bound");
         m_lossylosslessSliceArray[sliceLosslessIndexArray[i]] = true;
     }
-  } 
-  CHECK(m_lossylosslessSliceArray.size() < numSlices, "sliceLosslessArray size is less than number of slices");
+  }
+  CHECK_VTM(m_lossylosslessSliceArray.size() < numSlices, "sliceLosslessArray size is less than number of slices");
 }
 
 Slice *Picture::swapSliceObject(Slice * p, uint32_t i)
@@ -744,7 +744,7 @@ void Picture::sampleRateConv( const std::pair<int, int> scalingRatio, const std:
   int *buf = new int[orgHeight * scaledWidth];
   int maxVal = ( 1 << bitDepth ) - 1;
 
-  CHECK( bitDepth > 17, "Overflow may happen!" );
+  CHECK_VTM( bitDepth > 17, "Overflow may happen!" );
 
   for( int i = 0; i < scaledWidth; i++ )
   {
diff --git a/source/Lib/CommonLib/Quant.cpp b/source/Lib/CommonLib/Quant.cpp
index 789dad2..43f40bb 100644
--- a/source/Lib/CommonLib/Quant.cpp
+++ b/source/Lib/CommonLib/Quant.cpp
@@ -387,8 +387,8 @@ void Quant::dequant(const TransformUnit &tu,
     coef = tu.getCoeffs(compID).buf;
   }
   const TCoeff          *const piQCoef = coef;
-  CHECK(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
-  CHECK(uiWidth > m_uiMaxTrSize, "Unsupported transformation size");
+  CHECK_VTM(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
+  CHECK_VTM(uiWidth > m_uiMaxTrSize, "Unsupported transformation size");
 
   // Represents scaling through forward transform
   const bool bClipTransformShiftTo0 = tu.mtsIdx[compID] != MTS_SKIP && sps->getSpsRangeExtension().getExtendedPrecisionProcessingFlag();
@@ -972,7 +972,7 @@ void Quant::quant(TransformUnit &tu, const ComponentID &compID, const CCoeffBuf
 
     TCoeff deltaU[MAX_TB_SIZEY * MAX_TB_SIZEY];
     int scalingListType = getScalingListType(tu.cu->predMode, compID);
-    CHECK(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
+    CHECK_VTM(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
     const uint32_t uiLog2TrWidth = floorLog2(uiWidth);
     const uint32_t uiLog2TrHeight = floorLog2(uiHeight);
     int *piQuantCoeff = getQuantCoeff(scalingListType, cQP.rem(useTransformSkip), uiLog2TrWidth, uiLog2TrHeight);
@@ -1050,7 +1050,7 @@ bool Quant::xNeedRDOQ(TransformUnit &tu, const ComponentID &compID, const CCoeff
   const int  maxLog2TrDynamicRange = sps.getMaxLog2TrDynamicRange(toChannelType(compID));
 
   int scalingListType = getScalingListType(tu.cu->predMode, compID);
-  CHECK(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
+  CHECK_VTM(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
 
   const uint32_t uiLog2TrWidth  = floorLog2(uiWidth);
   const uint32_t uiLog2TrHeight = floorLog2(uiHeight);
@@ -1116,7 +1116,7 @@ void Quant::transformSkipQuantOneSample(TransformUnit &tu, const ComponentID &co
   const bool           useTransformSkip = (tu.mtsIdx[compID] == MTS_SKIP);
   const int            defaultQuantisationCoefficient = g_quantScales[0][cQP.rem(useTransformSkip)];
 
-  CHECK( scalingListType >= SCALING_LIST_NUM, "Invalid scaling list" );
+  CHECK_VTM( scalingListType >= SCALING_LIST_NUM, "Invalid scaling list" );
 
   const uint32_t uiLog2TrWidth      = floorLog2(uiWidth);
   const uint32_t uiLog2TrHeight     = floorLog2(uiHeight);
@@ -1175,7 +1175,7 @@ void Quant::invTrSkipDeQuantOneSample(TransformUnit &tu, const ComponentID &comp
   const bool           isLfnstApplied = tu.cu->lfnstIdx > 0 && (tu.cu->isSepTree() ? true : isLuma(compID));
   const bool           disableSMForACT = tu.cs->slice->getSPS()->getScalingMatrixForAlternativeColourSpaceDisabledFlag() && (tu.cs->slice->getSPS()->getScalingMatrixDesignatedColourSpaceFlag() == tu.cu->colorTransform);
   const bool           enableScalingLists = getUseScalingList(uiWidth, uiHeight, true, isLfnstApplied, disableSMForLFNST, disableSMForACT);
-  CHECK(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
+  CHECK_VTM(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
 
   const bool isTransformSkip = (tu.mtsIdx[compID] == MTS_SKIP);
   const int rightShift = (IQUANT_SHIFT - ((isTransformSkip ? 0 : iTransformShift) + QP_per)) + (enableScalingLists ? LOG2_SCALING_LIST_NEUTRAL_VALUE : 0);
@@ -1265,12 +1265,12 @@ void Quant::lambdaAdjustColorTrans(bool forward)
 
   if (forward)
   {
-    CHECK(m_pairCheck == 1, "lambda has been already adjusted");
+    CHECK_VTM(m_pairCheck == 1, "lambda has been already adjusted");
     m_pairCheck = 1;
   }
   else
   {
-    CHECK(m_pairCheck == 0, "lambda has not been adjusted");
+    CHECK_VTM(m_pairCheck == 0, "lambda has not been adjusted");
     m_pairCheck = 0;
   }
 
diff --git a/source/Lib/CommonLib/QuantRDOQ.cpp b/source/Lib/CommonLib/QuantRDOQ.cpp
index 9b9eccf..f304137 100644
--- a/source/Lib/CommonLib/QuantRDOQ.cpp
+++ b/source/Lib/CommonLib/QuantRDOQ.cpp
@@ -81,7 +81,7 @@ QuantRDOQ::QuantRDOQ( const Quant* other ) : Quant( other )
 {
 
   const QuantRDOQ *rdoq = dynamic_cast<const QuantRDOQ*>( other );
-  CHECK( other && !rdoq, "The RDOQ cast must be successfull!" );
+  CHECK_VTM( other && !rdoq, "The RDOQ cast must be successfull!" );
   xInitScalingList( rdoq );
 }
 
@@ -601,11 +601,11 @@ void QuantRDOQ::xRateDistOptQuant(TransformUnit &tu, const ComponentID &compID,
   const uint32_t uiLog2BlockHeight                 = floorLog2(uiHeight);
   const uint32_t uiMaxNumCoeff                     = rect.area();
 
-  CHECK(compID >= MAX_NUM_TBLOCKS, "Invalid component ID");
+  CHECK_VTM(compID >= MAX_NUM_TBLOCKS, "Invalid component ID");
 
   int scalingListType = getScalingListType(tu.cu->predMode, compID);
 
-  CHECK(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
+  CHECK_VTM(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
 
   const TCoeff *plSrcCoeff = pSrc.buf;
         TCoeff *piDstCoeff = tu.getCoeffs(compID).buf;
@@ -1201,10 +1201,10 @@ void QuantRDOQ::xRateDistOptQuantTS( TransformUnit &tu, const ComponentID &compI
         double   blockUncodedCost                   = 0;
   const uint32_t maxNumCoeff                        = rect.area();
 
-  CHECK( compID >= MAX_NUM_TBLOCKS, "Invalid component ID" );
+  CHECK_VTM( compID >= MAX_NUM_TBLOCKS, "Invalid component ID" );
 
   int scalingListType = getScalingListType( tu.cu->predMode, compID );
-  CHECK( scalingListType >= SCALING_LIST_NUM, "Invalid scaling list" );
+  CHECK_VTM( scalingListType >= SCALING_LIST_NUM, "Invalid scaling list" );
 
   const TCoeff *srcCoeff = coeffs.buf;
         TCoeff *dstCoeff = tu.getCoeffs( compID ).buf;
@@ -1423,10 +1423,10 @@ void QuantRDOQ::forwardBDPCM(TransformUnit &tu, const ComponentID &compID, const
   double   blockUncodedCost = 0;
   const uint32_t maxNumCoeff = rect.area();
 
-  CHECK(compID >= MAX_NUM_TBLOCKS, "Invalid component ID");
+  CHECK_VTM(compID >= MAX_NUM_TBLOCKS, "Invalid component ID");
 
   int scalingListType = getScalingListType(tu.cu->predMode, compID);
-  CHECK(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
+  CHECK_VTM(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
 
   const TCoeff *srcCoeff = coeffs.buf;
   TCoeff *dstCoeff = tu.getCoeffs(compID).buf;
diff --git a/source/Lib/CommonLib/RdCost.cpp b/source/Lib/CommonLib/RdCost.cpp
index 59b9778..40286a4 100644
--- a/source/Lib/CommonLib/RdCost.cpp
+++ b/source/Lib/CommonLib/RdCost.cpp
@@ -104,12 +104,12 @@ void RdCost::lambdaAdjustColorTrans(bool forward, ComponentID componentID, bool
 
   if (forward)
   {
-    CHECK(m_pairCheck == 1, "lambda has been already adjusted");
+    CHECK_VTM(m_pairCheck == 1, "lambda has been already adjusted");
     m_pairCheck = 1;
   }
   else
   {
-    CHECK(m_pairCheck == 0, "lambda has not been adjusted");
+    CHECK_VTM(m_pairCheck == 0, "lambda has not been adjusted");
     m_pairCheck = 0;
   }
 
@@ -117,14 +117,14 @@ void RdCost::lambdaAdjustColorTrans(bool forward, ComponentID componentID, bool
   m_DistScale = m_DistScaleStore[m_pairCheck][componentID];
   if (applyChromaScale)
   {
-    CHECK(m_pairCheck == 0 || componentID == COMPONENT_Y, "wrong lambda adjustment for CS");
+    CHECK_VTM(m_pairCheck == 0 || componentID == COMPONENT_Y, "wrong lambda adjustment for CS");
     double cResScale = (double)(1 << CSCALE_FP_PREC) / (double)(*resScaleInv);
     m_dLambda = m_dLambda / (cResScale*cResScale);
     m_DistScale = double(1 << SCALE_BITS) / m_dLambda;
   }
   if (m_pairCheck == 0)
   {
-    CHECK(m_DistScale != m_DistScaleUnadjusted, "lambda should be adjusted to the original value");
+    CHECK_VTM(m_DistScale != m_DistScaleUnadjusted, "lambda should be adjusted to the original value");
   }
 }
 
@@ -389,7 +389,7 @@ void RdCost::setDistParam( DistParam &rcDP, const Pel* pOrg, const Pel* piRefY,
   rcDP.subShift = subShiftMode;
   rcDP.step       = step;
   rcDP.maximumDistortionForEarlyExit = std::numeric_limits<Distortion>::max();
-  CHECK( useHadamard || rcDP.useMR, "only used in xDMVRCost with these default parameters (so far...)" );
+  CHECK_VTM( useHadamard || rcDP.useMR, "only used in xDMVRCost with these default parameters (so far...)" );
   if ( bioApplied )
   {
     rcDP.distFunc = m_afpDistortFunc[ DF_SAD_INTERMEDIATE_BITDEPTH ];
@@ -473,7 +473,7 @@ Distortion RdCost::getDistPart( const CPelBuf &org, const CPelBuf &cur, int bitD
 
 Distortion RdCost::xGetSAD_full( const DistParam& rcDtParam )
 {
-  CHECK( rcDtParam.applyWeight, "Cannot apply weight when using full-bit SAD!" );
+  CHECK_VTM( rcDtParam.applyWeight, "Cannot apply weight when using full-bit SAD!" );
   const Pel* piOrg = rcDtParam.org.buf;
   const Pel* piCur = rcDtParam.cur.buf;
   int  height      = rcDtParam.org.height;
@@ -1824,7 +1824,7 @@ Distortion RdCost::xGetSSE4( const DistParam &rcDtParam )
 {
   if ( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 4, "Invalid size" );
+    CHECK_VTM( rcDtParam.org.width != 4, "Invalid size" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
 
@@ -1858,7 +1858,7 @@ Distortion RdCost::xGetSSE8( const DistParam &rcDtParam )
 {
   if ( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 8, "Invalid size" );
+    CHECK_VTM( rcDtParam.org.width != 8, "Invalid size" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
 
@@ -1895,7 +1895,7 @@ Distortion RdCost::xGetSSE16( const DistParam &rcDtParam )
 {
   if ( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 16, "Invalid size" );
+    CHECK_VTM( rcDtParam.org.width != 16, "Invalid size" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
 
@@ -1986,7 +1986,7 @@ Distortion RdCost::xGetSSE32( const DistParam &rcDtParam )
 {
   if ( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 32, "Invalid size" );
+    CHECK_VTM( rcDtParam.org.width != 32, "Invalid size" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
 
@@ -2047,7 +2047,7 @@ Distortion RdCost::xGetSSE64( const DistParam &rcDtParam )
 {
   if ( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 64, "Invalid size" );
+    CHECK_VTM( rcDtParam.org.width != 64, "Invalid size" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
 
@@ -2144,7 +2144,7 @@ Distortion RdCost::xCalcHADs2x2( const Pel *piOrg, const Pel *piCur, int iStride
 {
   Distortion satd = 0;
   TCoeff diff[4], m[4];
-  CHECK( iStep != 1, "Invalid step" );
+  CHECK_VTM( iStep != 1, "Invalid step" );
   diff[0] = piOrg[0             ] - piCur[0];
   diff[1] = piOrg[1             ] - piCur[1];
   diff[2] = piOrg[iStrideOrg    ] - piCur[0 + iStrideCur];
@@ -2172,7 +2172,7 @@ Distortion RdCost::xCalcHADs4x4( const Pel *piOrg, const Pel *piCur, int iStride
   Distortion satd = 0;
   TCoeff diff[16], m[16], d[16];
 
-  CHECK( iStep != 1, "Invalid step" );
+  CHECK_VTM( iStep != 1, "Invalid step" );
   for( k = 0; k < 16; k+=4 )
   {
     diff[k+0] = piOrg[0] - piCur[0];
@@ -2272,7 +2272,7 @@ Distortion RdCost::xCalcHADs8x8( const Pel *piOrg, const Pel *piCur, int iStride
   int k, i, j, jj;
   Distortion sad = 0;
   TCoeff diff[64], m1[8][8], m2[8][8], m3[8][8];
-  CHECK( iStep != 1, "Invalid step" );
+  CHECK_VTM( iStep != 1, "Invalid step" );
   for( k = 0; k < 64; k += 8 )
   {
     diff[k+0] = piOrg[0] - piCur[0];
@@ -3057,11 +3057,11 @@ Distortion RdCost::getWeightedMSE(int compIdx, const Pel org, const Pel cur, con
 {
   Distortion distortionVal = 0;
   Intermediate_Int iTemp = org - cur;
-  CHECK( org<0, "");
+  CHECK_VTM( org<0, "");
 
   if (compIdx == COMPONENT_Y)
   {
-    CHECK(org != orgLuma, "");
+    CHECK_VTM(org != orgLuma, "");
   }
   // use luma to get weight
   double weight = 1.0;
@@ -3123,7 +3123,7 @@ Distortion RdCost::xGetSSE2_WTD( const DistParam &rcDtParam )
 {
   if( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 2, "" );
+    CHECK_VTM( rcDtParam.org.width != 2, "" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam ); // ignore it for now
   }
 
@@ -3154,7 +3154,7 @@ Distortion RdCost::xGetSSE4_WTD( const DistParam &rcDtParam )
 {
   if( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 4, "" );
+    CHECK_VTM( rcDtParam.org.width != 4, "" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam ); // ignore it for now
   }
 
@@ -3187,7 +3187,7 @@ Distortion RdCost::xGetSSE8_WTD( const DistParam &rcDtParam )
 {
   if( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 8, "" );
+    CHECK_VTM( rcDtParam.org.width != 8, "" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
 
@@ -3224,7 +3224,7 @@ Distortion RdCost::xGetSSE16_WTD( const DistParam &rcDtParam )
 {
   if( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 16, "" );
+    CHECK_VTM( rcDtParam.org.width != 16, "" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
         int  iRows = rcDtParam.org.height;
@@ -3314,7 +3314,7 @@ Distortion RdCost::xGetSSE32_WTD( const DistParam &rcDtParam )
 {
   if( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 32, "" );
+    CHECK_VTM( rcDtParam.org.width != 32, "" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
         int  iRows = rcDtParam.org.height;
@@ -3374,7 +3374,7 @@ Distortion RdCost::xGetSSE64_WTD( const DistParam &rcDtParam )
 {
   if( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 64, "" );
+    CHECK_VTM( rcDtParam.org.width != 64, "" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
         int  iRows = rcDtParam.org.height;
diff --git a/source/Lib/CommonLib/RdCostWeightPrediction.cpp b/source/Lib/CommonLib/RdCostWeightPrediction.cpp
index f88f665..ff15d23 100644
--- a/source/Lib/CommonLib/RdCostWeightPrediction.cpp
+++ b/source/Lib/CommonLib/RdCostWeightPrediction.cpp
@@ -62,7 +62,7 @@ Distortion RdCostWeightPrediction::xGetSADw( const DistParam &rcDtParam )
   const int             iStrideOrg = rcDtParam.org.stride;
   const ComponentID     compID     = rcDtParam.compID;
 
-  CHECK( compID >= MAX_NUM_COMPONENT, "Invalid component" );
+  CHECK_VTM( compID >= MAX_NUM_COMPONENT, "Invalid component" );
 
   const WPScalingParam &wpCur      = rcDtParam.wpCur[compID];
 
@@ -245,8 +245,8 @@ Distortion RdCostWeightPrediction::xGetSSEw( const DistParam &rcDtParam )
   const int             iStrideOrg = rcDtParam.org.stride;
   const ComponentID     compID     = rcDtParam.compID;
 
-  CHECK( rcDtParam.subShift != 0, "Subshift not supported" ); // NOTE: what is this protecting?
-  CHECK( compID >= MAX_NUM_COMPONENT, "Invalid channel" );
+  CHECK_VTM( rcDtParam.subShift != 0, "Subshift not supported" ); // NOTE: what is this protecting?
+  CHECK_VTM( compID >= MAX_NUM_COMPONENT, "Invalid channel" );
 
   const WPScalingParam &wpCur           = rcDtParam.wpCur[compID];
   const int             w0              = wpCur.w;
@@ -590,7 +590,7 @@ Distortion RdCostWeightPrediction::xGetHADsw( const DistParam &rcDtParam )
   const int         iStrideOrg = rcDtParam.org.stride;
   const int         iStep      = rcDtParam.step;
   const ComponentID compIdx    = rcDtParam.compID;
-  CHECK(compIdx>=MAX_NUM_COMPONENT, "Invalid component");
+  CHECK_VTM(compIdx>=MAX_NUM_COMPONENT, "Invalid component");
   const WPScalingParam &wpCur  = rcDtParam.wpCur[compIdx];
 
   Distortion uiSum = 0;
diff --git a/source/Lib/CommonLib/Reshape.cpp b/source/Lib/CommonLib/Reshape.cpp
index 2137117..fc5fed9 100644
--- a/source/Lib/CommonLib/Reshape.cpp
+++ b/source/Lib/CommonLib/Reshape.cpp
@@ -188,7 +188,7 @@ int  Reshape::calculateChromaAdjVpduNei(TransformUnit &tu, const CompArea &areaY
     }
     else
     {
-      CHECK(pelnum != 0, "");
+      CHECK_VTM(pelnum != 0, "");
       lumaValue = valueDC;
     }
     chromaScale = calculateChromaAdj(lumaValue);
diff --git a/source/Lib/CommonLib/SampleAdaptiveOffset.cpp b/source/Lib/CommonLib/SampleAdaptiveOffset.cpp
index a34b446..cab8bc3 100644
--- a/source/Lib/CommonLib/SampleAdaptiveOffset.cpp
+++ b/source/Lib/CommonLib/SampleAdaptiveOffset.cpp
@@ -165,7 +165,7 @@ void SampleAdaptiveOffset::invertQuantOffsets(ComponentID compIdx, int typeIdc,
     {
       dstOffsets[i] = codedOffset[i] *(1<<m_offsetStepLog2[compIdx]);
     }
-    CHECK(dstOffsets[SAO_CLASS_EO_PLAIN] != 0, "EO offset is not '0'"); //keep EO plain offset as zero
+    CHECK_VTM(dstOffsets[SAO_CLASS_EO_PLAIN] != 0, "EO offset is not '0'"); //keep EO plain offset as zero
   }
 
 }
@@ -250,7 +250,7 @@ void SampleAdaptiveOffset::reconstructBlkSAOParam(SAOBlkParam& recParam, SAOBlkP
     case SAO_MODE_MERGE:
       {
         SAOBlkParam* mergeTarget = mergeList[offsetParam.typeIdc];
-        CHECK(mergeTarget == NULL, "Merge target does not exist");
+        CHECK_VTM(mergeTarget == NULL, "Merge target does not exist");
 
         offsetParam = (*mergeTarget)[component];
       }
@@ -618,7 +618,7 @@ void SampleAdaptiveOffset::offsetCTU( const UnitArea& area, const CPelUnitBuf& s
 void SampleAdaptiveOffset::SAOProcess( CodingStructure& cs, SAOBlkParam* saoBlkParams
                                       )
 {
-  CHECK(!saoBlkParams, "No parameters present");
+  CHECK_VTM(!saoBlkParams, "No parameters present");
 
   xReconstructBlkSAOParams(cs, saoBlkParams);
 
diff --git a/source/Lib/CommonLib/Slice.cpp b/source/Lib/CommonLib/Slice.cpp
index 06db6fa..4591e9a 100644
--- a/source/Lib/CommonLib/Slice.cpp
+++ b/source/Lib/CommonLib/Slice.cpp
@@ -444,7 +444,7 @@ void Slice::constructRefPicList(PicList& rcListPic)
   {
     if( m_RPL0.isInterLayerRefPic( ii ) )
     {
-      CHECK( m_RPL0.getInterLayerRefPicIdx( ii ) == NOT_VALID, "Wrong ILRP index" );
+      CHECK_VTM( m_RPL0.getInterLayerRefPicIdx( ii ) == NOT_VALID, "Wrong ILRP index" );
 
       int refLayerId = m_pcPic->cs->vps->getLayerId( m_pcPic->cs->vps->getDirectRefLayerIdx( layerIdx, m_RPL0.getInterLayerRefPicIdx( ii ) ) );
 
@@ -483,7 +483,7 @@ void Slice::constructRefPicList(PicList& rcListPic)
   {
     if( m_RPL1.isInterLayerRefPic( ii ) )
     {
-      CHECK( m_RPL1.getInterLayerRefPicIdx( ii ) == NOT_VALID, "Wrong ILRP index" );
+      CHECK_VTM( m_RPL1.getInterLayerRefPicIdx( ii ) == NOT_VALID, "Wrong ILRP index" );
 
       int refLayerId = m_pcPic->cs->vps->getLayerId( m_pcPic->cs->vps->getDirectRefLayerIdx( layerIdx, m_RPL1.getInterLayerRefPicIdx( ii ) ) );
 
@@ -564,7 +564,7 @@ void Slice::checkCRA(const ReferencePictureList* pRPL0, const ReferencePictureLi
     {
       if (!pRPL0->isRefPicLongterm(i))
       {
-        CHECK(getPOC() + pRPL0->getRefPicIdentifier(i) < pocCRA, "Invalid state");
+        CHECK_VTM(getPOC() + pRPL0->getRefPicIdentifier(i) < pocCRA, "Invalid state");
       }
       else if (!pRPL0->isInterLayerRefPic(i))
       {
@@ -577,8 +577,8 @@ void Slice::checkCRA(const ReferencePictureList* pRPL0, const ReferencePictureLi
         }
         const Picture *ltrp =
           xGetLongTermRefPic(rcListPic, ltrpPoc, pRPL0->getDeltaPocMSBPresentFlag(i), m_pcPic->layerId);
-        CHECK(ltrp == nullptr, "Long-term pic not found");
-        CHECK(ltrp->getPOC() < pocCRA, "Invalid state");
+        CHECK_VTM(ltrp == nullptr, "Long-term pic not found");
+        CHECK_VTM(ltrp->getPOC() < pocCRA, "Invalid state");
       }
     }
     numRefPic = pRPL1->getNumberOfShorttermPictures() + pRPL1->getNumberOfLongtermPictures();
@@ -586,7 +586,7 @@ void Slice::checkCRA(const ReferencePictureList* pRPL0, const ReferencePictureLi
     {
       if (!pRPL1->isRefPicLongterm(i))
       {
-        CHECK(getPOC() + pRPL1->getRefPicIdentifier(i) < pocCRA, "Invalid state");
+        CHECK_VTM(getPOC() + pRPL1->getRefPicIdentifier(i) < pocCRA, "Invalid state");
       }
       else if( !pRPL1->isInterLayerRefPic( i ) )
       {
@@ -599,8 +599,8 @@ void Slice::checkCRA(const ReferencePictureList* pRPL0, const ReferencePictureLi
         }
         const Picture *ltrp =
           xGetLongTermRefPic(rcListPic, ltrpPoc, pRPL1->getDeltaPocMSBPresentFlag(i), m_pcPic->layerId);
-        CHECK(ltrp == nullptr, "Long-term pic not found");
-        CHECK(ltrp->getPOC() < pocCRA, "Invalid state");
+        CHECK_VTM(ltrp == nullptr, "Long-term pic not found");
+        CHECK_VTM(ltrp->getPOC() < pocCRA, "Invalid state");
       }
     }
   }
@@ -653,14 +653,14 @@ void Slice::checkRPL(const ReferencePictureList* pRPL0, const ReferencePictureLi
 
         if( m_eNalUnitType == NAL_UNIT_CODED_SLICE_CRA || m_eNalUnitType == NAL_UNIT_CODED_SLICE_IDR_W_RADL || m_eNalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP )
         {
-          CHECK( refPicPOC < irapPOC || refPicDecodingOrderNumber < associatedIRAPDecodingOrderNumber, "When the current picture, with nuh_layer_id equal to a particular value layerId, "
+          CHECK_VTM( refPicPOC < irapPOC || refPicDecodingOrderNumber < associatedIRAPDecodingOrderNumber, "When the current picture, with nuh_layer_id equal to a particular value layerId, "
             "is an IRAP picture, there shall be no picture referred to by an entry in RefPicList[ 0 ] that precedes, in output order or decoding order, any preceding IRAP picture "
             "with nuh_layer_id equal to layerId in decoding order (when present)." );
         }
 
         if( irapPOC < getPOC() && !fieldSeqFlag )
         {
-          CHECK( refPicPOC < irapPOC || refPicDecodingOrderNumber < associatedIRAPDecodingOrderNumber, "When the current picture follows an IRAP picture having the same value "
+          CHECK_VTM( refPicPOC < irapPOC || refPicDecodingOrderNumber < associatedIRAPDecodingOrderNumber, "When the current picture follows an IRAP picture having the same value "
             "of nuh_layer_id and the leading pictures, if any, associated with that IRAP picture, in both decoding order and output order, there shall be no picture referred "
             "to by an entry in RefPicList[ 0 ] or RefPicList[ 1 ] that precedes that IRAP picture in output order or decoding order." );
         }
@@ -669,13 +669,13 @@ void Slice::checkRPL(const ReferencePictureList* pRPL0, const ReferencePictureLi
         const bool isGeneratedRefPic = pcRefPic->slices[0]->getPicHeader() ? false : true;
 
         const bool nonReferencePictureFlag = isGeneratedRefPic ? pcRefPic->slices[0]->getPicHeader()->getNonReferencePictureFlag() : pcRefPic->nonReferencePictureFlag;
-        CHECK( pcRefPic == m_pcPic || nonReferencePictureFlag, "The picture referred to by each entry in RefPicList[ 0 ] or RefPicList[ 1 ] shall not be the current picture and shall have ph_non_ref_pic_flag equal to 0" );
+        CHECK_VTM( pcRefPic == m_pcPic || nonReferencePictureFlag, "The picture referred to by each entry in RefPicList[ 0 ] or RefPicList[ 1 ] shall not be the current picture and shall have ph_non_ref_pic_flag equal to 0" );
 
         if( i < numActiveEntries[refPicList] )
         {
           if( irapPOC < getPOC() )
           {
-            CHECK( refPicPOC < irapPOC || refPicDecodingOrderNumber < associatedIRAPDecodingOrderNumber, "When the current picture follows an IRAP picture having the same value "
+            CHECK_VTM( refPicPOC < irapPOC || refPicDecodingOrderNumber < associatedIRAPDecodingOrderNumber, "When the current picture follows an IRAP picture having the same value "
               "of nuh_layer_id in both decoding order and output order, there shall be no picture referred to by an active entry in RefPicList[ 0 ] or RefPicList[ 1 ] that "
               "precedes that IRAP picture in output order or decoding order." );
           }
@@ -684,10 +684,10 @@ void Slice::checkRPL(const ReferencePictureList* pRPL0, const ReferencePictureLi
           // RefPicList[ 1 ] that is any of the following: A picture that precedes the associated IRAP picture in decoding order"
           if( m_eNalUnitType == NAL_UNIT_CODED_SLICE_RADL )
           {
-            CHECK( refPicDecodingOrderNumber < associatedIRAPDecodingOrderNumber, "RADL picture detected that violate the rule that no active entry in RefPicList[] shall precede the associated IRAP picture in decoding order" );
+            CHECK_VTM( refPicDecodingOrderNumber < associatedIRAPDecodingOrderNumber, "RADL picture detected that violate the rule that no active entry in RefPicList[] shall precede the associated IRAP picture in decoding order" );
           }
 
-          CHECK( pcRefPic->temporalId > m_pcPic->temporalId, "The picture referred to by each active entry in RefPicList[ 0 ] or RefPicList[ 1 ] shall be present in the DPB and shall have TemporalId less than or equal to that of the current picture." );
+          CHECK_VTM( pcRefPic->temporalId > m_pcPic->temporalId, "The picture referred to by each active entry in RefPicList[ 0 ] or RefPicList[ 1 ] shall be present in the DPB and shall have TemporalId less than or equal to that of the current picture." );
         }
       }
     }
@@ -706,12 +706,12 @@ void Slice::checkSTSA(PicList& rcListPic)
 
     if( m_eNalUnitType == NAL_UNIT_CODED_SLICE_STSA && pcRefPic->layerId == m_pcPic->layerId )
     {
-      CHECK( pcRefPic->temporalId == m_uiTLayer, "When the current picture is an STSA picture and nuh_layer_id equal to that of the current picture, there shall be no active entry in the RPL that has TemporalId equal to that of the current picture" );
+      CHECK_VTM( pcRefPic->temporalId == m_uiTLayer, "When the current picture is an STSA picture and nuh_layer_id equal to that of the current picture, there shall be no active entry in the RPL that has TemporalId equal to that of the current picture" );
     }
 
     // Checking this: "When the current picture is a picture that follows, in decoding order, an STSA picture that has TemporalId equal to that of the current picture, there shall be no
     // picture that has TemporalId equal to that of the current picture included as an active entry in RefPicList[ 0 ] or RefPicList[ 1 ] that precedes the STSA picture in decoding order."
-    CHECK(pcRefPic->subLayerNonReferencePictureDueToSTSA, "The RPL of the current picture contains a picture that is not allowed in this temporal layer due to an earlier STSA picture");
+    CHECK_VTM(pcRefPic->subLayerNonReferencePictureDueToSTSA, "The RPL of the current picture contains a picture that is not allowed in this temporal layer due to an earlier STSA picture");
   }
 
   numOfActiveRef = getNumRefIdx(REF_PIC_LIST_1);
@@ -721,12 +721,12 @@ void Slice::checkSTSA(PicList& rcListPic)
 
     if( m_eNalUnitType == NAL_UNIT_CODED_SLICE_STSA && pcRefPic->layerId == m_pcPic->layerId )
     {
-      CHECK( pcRefPic->temporalId == m_uiTLayer, "When the current picture is an STSA picture and nuh_layer_id equal to that of the current picture, there shall be no active entry in the RPL that has TemporalId equal to that of the current picture" );
+      CHECK_VTM( pcRefPic->temporalId == m_uiTLayer, "When the current picture is an STSA picture and nuh_layer_id equal to that of the current picture, there shall be no active entry in the RPL that has TemporalId equal to that of the current picture" );
     }
 
     // Checking this: "When the current picture is a picture that follows, in decoding order, an STSA picture that has TemporalId equal to that of the current picture, there shall be no
     // picture that has TemporalId equal to that of the current picture included as an active entry in RefPicList[ 0 ] or RefPicList[ 1 ] that precedes the STSA picture in decoding order."
-    CHECK(pcRefPic->subLayerNonReferencePictureDueToSTSA, "The active RPL part of the current picture contains a picture that is not allowed in this temporal layer due to an earlier STSA picture");
+    CHECK_VTM(pcRefPic->subLayerNonReferencePictureDueToSTSA, "The active RPL part of the current picture contains a picture that is not allowed in this temporal layer due to an earlier STSA picture");
   }
 
   // If the current picture is an STSA picture, make all reference pictures in the DPB with temporal
@@ -844,7 +844,7 @@ void Slice::decodingRefreshMarking(int& pocCRA, bool& bRefreshPending, PicList&
 
 void Slice::copySliceInfo(Slice *pSrc, bool cpyAlmostAll)
 {
-  CHECK(!pSrc, "Source is NULL");
+  CHECK_VTM(!pSrc, "Source is NULL");
 
   int i, j, k;
 
@@ -1031,7 +1031,7 @@ void Slice::checkLeadingPictureRestrictions(PicList& rcListPic, const PPS& pps)
       if (nalUnitType < NAL_UNIT_CODED_SLICE_IDR_W_RADL ||
           nalUnitType > NAL_UNIT_CODED_SLICE_CRA)
       {
-        CHECK(nalUnitType != NAL_UNIT_CODED_SLICE_RASL &&
+        CHECK_VTM(nalUnitType != NAL_UNIT_CODED_SLICE_RASL &&
               nalUnitType != NAL_UNIT_CODED_SLICE_RADL, "Invalid NAL unit type");
       }
     }
@@ -1041,7 +1041,7 @@ void Slice::checkLeadingPictureRestrictions(PicList& rcListPic, const PPS& pps)
   {
     if (pps.getMixedNaluTypesInPicFlag() == 0)
     {
-      CHECK(nalUnitType == NAL_UNIT_CODED_SLICE_RASL || nalUnitType == NAL_UNIT_CODED_SLICE_RADL, "When a picture is not a leading picture, it shall not be a RADL or RASL picture.");
+      CHECK_VTM(nalUnitType == NAL_UNIT_CODED_SLICE_RASL || nalUnitType == NAL_UNIT_CODED_SLICE_RADL, "When a picture is not a leading picture, it shall not be a RADL or RASL picture.");
     }
   }
 
@@ -1049,7 +1049,7 @@ void Slice::checkLeadingPictureRestrictions(PicList& rcListPic, const PPS& pps)
   // an IDR picture.
   if (nalUnitType == NAL_UNIT_CODED_SLICE_RASL && !pps.getMixedNaluTypesInPicFlag())
   {
-    CHECK( this->getAssociatedIRAPType() == NAL_UNIT_CODED_SLICE_IDR_N_LP   ||
+    CHECK_VTM( this->getAssociatedIRAPType() == NAL_UNIT_CODED_SLICE_IDR_N_LP   ||
            this->getAssociatedIRAPType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL, "Invalid NAL unit type");
   }
 
@@ -1058,7 +1058,7 @@ void Slice::checkLeadingPictureRestrictions(PicList& rcListPic, const PPS& pps)
   // with an IDR picture having nal_unit_type equal to IDR_N_LP.
   if (nalUnitType == NAL_UNIT_CODED_SLICE_RADL && !pps.getMixedNaluTypesInPicFlag())
   {
-    CHECK (this->getAssociatedIRAPType() == NAL_UNIT_CODED_SLICE_IDR_N_LP, "Invalid NAL unit type");
+    CHECK_VTM(this->getAssociatedIRAPType() == NAL_UNIT_CODED_SLICE_IDR_N_LP, "Invalid NAL unit type");
   }
 
   // loop through all pictures in the reference picture buffer
@@ -1081,7 +1081,7 @@ void Slice::checkLeadingPictureRestrictions(PicList& rcListPic, const PPS& pps)
     {
       if ((nalUnitType == NAL_UNIT_CODED_SLICE_CRA || nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP || nalUnitType == NAL_UNIT_CODED_SLICE_IDR_W_RADL) && !pps.getMixedNaluTypesInPicFlag())
       {
-        CHECK(pcPic->poc >= this->getPOC(), "Any picture, with nuh_layer_id equal to a particular value layerId, that precedes an IRAP picture with nuh_layer_id "
+        CHECK_VTM(pcPic->poc >= this->getPOC(), "Any picture, with nuh_layer_id equal to a particular value layerId, that precedes an IRAP picture with nuh_layer_id "
               "equal to layerId in decoding order shall precede the IRAP picture in output order.");
       }
     }
@@ -1094,7 +1094,7 @@ void Slice::checkLeadingPictureRestrictions(PicList& rcListPic, const PPS& pps)
         {
           if (this->getAssociatedIRAPPOC() != pcPic->poc)
           {
-            CHECK(pcPic->poc >= this->getPOC(), "Any picture, with nuh_layer_id equal to a particular value layerId, that precedes an IRAP picture with nuh_layer_id "
+            CHECK_VTM(pcPic->poc >= this->getPOC(), "Any picture, with nuh_layer_id equal to a particular value layerId, that precedes an IRAP picture with nuh_layer_id "
                   "equal to layerId in decoding order shall precede any RADL picture associated with the IRAP picture in output order.");
           }
         }
@@ -1106,7 +1106,7 @@ void Slice::checkLeadingPictureRestrictions(PicList& rcListPic, const PPS& pps)
     {
       if (this->getPOC() == this->getPicHeader()->getRecoveryPocCnt() + this->getPrevGDRInSameLayerPOC())
       {
-        CHECK(pcPic->poc >= this->getPOC(), "Any picture, with nuh_layer_id equal to a particular value layerId, that precedes a recovery point picture with "
+        CHECK_VTM(pcPic->poc >= this->getPOC(), "Any picture, with nuh_layer_id equal to a particular value layerId, that precedes a recovery point picture with "
               "nuh_layer_id equal to layerId in decoding order shall precede the recovery point picture in output order.");
       }
     }
@@ -1122,7 +1122,7 @@ void Slice::checkLeadingPictureRestrictions(PicList& rcListPic, const PPS& pps)
         {
           limitNonLP = 1;
         }
-        CHECK(pcPic->poc > this->getAssociatedIRAPPOC() && numNonLPFound > limitNonLP, "If sps_field_seq_flag is equal to 0 and the current picture, with nuh_layer_id "
+        CHECK_VTM(pcPic->poc > this->getAssociatedIRAPPOC() && numNonLPFound > limitNonLP, "If sps_field_seq_flag is equal to 0 and the current picture, with nuh_layer_id "
               "equal to a particular value layerId, is a leading picture associated with an IRAP picture, it shall precede, in decoding order, all non-leading "
               "pictures that are associated with the same IRAP picture.Otherwise, let picA and picB be the first and the last leading pictures, in decoding order, "
               "associated with an IRAP picture, respectively, there shall be at most one non-leading picture with nuh_layer_id equal to layerId preceding picA in "
@@ -1137,7 +1137,7 @@ void Slice::checkLeadingPictureRestrictions(PicList& rcListPic, const PPS& pps)
       {
         if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL)
         {
-          CHECK(pcPic->poc <= this->getPOC(), "Any RASL picture associated with a CRA picture shall precede any RADL picture associated with the CRA picture in output order.");
+          CHECK_VTM(pcPic->poc <= this->getPOC(), "Any RASL picture associated with a CRA picture shall precede any RADL picture associated with the CRA picture in output order.");
         }
       }
     }
@@ -1154,7 +1154,7 @@ void Slice::checkLeadingPictureRestrictions(PicList& rcListPic, const PPS& pps)
             pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR) &&
             pcPic->layerId == this->m_nuhLayerId)
         {
-          CHECK(this->getPOC() <= pcSlice->getPOC(), "Any RASL picture, with nuh_layer_id equal to a particular value layerId, associated with a CRA picture shall follow, "
+          CHECK_VTM(this->getPOC() <= pcSlice->getPOC(), "Any RASL picture, with nuh_layer_id equal to a particular value layerId, associated with a CRA picture shall follow, "
                "in output order, any IRAP or GDR picture with nuh_layer_id equal to layerId that precedes the CRA picture in decoding order.");
         }
       }
@@ -1168,7 +1168,7 @@ void Slice::checkSubpicTypeConstraints(PicList& rcListPic, const ReferencePictur
 
   if (getPPS()->getMixedNaluTypesInPicFlag() && getSliceType() != I_SLICE)
   {
-    CHECK(!getSPS()->getSubPicTreatedAsPicFlag(curSubpicIdx), "When pps_mixed_nalu_types_in_pic_flag is equal 1, the value of sps_subpic_treated_as_pic_flag shall be equal to 1 "
+    CHECK_VTM(!getSPS()->getSubPicTreatedAsPicFlag(curSubpicIdx), "When pps_mixed_nalu_types_in_pic_flag is equal 1, the value of sps_subpic_treated_as_pic_flag shall be equal to 1 "
           "for all the subpictures that are in the picture and contain at least one P or B slice");
   }
 
@@ -1183,20 +1183,20 @@ void Slice::checkSubpicTypeConstraints(PicList& rcListPic, const ReferencePictur
 
     if (prevIRAPSubpicPOC > getPOC() && (nalUnitType < NAL_UNIT_CODED_SLICE_IDR_W_RADL || nalUnitType > NAL_UNIT_CODED_SLICE_CRA))
     {
-      CHECK(nalUnitType != NAL_UNIT_CODED_SLICE_RASL && nalUnitType != NAL_UNIT_CODED_SLICE_RADL,
+      CHECK_VTM(nalUnitType != NAL_UNIT_CODED_SLICE_RASL && nalUnitType != NAL_UNIT_CODED_SLICE_RADL,
         "When a subpicture is a leading subpicture of an IRAP subpicture, it shall be a RADL or RASL subpicture");
     }
 
     if (prevIRAPSubpicPOC <= getPOC())
     {
-      CHECK(nalUnitType == NAL_UNIT_CODED_SLICE_RASL || nalUnitType == NAL_UNIT_CODED_SLICE_RADL,
+      CHECK_VTM(nalUnitType == NAL_UNIT_CODED_SLICE_RASL || nalUnitType == NAL_UNIT_CODED_SLICE_RADL,
         "When a subpicture is not a leading subpicture of an IRAP subpicture, it shall not be a RADL or RASL subpicture");
     }
 
-    CHECK(nalUnitType == NAL_UNIT_CODED_SLICE_RASL && (prevIRAPSubpicType == NAL_UNIT_CODED_SLICE_IDR_N_LP || prevIRAPSubpicType == NAL_UNIT_CODED_SLICE_IDR_W_RADL),
+    CHECK_VTM(nalUnitType == NAL_UNIT_CODED_SLICE_RASL && (prevIRAPSubpicType == NAL_UNIT_CODED_SLICE_IDR_N_LP || prevIRAPSubpicType == NAL_UNIT_CODED_SLICE_IDR_W_RADL),
       "No RASL subpictures shall be present in the bitstream that are associated with an IDR subpicture");
 
-    CHECK(nalUnitType == NAL_UNIT_CODED_SLICE_RADL && prevIRAPSubpicType == NAL_UNIT_CODED_SLICE_IDR_N_LP,
+    CHECK_VTM(nalUnitType == NAL_UNIT_CODED_SLICE_RADL && prevIRAPSubpicType == NAL_UNIT_CODED_SLICE_IDR_N_LP,
       "No RADL subpictures shall be present in the bitstream that are associated with an IDR subpicture having nal_unit_type equal to IDR_N_LP");
 
     //constraints related to current subpicture type and its preceding subpicture types
@@ -1232,7 +1232,7 @@ void Slice::checkSubpicTypeConstraints(PicList& rcListPic, const ReferencePictur
       if ((nalUnitType == NAL_UNIT_CODED_SLICE_CRA || nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP || nalUnitType == NAL_UNIT_CODED_SLICE_IDR_W_RADL) &&
         !this->getNoOutputOfPriorPicsFlag() && isBufPicOutput == 1 && bufPic->layerId == m_nuhLayerId)
       {
-        CHECK(bufPic->poc >= getPOC(), "Any subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal to a particular value subpicIdx, that "
+        CHECK_VTM(bufPic->poc >= getPOC(), "Any subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal to a particular value subpicIdx, that "
           "precedes, in decoding order, an IRAP subpicture with nuh_layer_id equal to layerId and subpicture index equal to subpicIdx shall precede, in output order, the "
           "IRAP subpicture");
       }
@@ -1240,7 +1240,7 @@ void Slice::checkSubpicTypeConstraints(PicList& rcListPic, const ReferencePictur
       if (nalUnitType == NAL_UNIT_CODED_SLICE_RADL && isBufPicOutput == 1 && bufPic->layerId == m_nuhLayerId &&
         prevIRAPSubpicPOC > bufSubpicPrevIRAPSubpicPOC && prevIRAPSubpicPOC != bufPic->poc)
       {
-        CHECK(bufPic->poc >= getPOC(), "Any subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal to a particular value subpicIdx, that "
+        CHECK_VTM(bufPic->poc >= getPOC(), "Any subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal to a particular value subpicIdx, that "
           "precedes, in decoding order, an IRAP subpicture with nuh_layer_id equal to layerId and subpicture index equal to subpicIdx shall precede, in output order, all "
           "its associated RADL subpictures");
       }
@@ -1248,7 +1248,7 @@ void Slice::checkSubpicTypeConstraints(PicList& rcListPic, const ReferencePictur
       if ((getPOC() == getPicHeader()->getRecoveryPocCnt() + prevGDRSubpicPOC) && !this->getNoOutputOfPriorPicsFlag() && isBufPicOutput == 1 &&
         bufPic->layerId == m_nuhLayerId && nalUnitType != NAL_UNIT_CODED_SLICE_GDR && getPicHeader()->getRecoveryPocCnt() != -1)
       {
-        CHECK(bufPic->poc >= getPOC(), "Any subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal to a particular value subpicIdx, that "
+        CHECK_VTM(bufPic->poc >= getPOC(), "Any subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal to a particular value subpicIdx, that "
           "precedes, in decoding order, a subpicture with nuh_layer_id equal to layerId and subpicture index equal to subpicIdx in a recovery point picture shall precede "
           "that subpicture in the recovery point picture in output order");
       }
@@ -1256,7 +1256,7 @@ void Slice::checkSubpicTypeConstraints(PicList& rcListPic, const ReferencePictur
       if (nalUnitType == NAL_UNIT_CODED_SLICE_RASL && prevIRAPSubpicType == NAL_UNIT_CODED_SLICE_CRA && bufSubpicType == NAL_UNIT_CODED_SLICE_RADL &&
         prevIRAPSubpicPOC == bufSubpicPrevIRAPSubpicPOC)
       {
-        CHECK(bufPic->poc <= getPOC(), "Any RASL subpicture associated with a CRA subpicture shall precede any RADL subpicture associated with the CRA subpicture in output order");
+        CHECK_VTM(bufPic->poc <= getPOC(), "Any RASL subpicture associated with a CRA subpicture shall precede any RADL subpicture associated with the CRA subpicture in output order");
       }
 
       if (nalUnitType == NAL_UNIT_CODED_SLICE_RASL && prevIRAPSubpicType == NAL_UNIT_CODED_SLICE_CRA && bufPic->layerId == m_nuhLayerId && bufPic->poc < prevIRAPSubpicPOC)
@@ -1264,7 +1264,7 @@ void Slice::checkSubpicTypeConstraints(PicList& rcListPic, const ReferencePictur
         if (bufSubpicType == NAL_UNIT_CODED_SLICE_IDR_N_LP || bufSubpicType == NAL_UNIT_CODED_SLICE_IDR_W_RADL ||
           bufSubpicType == NAL_UNIT_CODED_SLICE_CRA || bufSubpicType == NAL_UNIT_CODED_SLICE_GDR)
         {
-          CHECK(bufPic->poc >= getPOC(), "Any RASL subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal to a particular value subpicIdx, "
+          CHECK_VTM(bufPic->poc >= getPOC(), "Any RASL subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal to a particular value subpicIdx, "
             "associated with a CRA subpicture shall follow, in output order, any IRAP or GDR subpicture , with nuh_layer_id equal to layerId and subpicture index equal to "
             "subpicIdx, that precedes the CRA subpicture in decoding order");
         }
@@ -1276,7 +1276,7 @@ void Slice::checkSubpicTypeConstraints(PicList& rcListPic, const ReferencePictur
       {
         numNonLeadingPic++;
         int th = bufPic->cs->sps->getFieldSeqFlag() ? 1 : 0;
-        CHECK(bufPic->poc > prevIRAPSubpicPOC && numNonLeadingPic > th, "If sps_field_seq_flag is equal to 0 and the current subpicture, with nuh_layer_id equal to a particular value "
+        CHECK_VTM(bufPic->poc > prevIRAPSubpicPOC && numNonLeadingPic > th, "If sps_field_seq_flag is equal to 0 and the current subpicture, with nuh_layer_id equal to a particular value "
           "layerId and subpicture index equal to a particular value subpicIdx, is a leading subpicture associated with an IRAP subpicture, it shall precede, in decoding order, "
           "all non-leading subpictures that are associated with the same IRAP subpicture. Otherwise, let subpicA and subpicB be the first and the last leading subpictures, in "
           "decoding order, associated with an IRAP subpicture, respectively, there shall be at most one non-leading subpicture with nuh_layer_id equal to layerId and subpicture "
@@ -1330,7 +1330,7 @@ void Slice::checkSubpicTypeConstraints(PicList& rcListPic, const ReferencePictur
 
       if (nalUnitType == NAL_UNIT_CODED_SLICE_CRA || nalUnitType == NAL_UNIT_CODED_SLICE_IDR_W_RADL || nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP)
       {
-        CHECK(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture, with nuh_layer_id equal to a particular value "
+        CHECK_VTM(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture, with nuh_layer_id equal to a particular value "
               "layerId and subpicture index equal to a particular value subpicIdx, is an IRAP subpicture, there shall be no picture referred to by an entry in RefPicList[0] that "
               "precedes, in output order or decoding order,any preceding picture, in decoding order (when present), containing an IRAP subpicture with nuh_layer_id equal to "
               "layerId and subpicture index equal to subpicIdx");
@@ -1338,7 +1338,7 @@ void Slice::checkSubpicTypeConstraints(PicList& rcListPic, const ReferencePictur
 
       if (prevIRAPSubpicPOC < getPOC() && !getSPS()->getFieldSeqFlag())
       {
-        CHECK(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture follows an IRAP subpicture having the same value "
+        CHECK_VTM(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture follows an IRAP subpicture having the same value "
               "of nuh_layer_id and the same value of subpicture index in both decoding and output order, there shall be no picture referred to by an active entry in RefPicList[ 0 ] "
               "that precedes the picture containing that IRAP subpicture in output order or decoding order");
       }
@@ -1347,14 +1347,14 @@ void Slice::checkSubpicTypeConstraints(PicList& rcListPic, const ReferencePictur
       {
         if (prevIRAPSubpicPOC < getPOC())
         {
-          CHECK(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture follows an IRAP subpicture having the same value "
+          CHECK_VTM(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture follows an IRAP subpicture having the same value "
                 "of nuh_layer_id and the same value of subpicture index and the leading subpictures, if any, associated with that IRAP subpicture in both decoding and output order, "
                 "there shall be no picture referred to by an entry in RefPicList[ 0 ] that precedes the picture containing that IRAP subpicture in output order or decoding order");
         }
 
         if (nalUnitType == NAL_UNIT_CODED_SLICE_RADL)
         {
-          CHECK(refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal "
+          CHECK_VTM(refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal "
                 "to a particular value subpicIdx, is a RADL subpicture, there shall be no active entry in RefPicList[ 0 ] that is a picture that precedes the picture containing the"
                 "associated IRAP subpicture in decoding order");
 
@@ -1364,7 +1364,7 @@ void Slice::checkSubpicTypeConstraints(PicList& rcListPic, const ReferencePictur
             {
               if (pcRefPic->sliceSubpicIdx[i] == curSubpicIdx)
               {
-                CHECK(pcRefPic->slices[i]->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL, "When the current subpicture, with nuh_layer_id equal to a particular value layerId and "
+                CHECK_VTM(pcRefPic->slices[i]->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL, "When the current subpicture, with nuh_layer_id equal to a particular value layerId and "
                       "subpicture index equal to a particular value subpicIdx, is a RADL subpicture, there shall be no active entry in RefPicList[ 0 ] that is a picture with "
                       "nuh_layer_id equal to layerId containing a RASL subpicture with subpicture index equal to subpicIdx");
               }
@@ -1406,7 +1406,7 @@ void Slice::checkSubpicTypeConstraints(PicList& rcListPic, const ReferencePictur
 
       if (nalUnitType == NAL_UNIT_CODED_SLICE_CRA || nalUnitType == NAL_UNIT_CODED_SLICE_IDR_W_RADL || nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP)
       {
-        CHECK(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture, with nuh_layer_id equal to a particular value"
+        CHECK_VTM(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture, with nuh_layer_id equal to a particular value"
               "layerId and subpicture index equal to a particular value subpicIdx, is an IRAP subpicture, there shall be no picture referred to by an entry in RefPicList[1] that"
               "precedes, in output order or decoding order,any preceding picture, in decoding order (when present), containing an IRAP subpicture with nuh_layer_id equal to "
               "layerId and subpicture index equal to subpicIdx");
@@ -1414,7 +1414,7 @@ void Slice::checkSubpicTypeConstraints(PicList& rcListPic, const ReferencePictur
 
       if (prevIRAPSubpicPOC < getPOC() && !getSPS()->getFieldSeqFlag())
       {
-        CHECK(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture follows an IRAP subpicture having the same value "
+        CHECK_VTM(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture follows an IRAP subpicture having the same value "
               "of nuh_layer_id and the same value of subpicture index in both decoding and output order, there shall be no picture referred to by an active entry in RefPicList[ 1 ] "
               "that precedes the picture containing that IRAP subpicture in output order or decoding order");
       }
@@ -1422,14 +1422,14 @@ void Slice::checkSubpicTypeConstraints(PicList& rcListPic, const ReferencePictur
       {
         if (prevIRAPSubpicPOC < getPOC())
         {
-          CHECK(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture follows an IRAP subpicture having the same value "
+          CHECK_VTM(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture follows an IRAP subpicture having the same value "
                 "of nuh_layer_id and the same value of subpicture index and the leading subpictures, if any, associated with that IRAP subpicture in both decoding and output order, "
                 "there shall be no picture referred to by an entry in RefPicList[ 1 ] that precedes the picture containing that IRAP subpicture in output order or decoding order");
         }
 
         if (nalUnitType == NAL_UNIT_CODED_SLICE_RADL)
         {
-          CHECK(refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal "
+          CHECK_VTM(refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal "
                 "to a particular value subpicIdx, is a RADL subpicture, there shall be no active entry in RefPicList[ 1 ] that is a picture that precedes the picture containing the"
                 "associated IRAP subpicture in decoding order");
 
@@ -1439,7 +1439,7 @@ void Slice::checkSubpicTypeConstraints(PicList& rcListPic, const ReferencePictur
             {
               if (pcRefPic->sliceSubpicIdx[i] == curSubpicIdx)
               {
-                CHECK(pcRefPic->slices[i]->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL, "When the current subpicture, with nuh_layer_id equal to a particular value layerId and "
+                CHECK_VTM(pcRefPic->slices[i]->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL, "When the current subpicture, with nuh_layer_id equal to a particular value layerId and "
                       "subpicture index equal to a particular value subpicIdx, is a RADL subpicture, there shall be no active entry in RefPicList[ 1 ] that is a picture with "
                       "nuh_layer_id equal to layerId containing a RASL subpicture with subpicture index equal to subpicIdx");
               }
@@ -1609,7 +1609,7 @@ void Slice::applyReferencePictureListBasedMarking( PicList& rcListPic, const Ref
       if( pRPL0->isInterLayerRefPic( i ) )
       {
         // Diagonal inter-layer prediction is not allowed
-        CHECK( pRPL0->getRefPicIdentifier( i ), "ILRP identifier should be 0" );
+        CHECK_VTM( pRPL0->getRefPicIdentifier( i ), "ILRP identifier should be 0" );
 
         if( pcPic->poc == m_iPOC )
         {
@@ -1654,7 +1654,7 @@ void Slice::applyReferencePictureListBasedMarking( PicList& rcListPic, const Ref
       if( pRPL1->isInterLayerRefPic( i ) )
       {
         // Diagonal inter-layer prediction is not allowed
-        CHECK( pRPL1->getRefPicIdentifier( i ), "ILRP identifier should be 0" );
+        CHECK_VTM( pRPL1->getRefPicIdentifier( i ), "ILRP identifier should be 0" );
 
         if( pcPic->poc == m_iPOC )
         {
@@ -1705,7 +1705,7 @@ void Slice::applyReferencePictureListBasedMarking( PicList& rcListPic, const Ref
     if (pcPic->referenced)
     {
       //check that pictures of higher temporal layers are not used
-      CHECK(pcPic->usedByCurr && !(pcPic->temporalId <= this->getTLayer()), "Invalid state");
+      CHECK_VTM(pcPic->usedByCurr && !(pcPic->temporalId <= this->getTLayer()), "Invalid state");
     }
   }
 }
@@ -1938,7 +1938,7 @@ bool Slice::isPOCInRefPicList(const ReferencePictureList *rpl, int poc )
     if( rpl->isInterLayerRefPic( i ) )
     {
       // Diagonal inter-layer prediction is not allowed
-      CHECK( rpl->getRefPicIdentifier( i ), "ILRP identifier should be 0" );
+      CHECK_VTM( rpl->getRefPicIdentifier( i ), "ILRP identifier should be 0" );
 
       if( poc == m_iPOC )
       {
@@ -2055,7 +2055,7 @@ void  Slice::initWpAcDcParam()
 //! get tables for weighted prediction
 const WPScalingParam *Slice::getWpScaling(const RefPicList refPicList, const int refIdx) const
 {
-  CHECK(refPicList >= NUM_REF_PIC_LIST_01, "Invalid picture reference list");
+  CHECK_VTM(refPicList >= NUM_REF_PIC_LIST_01, "Invalid picture reference list");
   if (refIdx < 0)
   {
     return nullptr;
@@ -2068,7 +2068,7 @@ const WPScalingParam *Slice::getWpScaling(const RefPicList refPicList, const int
 
 WPScalingParam *Slice::getWpScaling(const RefPicList refPicList, const int refIdx)
 {
-  CHECK(refPicList >= NUM_REF_PIC_LIST_01, "Invalid picture reference list");
+  CHECK_VTM(refPicList >= NUM_REF_PIC_LIST_01, "Invalid picture reference list");
   if (refIdx < 0)
   {
     return nullptr;
@@ -2365,7 +2365,7 @@ void VPS::deriveOutputLayerSets()
   }
   for (int i = 0; i < m_maxLayers; i++)
   {
-    CHECK(layerUsedAsRefLayerFlag[i] == 0 && layerUsedAsOutputLayerFlag[i] == 0, "There shall be no layer that is neither an output layer nor a direct reference layer");
+    CHECK_VTM(layerUsedAsRefLayerFlag[i] == 0 && layerUsedAsOutputLayerFlag[i] == 0, "There shall be no layer that is neither an output layer nor a direct reference layer");
   }
 
   m_numLayersInOls[0] = 1;
@@ -2423,11 +2423,11 @@ void VPS::checkVPS()
     const int olsIdx = m_multiLayerOlsIdxToOlsIdx[multiLayerOlsIdx];
     const int olsTimingHrdIdx = getOlsTimingHrdIdx(multiLayerOlsIdx);
     const int olsPtlIdx = getOlsPtlIdx(olsIdx);
-    CHECK (getHrdMaxTid(olsTimingHrdIdx) < getPtlMaxTemporalId(olsPtlIdx), "The value of vps_hrd_max_tid[vps_ols_timing_hrd_idx[m]] shall be greater than or equal to "
+    CHECK_VTM(getHrdMaxTid(olsTimingHrdIdx) < getPtlMaxTemporalId(olsPtlIdx), "The value of vps_hrd_max_tid[vps_ols_timing_hrd_idx[m]] shall be greater than or equal to "
                                                                      "vps_ptl_max_tid[ vps_ols_ptl_idx[n]] for each m-th multi-layer OLS for m from 0 to "
                                                                      "NumMultiLayerOlss - 1, inclusive, and n being the OLS index of the m-th multi-layer OLS among all OLSs.");
     const int olsDpbParamsIdx = getOlsDpbParamsIdx(multiLayerOlsIdx);
-    CHECK (m_dpbMaxTemporalId[olsDpbParamsIdx] < getPtlMaxTemporalId(olsPtlIdx), "The value of vps_dpb_max_tid[vps_ols_dpb_params_idx[m]] shall be greater than or equal to "
+    CHECK_VTM(m_dpbMaxTemporalId[olsDpbParamsIdx] < getPtlMaxTemporalId(olsPtlIdx), "The value of vps_dpb_max_tid[vps_ols_dpb_params_idx[m]] shall be greater than or equal to "
                                                                      "vps_ptl_max_tid[ vps_ols_ptl_idx[n]] for each m-th multi-layer OLS for m from 0 to "
                                                                      "NumMultiLayerOlss - 1, inclusive, and n being the OLS index of the m-th multi-layer OLS among all OLSs.");
   }
@@ -2619,7 +2619,7 @@ void PicHeader::initPicHeader()
 
 const WPScalingParam *PicHeader::getWpScaling(const RefPicList refPicList, const int refIdx) const
 {
-  CHECK(refPicList >= NUM_REF_PIC_LIST_01, "Invalid picture reference list");
+  CHECK_VTM(refPicList >= NUM_REF_PIC_LIST_01, "Invalid picture reference list");
   if (refIdx < 0)
   {
     return nullptr;
@@ -2632,7 +2632,7 @@ const WPScalingParam *PicHeader::getWpScaling(const RefPicList refPicList, const
 
 WPScalingParam *PicHeader::getWpScaling(const RefPicList refPicList, const int refIdx)
 {
-  CHECK(refPicList >= NUM_REF_PIC_LIST_01, "Invalid picture reference list");
+  CHECK_VTM(refPicList >= NUM_REF_PIC_LIST_01, "Invalid picture reference list");
   if (refIdx < 0)
   {
     return nullptr;
@@ -2861,8 +2861,8 @@ void ChromaQpMappingTable::derivedChromaQPMappingTables()
 
     for (int j = 0; j <= getNumPtsInCQPTableMinus1(i); j++)
     {
-      CHECK(qpInVal[j]  < -qpBdOffsetC || qpInVal[j]  > MAX_QP, "qpInVal out of range");
-      CHECK(qpOutVal[j] < -qpBdOffsetC || qpOutVal[j] > MAX_QP, "qpOutVal out of range");
+      CHECK_VTM(qpInVal[j]  < -qpBdOffsetC || qpInVal[j]  > MAX_QP, "qpInVal out of range");
+      CHECK_VTM(qpOutVal[j] < -qpBdOffsetC || qpOutVal[j] > MAX_QP, "qpOutVal out of range");
     }
 
     m_chromaQpMappingTables[i][qpInVal[0]] = qpOutVal[0];
@@ -3052,7 +3052,7 @@ void PPS::initTiles()
 
   for( colIdx = 0; colIdx < m_numExpTileCols; colIdx++ )
   {
-    CHECK(m_tileColWidth[colIdx] > remainingWidthInCtu,    "Tile column width exceeds picture width");
+    CHECK_VTM(m_tileColWidth[colIdx] > remainingWidthInCtu,    "Tile column width exceeds picture width");
     remainingWidthInCtu -= m_tileColWidth[colIdx];
   }
 
@@ -3060,7 +3060,7 @@ void PPS::initTiles()
   uint32_t  uniformTileColWidth = m_tileColWidth[colIdx-1];
   while( remainingWidthInCtu > 0 )
   {
-    CHECK(colIdx >= MAX_TILE_COLS, "Number of tile columns exceeds valid range");
+    CHECK_VTM(colIdx >= MAX_TILE_COLS, "Number of tile columns exceeds valid range");
     uniformTileColWidth = std::min(remainingWidthInCtu, uniformTileColWidth);
     m_tileColWidth.push_back( uniformTileColWidth );
     remainingWidthInCtu -= uniformTileColWidth;
@@ -3073,7 +3073,7 @@ void PPS::initTiles()
 
   for( rowIdx = 0; rowIdx < m_numExpTileRows; rowIdx++ )
   {
-    CHECK(m_tileRowHeight[rowIdx] > remainingHeightInCtu,     "Tile row height exceeds picture height");
+    CHECK_VTM(m_tileRowHeight[rowIdx] > remainingHeightInCtu,     "Tile row height exceeds picture height");
     remainingHeightInCtu -= m_tileRowHeight[rowIdx];
   }
 
@@ -3130,7 +3130,7 @@ void PPS::initTiles()
  */
 void PPS::initRectSlices()
 {
-  CHECK(m_numSlicesInPic > MAX_SLICES, "Number of slices in picture exceeds valid range");
+  CHECK_VTM(m_numSlicesInPic > MAX_SLICES, "Number of slices in picture exceeds valid range");
   m_rectSlices.resize(m_numSlicesInPic);
 }
 
@@ -3169,11 +3169,11 @@ void PPS::initRectSliceMap(const SPS  *sps)
 
   if( getSingleSlicePerSubPicFlag() )
   {
-    CHECK (sps==nullptr, "RectSliceMap can only be initialized for slice_per_sub_pic_flag with a valid SPS");
+    CHECK_VTM(sps==nullptr, "RectSliceMap can only be initialized for slice_per_sub_pic_flag with a valid SPS");
     m_numSlicesInPic = sps->getNumSubPics();
 
     // allocate new memory for slice list
-    CHECK(m_numSlicesInPic > MAX_SLICES, "Number of slices in picture exceeds valid range");
+    CHECK_VTM(m_numSlicesInPic > MAX_SLICES, "Number of slices in picture exceeds valid range");
     m_sliceMap.resize( m_numSlicesInPic );
 
     if (sps->getNumSubPics() > 1)
@@ -3207,7 +3207,7 @@ void PPS::initRectSliceMap(const SPS  *sps)
 
       for( int i = 0; i < m_numSlicesInPic; i++ )
       {
-        CHECK(m_numSlicesInPic != sps->getNumSubPics(), "in single slice per subpic mode, number of slice and subpic shall be equal");
+        CHECK_VTM(m_numSlicesInPic != sps->getNumSubPics(), "in single slice per subpic mode, number of slice and subpic shall be equal");
         m_sliceMap[ i ].initSliceMap();
         if (subpicHeightLessThanOneTileFlag[i])
         {
@@ -3248,7 +3248,7 @@ void PPS::initRectSliceMap(const SPS  *sps)
   else
   {
     // allocate new memory for slice list
-    CHECK(m_numSlicesInPic > MAX_SLICES, "Number of slices in picture exceeds valid range");
+    CHECK_VTM(m_numSlicesInPic > MAX_SLICES, "Number of slices in picture exceeds valid range");
     m_sliceMap.resize( m_numSlicesInPic );
     // generate CTU maps for all rectangular slices in picture
     for( uint32_t i = 0; i < m_numSlicesInPic; i++ )
@@ -3299,7 +3299,7 @@ void PPS::initRectSliceMap(const SPS  *sps)
         }
 
         // infer slice height for last slice in tile
-        CHECK( ctuY >= getTileRowBd( tileY + 1 ), "Invalid rectangular slice signalling");
+        CHECK_VTM( ctuY >= getTileRowBd( tileY + 1 ), "Invalid rectangular slice signalling");
         m_rectSlices[ i ].setSliceHeightInCtu( getTileRowBd( tileY + 1 ) - ctuY );
         m_sliceMap[ i ].addCtusToSlice( getTileColumnBd(tileX), getTileColumnBd(tileX+1),
                                         ctuY, getTileRowBd( tileY + 1 ), m_picWidthInCtu);
@@ -3318,7 +3318,7 @@ void PPS::initSubPic(const SPS &sps)
   if (getSubPicIdMappingInPpsFlag())
   {
     // When signalled, the number of subpictures has to match in PPS and SPS
-    CHECK (getNumSubPics() != sps.getNumSubPics(), "pps_num_subpics_minus1 shall be equal to sps_num_subpics_minus1");
+    CHECK_VTM(getNumSubPics() != sps.getNumSubPics(), "pps_num_subpics_minus1 shall be equal to sps_num_subpics_minus1");
   }
   else
   {
@@ -3326,21 +3326,21 @@ void PPS::initSubPic(const SPS &sps)
     setNumSubPics(sps.getNumSubPics());
   }
 
-  CHECK(getNumSubPics() > MAX_NUM_SUB_PICS, "Number of sub-pictures in picture exceeds valid range");
+  CHECK_VTM(getNumSubPics() > MAX_NUM_SUB_PICS, "Number of sub-pictures in picture exceeds valid range");
   m_subPics.resize(getNumSubPics());
 
   // Check that no subpicture is specified outside of the conformance cropping window
   for(int i = 0; i < sps.getNumSubPics(); i++)
   {
-    CHECK( (sps.getSubPicCtuTopLeftX(i) * sps.getCTUSize()) >=
+    CHECK_VTM( (sps.getSubPicCtuTopLeftX(i) * sps.getCTUSize()) >=
           (sps.getMaxPicWidthInLumaSamples() - sps.getConformanceWindow().getWindowRightOffset() * SPS::getWinUnitX(sps.getChromaFormatIdc())),
           "No subpicture can be located completely outside of the conformance cropping window");
-    CHECK( ((sps.getSubPicCtuTopLeftX(i) + sps.getSubPicWidth(i)) * sps.getCTUSize()) <= (sps.getConformanceWindow().getWindowLeftOffset() * SPS::getWinUnitX(sps.getChromaFormatIdc())),
+    CHECK_VTM( ((sps.getSubPicCtuTopLeftX(i) + sps.getSubPicWidth(i)) * sps.getCTUSize()) <= (sps.getConformanceWindow().getWindowLeftOffset() * SPS::getWinUnitX(sps.getChromaFormatIdc())),
           "No subpicture can be located completely outside of the conformance cropping window" );
-    CHECK( (sps.getSubPicCtuTopLeftY(i) * sps.getCTUSize()) >=
+    CHECK_VTM( (sps.getSubPicCtuTopLeftY(i) * sps.getCTUSize()) >=
           (sps.getMaxPicHeightInLumaSamples()  - sps.getConformanceWindow().getWindowBottomOffset() * SPS::getWinUnitY(sps.getChromaFormatIdc())),
           "No subpicture can be located completely outside of the conformance cropping window");
-    CHECK( ((sps.getSubPicCtuTopLeftY(i) + sps.getSubPicHeight(i)) * sps.getCTUSize()) <= (sps.getConformanceWindow().getWindowTopOffset() * SPS::getWinUnitY(sps.getChromaFormatIdc())),
+    CHECK_VTM( ((sps.getSubPicCtuTopLeftY(i) + sps.getSubPicHeight(i)) * sps.getCTUSize()) <= (sps.getConformanceWindow().getWindowTopOffset() * SPS::getWinUnitY(sps.getChromaFormatIdc())),
           "No subpicture can be located completely outside of the conformance cropping window");
   }
 
@@ -3400,7 +3400,7 @@ void PPS::initSubPic(const SPS &sps)
 
     if (m_numSlicesInPic == 1)
     {
-      CHECK(getNumSubPics() != 1, "only one slice in picture, but number of subpic is not one");
+      CHECK_VTM(getNumSubPics() != 1, "only one slice in picture, but number of subpic is not one");
       m_subPics[i].addAllCtusInPicToSubPic(0, getPicWidthInCtu(), 0, getPicHeightInCtu(), getPicWidthInCtu());
       m_subPics[i].setNumSlicesInSubPic(1);
     }
@@ -3429,7 +3429,7 @@ void PPS::initSubPic(const SPS &sps)
           idxFirstSliceAfterSubpic = j;
         }
       }
-      CHECK( idxFirstSliceAfterSubpic < idxLastSliceInSubpic, "The signalling order of slices shall follow the coding order" );
+      CHECK_VTM( idxFirstSliceAfterSubpic < idxLastSliceInSubpic, "The signalling order of slices shall follow the coding order" );
       m_subPics[i].setNumSlicesInSubPic(numSlicesInSubPic);
     }
     m_subPics[i].setTreatedAsPicFlag(sps.getSubPicTreatedAsPicFlag(i));
@@ -3473,7 +3473,7 @@ void PPS::initRasterSliceMap( std::vector<uint32_t> numTilesInSlice )
   setNumSlicesInPic( (uint32_t) numTilesInSlice.size() );
 
   // allocate new memory for slice list
-  CHECK(m_numSlicesInPic > MAX_SLICES, "Number of slices in picture exceeds valid range");
+  CHECK_VTM(m_numSlicesInPic > MAX_SLICES, "Number of slices in picture exceeds valid range");
   m_sliceMap.resize( m_numSlicesInPic );
 
   for( uint32_t sliceIdx = 0; sliceIdx < numTilesInSlice.size(); sliceIdx++ )
@@ -3485,7 +3485,7 @@ void PPS::initRasterSliceMap( std::vector<uint32_t> numTilesInSlice )
     {
       uint32_t tileX = tileIdx % getNumTileColumns();
       uint32_t tileY = tileIdx / getNumTileColumns();
-      CHECK(tileY >= getNumTileRows(), "Number of tiles in slice exceeds the remaining number of tiles in picture");
+      CHECK_VTM(tileY >= getNumTileRows(), "Number of tiles in slice exceeds the remaining number of tiles in picture");
 
       m_sliceMap[sliceIdx].addCtusToSlice(getTileColumnBd(tileX), getTileColumnBd(tileX + 1),
                                           getTileRowBd(tileY), getTileRowBd(tileY + 1),
@@ -3511,13 +3511,13 @@ void PPS::checkSliceMap()
     sliceList = m_sliceMap[ i ].getCtuAddrList();
     ctuList.insert( ctuList.end(), sliceList.begin(), sliceList.end() );
   }
-  CHECK( ctuList.size() < picSizeInCtu, "Slice map contains too few CTUs");
-  CHECK( ctuList.size() > picSizeInCtu, "Slice map contains too many CTUs");
+  CHECK_VTM( ctuList.size() < picSizeInCtu, "Slice map contains too few CTUs");
+  CHECK_VTM( ctuList.size() > picSizeInCtu, "Slice map contains too many CTUs");
   std::sort( ctuList.begin(), ctuList.end() );
   for( i = 1; i < ctuList.size(); i++ )
   {
-    CHECK( ctuList[i] > ctuList[i-1]+1, "CTU missing in slice map");
-    CHECK( ctuList[i] == ctuList[i-1],  "CTU duplicated in slice map");
+    CHECK_VTM( ctuList[i] > ctuList[i-1]+1, "CTU missing in slice map");
+    CHECK_VTM( ctuList[i] == ctuList[i-1],  "CTU duplicated in slice map");
   }
 }
 
@@ -3693,7 +3693,7 @@ int ScalingList::lengthUvlc(int uiCode)
   int uiLength = 1;
   int uiTemp = ++uiCode;
 
-  CHECK(!uiTemp, "Integer overflow");
+  CHECK_VTM(!uiTemp, "Integer overflow");
 
   while (1 != uiTemp)
   {
@@ -3708,7 +3708,7 @@ int ScalingList::lengthSvlc(int uiCode)
   int uiLength = 1;
   int uiTemp = ++uiCode2;
 
-  CHECK(!uiTemp, "Integer overflow");
+  CHECK_VTM(!uiTemp, "Integer overflow");
 
   while (1 != uiTemp)
   {
@@ -4172,7 +4172,7 @@ void Slice::scaleRefPicList( Picture *scaledRefPic[ ], PicHeader *picHeader, APS
       CU::getRprScaling( sps, pps, m_apcRefPicList[refList][rIdx], xScale, yScale );
       m_scalingRatio[refList][rIdx] = std::pair<int, int>( xScale, yScale );
 
-      CHECK( m_apcRefPicList[refList][rIdx]->unscaledPic == nullptr, "unscaledPic is not properly set" );
+      CHECK_VTM( m_apcRefPicList[refList][rIdx]->unscaledPic == nullptr, "unscaledPic is not properly set" );
 
       if( m_apcRefPicList[refList][rIdx]->isRefScaled( pps ) == false )
       {
@@ -4209,7 +4209,7 @@ void Slice::scaleRefPicList( Picture *scaledRefPic[ ], PicHeader *picHeader, APS
             }
           }
 
-          CHECK( j >= MAX_NUM_REF, "scaledRefPic can not hold all reference pictures!" );
+          CHECK_VTM( j >= MAX_NUM_REF, "scaledRefPic can not hold all reference pictures!" );
 
           if( j >= MAX_NUM_REF )
           {
@@ -4275,7 +4275,7 @@ void Slice::scaleRefPicList( Picture *scaledRefPic[ ], PicHeader *picHeader, APS
   //Make sure that TMVP is disabled when there are no reference pictures with the same resolution
   if(!refPicIsSameRes)
   {
-    CHECK(getPicHeader()->getEnableTMVPFlag() != 0, "TMVP cannot be enabled in pictures that have no reference pictures with the same resolution")
+    CHECK_VTM(getPicHeader()->getEnableTMVPFlag() != 0, "TMVP cannot be enabled in pictures that have no reference pictures with the same resolution")
   }
 }
 
@@ -4418,7 +4418,7 @@ bool             operator != (const ProfileTierLevel& op1, const ProfileTierLeve
 
 bool Slice::isLastSliceInSubpic()
 {
-  CHECK(m_pcPPS == NULL, "PPS pointer not initialized");
+  CHECK_VTM(m_pcPPS == NULL, "PPS pointer not initialized");
 
   int lastCTUAddrInSlice = m_sliceMap.getCtuAddrList().back();
 
diff --git a/source/Lib/CommonLib/Slice.h b/source/Lib/CommonLib/Slice.h
index 37f7385..42b282e 100644
--- a/source/Lib/CommonLib/Slice.h
+++ b/source/Lib/CommonLib/Slice.h
@@ -736,7 +736,8 @@ public:
   void                   setNumCtuInSlice( uint32_t u )       { m_numCtuInSlice = u;      }
   uint32_t               getNumCtuInSlice() const             { return m_numCtuInSlice;   }
   std::vector<uint32_t>  getCtuAddrList( ) const              { return m_ctuAddrInSlice;  }
-  uint32_t               getCtuAddrInSlice( int idx ) const   { CHECK(idx >= m_ctuAddrInSlice.size(), "CTU index exceeds number of CTUs in slice."); return m_ctuAddrInSlice[idx]; }
+  uint32_t               getCtuAddrInSlice( int idx ) const   {
+    CHECK_VTM(idx >= m_ctuAddrInSlice.size(), "CTU index exceeds number of CTUs in slice."); return m_ctuAddrInSlice[idx]; }
   void                   pushToCtuAddrInSlice( uint32_t u )   { m_ctuAddrInSlice.push_back(u); m_numCtuInSlice++;}
 
   void  initSliceMap()
@@ -749,7 +750,7 @@ public:
 
   void  addCtusToSlice( uint32_t startX, uint32_t stopX, uint32_t startY, uint32_t stopY, uint32_t picWidthInCtbsY )
   {
-    CHECK( startX >= stopX || startY >= stopY, "Invalid slice definition");
+    CHECK_VTM( startX >= stopX || startY >= stopY, "Invalid slice definition");
     for( uint32_t ctbY = startY; ctbY < stopY; ctbY++ )
     {
       for( uint32_t ctbX = startX; ctbX < stopX; ctbX++ )
@@ -856,7 +857,7 @@ public:
   }
   void  addAllCtusInPicToSubPic(uint32_t startX, uint32_t stopX, uint32_t startY, uint32_t stopY, uint32_t picWidthInCtbsY)
   {
-    CHECK(startX >= stopX || startY >= stopY, "Invalid slice definition");
+    CHECK_VTM(startX >= stopX || startY >= stopY, "Invalid slice definition");
     for (uint32_t ctbY = startY; ctbY < stopY; ctbY++)
     {
       for (uint32_t ctbX = startX; ctbX < stopX; ctbX++)
@@ -1498,8 +1499,10 @@ public:
   ChromaFormat            getChromaFormatIdc () const                                                     { return m_chromaFormatIdc;                                            }
   void                    setChromaFormatIdc (ChromaFormat i)                                             { m_chromaFormatIdc = i;                                               }
 
-  static int              getWinUnitX (int chromaFormatIdc)                                               { CHECK(chromaFormatIdc < 0 || chromaFormatIdc >= NUM_CHROMA_FORMAT, "Invalid chroma format parameter"); return m_winUnitX[chromaFormatIdc]; }
-  static int              getWinUnitY (int chromaFormatIdc)                                               { CHECK(chromaFormatIdc < 0 || chromaFormatIdc >= NUM_CHROMA_FORMAT, "Invalid chroma format parameter"); return m_winUnitY[chromaFormatIdc]; }
+  static int              getWinUnitX (int chromaFormatIdc)                                               {
+    CHECK_VTM(chromaFormatIdc < 0 || chromaFormatIdc >= NUM_CHROMA_FORMAT, "Invalid chroma format parameter"); return m_winUnitX[chromaFormatIdc]; }
+  static int              getWinUnitY (int chromaFormatIdc)                                               {
+    CHECK_VTM(chromaFormatIdc < 0 || chromaFormatIdc >= NUM_CHROMA_FORMAT, "Invalid chroma format parameter"); return m_winUnitY[chromaFormatIdc]; }
 
   // structure
   void                    setMaxPicWidthInLumaSamples( uint32_t u )                                       { m_maxWidthInLumaSamples = u; }
@@ -1513,7 +1516,8 @@ public:
   void      setSubPicInfoPresentFlag(bool b)                                                { m_subPicInfoPresentFlag = b;            }
   bool      getSubPicInfoPresentFlag() const                                                { return m_subPicInfoPresentFlag;         }
 
-  void      setNumSubPics( uint32_t u )                                                     { CHECK( u >= MAX_NUM_SUB_PICS, "Maximum number of subpictures exceeded" );
+  void      setNumSubPics( uint32_t u )                                                     {
+    CHECK_VTM( u >= MAX_NUM_SUB_PICS, "Maximum number of subpictures exceeded" );
                                                                                               m_numSubPics = u;
                                                                                               m_subPicCtuTopLeftX.resize(m_numSubPics);
                                                                                               m_subPicCtuTopLeftY.resize(m_numSubPics);
@@ -1541,12 +1545,18 @@ public:
   void      setLoopFilterAcrossSubpicEnabledFlag( int i, bool u )                           { m_loopFilterAcrossSubpicEnabledFlag[i] = u;     }
   bool      getLoopFilterAcrossSubpicEnabledFlag( int i ) const                             { return  m_loopFilterAcrossSubpicEnabledFlag[i]; }
 
-  void      setSubPicCtuTopLeftX                        (const std::vector<uint32_t> &v)   { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicCtuTopLeftX = v; }
-  void      setSubPicCtuTopLeftY                        (const std::vector<uint32_t> &v)   { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicCtuTopLeftY = v; }
-  void      setSubPicWidth                              (const std::vector<uint32_t> &v)   { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicWidth = v; }
-  void      setSubPicHeight                             (const std::vector<uint32_t> &v)   { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicHeight = v; }
-  void      setSubPicTreatedAsPicFlag                   (const std::vector<bool> &v)       { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicTreatedAsPicFlag = v; }
-  void      setLoopFilterAcrossSubpicEnabledFlag        (const std::vector<bool> &v)       { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_loopFilterAcrossSubpicEnabledFlag = v; }
+  void      setSubPicCtuTopLeftX                        (const std::vector<uint32_t> &v)   {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicCtuTopLeftX = v; }
+  void      setSubPicCtuTopLeftY                        (const std::vector<uint32_t> &v)   {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicCtuTopLeftY = v; }
+  void      setSubPicWidth                              (const std::vector<uint32_t> &v)   {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicWidth = v; }
+  void      setSubPicHeight                             (const std::vector<uint32_t> &v)   {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicHeight = v; }
+  void      setSubPicTreatedAsPicFlag                   (const std::vector<bool> &v)       {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicTreatedAsPicFlag = v; }
+  void      setLoopFilterAcrossSubpicEnabledFlag        (const std::vector<bool> &v)       {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_loopFilterAcrossSubpicEnabledFlag = v; }
 
   bool       getDisableScalingMatrixForLfnstBlks() const { return m_disableScalingMatrixForLfnstBlks; }
   void       setDisableScalingMatrixForLfnstBlks(bool flag) { m_disableScalingMatrixForLfnstBlks = flag; }
@@ -1559,17 +1569,22 @@ public:
   uint32_t                getSubPicIdLen() const                                                          { return  m_subPicIdLen;                   }
   void                    setSubPicId( int i, uint16_t u )                                                { m_subPicId[i] = u;     }
   uint16_t                getSubPicId( int i ) const                                                      { return  m_subPicId[i]; }
-  void                    setSubPicId(const std::vector<uint16_t> &v)                                     { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ; m_subPicId = v; }
+  void                    setSubPicId(const std::vector<uint16_t> &v)                                     {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ; m_subPicId = v; }
   const std::vector<uint16_t> getSubPicIds() const                                                        { return  m_subPicId; }
 
   uint32_t                getNumLongTermRefPicSPS() const                                                 { return m_numLongTermRefPicSPS;                                       }
   void                    setNumLongTermRefPicSPS(uint32_t val)                                           { m_numLongTermRefPicSPS = val;                                        }
 
-  uint32_t                getLtRefPicPocLsbSps(uint32_t index) const                                      { CHECK( index >= MAX_NUM_LONG_TERM_REF_PICS, "Index exceeds boundary" ); return m_ltRefPicPocLsbSps[index]; }
-  void                    setLtRefPicPocLsbSps(uint32_t index, uint32_t val)                              { CHECK( index >= MAX_NUM_LONG_TERM_REF_PICS, "Index exceeds boundary" ); m_ltRefPicPocLsbSps[index] = val;  }
+  uint32_t                getLtRefPicPocLsbSps(uint32_t index) const                                      {
+    CHECK_VTM( index >= MAX_NUM_LONG_TERM_REF_PICS, "Index exceeds boundary" ); return m_ltRefPicPocLsbSps[index]; }
+  void                    setLtRefPicPocLsbSps(uint32_t index, uint32_t val)                              {
+    CHECK_VTM( index >= MAX_NUM_LONG_TERM_REF_PICS, "Index exceeds boundary" ); m_ltRefPicPocLsbSps[index] = val;  }
 
-  bool                    getUsedByCurrPicLtSPSFlag(int i) const                                          { CHECK( i >= MAX_NUM_LONG_TERM_REF_PICS, "Index exceeds boundary" ); return m_usedByCurrPicLtSPSFlag[i];    }
-  void                    setUsedByCurrPicLtSPSFlag(int i, bool x)                                        { CHECK( i >= MAX_NUM_LONG_TERM_REF_PICS, "Index exceeds boundary" ); m_usedByCurrPicLtSPSFlag[i] = x;       }
+  bool                    getUsedByCurrPicLtSPSFlag(int i) const                                          {
+    CHECK_VTM( i >= MAX_NUM_LONG_TERM_REF_PICS, "Index exceeds boundary" ); return m_usedByCurrPicLtSPSFlag[i];    }
+  void                    setUsedByCurrPicLtSPSFlag(int i, bool x)                                        {
+    CHECK_VTM( i >= MAX_NUM_LONG_TERM_REF_PICS, "Index exceeds boundary" ); m_usedByCurrPicLtSPSFlag[i] = x;       }
 
   int                     getLog2MinCodingBlockSize() const                                               { return m_log2MinCodingBlockSize;                                     }
   void                    setLog2MinCodingBlockSize(int val)                                              { m_log2MinCodingBlockSize = val;                                      }
@@ -1708,7 +1723,8 @@ void                    setCCALFEnabledFlag( bool b )
   bool                    getProfControlPresentInPhFlag()const                                            { return m_ProfControlPresentInPhFlag; }
   void                    setProfControlPresentInPhFlag(bool b)                                           { m_ProfControlPresentInPhFlag = b;    }
   uint32_t                getMaxTLayers() const                                                           { return m_uiMaxTLayers; }
-  void                    setMaxTLayers( uint32_t uiMaxTLayers )                                          { CHECK( uiMaxTLayers > MAX_TLAYER, "Invalid number T-layers" ); m_uiMaxTLayers = uiMaxTLayers; }
+  void                    setMaxTLayers( uint32_t uiMaxTLayers )                                          {
+    CHECK_VTM( uiMaxTLayers > MAX_TLAYER, "Invalid number T-layers" ); m_uiMaxTLayers = uiMaxTLayers; }
 
   bool                    getPtlDpbHrdParamsPresentFlag()  const                                          { return m_ptlDpbHrdParamsPresentFlag;     }
   void                    setPtlDpbHrdParamsPresentFlag(bool b)                                           {        m_ptlDpbHrdParamsPresentFlag = b; }
@@ -1731,12 +1747,17 @@ void                    setCCALFEnabledFlag( bool b )
   unsigned                getNumVerVirtualBoundaries() const                                              { return m_numVerVirtualBoundaries;                                    }
   void                    setNumHorVirtualBoundaries(unsigned u)                                          { m_numHorVirtualBoundaries = u;                                       }
   unsigned                getNumHorVirtualBoundaries() const                                              { return m_numHorVirtualBoundaries;                                    }
-  void                    setVirtualBoundariesPosX(unsigned u, unsigned idx)                              { CHECK( idx >= 3, "vitrual boundary index exceeds valid range" ); m_virtualBoundariesPosX[idx] = u;    }
-  unsigned                getVirtualBoundariesPosX(unsigned idx) const                                    { CHECK( idx >= 3, "vitrual boundary index exceeds valid range" ); return m_virtualBoundariesPosX[idx]; }
-  void                    setVirtualBoundariesPosY(unsigned u, unsigned idx)                              { CHECK( idx >= 3, "vitrual boundary index exceeds valid range" ); m_virtualBoundariesPosY[idx] = u;    }
-  unsigned                getVirtualBoundariesPosY(unsigned idx) const                                    { CHECK( idx >= 3, "vitrual boundary index exceeds valid range" ); return m_virtualBoundariesPosY[idx]; }
+  void                    setVirtualBoundariesPosX(unsigned u, unsigned idx)                              {
+    CHECK_VTM( idx >= 3, "vitrual boundary index exceeds valid range" ); m_virtualBoundariesPosX[idx] = u;    }
+  unsigned                getVirtualBoundariesPosX(unsigned idx) const                                    {
+    CHECK_VTM( idx >= 3, "vitrual boundary index exceeds valid range" ); return m_virtualBoundariesPosX[idx]; }
+  void                    setVirtualBoundariesPosY(unsigned u, unsigned idx)                              {
+    CHECK_VTM( idx >= 3, "vitrual boundary index exceeds valid range" ); m_virtualBoundariesPosY[idx] = u;    }
+  unsigned                getVirtualBoundariesPosY(unsigned idx) const                                    {
+    CHECK_VTM( idx >= 3, "vitrual boundary index exceeds valid range" ); return m_virtualBoundariesPosY[idx]; }
   uint32_t                getMaxDecPicBuffering(uint32_t tlayer) const                                    { return m_uiMaxDecPicBuffering[tlayer];                               }
-  void                    setMaxDecPicBuffering( uint32_t ui, uint32_t tlayer )                           { CHECK(tlayer >= MAX_TLAYER, "Invalid T-layer"); m_uiMaxDecPicBuffering[tlayer] = ui;    }
+  void                    setMaxDecPicBuffering( uint32_t ui, uint32_t tlayer )                           {
+    CHECK_VTM(tlayer >= MAX_TLAYER, "Invalid T-layer"); m_uiMaxDecPicBuffering[tlayer] = ui;    }
   uint32_t                getMaxLatencyIncreasePlus1(uint32_t tlayer) const                               { return m_uiMaxLatencyIncreasePlus1[tlayer];                          }
   void                    setMaxLatencyIncreasePlus1( uint32_t ui , uint32_t tlayer)                      { m_uiMaxLatencyIncreasePlus1[tlayer] = ui;                            }
   uint32_t                getMaxNumMergeCand() const { return m_maxNumMergeCand; }
@@ -2026,13 +2047,13 @@ public:
 
   const ChromaQpAdj&     getChromaQpOffsetListEntry( int cuChromaQpOffsetIdxPlus1 ) const
   {
-    CHECK(cuChromaQpOffsetIdxPlus1 >= m_chromaQpOffsetListLen+1, "Invalid chroma QP offset");
+    CHECK_VTM(cuChromaQpOffsetIdxPlus1 >= m_chromaQpOffsetListLen+1, "Invalid chroma QP offset");
     return m_ChromaQpAdjTableIncludingNullEntry[cuChromaQpOffsetIdxPlus1]; // Array includes entry [0] for the null offset used when cu_chroma_qp_offset_flag=0, and entries [cu_chroma_qp_offset_idx+1...] otherwise
   }
 
   void                   setChromaQpOffsetListEntry( int cuChromaQpOffsetIdxPlus1, int cbOffset, int crOffset, int jointCbCrOffset )
   {
-    CHECK(cuChromaQpOffsetIdxPlus1 == 0 || cuChromaQpOffsetIdxPlus1 > MAX_QP_OFFSET_LIST_SIZE, "Invalid chroma QP offset");
+    CHECK_VTM(cuChromaQpOffsetIdxPlus1 == 0 || cuChromaQpOffsetIdxPlus1 > MAX_QP_OFFSET_LIST_SIZE, "Invalid chroma QP offset");
     m_ChromaQpAdjTableIncludingNullEntry[cuChromaQpOffsetIdxPlus1].u.comp.CbOffset = cbOffset; // Array includes entry [0] for the null offset used when cu_chroma_qp_offset_flag=0, and entries [cu_chroma_qp_offset_idx+1...] otherwise
     m_ChromaQpAdjTableIncludingNullEntry[cuChromaQpOffsetIdxPlus1].u.comp.CrOffset = crOffset;
     m_ChromaQpAdjTableIncludingNullEntry[cuChromaQpOffsetIdxPlus1].u.comp.JointCbCrOffset = jointCbCrOffset;
@@ -2060,7 +2081,8 @@ public:
   unsigned               getWrapAroundOffset() const                                      { return m_wrapAroundOffset;                    }
   void                   setOutputFlagPresentFlag( bool b )                               { m_OutputFlagPresentFlag = b;                  }
   bool                   getOutputFlagPresentFlag() const                                 { return m_OutputFlagPresentFlag;               }
-  void                   setNumSubPics(uint32_t u )                                       { CHECK( u >= MAX_NUM_SUB_PICS, "Maximum number of subpictures exceeded" );
+  void                   setNumSubPics(uint32_t u )                                       {
+    CHECK_VTM( u >= MAX_NUM_SUB_PICS, "Maximum number of subpictures exceeded" );
                                                                                             m_numSubPics = u;
                                                                                             m_subPicId.resize(m_numSubPics);
                                                                                           }
@@ -2070,7 +2092,8 @@ public:
   void                   setSubPicIdLen( uint32_t u )                                     { m_subPicIdLen = u;                            }
   uint32_t               getSubPicIdLen() const                                           { return  m_subPicIdLen;                        }
   void                   setSubPicId( int i, uint16_t u )                                 { m_subPicId[i] = u;     }
-  void                   setSubPicId(const std::vector<uint16_t> &v)                      { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ; m_subPicId = v; }
+  void                   setSubPicId(const std::vector<uint16_t> &v)                      {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ; m_subPicId = v; }
   uint16_t               getSubPicId( int i ) const                                       { return  m_subPicId[i]; }
   const std::vector<uint16_t> getSubPicIds() const                                        { return  m_subPicId; }
   uint32_t               getSubPicIdxFromSubPicId( uint32_t subPicId ) const;
@@ -2094,14 +2117,21 @@ public:
   uint32_t               getNumTiles( ) const                                             { return  m_numTileCols * m_numTileRows;        }
   void                   setTileColumnWidths( std::vector<uint32_t> widths )              { m_tileColWidth = widths;                      }
   void                   setTileRowHeights( std::vector<uint32_t> heights )               { m_tileRowHeight = heights;                    }
-  void                   addTileColumnWidth( uint32_t u )                                 { CHECK( m_tileColWidth.size()  >= MAX_TILE_COLS, "Number of tile columns exceeds valid range" ); m_tileColWidth.push_back(u);    }
+  void                   addTileColumnWidth( uint32_t u )                                 {
+    CHECK_VTM( m_tileColWidth.size()  >= MAX_TILE_COLS, "Number of tile columns exceeds valid range" ); m_tileColWidth.push_back(u);    }
   void                   addTileRowHeight( uint32_t u )                                   { m_tileRowHeight.push_back(u);   }
-  uint32_t               getTileColumnWidth( int idx ) const                              { CHECK( idx >= m_tileColWidth.size(), "Tile column index exceeds valid range" );                 return  m_tileColWidth[idx];    }
-  uint32_t               getTileRowHeight( int idx ) const                                { CHECK( idx >= m_tileRowHeight.size(), "Tile row index exceeds valid range" );                   return  m_tileRowHeight[idx];   }
-  uint32_t               getTileColumnBd( int idx ) const                                 { CHECK( idx >= m_tileColBd.size(), "Tile column index exceeds valid range" );                    return  m_tileColBd[idx];       }
-  uint32_t               getTileRowBd( int idx ) const                                    { CHECK( idx >= m_tileRowBd.size(), "Tile row index exceeds valid range" );                       return  m_tileRowBd[idx];       }
-  uint32_t               ctuToTileCol( int ctuX ) const                                   { CHECK( ctuX >= m_ctuToTileCol.size(), "CTU address index exceeds valid range" ); return  m_ctuToTileCol[ctuX];                  }
-  uint32_t               ctuToTileRow( int ctuY ) const                                   { CHECK( ctuY >= m_ctuToTileRow.size(), "CTU address index exceeds valid range" ); return  m_ctuToTileRow[ctuY];                  }
+  uint32_t               getTileColumnWidth( int idx ) const                              {
+    CHECK_VTM( idx >= m_tileColWidth.size(), "Tile column index exceeds valid range" );                 return  m_tileColWidth[idx];    }
+  uint32_t               getTileRowHeight( int idx ) const                                {
+    CHECK_VTM( idx >= m_tileRowHeight.size(), "Tile row index exceeds valid range" );                   return  m_tileRowHeight[idx];   }
+  uint32_t               getTileColumnBd( int idx ) const                                 {
+    CHECK_VTM( idx >= m_tileColBd.size(), "Tile column index exceeds valid range" );                    return  m_tileColBd[idx];       }
+  uint32_t               getTileRowBd( int idx ) const                                    {
+    CHECK_VTM( idx >= m_tileRowBd.size(), "Tile row index exceeds valid range" );                       return  m_tileRowBd[idx];       }
+  uint32_t               ctuToTileCol( int ctuX ) const                                   {
+    CHECK_VTM( ctuX >= m_ctuToTileCol.size(), "CTU address index exceeds valid range" ); return  m_ctuToTileCol[ctuX];                  }
+  uint32_t               ctuToTileRow( int ctuY ) const                                   {
+    CHECK_VTM( ctuY >= m_ctuToTileRow.size(), "CTU address index exceeds valid range" ); return  m_ctuToTileRow[ctuY];                  }
   uint32_t               ctuToTileColBd( int ctuX ) const                                 { return  getTileColumnBd(ctuToTileCol( ctuX ));                                                                                  }
   uint32_t               ctuToTileRowBd( int ctuY ) const                                 { return  getTileRowBd(ctuToTileRow( ctuY ));                                                                                     }
   bool                   ctuIsTileColBd( int ctuX ) const                                 { return  ctuX == ctuToTileColBd( ctuX );                                                                                         }
@@ -2113,21 +2143,34 @@ public:
   bool                   getRectSliceFlag( ) const                                        { return  m_rectSliceFlag;                                                                                                        }
   void                   setSingleSlicePerSubPicFlag( bool b )                            { m_singleSlicePerSubPicFlag = b;                                                                                                 }
   bool                   getSingleSlicePerSubPicFlag( ) const                             { return  m_singleSlicePerSubPicFlag;                                                                                             }
-  uint32_t               getCtuToSubPicIdx( int idx ) const                               { CHECK( idx >= m_ctuToSubPicIdx.size(), "CTU address index exceeds valid range" ); CHECK( getNumSubPics() < 1, "Number of subpicture cannot be 0" ); return  m_ctuToSubPicIdx[ idx ]; }
-  void                   setNumSlicesInPic( uint32_t u )                                  { CHECK( u > MAX_SLICES, "Number of slices in picture exceeds valid range" ); m_numSlicesInPic = u;                               }
+  uint32_t               getCtuToSubPicIdx( int idx ) const                               {
+    CHECK_VTM( idx >= m_ctuToSubPicIdx.size(), "CTU address index exceeds valid range" );
+    CHECK_VTM( getNumSubPics() < 1, "Number of subpicture cannot be 0" ); return  m_ctuToSubPicIdx[ idx ]; }
+  void                   setNumSlicesInPic( uint32_t u )                                  {
+    CHECK_VTM( u > MAX_SLICES, "Number of slices in picture exceeds valid range" ); m_numSlicesInPic = u;                               }
   uint32_t               getNumSlicesInPic( ) const                                       { return  m_numSlicesInPic;                                                                                                       }
   void                   setTileIdxDeltaPresentFlag( bool b )                             { m_tileIdxDeltaPresentFlag = b;                                                                                                  }
   bool                   getTileIdxDeltaPresentFlag( ) const                              { return  m_tileIdxDeltaPresentFlag;                                                                                              }
-  void                   setSliceWidthInTiles( int idx, uint32_t u )                      { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setSliceWidthInTiles( u );            }
-  uint32_t               getSliceWidthInTiles( int idx ) const                            { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getSliceWidthInTiles( );      }
-  void                   setSliceHeightInTiles( int idx, uint32_t u )                     { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setSliceHeightInTiles( u );           }
-  uint32_t               getSliceHeightInTiles( int idx ) const                           { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getSliceHeightInTiles( );     }
-  void                   setNumSlicesInTile( int idx, uint32_t u )                        { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setNumSlicesInTile( u );              }
-  uint32_t               getNumSlicesInTile( int idx ) const                              { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getNumSlicesInTile( );        }
-  void                   setSliceHeightInCtu( int idx, uint32_t u )                       { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setSliceHeightInCtu( u );             }
-  uint32_t               getSliceHeightInCtu( int idx ) const                             { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getSliceHeightInCtu( );       }
-  void                   setSliceTileIdx(  int idx, uint32_t u )                          { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setTileIdx( u );                      }
-  uint32_t               getSliceTileIdx( int idx ) const                                 { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getTileIdx( );                }
+  void                   setSliceWidthInTiles( int idx, uint32_t u )                      {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setSliceWidthInTiles( u );            }
+  uint32_t               getSliceWidthInTiles( int idx ) const                            {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getSliceWidthInTiles( );      }
+  void                   setSliceHeightInTiles( int idx, uint32_t u )                     {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setSliceHeightInTiles( u );           }
+  uint32_t               getSliceHeightInTiles( int idx ) const                           {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getSliceHeightInTiles( );     }
+  void                   setNumSlicesInTile( int idx, uint32_t u )                        {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setNumSlicesInTile( u );              }
+  uint32_t               getNumSlicesInTile( int idx ) const                              {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getNumSlicesInTile( );        }
+  void                   setSliceHeightInCtu( int idx, uint32_t u )                       {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setSliceHeightInCtu( u );             }
+  uint32_t               getSliceHeightInCtu( int idx ) const                             {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getSliceHeightInCtu( );       }
+  void                   setSliceTileIdx(  int idx, uint32_t u )                          {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setTileIdx( u );                      }
+  uint32_t               getSliceTileIdx( int idx ) const                                 {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getTileIdx( );                }
   void                   setRectSlices( std::vector<RectSlice> rectSlices )               { m_rectSlices = rectSlices;                                                                                                      }
   void                   setLoopFilterAcrossTilesEnabledFlag( bool b )                    { m_loopFilterAcrossTilesEnabledFlag = b;                                                                                         }
   bool                   getLoopFilterAcrossTilesEnabledFlag( ) const                     { return  m_loopFilterAcrossTilesEnabledFlag;                                                                                     }
@@ -2144,7 +2187,8 @@ public:
   const SubPic&          getSubPicFromCU (const CodingUnit& cu) const;
   void                   initRasterSliceMap( std::vector<uint32_t> sizes );
   void                   checkSliceMap();
-  SliceMap               getSliceMap( int idx ) const                                     { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return m_sliceMap[idx];                             }
+  SliceMap               getSliceMap( int idx ) const                                     {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return m_sliceMap[idx];                             }
 
 
 
@@ -2394,10 +2438,14 @@ public:
   unsigned                    getNumVerVirtualBoundaries() const                        { return m_numVerVirtualBoundaries;                                                            }
   void                        setNumHorVirtualBoundaries(unsigned u)                    { m_numHorVirtualBoundaries = u;                                                               }
   unsigned                    getNumHorVirtualBoundaries() const                        { return m_numHorVirtualBoundaries;                                                            }
-  void                        setVirtualBoundariesPosX(unsigned u, unsigned idx)        { CHECK( idx >= 3, "boundary index exceeds valid range" ); m_virtualBoundariesPosX[idx] = u;   }
-  unsigned                    getVirtualBoundariesPosX(unsigned idx) const              { CHECK( idx >= 3, "boundary index exceeds valid range" ); return m_virtualBoundariesPosX[idx];}
-  void                        setVirtualBoundariesPosY(unsigned u, unsigned idx)        { CHECK( idx >= 3, "boundary index exceeds valid range" ); m_virtualBoundariesPosY[idx] = u;   }
-  unsigned                    getVirtualBoundariesPosY(unsigned idx) const              { CHECK( idx >= 3, "boundary index exceeds valid range" ); return m_virtualBoundariesPosY[idx];}
+  void                        setVirtualBoundariesPosX(unsigned u, unsigned idx)        {
+    CHECK_VTM( idx >= 3, "boundary index exceeds valid range" ); m_virtualBoundariesPosX[idx] = u;   }
+  unsigned                    getVirtualBoundariesPosX(unsigned idx) const              {
+    CHECK_VTM( idx >= 3, "boundary index exceeds valid range" ); return m_virtualBoundariesPosX[idx];}
+  void                        setVirtualBoundariesPosY(unsigned u, unsigned idx)        {
+    CHECK_VTM( idx >= 3, "boundary index exceeds valid range" ); m_virtualBoundariesPosY[idx] = u;   }
+  unsigned                    getVirtualBoundariesPosY(unsigned idx) const              {
+    CHECK_VTM( idx >= 3, "boundary index exceeds valid range" ); return m_virtualBoundariesPosY[idx];}
   void                        setPicOutputFlag( bool b )                                { m_picOutputFlag = b;                                                                         }
   bool                        getPicOutputFlag() const                                  { return m_picOutputFlag;                                                                      }
   ReferencePictureList*       getRPL( bool b )                                          { return (b==1) ? getRPL1() : getRPL0();                                                       }
@@ -2829,7 +2877,7 @@ public:
   void                        initEqualRef();
   bool                        isEqualRef( RefPicList e, int iRefIdx1, int iRefIdx2 )
   {
-    CHECK(e>=NUM_REF_PIC_LIST_01, "Invalid reference picture list");
+    CHECK_VTM(e>=NUM_REF_PIC_LIST_01, "Invalid reference picture list");
     if (iRefIdx1 < 0 || iRefIdx2 < 0)
     {
       return false;
@@ -2842,7 +2890,7 @@ public:
 
   void                        setEqualRef( RefPicList e, int iRefIdx1, int iRefIdx2, bool b)
   {
-    CHECK( e >= NUM_REF_PIC_LIST_01, "Invalid reference picture list" );
+    CHECK_VTM( e >= NUM_REF_PIC_LIST_01, "Invalid reference picture list" );
     m_abEqualRef[e][iRefIdx1][iRefIdx2] = m_abEqualRef[e][iRefIdx2][iRefIdx1] = b;
   }
 
@@ -2906,7 +2954,8 @@ public:
   void                        clearSubstreamSizes( )                                 { return m_substreamSizes.clear();                              }
   uint32_t                        getNumberOfSubstreamSizes( )                           { return (uint32_t) m_substreamSizes.size();                        }
   void                        addSubstreamSize( uint32_t size )                          { m_substreamSizes.push_back(size);                             }
-  uint32_t                        getSubstreamSize( uint32_t idx )                           { CHECK(idx>=getNumberOfSubstreamSizes(),"Invalid index"); return m_substreamSizes[idx]; }
+  uint32_t                        getSubstreamSize( uint32_t idx )                           {
+    CHECK_VTM(idx>=getNumberOfSubstreamSizes(),"Invalid index"); return m_substreamSizes[idx]; }
   void                        resetNumberOfSubstream()                               { m_numSubstream = 0;                                           }
   uint32_t                    getNumberOfSubstream()                                 { return (uint32_t) m_numSubstream;                             }
   void                        increaseNumberOfSubstream()                            { m_numSubstream++;                                             }
@@ -2966,7 +3015,8 @@ public:
   void                        scaleRefPicList( Picture *scaledRefPic[ ], PicHeader *picHeader, APS** apss, APS* lmcsAps, APS* scalingListAps, const bool isDecoder );
   void                        freeScaledRefPicList( Picture *scaledRefPic[] );
   bool                        checkRPR();
-  const std::pair<int, int>&  getScalingRatio( const RefPicList refPicList, const int refIdx )  const { CHECK( refIdx < 0, "Invalid reference index" ); return m_scalingRatio[refPicList][refIdx]; }
+  const std::pair<int, int>&  getScalingRatio( const RefPicList refPicList, const int refIdx )  const {
+    CHECK_VTM( refIdx < 0, "Invalid reference index" ); return m_scalingRatio[refPicList][refIdx]; }
   void                        setNumSubstream( const SPS *sps, const PPS *pps );
   void                        setNumEntryPoints( const SPS *sps, const PPS *pps );
   uint32_t                    getNumEntryPoints( ) const { return m_numEntryPoints;  }
diff --git a/source/Lib/CommonLib/TrQuant.cpp b/source/Lib/CommonLib/TrQuant.cpp
index 6a7fbf4..b2081b7 100644
--- a/source/Lib/CommonLib/TrQuant.cpp
+++ b/source/Lib/CommonLib/TrQuant.cpp
@@ -340,7 +340,7 @@ void TrQuant::xInvLfnst( const TransformUnit &tu, const ComponentID compID )
     {
       intraMode = PLANAR_IDX;
     }
-    CHECK( intraMode >= NUM_INTRA_MODE - 1, "Invalid intra mode" );
+    CHECK_VTM( intraMode >= NUM_INTRA_MODE - 1, "Invalid intra mode" );
 
     if( lfnstIdx < 3 )
     {
@@ -438,7 +438,7 @@ void TrQuant::xFwdLfnst( const TransformUnit &tu, const ComponentID compID, cons
     {
       intraMode = PLANAR_IDX;
     }
-    CHECK( intraMode >= NUM_INTRA_MODE - 1, "Invalid intra mode" );
+    CHECK_VTM( intraMode >= NUM_INTRA_MODE - 1, "Invalid intra mode" );
 
     if( lfnstIdx < 3 )
     {
@@ -526,7 +526,7 @@ void TrQuant::invTransformNxN( TransformUnit &tu, const ComponentID &compID, Pel
   const uint32_t uiWidth      = area.width;
   const uint32_t uiHeight     = area.height;
 
-  CHECK( uiWidth > tu.cs->sps->getMaxTbSize() || uiHeight > tu.cs->sps->getMaxTbSize(), "Maximal allowed transformation size exceeded!" );
+  CHECK_VTM( uiWidth > tu.cs->sps->getMaxTbSize() || uiHeight > tu.cs->sps->getMaxTbSize(), "Maximal allowed transformation size exceeded!" );
   CoeffBuf tempCoeff = CoeffBuf(m_tempCoeff, area);
   xDeQuant(tu, tempCoeff, compID, cQP);
 
@@ -552,21 +552,21 @@ void TrQuant::invTransformNxN( TransformUnit &tu, const ComponentID &compID, Pel
 
 std::pair<int64_t,int64_t> TrQuant::fwdTransformICT( const TransformUnit &tu, const PelBuf &resCb, const PelBuf &resCr, PelBuf &resC1, PelBuf &resC2, int jointCbCr )
 {
-  CHECK( Size(resCb) != Size(resCr), "resCb and resCr have different sizes" );
-  CHECK( Size(resCb) != Size(resC1), "resCb and resC1 have different sizes" );
-  CHECK( Size(resCb) != Size(resC2), "resCb and resC2 have different sizes" );
+  CHECK_VTM( Size(resCb) != Size(resCr), "resCb and resCr have different sizes" );
+  CHECK_VTM( Size(resCb) != Size(resC1), "resCb and resC1 have different sizes" );
+  CHECK_VTM( Size(resCb) != Size(resC2), "resCb and resC2 have different sizes" );
   return (*m_fwdICT[ TU::getICTMode(tu, jointCbCr) ])( resCb, resCr, resC1, resC2 );
 }
 
 void TrQuant::invTransformICT( const TransformUnit &tu, PelBuf &resCb, PelBuf &resCr )
 {
-  CHECK( Size(resCb) != Size(resCr), "resCb and resCr have different sizes" );
+  CHECK_VTM( Size(resCb) != Size(resCr), "resCb and resCr have different sizes" );
   (*m_invICT[ TU::getICTMode(tu) ])( resCb, resCr );
 }
 
 std::vector<int> TrQuant::selectICTCandidates( const TransformUnit &tu, CompStorage* resCb, CompStorage* resCr )
 {
-  CHECK( !resCb[0].valid() || !resCr[0].valid(), "standard components are not valid" );
+  CHECK_VTM( !resCb[0].valid() || !resCr[0].valid(), "standard components are not valid" );
 
   if( !CU::isIntra( *tu.cu ) )
   {
@@ -584,7 +584,7 @@ std::vector<int> TrQuant::selectICTCandidates( const TransformUnit &tu, CompStor
   {
     if( cbfMask )
     {
-      CHECK( resCb[cbfMask].valid() || resCr[cbfMask].valid(), "target components for cbfMask=" << cbfMask << " are already present" );
+      CHECK_VTM( resCb[cbfMask].valid() || resCr[cbfMask].valid(), "target components for cbfMask=" << cbfMask << " are already present" );
       resCb[cbfMask].create( tu.blocks[COMPONENT_Cb] );
       resCr[cbfMask].create( tu.blocks[COMPONENT_Cr] );
     }
@@ -780,8 +780,8 @@ void TrQuant::xT( const TransformUnit &tu, const ComponentID &compID, const CPel
   {
     const int      shift_1st              = ((floorLog2(width )) + bitDepth + TRANSFORM_MATRIX_SHIFT) - maxLog2TrDynamicRange + COM16_C806_TRANS_PREC;
     const int      shift_2nd              =  (floorLog2(height))            + TRANSFORM_MATRIX_SHIFT                          + COM16_C806_TRANS_PREC;
-    CHECK( shift_1st < 0, "Negative shift" );
-    CHECK( shift_2nd < 0, "Negative shift" );
+    CHECK_VTM( shift_1st < 0, "Negative shift" );
+    CHECK_VTM( shift_2nd < 0, "Negative shift" );
     TCoeff *tmp = (TCoeff *) alloca(width * height * sizeof(TCoeff));
 
     fastFwdTrans[trTypeHor][transformWidthIndex](block, tmp, shift_1st, height, 0, skipWidth);
@@ -790,14 +790,14 @@ void TrQuant::xT( const TransformUnit &tu, const ComponentID &compID, const CPel
   else if( height == 1 ) //1-D horizontal transform
   {
     const int      shift              = ((floorLog2(width )) + bitDepth + TRANSFORM_MATRIX_SHIFT) - maxLog2TrDynamicRange + COM16_C806_TRANS_PREC;
-    CHECK( shift < 0, "Negative shift" );
+    CHECK_VTM( shift < 0, "Negative shift" );
     CHECKD( ( transformWidthIndex < 0 ), "There is a problem with the width." );
     fastFwdTrans[trTypeHor][transformWidthIndex]( block, dstCoeff.buf, shift, 1, 0, skipWidth );
   }
   else //if (iWidth == 1) //1-D vertical transform
   {
     int shift = ( ( floorLog2(height) ) + bitDepth + TRANSFORM_MATRIX_SHIFT ) - maxLog2TrDynamicRange + COM16_C806_TRANS_PREC;
-    CHECK( shift < 0, "Negative shift" );
+    CHECK_VTM( shift < 0, "Negative shift" );
     CHECKD( ( transformHeightIndex < 0 ), "There is a problem with the height." );
     fastFwdTrans[trTypeVer][transformHeightIndex]( block, dstCoeff.buf, shift, 1, 0, skipHeight );
   }
@@ -841,8 +841,8 @@ void TrQuant::xIT( const TransformUnit &tu, const ComponentID &compID, const CCo
   {
     const int      shift_1st              =   TRANSFORM_MATRIX_SHIFT + 1 + COM16_C806_TRANS_PREC; // 1 has been added to shift_1st at the expense of shift_2nd
     const int      shift_2nd              = ( TRANSFORM_MATRIX_SHIFT + maxLog2TrDynamicRange - 1 ) - bitDepth + COM16_C806_TRANS_PREC;
-    CHECK( shift_1st < 0, "Negative shift" );
-    CHECK( shift_2nd < 0, "Negative shift" );
+    CHECK_VTM( shift_1st < 0, "Negative shift" );
+    CHECK_VTM( shift_2nd < 0, "Negative shift" );
     TCoeff *tmp = ( TCoeff * ) alloca( width * height * sizeof( TCoeff ) );
   fastInvTrans[trTypeVer][transformHeightIndex](pCoeff.buf, tmp, shift_1st, width, skipWidth, skipHeight, clipMinimum, clipMaximum);
   fastInvTrans[trTypeHor][transformWidthIndex] (tmp,      block, shift_2nd, height,         0, skipWidth, clipMinimum, clipMaximum);
@@ -850,15 +850,15 @@ void TrQuant::xIT( const TransformUnit &tu, const ComponentID &compID, const CCo
   else if( width == 1 ) //1-D vertical transform
   {
     int shift = ( TRANSFORM_MATRIX_SHIFT + maxLog2TrDynamicRange - 1 ) - bitDepth + COM16_C806_TRANS_PREC;
-    CHECK( shift < 0, "Negative shift" );
-    CHECK( ( transformHeightIndex < 0 ), "There is a problem with the height." );
+    CHECK_VTM( shift < 0, "Negative shift" );
+    CHECK_VTM( ( transformHeightIndex < 0 ), "There is a problem with the height." );
     fastInvTrans[trTypeVer][transformHeightIndex]( pCoeff.buf, block, shift + 1, 1, 0, skipHeight, clipMinimum, clipMaximum );
   }
   else //if(iHeight == 1) //1-D horizontal transform
   {
     const int      shift              = ( TRANSFORM_MATRIX_SHIFT + maxLog2TrDynamicRange - 1 ) - bitDepth + COM16_C806_TRANS_PREC;
-    CHECK( shift < 0, "Negative shift" );
-    CHECK( ( transformWidthIndex < 0 ), "There is a problem with the width." );
+    CHECK_VTM( shift < 0, "Negative shift" );
+    CHECK_VTM( ( transformWidthIndex < 0 ), "There is a problem with the width." );
     fastInvTrans[trTypeHor][transformWidthIndex]( pCoeff.buf, block, shift + 1, 1, 0, skipWidth, clipMinimum, clipMaximum );
   }
 
@@ -908,7 +908,7 @@ void TrQuant::transformNxN( TransformUnit& tu, const ComponentID& compID, const
 
   const CPelBuf  resiBuf    = cs.getResiBuf(rect);
 
-  CHECK( cs.sps->getMaxTbSize() < width, "Unsupported transformation size" );
+  CHECK_VTM( cs.sps->getMaxTbSize() < width, "Unsupported transformation size" );
 
   int pos = 0;
   std::vector<TrCost> trCosts;
@@ -996,7 +996,7 @@ void TrQuant::transformNxN( TransformUnit& tu, const ComponentID& compID, const
   uiAbsSum = 0;
 
   // transform and quantize
-  CHECK(cs.sps->getMaxTbSize() < uiWidth, "Unsupported transformation size");
+  CHECK_VTM(cs.sps->getMaxTbSize() < uiWidth, "Unsupported transformation size");
 
   CoeffBuf tempCoeff(loadTr ? m_mtsCoeffs[tu.mtsIdx[compID]] : m_tempCoeff, rect);
 
diff --git a/source/Lib/CommonLib/TypeDef.h b/source/Lib/CommonLib/TypeDef.h
index afa063a..09c7810 100644
--- a/source/Lib/CommonLib/TypeDef.h
+++ b/source/Lib/CommonLib/TypeDef.h
@@ -1062,9 +1062,9 @@ private:
 
 // if a check fails with THROW or CHECK, please check if ported correctly from assert in revision 1196)
 #define THROW(x)            throw( Exception( "\nERROR: In function \"" ) << __FUNCTION__ << "\" in " << __FILE__ << ":" << __LINE__ << ": " << x )
-#define CHECK(c,x)          if(c){ THROW(x); }
+#define CHECK_VTM(c,x)          if(c){ THROW(x); }
 #define EXIT(x)             throw( Exception( "\n" ) << x << "\n" )
-#define CHECK_NULLPTR(_ptr) CHECK( !( _ptr ), "Accessing an empty pointer pointer!" )
+#define CHECK_NULLPTR(_ptr) CHECK_VTM( !( _ptr ), "Accessing an empty pointer pointer!" )
 
 #if !NDEBUG  // for non MSVC compiler, define _DEBUG if in debug mode to have same behavior between MSVC and others in debug
 #ifndef _DEBUG
diff --git a/source/Lib/CommonLib/Unit.cpp b/source/Lib/CommonLib/Unit.cpp
index ab3fc75..bed37f4 100644
--- a/source/Lib/CommonLib/Unit.cpp
+++ b/source/Lib/CommonLib/Unit.cpp
@@ -398,7 +398,7 @@ const bool CodingUnit::checkCCLMAllowed() const
     {
       if( chromaFormat == CHROMA_420 )
       {
-        CHECK( !(blocks[COMPONENT_Cb].width <= 16 && blocks[COMPONENT_Cb].height <= 16), "chroma cu size shall be <= 16x16 for YUV420 format" );
+        CHECK_VTM( !(blocks[COMPONENT_Cb].width <= 16 && blocks[COMPONENT_Cb].height <= 16), "chroma cu size shall be <= 16x16 for YUV420 format" );
       }
       allowCCLM = true;
     }
@@ -407,7 +407,7 @@ const bool CodingUnit::checkCCLMAllowed() const
     {
       if( chromaFormat == CHROMA_420 )
       {
-        CHECK( !(blocks[COMPONENT_Cb].width == 32 && blocks[COMPONENT_Cb].height == 32), "chroma cu size shall be 32x32 for YUV420 format" );
+        CHECK_VTM( !(blocks[COMPONENT_Cb].width == 32 && blocks[COMPONENT_Cb].height == 32), "chroma cu size shall be 32x32 for YUV420 format" );
       }
       allowCCLM = true;
     }
@@ -416,7 +416,7 @@ const bool CodingUnit::checkCCLMAllowed() const
     {
       if( chromaFormat == CHROMA_420 )
       {
-        CHECK( !(blocks[COMPONENT_Cb].width == 32 && blocks[COMPONENT_Cb].height == 16), "chroma cu size shall be 32x16 for YUV420 format" );
+        CHECK_VTM( !(blocks[COMPONENT_Cb].width == 32 && blocks[COMPONENT_Cb].height == 16), "chroma cu size shall be 32x16 for YUV420 format" );
       }
       allowCCLM = true;
     }
@@ -431,7 +431,7 @@ const bool CodingUnit::checkCCLMAllowed() const
       if( colLumaCu->lwidth() < 64 || colLumaCu->lheight() < 64 ) //further split at 64x64 luma node
       {
         const PartSplit cuSplitTypeDepth1Luma = CU::getSplitAtDepth( *colLumaCu, depthFor64x64Node );
-        CHECK( !(cuSplitTypeDepth1Luma >= CU_QUAD_SPLIT && cuSplitTypeDepth1Luma <= CU_TRIV_SPLIT), "split mode shall be BT, TT or QT" );
+        CHECK_VTM( !(cuSplitTypeDepth1Luma >= CU_QUAD_SPLIT && cuSplitTypeDepth1Luma <= CU_TRIV_SPLIT), "split mode shall be BT, TT or QT" );
         if( cuSplitTypeDepth1Luma != CU_QUAD_SPLIT )
         {
           allowCCLM = false;
@@ -762,7 +762,7 @@ void TransformUnit::init(TCoeff **coeffs, Pel **pcmbuf, bool **runType)
 
 TransformUnit& TransformUnit::operator=(const TransformUnit& other)
 {
-  CHECK( chromaFormat != other.chromaFormat, "Incompatible formats" );
+  CHECK_VTM( chromaFormat != other.chromaFormat, "Incompatible formats" );
 
   unsigned numBlocks = ::getNumberValidTBlocks(*cs->pcv);
   for( unsigned i = 0; i < numBlocks; i++ )
@@ -788,7 +788,7 @@ TransformUnit& TransformUnit::operator=(const TransformUnit& other)
 
 void TransformUnit::copyComponentFrom(const TransformUnit& other, const ComponentID i)
 {
-  CHECK( chromaFormat != other.chromaFormat, "Incompatible formats" );
+  CHECK_VTM( chromaFormat != other.chromaFormat, "Incompatible formats" );
 
   CHECKD( blocks[i].area() != other.blocks[i].area(), "Transformation units cover different areas" );
 
diff --git a/source/Lib/CommonLib/Unit.h b/source/Lib/CommonLib/Unit.h
index 8a6858f..42249ee 100644
--- a/source/Lib/CommonLib/Unit.h
+++ b/source/Lib/CommonLib/Unit.h
@@ -357,8 +357,10 @@ struct CodingUnit : public UnitArea
 #endif
   const uint8_t     getSbtIdx() const { assert( ( ( sbtInfo >> 0 ) & 0xf ) < NUMBER_SBT_IDX ); return ( sbtInfo >> 0 ) & 0xf; }
   const uint8_t     getSbtPos() const { return ( sbtInfo >> 4 ) & 0x3; }
-  void              setSbtIdx( uint8_t idx ) { CHECK( idx >= NUMBER_SBT_IDX, "sbt_idx wrong" ); sbtInfo = ( idx << 0 ) + ( sbtInfo & 0xf0 ); }
-  void              setSbtPos( uint8_t pos ) { CHECK( pos >= 4, "sbt_pos wrong" ); sbtInfo = ( pos << 4 ) + ( sbtInfo & 0xcf ); }
+  void              setSbtIdx( uint8_t idx ) {
+    CHECK_VTM( idx >= NUMBER_SBT_IDX, "sbt_idx wrong" ); sbtInfo = ( idx << 0 ) + ( sbtInfo & 0xf0 ); }
+  void              setSbtPos( uint8_t pos ) {
+    CHECK_VTM( pos >= 4, "sbt_pos wrong" ); sbtInfo = ( pos << 4 ) + ( sbtInfo & 0xcf ); }
   uint8_t           getSbtTuSplit() const;
   const uint8_t     checkAllowedSbt() const;
   const bool        checkCCLMAllowed() const;
diff --git a/source/Lib/CommonLib/UnitPartitioner.cpp b/source/Lib/CommonLib/UnitPartitioner.cpp
index 7c2a0c0..3f088ad 100644
--- a/source/Lib/CommonLib/UnitPartitioner.cpp
+++ b/source/Lib/CommonLib/UnitPartitioner.cpp
@@ -346,8 +346,8 @@ void QTBTPartitioner::splitCurrArea( const PartSplit split, const CodingStructur
   }
   else if( split == CU_QUAD_SPLIT )
   {
-    CHECK( currBtDepth > 0, "Cannot split a non-square area other than with a binary split" );
-    CHECK( currMtDepth > 0, "Cannot split a non-square area other than with a binary split" );
+    CHECK_VTM( currBtDepth > 0, "Cannot split a non-square area other than with a binary split" );
+    CHECK_VTM( currMtDepth > 0, "Cannot split a non-square area other than with a binary split" );
     currMtDepth = 0;
     currBtDepth = 0;
     currQtDepth++;
@@ -573,7 +573,7 @@ void QTBTPartitioner::exitCurrSplit()
 
   m_partStack.pop_back();
 
-  CHECK( currDepth == 0, "depth is '0', although a split was performed" );
+  CHECK_VTM( currDepth == 0, "depth is '0', although a split was performed" );
   currDepth--;
   currSubdiv--;
   if( currQgEnable() )
@@ -586,34 +586,34 @@ void QTBTPartitioner::exitCurrSplit()
 
   if( currSplit == CU_HORZ_SPLIT || currSplit == CU_VERT_SPLIT || currSplit == CU_TRIH_SPLIT || currSplit == CU_TRIV_SPLIT )
   {
-    CHECK( !m_partStack.back().checkdIfImplicit, "Didn't check if the current split is implicit" );
-    CHECK( currBtDepth == 0, "BT depth is '0', athough a BT split was performed" );
-    CHECK( currMtDepth == 0, "MT depth is '0', athough a BT split was performed" );
+    CHECK_VTM( !m_partStack.back().checkdIfImplicit, "Didn't check if the current split is implicit" );
+    CHECK_VTM( currBtDepth == 0, "BT depth is '0', athough a BT split was performed" );
+    CHECK_VTM( currMtDepth == 0, "MT depth is '0', athough a BT split was performed" );
     currMtDepth--;
     if( m_partStack.back().isImplicit ) currImplicitBtDepth--;
     currBtDepth--;
     if( ( currSplit == CU_TRIH_SPLIT || currSplit == CU_TRIV_SPLIT ) && currIdx != 1 )
     {
-      CHECK( currBtDepth == 0, "BT depth is '0', athough a TT split was performed" );
+      CHECK_VTM( currBtDepth == 0, "BT depth is '0', athough a TT split was performed" );
       currBtDepth--;
       currSubdiv--;
     }
   }
   else if( currSplit == TU_MAX_TR_SPLIT )
   {
-    CHECK( currTrDepth == 0, "TR depth is '0', although a TU split was performed" );
+    CHECK_VTM( currTrDepth == 0, "TR depth is '0', although a TU split was performed" );
     currTrDepth--;
   }
   else if( currSplit >= SBT_VER_HALF_POS0_SPLIT && currSplit <= SBT_HOR_QUAD_POS1_SPLIT )
   {
-    CHECK( currTrDepth == 0, "TR depth is '0', although a TU split was performed" );
+    CHECK_VTM( currTrDepth == 0, "TR depth is '0', although a TU split was performed" );
     currTrDepth--;
   }
   else
   {
-    CHECK( currTrDepth > 0, "RQT found with QTBT partitioner" );
+    CHECK_VTM( currTrDepth > 0, "RQT found with QTBT partitioner" );
 
-    CHECK( currQtDepth == 0, "QT depth is '0', although a QT split was performed" );
+    CHECK_VTM( currQtDepth == 0, "QT depth is '0', although a QT split was performed" );
     currQtDepth--;
     currSubdiv--;
   }
@@ -700,7 +700,7 @@ void TUIntraSubPartitioner::exitCurrSplit()
 
   m_partStack.pop_back();
 
-  CHECK( currDepth == 0, "depth is '0', although a split was performed" );
+  CHECK_VTM( currDepth == 0, "depth is '0', although a split was performed" );
 
   currDepth--;
   currTrDepth--;
@@ -709,7 +709,7 @@ void TUIntraSubPartitioner::exitCurrSplit()
   m_currArea = m_partStack.back().parts[m_partStack.back().idx];
 #endif
 
-  CHECK( !( currSplit == TU_1D_HORZ_SPLIT || currSplit == TU_1D_VERT_SPLIT || currSplit == TU_MAX_TR_SPLIT ), "Unknown 1D partition split type!" );
+  CHECK_VTM( !( currSplit == TU_1D_HORZ_SPLIT || currSplit == TU_1D_VERT_SPLIT || currSplit == TU_MAX_TR_SPLIT ), "Unknown 1D partition split type!" );
 }
 
 bool TUIntraSubPartitioner::nextPart( const CodingStructure &cs, bool autoPop /*= false*/ )
@@ -790,7 +790,7 @@ Partitioning PartitionerImpl::getCUSubPartitions( const UnitArea &cuArea, const
           if( i &  1 ) blk.x += blk.width;
         }
 
-        CHECK( sub[i].lumaSize().height < MIN_TB_SIZEY, "the split causes the block to be smaller than the minimal TU size" );
+        CHECK_VTM( sub[i].lumaSize().height < MIN_TB_SIZEY, "the split causes the block to be smaller than the minimal TU size" );
       }
 
       return sub;
@@ -883,7 +883,7 @@ Partitioning PartitionerImpl::getCUSubPartitions( const UnitArea &cuArea, const
         if (i == 1) blk.y += blk.height;
       }
 
-      CHECK(sub[i].lumaSize().height < MIN_TB_SIZEY, "the cs split causes the block to be smaller than the minimal TU size");
+      CHECK_VTM(sub[i].lumaSize().height < MIN_TB_SIZEY, "the cs split causes the block to be smaller than the minimal TU size");
     }
 
     return sub;
@@ -902,7 +902,7 @@ Partitioning PartitionerImpl::getCUSubPartitions( const UnitArea &cuArea, const
         if( i == 1 ) blk.x += blk.width;
       }
 
-      CHECK( sub[i].lumaSize().width < MIN_TB_SIZEY, "the split causes the block to be smaller than the minimal TU size" );
+      CHECK_VTM( sub[i].lumaSize().width < MIN_TB_SIZEY, "the split causes the block to be smaller than the minimal TU size" );
     }
 
     return sub;
@@ -923,7 +923,7 @@ Partitioning PartitionerImpl::getCUSubPartitions( const UnitArea &cuArea, const
         if( i == 2 )        blk.y       += 3 * blk.height;
       }
 
-      CHECK( sub[i].lumaSize().height < MIN_TB_SIZEY, "the cs split causes the block to be smaller than the minimal TU size" );
+      CHECK_VTM( sub[i].lumaSize().height < MIN_TB_SIZEY, "the cs split causes the block to be smaller than the minimal TU size" );
     }
 
     return sub;
@@ -945,7 +945,7 @@ Partitioning PartitionerImpl::getCUSubPartitions( const UnitArea &cuArea, const
         if( i == 2 )        blk.x      += 3 * blk.width;
       }
 
-      CHECK( sub[i].lumaSize().width < MIN_TB_SIZEY, "the cs split causes the block to be smaller than the minimal TU size" );
+      CHECK_VTM( sub[i].lumaSize().width < MIN_TB_SIZEY, "the cs split causes the block to be smaller than the minimal TU size" );
     }
 
     return sub;
@@ -978,7 +978,7 @@ void PartitionerImpl::getTUIntraSubPartitions( Partitioning &sub, const UnitArea
       blkY.height = splitDimensionSize;
       blkY.y = i > 0 ? sub[i - 1].blocks[COMPONENT_Y].y + splitDimensionSize : blkY.y;
 
-      CHECK( sub[i].lumaSize().height < 1, "the cs split causes the block to be smaller than the minimal TU size" );
+      CHECK_VTM( sub[i].lumaSize().height < 1, "the cs split causes the block to be smaller than the minimal TU size" );
     }
   }
   else if( splitType == TU_1D_VERT_SPLIT )
@@ -994,7 +994,7 @@ void PartitionerImpl::getTUIntraSubPartitions( Partitioning &sub, const UnitArea
 
       blkY.width = splitDimensionSize;
       blkY.x = i > 0 ? sub[i - 1].blocks[COMPONENT_Y].x + splitDimensionSize : blkY.x;
-      CHECK( sub[i].lumaSize().width < 1, "the split causes the block to be smaller than the minimal TU size" );
+      CHECK_VTM( sub[i].lumaSize().width < 1, "the split causes the block to be smaller than the minimal TU size" );
     }
   }
   else
@@ -1058,7 +1058,7 @@ Partitioning PartitionerImpl::getMaxTuTiling( const UnitArea &cuArea, const Codi
   const int numTilesV = std::max<int>( 1, area.height / maxTrSize );
   const int numTiles  = numTilesH * numTilesV;
 
-  CHECK( numTiles > MAX_CU_TILING_PARTITIONS, "CU partitioning requires more partitions than available" );
+  CHECK_VTM( numTiles > MAX_CU_TILING_PARTITIONS, "CU partitioning requires more partitions than available" );
 
   Partitioning ret;
   ret.resize( numTiles, cuArea );
diff --git a/source/Lib/CommonLib/UnitTools.cpp b/source/Lib/CommonLib/UnitTools.cpp
index f76f64e..58b1114 100644
--- a/source/Lib/CommonLib/UnitTools.cpp
+++ b/source/Lib/CommonLib/UnitTools.cpp
@@ -118,31 +118,31 @@ bool CU::getRprScaling( const SPS* sps, const PPS* curPPS, Picture* refPic, int&
   int curPicHeightY = curPPS->getPicHeightInLumaSamples();                      // pps_pic_height_in_luma_samples
   int max8MinCbSizeY = std::max((int)8, (1<<sps->getLog2MinCodingBlockSize())); // Max(8, MinCbSizeY)
 
-  CHECK((curPicWidth * curSeqMaxPicWidthY) < refPicWidth * (curPicWidthY - max8MinCbSizeY), "(curPicWidth * curSeqMaxPicWidthY) should be greater than or equal to refPicWidth * (curPicWidthY - max8MinCbSizeY))");
-  CHECK((curPicHeight * curSeqMaxPicHeightY) < refPicHeight * (curPicHeightY - max8MinCbSizeY), "(curPicHeight * curSeqMaxPicHeightY) should be greater than or equal to refPicHeight * (curPicHeightY - max8MinCbSizeY))");
+  CHECK_VTM((curPicWidth * curSeqMaxPicWidthY) < refPicWidth * (curPicWidthY - max8MinCbSizeY), "(curPicWidth * curSeqMaxPicWidthY) should be greater than or equal to refPicWidth * (curPicWidthY - max8MinCbSizeY))");
+  CHECK_VTM((curPicHeight * curSeqMaxPicHeightY) < refPicHeight * (curPicHeightY - max8MinCbSizeY), "(curPicHeight * curSeqMaxPicHeightY) should be greater than or equal to refPicHeight * (curPicHeightY - max8MinCbSizeY))");
 
-  CHECK(curPicWidth * 2 < refPicWidth, "curPicWidth * 2 shall be greater than or equal to refPicWidth");
-  CHECK(curPicHeight * 2 < refPicHeight, "curPicHeight * 2 shall be greater than or equal to refPicHeight");
-  CHECK(curPicWidth > refPicWidth * 8, "curPicWidth shall be less than or equal to refPicWidth * 8");
-  CHECK(curPicHeight > refPicHeight * 8, "curPicHeight shall be less than or equal to refPicHeight * 8");
+  CHECK_VTM(curPicWidth * 2 < refPicWidth, "curPicWidth * 2 shall be greater than or equal to refPicWidth");
+  CHECK_VTM(curPicHeight * 2 < refPicHeight, "curPicHeight * 2 shall be greater than or equal to refPicHeight");
+  CHECK_VTM(curPicWidth > refPicWidth * 8, "curPicWidth shall be less than or equal to refPicWidth * 8");
+  CHECK_VTM(curPicHeight > refPicHeight * 8, "curPicHeight shall be less than or equal to refPicHeight * 8");
 
   int subWidthC = SPS::getWinUnitX(sps->getChromaFormatIdc());
   int subHeightC = SPS::getWinUnitY(sps->getChromaFormatIdc());
 
-  CHECK(subWidthC * curScalingWindow.getWindowLeftOffset() < (-curPicWidthY) * 15, "The value of SubWidthC * pps_scaling_win_left_offset shall be greater than or equal to -pps_pic_width_in_luma_samples * 15");
-  CHECK(subWidthC * curScalingWindow.getWindowLeftOffset() >= curPicWidthY, "The value of SubWidthC * pps_scaling_win_left_offset shall be less than pps_pic_width_in_luma_samples");
-  CHECK(subWidthC * curScalingWindow.getWindowRightOffset() < (-curPicWidthY) * 15, "The value of SubWidthC * pps_scaling_win_right_offset shall be greater than or equal to -pps_pic_width_in_luma_samples * 15");
-  CHECK(subWidthC * curScalingWindow.getWindowRightOffset() >= curPicWidthY, "The value of SubWidthC * pps_scaling_win_right_offset shall be less than pps_pic_width_in_luma_samples");
+  CHECK_VTM(subWidthC * curScalingWindow.getWindowLeftOffset() < (-curPicWidthY) * 15, "The value of SubWidthC * pps_scaling_win_left_offset shall be greater than or equal to -pps_pic_width_in_luma_samples * 15");
+  CHECK_VTM(subWidthC * curScalingWindow.getWindowLeftOffset() >= curPicWidthY, "The value of SubWidthC * pps_scaling_win_left_offset shall be less than pps_pic_width_in_luma_samples");
+  CHECK_VTM(subWidthC * curScalingWindow.getWindowRightOffset() < (-curPicWidthY) * 15, "The value of SubWidthC * pps_scaling_win_right_offset shall be greater than or equal to -pps_pic_width_in_luma_samples * 15");
+  CHECK_VTM(subWidthC * curScalingWindow.getWindowRightOffset() >= curPicWidthY, "The value of SubWidthC * pps_scaling_win_right_offset shall be less than pps_pic_width_in_luma_samples");
 
-  CHECK(subHeightC * curScalingWindow.getWindowTopOffset() < (-curPicHeightY) * 15, "The value of SubHeightC * pps_scaling_win_top_offset shall be greater than or equal to -pps_pic_height_in_luma_samples * 15");
-  CHECK(subHeightC * curScalingWindow.getWindowTopOffset() >= curPicHeightY, "The value of SubHeightC * pps_scaling_win_top_offset shall be less than pps_pic_height_in_luma_samples");
-  CHECK(subHeightC * curScalingWindow.getWindowBottomOffset() < (-curPicHeightY) * 15, "The value of SubHeightC *pps_scaling_win_bottom_offset shall be greater than or equal to -pps_pic_height_in_luma_samples * 15");
-  CHECK(subHeightC * curScalingWindow.getWindowBottomOffset() >= curPicHeightY, "The value of SubHeightC *pps_scaling_win_bottom_offset shall be less than pps_pic_height_in_luma_samples");
+  CHECK_VTM(subHeightC * curScalingWindow.getWindowTopOffset() < (-curPicHeightY) * 15, "The value of SubHeightC * pps_scaling_win_top_offset shall be greater than or equal to -pps_pic_height_in_luma_samples * 15");
+  CHECK_VTM(subHeightC * curScalingWindow.getWindowTopOffset() >= curPicHeightY, "The value of SubHeightC * pps_scaling_win_top_offset shall be less than pps_pic_height_in_luma_samples");
+  CHECK_VTM(subHeightC * curScalingWindow.getWindowBottomOffset() < (-curPicHeightY) * 15, "The value of SubHeightC *pps_scaling_win_bottom_offset shall be greater than or equal to -pps_pic_height_in_luma_samples * 15");
+  CHECK_VTM(subHeightC * curScalingWindow.getWindowBottomOffset() >= curPicHeightY, "The value of SubHeightC *pps_scaling_win_bottom_offset shall be less than pps_pic_height_in_luma_samples");
 
-  CHECK(subWidthC * (curScalingWindow.getWindowLeftOffset() + curScalingWindow.getWindowRightOffset()) < (-curPicWidthY) * 15, "The value of SubWidthC * ( pps_scaling_win_left_offset + pps_scaling_win_right_offset ) shall be greater than or equal to -pps_pic_width_in_luma_samples * 15");
-  CHECK(subWidthC * (curScalingWindow.getWindowLeftOffset() + curScalingWindow.getWindowRightOffset()) >= curPicWidthY, "The value of SubWidthC * ( pps_scaling_win_left_offset + pps_scaling_win_right_offset ) shall be less than pps_pic_width_in_luma_samples");
-  CHECK(subHeightC * (curScalingWindow.getWindowTopOffset() + curScalingWindow.getWindowBottomOffset()) < (-curPicHeightY) * 15, "The value of SubHeightC * ( pps_scaling_win_top_offset + pps_scaling_win_bottom_offset ) shall be greater than or equal to -pps_pic_height_in_luma_samples * 15");
-  CHECK(subHeightC * (curScalingWindow.getWindowTopOffset() + curScalingWindow.getWindowBottomOffset()) >= curPicHeightY, "The value of SubHeightC * ( pps_scaling_win_top_offset + pps_scaling_win_bottom_offset ) shall be less than pps_pic_height_in_luma_samples");
+  CHECK_VTM(subWidthC * (curScalingWindow.getWindowLeftOffset() + curScalingWindow.getWindowRightOffset()) < (-curPicWidthY) * 15, "The value of SubWidthC * ( pps_scaling_win_left_offset + pps_scaling_win_right_offset ) shall be greater than or equal to -pps_pic_width_in_luma_samples * 15");
+  CHECK_VTM(subWidthC * (curScalingWindow.getWindowLeftOffset() + curScalingWindow.getWindowRightOffset()) >= curPicWidthY, "The value of SubWidthC * ( pps_scaling_win_left_offset + pps_scaling_win_right_offset ) shall be less than pps_pic_width_in_luma_samples");
+  CHECK_VTM(subHeightC * (curScalingWindow.getWindowTopOffset() + curScalingWindow.getWindowBottomOffset()) < (-curPicHeightY) * 15, "The value of SubHeightC * ( pps_scaling_win_top_offset + pps_scaling_win_bottom_offset ) shall be greater than or equal to -pps_pic_height_in_luma_samples * 15");
+  CHECK_VTM(subHeightC * (curScalingWindow.getWindowTopOffset() + curScalingWindow.getWindowBottomOffset()) >= curPicHeightY, "The value of SubHeightC * ( pps_scaling_win_top_offset + pps_scaling_win_bottom_offset ) shall be less than pps_pic_height_in_luma_samples");
 
   return refPic->isRefScaled( curPPS );
 }
@@ -163,7 +163,7 @@ void CU::checkConformanceILRP(Slice *slice)
     }
   }
 
-  CHECK( currentSubPicIdx == NOT_VALID, "Sub-picture was not found" );
+  CHECK_VTM( currentSubPicIdx == NOT_VALID, "Sub-picture was not found" );
 
   if( !slice->getPic()->cs->sps->getSubPicTreatedAsPicFlag( currentSubPicIdx ) )
   {
@@ -225,7 +225,7 @@ void CU::checkConformanceILRP(Slice *slice)
       for (int refIdx = 0; refIdx < slice->getNumRefIdx(eRefPicList); refIdx++)
       {
         const Picture* refPic = slice->getRefPic( eRefPicList, refIdx );
-        CHECK( refPic->layerId == slice->getPic()->layerId || refPic->subPictures.size() > 1, "The inter-layer reference shall contain a single subpicture or have same subpicture layout with the current picture" );
+        CHECK_VTM( refPic->layerId == slice->getPic()->layerId || refPic->subPictures.size() > 1, "The inter-layer reference shall contain a single subpicture or have same subpicture layout with the current picture" );
       }
     }
   }
@@ -403,7 +403,7 @@ PartSplit CU::getSplitAtDepth( const CodingUnit& cu, const unsigned depth )
 ModeType CU::getModeTypeAtDepth( const CodingUnit& cu, const unsigned depth )
 {
   ModeType modeType = ModeType( (cu.modeTypeSeries >> (depth * 3)) & 0x07 );
-  CHECK( depth > cu.depth, " depth is wrong" );
+  CHECK_VTM( depth > cu.depth, " depth is wrong" );
   return modeType;
 }
 
@@ -411,7 +411,7 @@ ModeType CU::getModeTypeAtDepth( const CodingUnit& cu, const unsigned depth )
 
 bool CU::divideTuInRows( const CodingUnit &cu )
 {
-  CHECK( cu.ispMode != HOR_INTRA_SUBPARTITIONS && cu.ispMode != VER_INTRA_SUBPARTITIONS, "Intra Subpartitions type not recognized!" );
+  CHECK_VTM( cu.ispMode != HOR_INTRA_SUBPARTITIONS && cu.ispMode != VER_INTRA_SUBPARTITIONS, "Intra Subpartitions type not recognized!" );
   return cu.ispMode == HOR_INTRA_SUBPARTITIONS ? true : false;
 }
 
@@ -486,7 +486,7 @@ bool CU::canUseLfnstWithISP( const CompArea& cuArea, const ISPType ispSplitType
 
 bool CU::canUseLfnstWithISP( const CodingUnit& cu, const ChannelType chType )
 {
-  CHECK( !isLuma( chType ), "Wrong ISP mode!" );
+  CHECK_VTM( !isLuma( chType ), "Wrong ISP mode!" );
   return CU::canUseLfnstWithISP( cu.blocks[chType == CHANNEL_TYPE_LUMA ? 0 : 1], (ISPType)cu.ispMode );
 }
 
@@ -510,7 +510,7 @@ uint32_t CU::getISPSplitDim( const int width, const int height, const PartSplit
   const int factorToMinSamples = nonSplitDimensionSize < minNumberOfSamplesPerCu ? minNumberOfSamplesPerCu >> floorLog2(nonSplitDimensionSize) : 1;
   partitionSize = ( splitDimensionSize >> divShift ) < factorToMinSamples ? factorToMinSamples : ( splitDimensionSize >> divShift );
 
-  CHECK( floorLog2(partitionSize) + floorLog2(nonSplitDimensionSize) < floorLog2(minNumberOfSamplesPerCu), "A partition has less than the minimum amount of samples!" );
+  CHECK_VTM( floorLog2(partitionSize) + floorLog2(nonSplitDimensionSize) < floorLog2(minNumberOfSamplesPerCu), "A partition has less than the minimum amount of samples!" );
   return partitionSize;
 }
 
@@ -563,7 +563,7 @@ int PU::getIntraMPMs( const PredictionUnit &pu, unsigned* mpm, const ChannelType
 {
   const int numMPMs = NUM_MOST_PROBABLE_MODES;
   {
-    CHECK(channelType != CHANNEL_TYPE_LUMA, "Not harmonized yet");
+    CHECK_VTM(channelType != CHANNEL_TYPE_LUMA, "Not harmonized yet");
     int numCand      = -1;
     int leftIntraDir = PLANAR_IDX, aboveIntraDir = PLANAR_IDX;
 
@@ -585,7 +585,7 @@ int PU::getIntraMPMs( const PredictionUnit &pu, unsigned* mpm, const ChannelType
       aboveIntraDir = PU::getIntraDirLuma( *puAbove );
     }
 
-    CHECK(2 >= numMPMs, "Invalid number of most probable modes");
+    CHECK_VTM(2 >= numMPMs, "Invalid number of most probable modes");
 
     const int offset = (int)NUM_LUMA_MODE - 6;
     const int mod = offset + 3;
@@ -660,9 +660,9 @@ int PU::getIntraMPMs( const PredictionUnit &pu, unsigned* mpm, const ChannelType
     }
     for (int i = 0; i < numMPMs; i++)
     {
-      CHECK(mpm[i] >= NUM_LUMA_MODE, "Invalid MPM");
+      CHECK_VTM(mpm[i] >= NUM_LUMA_MODE, "Invalid MPM");
     }
-    CHECK(numCand == 0, "No candidates found");
+    CHECK_VTM(numCand == 0, "No candidates found");
     return numCand;
   }
 }
@@ -973,7 +973,7 @@ void PU::getInterMergeCandidates( const PredictionUnit &pu, MergeCtx& mrgCtx,
   const CodingStructure &cs  = *pu.cs;
   const Slice &slice         = *pu.cs->slice;
   const uint32_t maxNumMergeCand = pu.cs->sps->getMaxNumMergeCand();
-  CHECK (maxNumMergeCand > MRG_MAX_NUM_CANDS, "selected maximum number of merge candidate exceeds global limit");
+  CHECK_VTM(maxNumMergeCand > MRG_MAX_NUM_CANDS, "selected maximum number of merge candidate exceeds global limit");
   for (uint32_t ui = 0; ui < maxNumMergeCand; ++ui)
   {
     mrgCtx.BcwIdx[ui] = BCW_DEFAULT;
@@ -1576,7 +1576,7 @@ bool PU::getColocatedMVP(const PredictionUnit &pu, const RefPicList &eRefPicList
     }
   }
 
-  CHECK( pColSlice == nullptr, "Slice segment not found" );
+  CHECK_VTM( pColSlice == nullptr, "Slice segment not found" );
 
   const Slice &colSlice = *pColSlice;
 
@@ -2458,8 +2458,7 @@ void PU::getAffineControlPointCand(const PredictionUnit &pu, MotionInfo mi[4], b
         cMv[l][1].clipToStorageBitDepth();
         break;
 
-      default:
-        CHECK( 1, "Invalid model index!\n" );
+      default: CHECK_VTM( 1, "Invalid model index!\n" );
         break;
       }
     }
@@ -2579,7 +2578,7 @@ void PU::getAffineMergeCand( const PredictionUnit &pu, AffineMergeCtx& affMrgCtx
     MergeCtx mrgCtx = *affMrgCtx.mrgCtx;
     bool tmpLICFlag = false;
 
-    CHECK( mrgCtx.subPuMvpMiBuf.area() == 0 || !mrgCtx.subPuMvpMiBuf.buf, "Buffer not initialized" );
+    CHECK_VTM( mrgCtx.subPuMvpMiBuf.area() == 0 || !mrgCtx.subPuMvpMiBuf.buf, "Buffer not initialized" );
     mrgCtx.subPuMvpMiBuf.fill( MotionInfo() );
 
     int pos = 0;
@@ -2860,7 +2859,7 @@ void PU::setAllAffineMvField( PredictionUnit &pu, MvField *mvField, RefPicList e
   setAllAffineMv( pu, mv[0], mv[1], mv[2], eRefList );
 
   // Set RefIdx
-  CHECK( mvField[0].refIdx != mvField[1].refIdx || mvField[0].refIdx != mvField[2].refIdx, "Affine mv corners don't have the same refIdx." );
+  CHECK_VTM( mvField[0].refIdx != mvField[1].refIdx || mvField[0].refIdx != mvField[2].refIdx, "Affine mv corners don't have the same refIdx." );
   pu.refIdx[eRefList] = mvField[0].refIdx;
 }
 
@@ -3173,7 +3172,7 @@ void PU::spanMotionInfo( PredictionUnit &pu, const MergeCtx &mrgCtx )
   }
   else if (pu.mergeType == MRG_TYPE_SUBPU_ATMVP)
   {
-    CHECK(mrgCtx.subPuMvpMiBuf.area() == 0 || !mrgCtx.subPuMvpMiBuf.buf, "Buffer not initialized");
+    CHECK_VTM(mrgCtx.subPuMvpMiBuf.area() == 0 || !mrgCtx.subPuMvpMiBuf.buf, "Buffer not initialized");
     mb.copyFrom(mrgCtx.subPuMvpMiBuf);
   }
   else
@@ -3601,7 +3600,7 @@ uint8_t CU::targetSbtAllowed( uint8_t sbtIdx, uint8_t sbtAllowed )
   case SBT_HOR_HALF: val = ( ( sbtAllowed >> SBT_HOR_HALF ) & 0x1 ); break;
   case SBT_VER_QUAD: val = ( ( sbtAllowed >> SBT_VER_QUAD ) & 0x1 ); break;
   case SBT_HOR_QUAD: val = ( ( sbtAllowed >> SBT_HOR_QUAD ) & 0x1 ); break;
-  default:           CHECK( 1, "unknown SBT type" );
+  default: CHECK_VTM( 1, "unknown SBT type" );
   }
   return val;
 }
@@ -3667,7 +3666,7 @@ bool CU::isBcwIdxCoded( const CodingUnit &cu )
 {
   if( cu.cs->sps->getUseBcw() == false )
   {
-    CHECK(cu.BcwIdx != BCW_DEFAULT, "Error: cu.BcwIdx != BCW_DEFAULT");
+    CHECK_VTM(cu.BcwIdx != BCW_DEFAULT, "Error: cu.BcwIdx != BCW_DEFAULT");
     return false;
   }
 
@@ -3715,11 +3714,11 @@ uint8_t CU::getValidBcwIdx( const CodingUnit &cu )
   }
   else if( cu.firstPU->mergeFlag && cu.firstPU->mergeType == MRG_TYPE_SUBPU_ATMVP )
   {
-    CHECK(cu.BcwIdx != BCW_DEFAULT, " cu.BcwIdx != BCW_DEFAULT ");
+    CHECK_VTM(cu.BcwIdx != BCW_DEFAULT, " cu.BcwIdx != BCW_DEFAULT ");
   }
   else
   {
-    CHECK(cu.BcwIdx != BCW_DEFAULT, " cu.BcwIdx != BCW_DEFAULT ");
+    CHECK_VTM(cu.BcwIdx != BCW_DEFAULT, " cu.BcwIdx != BCW_DEFAULT ");
   }
 
   return BCW_DEFAULT;
@@ -3747,7 +3746,7 @@ void CU::setBcwIdx( CodingUnit &cu, uint8_t uh )
     cu.BcwIdx = BCW_DEFAULT;
   }
 
-  CHECK(uhCnt <= 0, " uhCnt <= 0 ");
+  CHECK_VTM(uhCnt <= 0, " uhCnt <= 0 ");
 }
 
 uint8_t CU::deriveBcwIdx( uint8_t bcwLO, uint8_t bcwL1 )
@@ -3829,7 +3828,7 @@ bool TU::getCbfAtDepth(const TransformUnit &tu, const ComponentID &compID, const
 {
   if( !tu.blocks[compID].valid() )
   {
-    CHECK(tu.cbf[compID] != 0, "cbf must be 0 if the component is not available");
+    CHECK_VTM(tu.cbf[compID] != 0, "cbf must be 0 if the component is not available");
   }
   return ((tu.cbf[compID] >> depth) & 1) == 1;
 }
diff --git a/source/Lib/CommonLib/UnitTools.h b/source/Lib/CommonLib/UnitTools.h
index c87fbdc..990b616 100644
--- a/source/Lib/CommonLib/UnitTools.h
+++ b/source/Lib/CommonLib/UnitTools.h
@@ -206,8 +206,8 @@ template<typename T, size_t N>
 uint32_t updateCandList(T uiMode, double uiCost, static_vector<T, N>& candModeList, static_vector<double, N>& candCostList
   , size_t uiFastCandNum = N, int* iserttPos = nullptr)
 {
-  CHECK( std::min( uiFastCandNum, candModeList.size() ) != std::min( uiFastCandNum, candCostList.size() ), "Sizes do not match!" );
-  CHECK( uiFastCandNum > candModeList.capacity(), "The vector is to small to hold all the candidates!" );
+  CHECK_VTM( std::min( uiFastCandNum, candModeList.size() ) != std::min( uiFastCandNum, candCostList.size() ), "Sizes do not match!" );
+  CHECK_VTM( uiFastCandNum > candModeList.capacity(), "The vector is to small to hold all the candidates!" );
 
   size_t i;
   size_t shift = 0;
diff --git a/source/Lib/CommonLib/WeightPrediction.cpp b/source/Lib/CommonLib/WeightPrediction.cpp
index 1493d08..21a2c8a 100644
--- a/source/Lib/CommonLib/WeightPrediction.cpp
+++ b/source/Lib/CommonLib/WeightPrediction.cpp
@@ -75,7 +75,7 @@ WeightPrediction::WeightPrediction()
 void WeightPrediction::getWpScaling(Slice *pcSlice, const int &iRefIdx0, const int &iRefIdx1, WPScalingParam *&wp0,
                                     WPScalingParam *&wp1, const ComponentID maxNumComp)
 {
-  CHECK(iRefIdx0 < 0 && iRefIdx1 < 0, "Both picture reference list indizes smaller than '0'");
+  CHECK_VTM(iRefIdx0 < 0 && iRefIdx1 < 0, "Both picture reference list indizes smaller than '0'");
 
   const bool wpBiPred        = pcSlice->getPPS()->getWPBiPred();
   const bool bBiPred         = (iRefIdx0 >= 0 && iRefIdx1 >= 0);
@@ -158,7 +158,7 @@ void WeightPrediction::addWeightBi(const CPelUnitBuf          &pcYuvSrc0,
 
   const uint32_t numValidComponent = (const uint32_t)pcYuvSrc0.bufs.size();
 
-  CHECK( lumaOnly && chromaOnly, "Not allowed to have both lumaOnly and chromaOnly selected" );
+  CHECK_VTM( lumaOnly && chromaOnly, "Not allowed to have both lumaOnly and chromaOnly selected" );
   int firstComponent = chromaOnly ? 1 : 0;
   int lastComponent = lumaOnly ? 0 : maxNumComp;
   for (int componentIndex = firstComponent; componentIndex < numValidComponent && componentIndex <= lastComponent; componentIndex++)
@@ -276,7 +276,7 @@ void  WeightPrediction::addWeightUni(const CPelUnitBuf          &pcYuvSrc0,
 {
   const uint32_t numValidComponent = (const uint32_t)pcYuvSrc0.bufs.size();
 
-  CHECK( lumaOnly && chromaOnly, "Not allowed to have both lumaOnly and chromaOnly selected" );
+  CHECK_VTM( lumaOnly && chromaOnly, "Not allowed to have both lumaOnly and chromaOnly selected" );
   int firstComponent = chromaOnly ? 1 : 0;
   int lastComponent  = lumaOnly ? 0 : maxNumComp;
   for (int componentIndex = firstComponent; componentIndex < numValidComponent && componentIndex <= lastComponent;
@@ -385,7 +385,7 @@ void  WeightPrediction::xWeightedPredictionUni(const PredictionUnit       &pu,
     iRefIdx = pu.refIdx[eRefPicList];
   }
 
-  CHECK(iRefIdx < 0, "Negative reference picture list index");
+  CHECK_VTM(iRefIdx < 0, "Negative reference picture list index");
 
   if (eRefPicList == REF_PIC_LIST_0)
   {
@@ -412,7 +412,7 @@ void  WeightPrediction::xWeightedPredictionBi(const PredictionUnit       &pu,
   WPScalingParam  *pwp0;
   WPScalingParam  *pwp1;
 
-  CHECK( !pu.cs->pps->getWPBiPred(), "Weighted Bi-prediction disabled" );
+  CHECK_VTM( !pu.cs->pps->getWPBiPred(), "Weighted Bi-prediction disabled" );
 
   if (iRefIdx0 < 0 && iRefIdx1 < 0) return;
 
diff --git a/source/Lib/CommonLib/x86/AdaptiveLoopFilterX86.h b/source/Lib/CommonLib/x86/AdaptiveLoopFilterX86.h
index 9626203..46e4c84 100644
--- a/source/Lib/CommonLib/x86/AdaptiveLoopFilterX86.h
+++ b/source/Lib/CommonLib/x86/AdaptiveLoopFilterX86.h
@@ -46,9 +46,9 @@ static void simdDeriveClassificationBlk(AlfClassifier **classifier, int **laplac
                                         const CPelBuf &srcLuma, const Area &blkDst, const Area &blk, const int shift,
                                         const int vbCTUHeight, int vbPos )
 {
-  CHECK((blk.height & 7) != 0, "Block height must be a multiple of 8");
-  CHECK((blk.width & 7) != 0, "Block width must be a multiple of 8");
-  CHECK((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
+  CHECK_VTM((blk.height & 7) != 0, "Block height must be a multiple of 8");
+  CHECK_VTM((blk.width & 7) != 0, "Block width must be a multiple of 8");
+  CHECK_VTM((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
 
   const size_t imgStride = srcLuma.stride;
   const Pel *  srcExt    = srcLuma.buf;
@@ -301,8 +301,8 @@ static void simdFilter5x5Blk(AlfClassifier **classifier, const PelUnitBuf &recDs
   int vbPos)
 
 {
-  CHECK((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
-  CHECK(!isChroma(compId), "ALF 5x5 filter is for chroma only");
+  CHECK_VTM((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
+  CHECK_VTM(!isChroma(compId), "ALF 5x5 filter is for chroma only");
 
 
   const CPelBuf srcBuffer = recSrc.get(compId);
@@ -321,10 +321,10 @@ static void simdFilter5x5Blk(AlfClassifier **classifier, const PelUnitBuf &recDs
   constexpr size_t STEP_X = 8;
   constexpr size_t STEP_Y = 4;
 
-  CHECK(blk.y % STEP_Y, "Wrong startHeight in filtering");
-  CHECK(blk.x % STEP_X, "Wrong startWidth in filtering");
-  CHECK(height % STEP_Y, "Wrong endHeight in filtering");
-  CHECK(width % 4, "Wrong endWidth in filtering");
+  CHECK_VTM(blk.y % STEP_Y, "Wrong startHeight in filtering");
+  CHECK_VTM(blk.x % STEP_X, "Wrong startWidth in filtering");
+  CHECK_VTM(height % STEP_Y, "Wrong endHeight in filtering");
+  CHECK_VTM(width % 4, "Wrong endWidth in filtering");
 
   const Pel *src = srcBuffer.buf + blk.y * srcStride + blk.x;
   Pel *      dst = dstBuffer.buf + blkDst.y * dstStride + blkDst.x;
@@ -480,8 +480,8 @@ static void simdFilter7x7Blk(AlfClassifier **classifier, const PelUnitBuf &recDs
   const Pel *fClipSet, const ClpRng &clpRng, CodingStructure &cs, const int vbCTUHeight,
   int vbPos)
 {
-  CHECK((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
-  CHECK(isChroma(compId), "7x7 ALF filter is meant for luma only");
+  CHECK_VTM((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
+  CHECK_VTM(isChroma(compId), "7x7 ALF filter is meant for luma only");
 
 
   const CPelBuf srcBuffer = recSrc.get(compId);
@@ -499,10 +499,10 @@ static void simdFilter7x7Blk(AlfClassifier **classifier, const PelUnitBuf &recDs
   constexpr size_t STEP_X = 8;
   constexpr size_t STEP_Y = 4;
 
-  CHECK(blk.y % STEP_Y, "Wrong startHeight in filtering");
-  CHECK(blk.x % STEP_X, "Wrong startWidth in filtering");
-  CHECK(height % STEP_Y, "Wrong endHeight in filtering");
-  CHECK(width % STEP_X, "Wrong endWidth in filtering");
+  CHECK_VTM(blk.y % STEP_Y, "Wrong startHeight in filtering");
+  CHECK_VTM(blk.x % STEP_X, "Wrong startWidth in filtering");
+  CHECK_VTM(height % STEP_Y, "Wrong endHeight in filtering");
+  CHECK_VTM(width % STEP_X, "Wrong endWidth in filtering");
 
   const Pel *src = srcBuffer.buf + blk.y * srcStride + blk.x;
   Pel *      dst = dstBuffer.buf + blkDst.y * dstStride + blkDst.x;
diff --git a/source/Lib/CommonLib/x86/BufferX86.h b/source/Lib/CommonLib/x86/BufferX86.h
index c763a29..74aaab6 100644
--- a/source/Lib/CommonLib/x86/BufferX86.h
+++ b/source/Lib/CommonLib/x86/BufferX86.h
@@ -53,8 +53,8 @@ void addAvg_SSE( const int16_t* src0, int src0Stride, const int16_t* src1, int s
 {
   if( W == 8 )
   {
-    CHECK(offset & 1, "offset must be even");
-    CHECK(offset < -32768 || offset > 32767, "offset must be a 16-bit value");
+    CHECK_VTM(offset & 1, "offset must be even");
+    CHECK_VTM(offset < -32768 || offset > 32767, "offset must be a 16-bit value");
 
     __m128i vibdimin = _mm_set1_epi16(clpRng.min);
     __m128i vibdimax = _mm_set1_epi16(clpRng.max);
@@ -122,7 +122,7 @@ void copyBufferSimd(Pel *src, int srcStride, Pel *dst, int dstStride, int width,
 {
   if (width < 8)
   {
-    CHECK(width < 4, "width must be at least 4");
+    CHECK_VTM(width < 4, "width must be at least 4");
 
     for (size_t x = 0; x < width; x += 4)
     {
@@ -154,7 +154,7 @@ template<X86_VEXT vext>
 void paddingSimd(Pel *dst, int stride, int width, int height, int padSize)
 {
   size_t extWidth = width + 2 * padSize;
-  CHECK(extWidth < 8, "width plus 2 times padding size must be at least 8");
+  CHECK_VTM(extWidth < 8, "width plus 2 times padding size must be at least 8");
 
   if (padSize == 1)
   {
@@ -224,7 +224,7 @@ void paddingSimd(Pel *dst, int stride, int width, int height, int padSize)
   }
   else
   {
-    CHECK(false, "padding size must be 1 or 2");
+    CHECK_VTM(false, "padding size must be 1 or 2");
   }
 }
 
diff --git a/source/Lib/CommonLib/x86/InterpolationFilterX86.h b/source/Lib/CommonLib/x86/InterpolationFilterX86.h
index 3e52ef6..612eea9 100644
--- a/source/Lib/CommonLib/x86/InterpolationFilterX86.h
+++ b/source/Lib/CommonLib/x86/InterpolationFilterX86.h
@@ -1083,8 +1083,8 @@ static void simdInterpolateN2_HIGHBIT_M4(const int16_t* src, int srcStride, int1
 
   __m128i mmShift = _mm_cvtsi64_si128(shift);
 
-  CHECK(isLast, "Not Supported");
-  CHECK(width % 4 != 0, "Not Supported");
+  CHECK_VTM(isLast, "Not Supported");
+  CHECK_VTM(width % 4 != 0, "Not Supported");
 
   for (int row = 0; row < height; row++)
   {
@@ -1122,7 +1122,7 @@ static void simdInterpolateN2_10BIT_M4(const int16_t* src, int srcStride, int16_
   for (int n = 0; n < 2; n++)
     mmCoeff[n] = _mm_set1_epi16(c[n]);
 
-  CHECK(isLast, "Not Supported");
+  CHECK_VTM(isLast, "Not Supported");
 
 #if USE_AVX2
   __m256i mm256Offset = _mm256_set1_epi16(offset);
@@ -1188,7 +1188,7 @@ static void simdFilter( const ClpRng& clpRng, Pel const *src, int srcStride, Pel
   int shift    = IF_FILTER_PREC;
   // with the current settings (IF_INTERNAL_PREC = 14 and IF_FILTER_PREC = 6), though headroom can be
   // negative for bit depths greater than 14, shift will remain non-negative for bit depths of 8->20
-  CHECK( shift < 0, "Negative shift" );
+  CHECK_VTM( shift < 0, "Negative shift" );
 
 
   if( isLast )
diff --git a/source/Lib/CommonLib/x86/RdCostX86.h b/source/Lib/CommonLib/x86/RdCostX86.h
index a41f090..2c030a4 100644
--- a/source/Lib/CommonLib/x86/RdCostX86.h
+++ b/source/Lib/CommonLib/x86/RdCostX86.h
@@ -274,7 +274,7 @@ Distortion RdCost::xGetSAD_SIMD( const DistParam &rcDtParam )
   else
   {
     // Do with step of 4
-    CHECK( ( iCols & 3 ) != 0, "Not divisible by 4: " << iCols );
+    CHECK_VTM( ( iCols & 3 ) != 0, "Not divisible by 4: " << iCols );
     __m128i vzero = _mm_setzero_si128();
     __m128i vsum32 = vzero;
     for( int iY = 0; iY < iRows; iY += iSubStep )
diff --git a/source/Lib/DecoderLib/AnnexBread.cpp b/source/Lib/DecoderLib/AnnexBread.cpp
index 7058de9..e5f8b53 100644
--- a/source/Lib/DecoderLib/AnnexBread.cpp
+++ b/source/Lib/DecoderLib/AnnexBread.cpp
@@ -107,7 +107,7 @@ _byteStreamNALUnit(
     statBits.bits+=8; statBits.count++;
 #endif
 #endif
-    CHECK( zero_byte != 0, "Zero byte not '0'" );
+    CHECK_VTM( zero_byte != 0, "Zero byte not '0'" );
     stats.m_numZeroByteBytes++;
   }
 
@@ -181,7 +181,7 @@ _byteStreamNALUnit(
     statBits.bits+=8; statBits.count++;
 #endif
 #endif
-    CHECK( trailing_zero_8bits != 0, "Trailing zero bits not '0'" );
+    CHECK_VTM( trailing_zero_8bits != 0, "Trailing zero bits not '0'" );
     stats.m_numTrailingZero8BitsBytes++;
   }
 }
diff --git a/source/Lib/DecoderLib/AnnexBread.h b/source/Lib/DecoderLib/AnnexBread.h
index 6f9c733..1555625 100644
--- a/source/Lib/DecoderLib/AnnexBread.h
+++ b/source/Lib/DecoderLib/AnnexBread.h
@@ -86,7 +86,7 @@ public:
    */
   bool eofBeforeNBytes(uint32_t n)
   {
-    CHECK(n > 4, "Unsupported look-ahead value");
+    CHECK_VTM(n > 4, "Unsupported look-ahead value");
     if (m_NumFutureBytes >= n)
     {
       return false;
diff --git a/source/Lib/DecoderLib/BinDecoder.cpp b/source/Lib/DecoderLib/BinDecoder.cpp
index 81d4783..4b2c91f 100644
--- a/source/Lib/DecoderLib/BinDecoder.cpp
+++ b/source/Lib/DecoderLib/BinDecoder.cpp
@@ -72,7 +72,7 @@ void BinDecoderBase::uninit()
 
 void BinDecoderBase::start()
 {
-  CHECK( m_Bitstream->getNumBitsUntilByteAligned(), "Bitstream is not byte aligned." );
+  CHECK_VTM( m_Bitstream->getNumBitsUntilByteAligned(), "Bitstream is not byte aligned." );
 #if RExt__DECODER_DEBUG_BIT_STATISTICS
   CodingStatistics::UpdateCABACStat(STATS__CABAC_INITIALISATION, 512, 510, 0);
 #endif
@@ -86,7 +86,7 @@ void BinDecoderBase::finish()
 {
   unsigned lastByte;
   m_Bitstream->peekPreviousByte( lastByte );
-  CHECK( ( ( lastByte << ( 8 + m_bitsNeeded ) ) & 0xff ) != 0x80,
+  CHECK_VTM( ( ( lastByte << ( 8 + m_bitsNeeded ) ) & 0xff ) != 0x80,
         "No proper stop/alignment pattern at end of CABAC stream." );
 }
 
diff --git a/source/Lib/DecoderLib/CABACReader.cpp b/source/Lib/DecoderLib/CABACReader.cpp
index 2980b49..cf9eee7 100644
--- a/source/Lib/DecoderLib/CABACReader.cpp
+++ b/source/Lib/DecoderLib/CABACReader.cpp
@@ -112,7 +112,7 @@ void CABACReader::remaining_bytes( bool noTrailingBytesExpected )
 {
   if( noTrailingBytesExpected )
   {
-    CHECK( 0 != m_Bitstream->getNumBitsLeft(), "Bits left when not supposed" );
+    CHECK_VTM( 0 != m_Bitstream->getNumBitsLeft(), "Bits left when not supposed" );
   }
   else
   {
@@ -178,7 +178,7 @@ void CABACReader::coding_tree_unit( CodingStructure& cs, const UnitArea& area, i
         if( isChroma( (ComponentID)compIdx ) )
         {
           int apsIdx = cs.slice->getTileGroupApsIdChroma();
-          CHECK(cs.slice->getAlfAPSs()[apsIdx] == nullptr, "APS not initialized");
+          CHECK_VTM(cs.slice->getAlfAPSs()[apsIdx] == nullptr, "APS not initialized");
           const AlfParam& alfParam = cs.slice->getAlfAPSs()[apsIdx]->getAlfAPSParam();
           const int numAlts = alfParam.numAlternativesChroma;
           uint8_t* ctbAlfAlternative = cs.slice->getPic()->getAlfCtuAlternativeData( compIdx );
@@ -497,7 +497,7 @@ void CABACReader::coding_tree( CodingStructure& cs, Partitioner& partitioner, CU
 
   const PartSplit splitMode = split_cu_mode( cs, partitioner );
 
-  CHECK( !partitioner.canSplit( splitMode, cs ), "Got an invalid split!" );
+  CHECK_VTM( !partitioner.canSplit( splitMode, cs ), "Got an invalid split!" );
 
   if( splitMode != CU_DONT_SPLIT )
   {
@@ -520,7 +520,7 @@ void CABACReader::coding_tree( CodingStructure& cs, Partitioner& partitioner, CU
           }
           lumaContinue   = partitioner.nextPart(cs);
           chromaContinue = pPartitionerChroma->nextPart(cs);
-          CHECK(lumaContinue != chromaContinue, "luma chroma partition should be matched");
+          CHECK_VTM(lumaContinue != chromaContinue, "luma chroma partition should be matched");
           beContinue = lumaContinue;
         }
         else
@@ -537,7 +537,7 @@ void CABACReader::coding_tree( CodingStructure& cs, Partitioner& partitioner, CU
             coding_tree(cs, *pPartitionerChroma, *pCuCtxChroma);
           }
           chromaContinue = pPartitionerChroma->nextPart(cs);
-          CHECK(lumaContinue != chromaContinue, "luma chroma partition should be matched");
+          CHECK_VTM(lumaContinue != chromaContinue, "luma chroma partition should be matched");
           beContinue = lumaContinue;
         }
       }
@@ -582,7 +582,7 @@ void CABACReader::coding_tree( CodingStructure& cs, Partitioner& partitioner, CU
       cs.modeType = partitioner.modeType = mode_constraint(cs, partitioner, splitMode);   // change for child nodes
       // decide chroma split or not
       bool chromaNotSplit = modeTypeParent == MODE_TYPE_ALL && partitioner.modeType == MODE_TYPE_INTRA;
-      CHECK(chromaNotSplit && partitioner.chType != CHANNEL_TYPE_LUMA, "chType must be luma");
+      CHECK_VTM(chromaNotSplit && partitioner.chType != CHANNEL_TYPE_LUMA, "chType must be luma");
       if (partitioner.treeType == TREE_D)
       {
         cs.treeType = partitioner.treeType = chromaNotSplit ? TREE_L : TREE_D;
@@ -599,7 +599,7 @@ void CABACReader::coding_tree( CodingStructure& cs, Partitioner& partitioner, CU
       partitioner.exitCurrSplit();
       if( chromaNotSplit )
       {
-        CHECK( partitioner.chType != CHANNEL_TYPE_LUMA, "must be luma status" );
+        CHECK_VTM( partitioner.chType != CHANNEL_TYPE_LUMA, "must be luma status" );
         partitioner.chType = CHANNEL_TYPE_CHROMA;
         cs.treeType = partitioner.treeType = TREE_C;
 
@@ -624,7 +624,7 @@ void CABACReader::coding_tree( CodingStructure& cs, Partitioner& partitioner, CU
   partitioner.setCUData( cu );
   cu.slice   = cs.slice;
   cu.tileIdx = cs.pps->getTileIdx( currArea.lumaPos() );
-  CHECK( cu.cs->treeType != partitioner.treeType, "treeType mismatch" );
+  CHECK_VTM( cu.cs->treeType != partitioner.treeType, "treeType mismatch" );
   int lumaQPinLocalDualTree = -1;
 
   // Predict QP on start of quantization group
@@ -641,7 +641,7 @@ void CABACReader::coding_tree( CodingStructure& cs, Partitioner& partitioner, CU
     //derive chroma qp, but the chroma qp is saved in cuCtx.qp which is used for luma qp
     //therefore, after decoding the chroma CU, the cuCtx.qp shall be recovered to luma qp in order to decode next luma cu qp
     const CodingUnit* colLumaCu = cs.getLumaCU( lumaRefPos );
-    CHECK( colLumaCu == nullptr, "colLumaCU shall exist" );
+    CHECK_VTM( colLumaCu == nullptr, "colLumaCU shall exist" );
     lumaQPinLocalDualTree = cuCtx.qp;
 
     if (colLumaCu)
@@ -829,7 +829,7 @@ PartSplit CABACReader::split_cu_mode( CodingStructure& cs, Partitioner &partitio
 void CABACReader::coding_unit( CodingUnit &cu, Partitioner &partitioner, CUCtx& cuCtx )
 {
   CodingStructure& cs = *cu.cs;
-  CHECK( cu.treeType != partitioner.treeType || cu.modeType != partitioner.modeType, "treeType or modeType mismatch" );
+  CHECK_VTM( cu.treeType != partitioner.treeType || cu.modeType != partitioner.modeType, "treeType or modeType mismatch" );
   DTRACE( g_trace_ctx, D_SYNTAX, "coding_unit() treeType=%d modeType=%d\n", cu.treeType, cu.modeType );
   PredictionUnit&    pu = cs.addPU(cu, partitioner.chType);
   // skip flag
@@ -1237,7 +1237,7 @@ void CABACReader::cu_bcw_flag(CodingUnit& cu)
     return;
   }
 
-  CHECK(!(BCW_NUM > 1 && (BCW_NUM == 2 || (BCW_NUM & 0x01) == 1)), " !( BCW_NUM > 1 && ( BCW_NUM == 2 || ( BCW_NUM & 0x01 ) == 1 ) ) ");
+  CHECK_VTM(!(BCW_NUM > 1 && (BCW_NUM == 2 || (BCW_NUM & 0x01) == 1)), " !( BCW_NUM > 1 && ( BCW_NUM == 2 || ( BCW_NUM & 0x01 ) == 1 ) ) ");
 
   RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET(STATS__CABAC_BITS__BCW_IDX);
 
@@ -1373,7 +1373,7 @@ void CABACReader::intra_luma_pred_modes( CodingUnit &cu )
   int mpmFlag[4];
   for( int k = 0; k < numBlocks; k++ )
   {
-    CHECK(numBlocks != 1, "not supported yet");
+    CHECK_VTM(numBlocks != 1, "not supported yet");
     if ( cu.firstPU->multiRefIdx )
     {
       mpmFlag[0] = true;
@@ -1458,7 +1458,7 @@ void CABACReader::intra_chroma_pred_modes( CodingUnit& cu )
   }
   PredictionUnit *pu = cu.firstPU;
 
-  CHECK(pu->cu != &cu, "Inkonsistent PU-CU mapping");
+  CHECK_VTM(pu->cu != &cu, "Inkonsistent PU-CU mapping");
   intra_chroma_pred_mode(*pu);
 }
 
@@ -1472,7 +1472,7 @@ bool CABACReader::intra_chroma_lmc_mode(PredictionUnit& pu)
   if (symbol == 0)
   {
     pu.intraDir[1] = lmModeList[symbol];
-    CHECK(pu.intraDir[1] != LM_CHROMA_IDX, "should be LM_CHROMA");
+    CHECK_VTM(pu.intraDir[1] != LM_CHROMA_IDX, "should be LM_CHROMA");
   }
   else
   {
@@ -1514,9 +1514,9 @@ void CABACReader::intra_chroma_pred_mode(PredictionUnit& pu)
   unsigned chromaCandModes[NUM_CHROMA_MODE];
   PU::getIntraChromaCandModes(pu, chromaCandModes);
 
-  CHECK(candId >= NUM_CHROMA_MODE, "Chroma prediction mode index out of bounds");
-  CHECK(PU::isLMCMode(chromaCandModes[candId]), "The intra dir cannot be LM_CHROMA for this path");
-  CHECK(chromaCandModes[candId] == DM_CHROMA_IDX, "The intra dir cannot be DM_CHROMA for this path");
+  CHECK_VTM(candId >= NUM_CHROMA_MODE, "Chroma prediction mode index out of bounds");
+  CHECK_VTM(PU::isLMCMode(chromaCandModes[candId]), "The intra dir cannot be LM_CHROMA for this path");
+  CHECK_VTM(chromaCandModes[candId] == DM_CHROMA_IDX, "The intra dir cannot be DM_CHROMA for this path");
 
   pu.intraDir[1] = chromaCandModes[candId];
 }
@@ -1787,7 +1787,7 @@ void CABACReader::cu_palette_info(CodingUnit& cu, ComponentID compBegin, uint32_
   {
     cuPaletteSubblockInfo(cu, compBegin, numComp, subSetId, prevRunPos, prevRunType);
   }
-  CHECK(cu.curPLTSize[compBegin] > maxPltSize, " Current palette size is larger than maximum palette size");
+  CHECK_VTM(cu.curPLTSize[compBegin] > maxPltSize, " Current palette size is larger than maximum palette size");
 }
 
 void CABACReader::cuPaletteSubblockInfo(CodingUnit& cu, ComponentID compBegin, uint32_t numComp, int subSetId, uint32_t& prevRunPos, unsigned& prevRunType)
@@ -2140,7 +2140,7 @@ void CABACReader::prediction_unit( PredictionUnit& pu, MergeCtx& mrgCtx )
   {
     RefPicList eCurRefList = (RefPicList)(pu.cu->smvdMode - 1);
     pu.mvd[1 - eCurRefList].set( -pu.mvd[eCurRefList].hor, -pu.mvd[eCurRefList].ver );
-    CHECK(!((pu.mvd[1 - eCurRefList].getHor() >= MVD_MIN) && (pu.mvd[1 - eCurRefList].getHor() <= MVD_MAX)) || !((pu.mvd[1 - eCurRefList].getVer() >= MVD_MIN) && (pu.mvd[1 - eCurRefList].getVer() <= MVD_MAX)), "Illegal MVD value");
+    CHECK_VTM(!((pu.mvd[1 - eCurRefList].getHor() >= MVD_MIN) && (pu.mvd[1 - eCurRefList].getHor() <= MVD_MAX)) || !((pu.mvd[1 - eCurRefList].getVer() >= MVD_MIN) && (pu.mvd[1 - eCurRefList].getVer() <= MVD_MAX)), "Illegal MVD value");
     pu.refIdx[1 - eCurRefList] = pu.cs->slice->getSymRefIdx( 1 - eCurRefList );
   }
 }
@@ -2342,8 +2342,8 @@ void CABACReader::merge_idx( PredictionUnit& pu )
       xReadTruncBinCode(splitDir, GEO_NUM_PARTITION_MODE);
       pu.geoSplitDir          = splitDir;
       const int maxNumGeoCand = pu.cs->sps->getMaxNumGeoCand();
-      CHECK(maxNumGeoCand < 2, "Incorrect max number of geo candidates");
-      CHECK(pu.cu->lheight() > 64 || pu.cu->lwidth() > 64, "Incorrect block size of geo flag");
+      CHECK_VTM(maxNumGeoCand < 2, "Incorrect max number of geo candidates");
+      CHECK_VTM(pu.cu->lheight() > 64 || pu.cu->lwidth() > 64, "Incorrect block size of geo flag");
       int numCandminus2 = maxNumGeoCand - 2;
       pu.mergeIdx       = 0;
       int mergeCand0    = 0;
@@ -2706,7 +2706,7 @@ void CABACReader::mvd_coding( Mv &rMvd )
     }
   }
   rMvd = Mv(horAbs, verAbs);
-  CHECK(!((horAbs >= MVD_MIN) && (horAbs <= MVD_MAX)) || !((verAbs >= MVD_MIN) && (verAbs <= MVD_MAX)), "Illegal MVD value");
+  CHECK_VTM(!((horAbs >= MVD_MIN) && (horAbs <= MVD_MAX)) || !((verAbs >= MVD_MIN) && (verAbs <= MVD_MAX)), "Illegal MVD value");
 }
 
 //================================================================================
@@ -2849,7 +2849,7 @@ void CABACReader::cu_qp_delta( CodingUnit& cu, int predQP, int8_t& qp )
 {
   RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__DELTA_QP_EP );
 
-  CHECK( predQP == std::numeric_limits<int>::max(), "Invalid predicted QP" );
+  CHECK_VTM( predQP == std::numeric_limits<int>::max(), "Invalid predicted QP" );
   int qpY = predQP;
   int DQp = unary_max_symbol( Ctx::DeltaQP(), Ctx::DeltaQP(1), CU_DQP_TU_CMAX );
   if( DQp >= CU_DQP_TU_CMAX )
@@ -3175,7 +3175,7 @@ int CABACReader::last_sig_coeff( CoeffCodingContext& cctx, TransformUnit& tu, Co
 
 static void check_coeff_conformance(const CoeffCodingContext& cctx, const TCoeff coeff)
 {
-  CHECK( coeff < cctx.minCoeff() || coeff > cctx.maxCoeff(),
+  CHECK_VTM( coeff < cctx.minCoeff() || coeff > cctx.maxCoeff(),
          "TransCoeffLevel outside allowable range" );
 }
 
diff --git a/source/Lib/DecoderLib/DecCu.cpp b/source/Lib/DecoderLib/DecCu.cpp
index eeec347..9424023 100644
--- a/source/Lib/DecoderLib/DecCu.cpp
+++ b/source/Lib/DecoderLib/DecCu.cpp
@@ -340,10 +340,10 @@ void DecCu::xIntraRecACTBlk(TransformUnit& tu)
   const PredictionUnit &pu = *tu.cs->getPU(tu.blocks[COMPONENT_Y], CHANNEL_TYPE_LUMA);
   const Slice          &slice = *cs.slice;
 
-  CHECK(!tu.Y().valid() || !tu.Cb().valid() || !tu.Cr().valid(), "Invalid TU");
-  CHECK(&pu != tu.cu->firstPU, "wrong PU fetch");
-  CHECK(tu.cu->ispMode, "adaptive color transform cannot be applied to ISP");
-  CHECK(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "chroma should use DM mode for adaptive color transform");
+  CHECK_VTM(!tu.Y().valid() || !tu.Cb().valid() || !tu.Cr().valid(), "Invalid TU");
+  CHECK_VTM(&pu != tu.cu->firstPU, "wrong PU fetch");
+  CHECK_VTM(tu.cu->ispMode, "adaptive color transform cannot be applied to ISP");
+  CHECK_VTM(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "chroma should use DM mode for adaptive color transform");
 
   bool flag = slice.getLmcsEnabledFlag() && (slice.isIntra() || (!slice.isIntra() && m_pcReshape->getCTUFlag()));
   if (flag && slice.getPicHeader()->getLmcsChromaResidualScaleFlag())
@@ -646,10 +646,10 @@ void DecCu::xReconInter(CodingUnit &cu)
   m_pcIntraPred->geneIntrainterPred(cu);
 
   // inter prediction
-  CHECK(CU::isIBC(cu) && cu.firstPU->ciipFlag, "IBC and Ciip cannot be used together");
-  CHECK(CU::isIBC(cu) && cu.affine, "IBC and Affine cannot be used together");
-  CHECK(CU::isIBC(cu) && cu.geoFlag, "IBC and geo cannot be used together");
-  CHECK(CU::isIBC(cu) && cu.firstPU->mmvdMergeFlag, "IBC and MMVD cannot be used together");
+  CHECK_VTM(CU::isIBC(cu) && cu.firstPU->ciipFlag, "IBC and Ciip cannot be used together");
+  CHECK_VTM(CU::isIBC(cu) && cu.affine, "IBC and Affine cannot be used together");
+  CHECK_VTM(CU::isIBC(cu) && cu.geoFlag, "IBC and geo cannot be used together");
+  CHECK_VTM(CU::isIBC(cu) && cu.firstPU->mmvdMergeFlag, "IBC and MMVD cannot be used together");
   const bool luma = cu.Y().valid();
   const bool chroma = isChromaEnabled(cu.chromaFormat) && cu.Cb().valid();
   if (luma && (chroma || !isChromaEnabled(cu.chromaFormat)))
@@ -864,7 +864,7 @@ void DecCu::xDeriveCUMV( CodingUnit &cu )
     {
       if (pu.mmvdMergeFlag || pu.cu->mmvdSkip)
       {
-        CHECK(pu.ciipFlag == true, "invalid Ciip");
+        CHECK_VTM(pu.ciipFlag == true, "invalid Ciip");
         if (pu.cs->sps->getSbTMVPEnabledFlag())
         {
           Size bufSize = g_miScaling.scale(pu.lumaSize());
@@ -965,7 +965,7 @@ void DecCu::xDeriveCUMV( CodingUnit &cu )
               pu.mvpNum[eRefList] = affineAMVPInfo.numCand;
 
               //    Mv mv[3];
-              CHECK( pu.refIdx[eRefList] < 0, "Unexpected negative refIdx." );
+              CHECK_VTM( pu.refIdx[eRefList] < 0, "Unexpected negative refIdx." );
               if (!cu.cs->pcv->isEncoder)
               {
                 pu.mvdAffi[eRefList][0].changeAffinePrecAmvr2Internal(pu.cu->imv);
@@ -1004,7 +1004,7 @@ void DecCu::xDeriveCUMV( CodingUnit &cu )
           }
           if (pu.cs->sps->getMaxNumIBCMergeCand() == 1)
           {
-            CHECK( pu.mvpIdx[REF_PIC_LIST_0], "mvpIdx for IBC mode should be 0" );
+            CHECK_VTM( pu.mvpIdx[REF_PIC_LIST_0], "mvpIdx for IBC mode should be 0" );
           }
           pu.mv[REF_PIC_LIST_0] = amvpInfo.mvCand[pu.mvpIdx[REF_PIC_LIST_0]] + mvd;
           pu.mv[REF_PIC_LIST_0].mvCliptoStorageBitDepth();
@@ -1047,7 +1047,7 @@ void DecCu::xDeriveCUMV( CodingUnit &cu )
       const unsigned int  lcuWidth = pu.cs->slice->getSPS()->getMaxCUWidth();
       int xPred = pu.mv[0].getHor() >> MV_FRACTIONAL_BITS_INTERNAL;
       int yPred = pu.mv[0].getVer() >> MV_FRACTIONAL_BITS_INTERNAL;
-      CHECK(!m_pcInterPred->isLumaBvValid(lcuWidth, cuPelX, cuPelY, roiWidth, roiHeight, xPred, yPred), "invalid block vector for IBC detected.");
+      CHECK_VTM(!m_pcInterPred->isLumaBvValid(lcuWidth, cuPelX, cuPelY, roiWidth, roiHeight, xPred, yPred), "invalid block vector for IBC detected.");
     }
   }
 }
diff --git a/source/Lib/DecoderLib/DecLib.cpp b/source/Lib/DecoderLib/DecLib.cpp
index 1e65498..a7ed710 100644
--- a/source/Lib/DecoderLib/DecLib.cpp
+++ b/source/Lib/DecoderLib/DecLib.cpp
@@ -81,7 +81,7 @@ bool tryDecodePicture( Picture* pcEncPic, const int expectedPoc, const std::stri
       bitstreamFile = new std::ifstream( bitstreamFileName.c_str(), std::ifstream::in | std::ifstream::binary );
       bytestream    = new InputByteStream( *bitstreamFile );
 
-      CHECK( !*bitstreamFile, "failed to open bitstream file " << bitstreamFileName.c_str() << " for reading" ) ;
+      CHECK_VTM( !*bitstreamFile, "failed to open bitstream file " << bitstreamFileName.c_str() << " for reading" ) ;
       // create decoder class
       pcDecLib = new DecLib;
       pcDecLib->create();
@@ -151,9 +151,9 @@ bool tryDecodePicture( Picture* pcEncPic, const int expectedPoc, const std::stri
             {
               if( pic->poc == poc && (!bDecodeUntilPocFound || expectedPoc == poc ) )
               {
-                CHECK( pcEncPic->slices.size() == 0, "at least one slice should be available" );
+                CHECK_VTM( pcEncPic->slices.size() == 0, "at least one slice should be available" );
 
-                CHECK( expectedPoc != poc, "mismatch in POC - check encoder configuration" );
+                CHECK_VTM( expectedPoc != poc, "mismatch in POC - check encoder configuration" );
 
                 if( debugCTU < 0 || poc != debugPOC )
                 {
@@ -355,7 +355,7 @@ bool tryDecodePicture( Picture* pcEncPic, const int expectedPoc, const std::stri
 
   if( !bRet )
   {
-    CHECK( bDecodeUntilPocFound, " decoding failed - check decodeBitstream2 parameter File: " << bitstreamFileName.c_str() );
+    CHECK_VTM( bDecodeUntilPocFound, " decoding failed - check decodeBitstream2 parameter File: " << bitstreamFileName.c_str() );
     if( pcDecLib )
     {
       pcDecLib->destroy();
@@ -850,7 +850,7 @@ void DecLib::xCreateLostPicture( int iLostPoc, const int layerId )
   msg( INFO, "\ninserting lost poc : %d\n",iLostPoc);
   Picture *cFillPic = xGetNewPicBuffer( *( m_parameterSetManager.getFirstSPS() ), *( m_parameterSetManager.getFirstPPS() ), 0, layerId );
 
-  CHECK( !cFillPic->slices.size(), "No slices in picture" );
+  CHECK_VTM( !cFillPic->slices.size(), "No slices in picture" );
 
   cFillPic->slices[0]->initSlice();
 
@@ -894,7 +894,7 @@ void  DecLib::xCreateUnavailablePicture( const PPS *pps, const int iUnavailableP
   msg(INFO, "\ninserting unavailable poc : %d\n", iUnavailablePoc);
   Picture* cFillPic = xGetNewPicBuffer( *( m_parameterSetManager.getFirstSPS() ), *( m_parameterSetManager.getFirstPPS() ), 0, layerId );
 
-  CHECK(!cFillPic->slices.size(), "No slices in picture");
+  CHECK_VTM(!cFillPic->slices.size(), "No slices in picture");
 
   cFillPic->slices[0]->initSlice();
 
@@ -929,7 +929,7 @@ void DecLib::checkPicTypeAfterEos()
   if (m_prevEOS[layerId])
   {
     bool isIrapOrGdrPu = !m_pcPic->cs->pps->getMixedNaluTypesInPicFlag() && ( m_pcPic->slices[0]->isIRAP() || m_pcPic->slices[0]->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR );
-    CHECK(!isIrapOrGdrPu, "when present, the next PU of a particular layer after an EOS NAL unit that belongs to the same layer shall be an IRAP or GDR PU");
+    CHECK_VTM(!isIrapOrGdrPu, "when present, the next PU of a particular layer after an EOS NAL unit that belongs to the same layer shall be an IRAP or GDR PU");
 
     m_prevEOS[layerId] = false;
   }
@@ -956,7 +956,7 @@ void DecLib::checkLayerIdIncludedInCvss()
           break;
         }
       }
-      CHECK(!layerIdFind, "each picture in an AU in a CVS shall have nuh_layer_id equal to the nuh_layer_id of one of the pictures present in the first AU of the CVS");
+      CHECK_VTM(!layerIdFind, "each picture in an AU in a CVS shall have nuh_layer_id equal to the nuh_layer_id of one of the pictures present in the first AU of the CVS");
     }
 
 
@@ -975,7 +975,7 @@ void DecLib::checkLayerIdIncludedInCvss()
             break;
           }
         }
-        CHECK(!eosLayerIdFind, "When nal_unit_type is equal to EOS_NUT, nuh_layer_id shall be equal to one of the nuh_layer_id values of the layers present in the CVS");
+        CHECK_VTM(!eosLayerIdFind, "When nal_unit_type is equal to EOS_NUT, nuh_layer_id shall be equal to one of the nuh_layer_id values of the layers present in the CVS");
       }
     }
   }
@@ -997,7 +997,7 @@ void DecLib::CheckNoOutputPriorPicFlagsInAccessUnit()
   {
     bool anchor = m_accessUnitNoOutputPriorPicFlags[0];
     bool isDiffFlagsInAu = std::find(m_accessUnitNoOutputPriorPicFlags.begin(), m_accessUnitNoOutputPriorPicFlags.end(), !anchor) != m_accessUnitNoOutputPriorPicFlags.end();
-    CHECK(isDiffFlagsInAu, "The value of no_output_of_prior_pics_flag, when present, is required to be the same for all pictures in an AU");
+    CHECK_VTM(isDiffFlagsInAu, "The value of no_output_of_prior_pics_flag, when present, is required to be the same for all pictures in an AU");
   }
 }
 
@@ -1019,7 +1019,7 @@ void DecLib::checkTidLayerIdInAccessUnit()
       break;
     }
   }
-  CHECK(!isPicTidInAuSame, "All pictures in an AU shall have the same value of TemporalId");
+  CHECK_VTM(!isPicTidInAuSame, "All pictures in an AU shall have the same value of TemporalId");
 
   for (auto tid = m_accessUnitSeiTids.begin(); tid != m_accessUnitSeiTids.end(); tid++)
   {
@@ -1029,7 +1029,7 @@ void DecLib::checkTidLayerIdInAccessUnit()
       break;
     }
   }
-  CHECK(!isSeiTidInAuSameAsAuTid, "The TemporalId of an SEI NAL unit shall be equal to the TemporalId of the AU containing the NAL unit");
+  CHECK_VTM(!isSeiTidInAuSameAsAuTid, "The TemporalId of an SEI NAL unit shall be equal to the TemporalId of the AU containing the NAL unit");
 
   for (auto tempNalu = m_accessUnitNals.begin(); tempNalu != m_accessUnitNals.end(); tempNalu++)
   {
@@ -1039,7 +1039,7 @@ void DecLib::checkTidLayerIdInAccessUnit()
       break;
     }
   }
-  CHECK(!isFdNaluLayerIdSameAsVclNaluLayerId, "The nuh_layer_id of a filler data NAL unit shall be equal to the nuh_layer_id of associated VCL NAL unit");
+  CHECK_VTM(!isFdNaluLayerIdSameAsVclNaluLayerId, "The nuh_layer_id of a filler data NAL unit shall be equal to the nuh_layer_id of associated VCL NAL unit");
 
   for (auto tempNalu = m_accessUnitNals.begin(); tempNalu != m_accessUnitNals.end(); tempNalu++)
   {
@@ -1049,7 +1049,7 @@ void DecLib::checkTidLayerIdInAccessUnit()
       break;
     }
   }
-  CHECK(!isFdTidInAuSameAsAuTid, "The TemporalId of a filler data NAL unit shall be equal to the TemporalId of the AU containing the NAL unit");
+  CHECK_VTM(!isFdTidInAuSameAsAuTid, "The TemporalId of a filler data NAL unit shall be equal to the TemporalId of the AU containing the NAL unit");
 }
 
 void DecLib::checkSEIInAccessUnit()
@@ -1084,7 +1084,7 @@ void DecLib::checkSEIInAccessUnit()
           break;
         }
       }
-      CHECK(!olsIncludeAllLayersFind, "When there is no OLS that includes all layers in the current CVS in the entire bitstream, there shall be no non-scalable-nested SEI message with payloadType equal to 0 (BP), 1 (PT), 130 (DUI), or 203 (SLI)");
+      CHECK_VTM(!olsIncludeAllLayersFind, "When there is no OLS that includes all layers in the current CVS in the entire bitstream, there shall be no non-scalable-nested SEI message with payloadType equal to 0 (BP), 1 (PT), 130 (DUI), or 203 (SLI)");
     }
   }
 }
@@ -1171,8 +1171,8 @@ void DecLib::checkSeiInPictureUnit()
           count++;
         }
       }
-    }    
-    CHECK(count > 4, "There shall be less than or equal to 4 identical sei_payload( ) syntax structures within a picture unit.");
+    }
+    CHECK_VTM(count > 4, "There shall be less than or equal to 4 identical sei_payload( ) syntax structures within a picture unit.");
   }
 
   // free SEI message list memory
@@ -1246,11 +1246,11 @@ void DecLib::checkAPSInPictureUnit()
     if (NALUnit::isVclNalUnitType(nalu))
     {
       firstVCLFound = true;
-      CHECK( suffixAPSFound, "When any suffix APS NAL units are present in a PU, they shall follow the last VCL unit of the PU" );
+      CHECK_VTM( suffixAPSFound, "When any suffix APS NAL units are present in a PU, they shall follow the last VCL unit of the PU" );
     }
     else if (nalu == NAL_UNIT_PREFIX_APS)
     {
-      CHECK( firstVCLFound, "When any prefix APS NAL units are present in a PU, they shall precede the first VCL unit of the PU");
+      CHECK_VTM( firstVCLFound, "When any prefix APS NAL units are present in a PU, they shall precede the first VCL unit of the PU");
     }
     else if (nalu == NAL_UNIT_SUFFIX_APS)
     {
@@ -1278,12 +1278,12 @@ void activateAPS(PicHeader* picHeader, Slice* pSlice, ParameterSetManager& param
           THROW("APS activation failed!");
         }
 
-        CHECK( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+        CHECK_VTM( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
         //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
 
-        CHECK( sps->getChromaFormatIdc() == CHROMA_400 && aps->chromaPresentFlag, "When ChromaArrayType is equal to 0, the value of aps_chroma_present_flag of an ALF_APS shall be equal to 0" );
+        CHECK_VTM( sps->getChromaFormatIdc() == CHROMA_400 && aps->chromaPresentFlag, "When ChromaArrayType is equal to 0, the value of aps_chroma_present_flag of an ALF_APS shall be equal to 0" );
 
-        CHECK(((sps->getCCALFEnabledFlag() == false) && (aps->getCcAlfAPSParam().newCcAlfFilter[0] || aps->getCcAlfAPSParam().newCcAlfFilter[1])), "When sps_ccalf_enabled_flag is 0, the values of alf_cc_cb_filter_signal_flag and alf_cc_cr_filter_signal_flag shall be equal to 0");
+        CHECK_VTM(((sps->getCCALFEnabledFlag() == false) && (aps->getCcAlfAPSParam().newCcAlfFilter[0] || aps->getCcAlfAPSParam().newCcAlfFilter[1])), "When sps_ccalf_enabled_flag is 0, the values of alf_cc_cb_filter_signal_flag and alf_cc_cr_filter_signal_flag shall be equal to 0");
       }
     }
   }
@@ -1300,10 +1300,10 @@ void activateAPS(PicHeader* picHeader, Slice* pSlice, ParameterSetManager& param
         THROW("APS activation failed!");
       }
 
-      CHECK( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+      CHECK_VTM( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
       //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
 
-      CHECK(((sps->getCCALFEnabledFlag() == false) && (aps->getCcAlfAPSParam().newCcAlfFilter[0] || aps->getCcAlfAPSParam().newCcAlfFilter[1])), "When sps_ccalf_enabled_flag is 0, the values of alf_cc_cb_filter_signal_flag and alf_cc_cr_filter_signal_flag shall be equal to 0");
+      CHECK_VTM(((sps->getCCALFEnabledFlag() == false) && (aps->getCcAlfAPSParam().newCcAlfFilter[0] || aps->getCcAlfAPSParam().newCcAlfFilter[1])), "When sps_ccalf_enabled_flag is 0, the values of alf_cc_cb_filter_signal_flag and alf_cc_cr_filter_signal_flag shall be equal to 0");
     }
   }
 
@@ -1329,7 +1329,7 @@ void activateAPS(PicHeader* picHeader, Slice* pSlice, ParameterSetManager& param
         THROW("APS activation failed!");
       }
 
-      CHECK( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+      CHECK_VTM( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
       //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
 
       filterParam.ccAlfFilterCount[COMPONENT_Cb - 1] = aps->getCcAlfAPSParam().ccAlfFilterCount[COMPONENT_Cb - 1];
@@ -1357,7 +1357,7 @@ void activateAPS(PicHeader* picHeader, Slice* pSlice, ParameterSetManager& param
         THROW("APS activation failed!");
       }
 
-      CHECK( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+      CHECK_VTM( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
       //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
 
       filterParam.ccAlfFilterCount[COMPONENT_Cr - 1] = aps->getCcAlfAPSParam().ccAlfFilterCount[COMPONENT_Cr - 1];
@@ -1376,7 +1376,7 @@ void activateAPS(PicHeader* picHeader, Slice* pSlice, ParameterSetManager& param
   if (picHeader->getLmcsEnabledFlag() && lmcsAPS == nullptr)
   {
     lmcsAPS = parameterSetManager.getAPS(picHeader->getLmcsAPSId(), LMCS_APS);
-    CHECK(lmcsAPS == nullptr, "No LMCS APS present");
+    CHECK_VTM(lmcsAPS == nullptr, "No LMCS APS present");
     if (lmcsAPS)
     {
       parameterSetManager.clearAPSChangedFlag(picHeader->getLmcsAPSId(), LMCS_APS);
@@ -1385,11 +1385,11 @@ void activateAPS(PicHeader* picHeader, Slice* pSlice, ParameterSetManager& param
         THROW("LMCS APS activation failed!");
       }
 
-      CHECK( sps->getChromaFormatIdc() == CHROMA_400 && lmcsAPS->chromaPresentFlag, "When ChromaArrayType is equal to 0, the value of aps_chroma_present_flag of an LMCS_APS shall be equal to 0");
+      CHECK_VTM( sps->getChromaFormatIdc() == CHROMA_400 && lmcsAPS->chromaPresentFlag, "When ChromaArrayType is equal to 0, the value of aps_chroma_present_flag of an LMCS_APS shall be equal to 0");
 
-      CHECK( lmcsAPS->getReshaperAPSInfo().maxNbitsNeededDeltaCW - 1 < 0 || lmcsAPS->getReshaperAPSInfo().maxNbitsNeededDeltaCW - 1 > sps->getBitDepth(CHANNEL_TYPE_LUMA) - 2, "The value of lmcs_delta_cw_prec_minus1 of an LMCS_APS shall be in the range of 0 to BitDepth 2, inclusive" );
+      CHECK_VTM( lmcsAPS->getReshaperAPSInfo().maxNbitsNeededDeltaCW - 1 < 0 || lmcsAPS->getReshaperAPSInfo().maxNbitsNeededDeltaCW - 1 > sps->getBitDepth(CHANNEL_TYPE_LUMA) - 2, "The value of lmcs_delta_cw_prec_minus1 of an LMCS_APS shall be in the range of 0 to BitDepth 2, inclusive" );
 
-      CHECK( lmcsAPS->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+      CHECK_VTM( lmcsAPS->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
       //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
     }
   }
@@ -1398,7 +1398,7 @@ void activateAPS(PicHeader* picHeader, Slice* pSlice, ParameterSetManager& param
   if( picHeader->getExplicitScalingListEnabledFlag() && scalingListAPS == nullptr)
   {
     scalingListAPS = parameterSetManager.getAPS( picHeader->getScalingListAPSId(), SCALING_LIST_APS );
-    CHECK( scalingListAPS == nullptr, "No SCALING LIST APS present" );
+    CHECK_VTM( scalingListAPS == nullptr, "No SCALING LIST APS present" );
     if( scalingListAPS )
     {
       parameterSetManager.clearAPSChangedFlag( picHeader->getScalingListAPSId(), SCALING_LIST_APS );
@@ -1407,10 +1407,10 @@ void activateAPS(PicHeader* picHeader, Slice* pSlice, ParameterSetManager& param
         THROW( "SCALING LIST APS activation failed!" );
       }
 
-      CHECK( (sps->getChromaFormatIdc() == CHROMA_400 && scalingListAPS->chromaPresentFlag) || (sps->getChromaFormatIdc() != CHROMA_400 && !scalingListAPS->chromaPresentFlag),
+      CHECK_VTM( (sps->getChromaFormatIdc() == CHROMA_400 && scalingListAPS->chromaPresentFlag) || (sps->getChromaFormatIdc() != CHROMA_400 && !scalingListAPS->chromaPresentFlag),
         "The value of aps_chroma_present_flag of the APS NAL unit having aps_params_type equal to SCALING_APS and adaptation_parameter_set_id equal to ph_scaling_list_aps_id shall be equal to ChromaArrayType  = =  0 ? 0 : 1" );
 
-      CHECK( scalingListAPS->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+      CHECK_VTM( scalingListAPS->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
       //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
     }
   }
@@ -1424,7 +1424,7 @@ void DecLib::checkParameterSetsInclusionSEIconstraints(const InputNALUnit nalu)
   const APS* scalinglistAPS = m_pcPic->cs->scalinglistAps;
   APS** apss = m_parameterSetManager.getAPSs();
 
-  CHECK(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
+  CHECK_VTM(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
         pps->getTemporalId() == nalu.m_temporalId &&
         pps->getPuCounter() > m_puCounter, "Violating Parameter Sets Inclusion Indication SEI constraint");
 
@@ -1432,20 +1432,20 @@ void DecLib::checkParameterSetsInclusionSEIconstraints(const InputNALUnit nalu)
   {
     if (apss[i] != nullptr)
     {
-      CHECK(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
+      CHECK_VTM(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
             apss[i]->getTemporalId() == nalu.m_temporalId &&
             apss[i]->getPuCounter() > m_puCounter, "Violating Parameter Sets Inclusion Indication SEI constraint");
     }
   }
   if (lmcsAPS != nullptr)
   {
-    CHECK(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
+    CHECK_VTM(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
           lmcsAPS->getTemporalId() == nalu.m_temporalId &&
           lmcsAPS->getPuCounter() > m_puCounter, "Violating Parameter Sets Inclusion Indication SEI constraint");
   }
   if (scalinglistAPS != nullptr)
   {
-    CHECK(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
+    CHECK_VTM(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
           scalinglistAPS->getTemporalId() == nalu.m_temporalId &&
           scalinglistAPS->getPuCounter() > m_puCounter, "Violating Parameter Sets Inclusion Indication SEI constraint");
   }
@@ -1459,13 +1459,13 @@ void DecLib::xActivateParameterSets( const InputNALUnit nalu )
     APS** apss = m_parameterSetManager.getAPSs();
     memset(apss, 0, sizeof(*apss) * ALF_CTB_MAX_NUM_APS);
     const PPS *pps = m_parameterSetManager.getPPS(m_picHeader.getPPSId()); // this is a temporary PPS object. Do not store this value
-    CHECK(pps == 0, "Referred to PPS not present");
+    CHECK_VTM(pps == 0, "Referred to PPS not present");
 
     const SPS *sps = m_parameterSetManager.getSPS(pps->getSPSId());             // this is a temporary SPS object. Do not store this value
-    CHECK(sps == 0, "Referred to SPS not present");
+    CHECK_VTM(sps == 0, "Referred to SPS not present");
 
     const VPS *vps = m_parameterSetManager.getVPS( sps->getVPSId() );
-    CHECK(vps == 0, "Referred to VPS not present");
+    CHECK_VTM(vps == 0, "Referred to VPS not present");
 
     if( nullptr != pps->pcv )
     {
@@ -1492,7 +1492,7 @@ void DecLib::xActivateParameterSets( const InputNALUnit nalu )
     else
     {
       //VPS in the bitstream: check that SPS and VPS signalling are compatible
-      CHECK(sps->getMaxTLayers() > m_vps->getMaxSubLayers(), "The SPS signals more temporal sub-layers than allowed by the VPS");
+      CHECK_VTM(sps->getMaxTLayers() > m_vps->getMaxSubLayers(), "The SPS signals more temporal sub-layers than allowed by the VPS");
     }
 
     m_parameterSetManager.getApsMap()->clearActive();
@@ -1527,7 +1527,7 @@ void DecLib::xActivateParameterSets( const InputNALUnit nalu )
 
     m_pcPic->allocateNewSlice();
     // make the slice-pilot a real slice, and set up the slice-pilot for the next slice
-    CHECK(m_pcPic->slices.size() != (m_uiSliceSegmentIdx + 1), "Invalid number of slices");
+    CHECK_VTM(m_pcPic->slices.size() != (m_uiSliceSegmentIdx + 1), "Invalid number of slices");
     m_apcSlicePilot = m_pcPic->swapSliceObject(m_apcSlicePilot, m_uiSliceSegmentIdx);
 
     // we now have a real slice:
@@ -1624,7 +1624,7 @@ void DecLib::xActivateParameterSets( const InputNALUnit nalu )
   {
     // make the slice-pilot a real slice, and set up the slice-pilot for the next slice
     m_pcPic->allocateNewSlice();
-    CHECK(m_pcPic->slices.size() != (size_t)(m_uiSliceSegmentIdx + 1), "Invalid number of slices");
+    CHECK_VTM(m_pcPic->slices.size() != (size_t)(m_uiSliceSegmentIdx + 1), "Invalid number of slices");
     m_apcSlicePilot = m_pcPic->swapSliceObject(m_apcSlicePilot, m_uiSliceSegmentIdx);
 
     Slice *pSlice = m_pcPic->slices[m_uiSliceSegmentIdx]; // we now have a real slice.
@@ -1709,18 +1709,18 @@ void DecLib::xCheckParameterSetConstraints(const int layerId)
     {
       m_clsVPSid = sps->getVPSId();
     }
-    CHECK(m_clsVPSid != sps->getVPSId(), "The value of sps_video_parameter_set_id shall be the same in all SPSs that are referred to by CLVSs in a CVS.");
+    CHECK_VTM(m_clsVPSid != sps->getVPSId(), "The value of sps_video_parameter_set_id shall be the same in all SPSs that are referred to by CLVSs in a CVS.");
   }
 
   if (((vps!=nullptr)&&(vps->getVPSGeneralHrdParamsPresentFlag()))||(sps->getGeneralHrdParametersPresentFlag()))
   {
     if (((vps != nullptr) && (vps->getVPSGeneralHrdParamsPresentFlag())) && (sps->getGeneralHrdParametersPresentFlag()))
     {
-      CHECK(!(*vps->getGeneralHrdParameters() == *sps->getGeneralHrdParameters()), "It is a requirement of bitstream conformance that the content of the general_hrd_parameters( ) syntax structure present in any VPSs or SPSs in the bitstream shall be identical");
+      CHECK_VTM(!(*vps->getGeneralHrdParameters() == *sps->getGeneralHrdParameters()), "It is a requirement of bitstream conformance that the content of the general_hrd_parameters( ) syntax structure present in any VPSs or SPSs in the bitstream shall be identical");
     }
     if (!m_isFirstGeneralHrd)
     {
-      CHECK(!(m_prevGeneralHrdParams == (sps->getGeneralHrdParametersPresentFlag() ? *sps->getGeneralHrdParameters() : *vps->getGeneralHrdParameters())), "It is a requirement of bitstream conformance that the content of the general_hrd_parameters( ) syntax structure present in any VPSs or SPSs in the bitstream shall be identical");
+      CHECK_VTM(!(m_prevGeneralHrdParams == (sps->getGeneralHrdParametersPresentFlag() ? *sps->getGeneralHrdParameters() : *vps->getGeneralHrdParameters())), "It is a requirement of bitstream conformance that the content of the general_hrd_parameters( ) syntax structure present in any VPSs or SPSs in the bitstream shall be identical");
     }
     m_prevGeneralHrdParams = (sps->getGeneralHrdParametersPresentFlag() ? *sps->getGeneralHrdParameters() : *vps->getGeneralHrdParameters());
   }
@@ -1732,44 +1732,44 @@ void DecLib::xCheckParameterSetConstraints(const int layerId)
     m_clvssSPSid[layerId] = pps->getSPSId();
   }
 
-  CHECK( m_clvssSPSid[layerId] != pps->getSPSId(), "The value of pps_seq_parameter_set_id shall be the same in all PPSs that are referred to by coded pictures in a CLVS" );
+  CHECK_VTM( m_clvssSPSid[layerId] != pps->getSPSId(), "The value of pps_seq_parameter_set_id shall be the same in all PPSs that are referred to by coded pictures in a CLVS" );
 
-  CHECK(sps->getGDREnabledFlag() == false && m_picHeader.getGdrPicFlag(), "When sps_gdr_enabled_flag is equal to 0, the value of ph_gdr_pic_flag shall be equal to 0 ");
+  CHECK_VTM(sps->getGDREnabledFlag() == false && m_picHeader.getGdrPicFlag(), "When sps_gdr_enabled_flag is equal to 0, the value of ph_gdr_pic_flag shall be equal to 0 ");
   if( !sps->getUseWP() )
   {
-    CHECK( pps->getUseWP(), "When sps_weighted_pred_flag is equal to 0, the value of pps_weighted_pred_flag shall be equal to 0." );
+    CHECK_VTM( pps->getUseWP(), "When sps_weighted_pred_flag is equal to 0, the value of pps_weighted_pred_flag shall be equal to 0." );
   }
 
   if( !sps->getUseWPBiPred() )
   {
-    CHECK( pps->getWPBiPred(), "When sps_weighted_bipred_flag is equal to 0, the value of pps_weighted_bipred_flag shall be equal to 0." );
+    CHECK_VTM( pps->getWPBiPred(), "When sps_weighted_bipred_flag is equal to 0, the value of pps_weighted_bipred_flag shall be equal to 0." );
   }
 
   const int minCuSize = 1 << sps->getLog2MinCodingBlockSize();
-  CHECK( ( pps->getPicWidthInLumaSamples() % ( std::max( 8, minCuSize) ) ) != 0, "Coded frame width must be a multiple of Max(8, the minimum unit size)" );
-  CHECK( ( pps->getPicHeightInLumaSamples() % ( std::max( 8, minCuSize) ) ) != 0, "Coded frame height must be a multiple of Max(8, the minimum unit size)" );
+  CHECK_VTM( ( pps->getPicWidthInLumaSamples() % ( std::max( 8, minCuSize) ) ) != 0, "Coded frame width must be a multiple of Max(8, the minimum unit size)" );
+  CHECK_VTM( ( pps->getPicHeightInLumaSamples() % ( std::max( 8, minCuSize) ) ) != 0, "Coded frame height must be a multiple of Max(8, the minimum unit size)" );
   if (!sps->getResChangeInClvsEnabledFlag())
   {
-    CHECK(pps->getPicWidthInLumaSamples() != sps->getMaxPicWidthInLumaSamples(), "When sps_res_change_in_clvs_allowed_flag equal to 0, the value of pps_pic_width_in_luma_samples shall be equal to sps_pic_width_max_in_luma_samples.");
-    CHECK(pps->getPicHeightInLumaSamples() != sps->getMaxPicHeightInLumaSamples(), "When sps_res_change_in_clvs_allowed_flag equal to 0, the value of pps_pic_height_in_luma_samples shall be equal to sps_pic_height_max_in_luma_samples.");
+    CHECK_VTM(pps->getPicWidthInLumaSamples() != sps->getMaxPicWidthInLumaSamples(), "When sps_res_change_in_clvs_allowed_flag equal to 0, the value of pps_pic_width_in_luma_samples shall be equal to sps_pic_width_max_in_luma_samples.");
+    CHECK_VTM(pps->getPicHeightInLumaSamples() != sps->getMaxPicHeightInLumaSamples(), "When sps_res_change_in_clvs_allowed_flag equal to 0, the value of pps_pic_height_in_luma_samples shall be equal to sps_pic_height_max_in_luma_samples.");
   }
   if (sps->getResChangeInClvsEnabledFlag())
   {
-    CHECK(sps->getSubPicInfoPresentFlag() != 0, "When sps_res_change_in_clvs_allowed_flag is equal to 1, the value of sps_subpic_info_present_flag shall be equal to 0.");
+    CHECK_VTM(sps->getSubPicInfoPresentFlag() != 0, "When sps_res_change_in_clvs_allowed_flag is equal to 1, the value of sps_subpic_info_present_flag shall be equal to 0.");
   }
-  CHECK(sps->getResChangeInClvsEnabledFlag() && sps->getVirtualBoundariesEnabledFlag(), "when the value of sps_res_change_in_clvs_allowed_flag is equal to 1, the value of sps_virtual_boundaries_present_flag shall be equal to 0");
+  CHECK_VTM(sps->getResChangeInClvsEnabledFlag() && sps->getVirtualBoundariesEnabledFlag(), "when the value of sps_res_change_in_clvs_allowed_flag is equal to 1, the value of sps_virtual_boundaries_present_flag shall be equal to 0");
 
   if( sps->getCTUSize() + 2 * ( 1 << sps->getLog2MinCodingBlockSize() ) > pps->getPicWidthInLumaSamples() )
   {
-    CHECK( pps->getWrapAroundEnabledFlag(), "Wraparound shall be disabled when the value of ( CtbSizeY / MinCbSizeY + 1) is greater than or equal to ( pps_pic_width_in_luma_samples / MinCbSizeY - 1 )" );
+    CHECK_VTM( pps->getWrapAroundEnabledFlag(), "Wraparound shall be disabled when the value of ( CtbSizeY / MinCbSizeY + 1) is greater than or equal to ( pps_pic_width_in_luma_samples / MinCbSizeY - 1 )" );
   }
 
   if( vps != nullptr && vps->m_numOutputLayersInOls[vps->m_targetOlsIdx] > 1 )
   {
-    CHECK( sps->getMaxPicWidthInLumaSamples() > vps->getOlsDpbPicSize( vps->m_targetOlsIdx ).width, "sps_pic_width_max_in_luma_samples shall be less than or equal to the value of vps_ols_dpb_pic_width[ i ]" );
-    CHECK( sps->getMaxPicHeightInLumaSamples() > vps->getOlsDpbPicSize( vps->m_targetOlsIdx ).height, "sps_pic_height_max_in_luma_samples shall be less than or equal to the value of vps_ols_dpb_pic_height[ i ]" );
-    CHECK( sps->getChromaFormatIdc() > vps->getOlsDpbChromaFormatIdc( vps->m_targetOlsIdx ), "sps_chroma_format_idc shall be less than or equal to the value of vps_ols_dpb_chroma_format[ i ]");
-    CHECK((sps->getBitDepth(CHANNEL_TYPE_LUMA) - 8) > vps->getOlsDpbBitDepthMinus8(vps->m_targetOlsIdx),
+    CHECK_VTM( sps->getMaxPicWidthInLumaSamples() > vps->getOlsDpbPicSize( vps->m_targetOlsIdx ).width, "sps_pic_width_max_in_luma_samples shall be less than or equal to the value of vps_ols_dpb_pic_width[ i ]" );
+    CHECK_VTM( sps->getMaxPicHeightInLumaSamples() > vps->getOlsDpbPicSize( vps->m_targetOlsIdx ).height, "sps_pic_height_max_in_luma_samples shall be less than or equal to the value of vps_ols_dpb_pic_height[ i ]" );
+    CHECK_VTM( sps->getChromaFormatIdc() > vps->getOlsDpbChromaFormatIdc( vps->m_targetOlsIdx ), "sps_chroma_format_idc shall be less than or equal to the value of vps_ols_dpb_chroma_format[ i ]");
+    CHECK_VTM((sps->getBitDepth(CHANNEL_TYPE_LUMA) - 8) > vps->getOlsDpbBitDepthMinus8(vps->m_targetOlsIdx),
           "sps_bitdepth_minus8 shall be less than or equal to the value of vps_ols_dpb_bitdepth_minus8[ i ]");
   }
 
@@ -1789,8 +1789,8 @@ void DecLib::xCheckParameterSetConstraints(const int layerId)
     }
     else
     {
-      CHECK(m_layerChromaFormat[curLayerIdx] != curLayerChromaFormat, "Different chroma format in the same layer.");
-      CHECK(m_layerBitDepth[curLayerIdx] != curLayerBitDepth, "Different bit-depth in the same layer.");
+      CHECK_VTM(m_layerChromaFormat[curLayerIdx] != curLayerChromaFormat, "Different chroma format in the same layer.");
+      CHECK_VTM(m_layerBitDepth[curLayerIdx] != curLayerBitDepth, "Different bit-depth in the same layer.");
     }
 
     for (int i = 0; i < curLayerIdx; i++)
@@ -1798,75 +1798,75 @@ void DecLib::xCheckParameterSetConstraints(const int layerId)
       if (vps->getDirectRefLayerFlag(curLayerIdx, i))
       {
         int refLayerChromaFormat = m_layerChromaFormat[i];
-        CHECK(curLayerChromaFormat != refLayerChromaFormat, "The chroma formats of the current layer and the reference layer are different");
+        CHECK_VTM(curLayerChromaFormat != refLayerChromaFormat, "The chroma formats of the current layer and the reference layer are different");
         int refLayerBitDepth = m_layerBitDepth[i];
-        CHECK(curLayerBitDepth != refLayerBitDepth, "The bit-depth of the current layer and the reference layer are different");
+        CHECK_VTM(curLayerBitDepth != refLayerBitDepth, "The bit-depth of the current layer and the reference layer are different");
       }
     }
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getOneTilePerPicConstraintFlag())
   {
-    CHECK(pps->getNumTiles() != 1, "When one_tile_per_pic_constraint_flag is equal to 1, each picture shall contain only one tile");
+    CHECK_VTM(pps->getNumTiles() != 1, "When one_tile_per_pic_constraint_flag is equal to 1, each picture shall contain only one tile");
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getOneSlicePerPicConstraintFlag())
   {
-    CHECK( pps->getRectSliceFlag() && pps->getNumSlicesInPic() != 1, "When one_slice_per_pic_constraint_flag is equal to 1 and if pps_rect_slice_flag is equal to 1, the value of pps_num_slices_in_pic_minus1 shall be equal to 0");
+    CHECK_VTM( pps->getRectSliceFlag() && pps->getNumSlicesInPic() != 1, "When one_slice_per_pic_constraint_flag is equal to 1 and if pps_rect_slice_flag is equal to 1, the value of pps_num_slices_in_pic_minus1 shall be equal to 0");
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoRprConstraintFlag())
   {
-    CHECK(sps->getRprEnabledFlag(), "When gci_no_ref_pic_resampling_constraint_flag is equal to 1, the value of sps_ref_pic_resampling_enabled_flag shall be equal to 0");
+    CHECK_VTM(sps->getRprEnabledFlag(), "When gci_no_ref_pic_resampling_constraint_flag is equal to 1, the value of sps_ref_pic_resampling_enabled_flag shall be equal to 0");
   }
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoResChangeInClvsConstraintFlag())
   {
-    CHECK(sps->getResChangeInClvsEnabledFlag(), "When gci_no_res_change_in_clvs_constraint_flag is equal to 1, the value of sps_res_change_in_clvs_allowed_flag shall be equal to 0");
+    CHECK_VTM(sps->getResChangeInClvsEnabledFlag(), "When gci_no_res_change_in_clvs_constraint_flag is equal to 1, the value of sps_res_change_in_clvs_allowed_flag shall be equal to 0");
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoIdrRplConstraintFlag())
   {
-    CHECK(sps->getIDRRefParamListPresent(), "When gci_no_idr_rpl_constraint_flag equal to 1 , the value of sps_idr_rpl_present_flag shall be equal to 0")
+    CHECK_VTM(sps->getIDRRefParamListPresent(), "When gci_no_idr_rpl_constraint_flag equal to 1 , the value of sps_idr_rpl_present_flag shall be equal to 0")
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoMixedNaluTypesInPicConstraintFlag())
   {
-    CHECK(pps->getMixedNaluTypesInPicFlag(), "When gci_no_mixed_nalu_types_in_pic_constraint_flag equal to 1, the value of pps_mixed_nalu_types_in_pic_flag shall be equal to 0")
+    CHECK_VTM(pps->getMixedNaluTypesInPicFlag(), "When gci_no_mixed_nalu_types_in_pic_constraint_flag equal to 1, the value of pps_mixed_nalu_types_in_pic_flag shall be equal to 0")
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoRectSliceConstraintFlag())
   {
-    CHECK(pps->getRectSliceFlag(), "When gci_no_rectangular_slice_constraint_flag equal to 1, the value of pps_rect_slice_flag shall be equal to 0")
+    CHECK_VTM(pps->getRectSliceFlag(), "When gci_no_rectangular_slice_constraint_flag equal to 1, the value of pps_rect_slice_flag shall be equal to 0")
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getOneSlicePerSubpicConstraintFlag())
   {
-    CHECK(!(pps->getSingleSlicePerSubPicFlag()), "When gci_one_slice_per_subpic_constraint_flag equal to 1, the value of pps_single_slice_per_subpic_flag shall be equal to 1")
+    CHECK_VTM(!(pps->getSingleSlicePerSubPicFlag()), "When gci_one_slice_per_subpic_constraint_flag equal to 1, the value of pps_single_slice_per_subpic_flag shall be equal to 1")
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoSubpicInfoConstraintFlag())
   {
-    CHECK(sps->getSubPicInfoPresentFlag(), "When gci_no_subpic_info_constraint_flag is equal to 1, the value of sps_subpic_info_present_flag shall be equal to 0")
+    CHECK_VTM(sps->getSubPicInfoPresentFlag(), "When gci_no_subpic_info_constraint_flag is equal to 1, the value of sps_subpic_info_present_flag shall be equal to 0")
   }
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoMttConstraintFlag())
   {
-    CHECK((sps->getMaxMTTHierarchyDepth() || sps->getMaxMTTHierarchyDepthI() || sps->getMaxMTTHierarchyDepthIChroma()), "When gci_no_mtt_constraint_flag is equal to 1, the values of sps_max_mtt_hierarchy_depth_intra_slice_luma, sps_max_mtt_hierarchy_depth_inter_slice and sps_max_mtt_hierarchy_depth_intra_slice_chroma shall be equal to 0");
+    CHECK_VTM((sps->getMaxMTTHierarchyDepth() || sps->getMaxMTTHierarchyDepthI() || sps->getMaxMTTHierarchyDepthIChroma()), "When gci_no_mtt_constraint_flag is equal to 1, the values of sps_max_mtt_hierarchy_depth_intra_slice_luma, sps_max_mtt_hierarchy_depth_inter_slice and sps_max_mtt_hierarchy_depth_intra_slice_chroma shall be equal to 0");
   }
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoWeightedPredictionConstraintFlag())
   {
-    CHECK((sps->getUseWP() || sps->getUseWPBiPred()), "When gci_no_weighted_prediction_constraint_flag is equal to 1, the values of sps_weighted_pred_flag and sps_weighted_bipred_flag shall be equal to 0");
+    CHECK_VTM((sps->getUseWP() || sps->getUseWPBiPred()), "When gci_no_weighted_prediction_constraint_flag is equal to 1, the values of sps_weighted_pred_flag and sps_weighted_bipred_flag shall be equal to 0");
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoChromaQpOffsetConstraintFlag())
   {
-    CHECK((pps->getCuChromaQpOffsetListEnabledFlag()), "When gci_no_ChromaQpOffset_constraint_flag is equal to 1, the values of pps_cu_chroma_qp_offset_list_enabled_flag shall be equal to 0");
+    CHECK_VTM((pps->getCuChromaQpOffsetListEnabledFlag()), "When gci_no_ChromaQpOffset_constraint_flag is equal to 1, the values of pps_cu_chroma_qp_offset_list_enabled_flag shall be equal to 0");
   }
 
-  CHECK(sps->getCTUSize() > (1 << sps->getProfileTierLevel()->getConstraintInfo()->getMaxLog2CtuSizeConstraintIdc()), "The CTU size specified by sps_log2_ctu_size_minus5 shall not exceed the constraint specified by gci_three_minus_max_log2_ctu_size_constraint_idc");
+  CHECK_VTM(sps->getCTUSize() > (1 << sps->getProfileTierLevel()->getConstraintInfo()->getMaxLog2CtuSizeConstraintIdc()), "The CTU size specified by sps_log2_ctu_size_minus5 shall not exceed the constraint specified by gci_three_minus_max_log2_ctu_size_constraint_idc");
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoLumaTransformSize64ConstraintFlag())
   {
-    CHECK(sps->getLog2MaxTbSize() != 5, "When gci_no_luma_transform_size_64_constraint_flag is equal to 1, the value of sps_max_luma_transform_size_64_flag shall be equal to 0");
+    CHECK_VTM(sps->getLog2MaxTbSize() != 5, "When gci_no_luma_transform_size_64_constraint_flag is equal to 1, the value of sps_max_luma_transform_size_64_flag shall be equal to 0");
   }
 
   if (sps->getMaxPicWidthInLumaSamples() == pps->getPicWidthInLumaSamples() &&
@@ -1874,10 +1874,10 @@ void DecLib::xCheckParameterSetConstraints(const int layerId)
   {
     const Window& spsConfWin = sps->getConformanceWindow();
     const Window& ppsConfWin = pps->getConformanceWindow();
-    CHECK(spsConfWin.getWindowLeftOffset() != ppsConfWin.getWindowLeftOffset(), "When picture size is equal to maximum picutre size, conformance window left offset in SPS and PPS shall be equal");
-    CHECK(spsConfWin.getWindowRightOffset() != ppsConfWin.getWindowRightOffset(), "When picture size is equal to maximum picutre size, conformance window right offset in SPS and PPS shall be equal");
-    CHECK(spsConfWin.getWindowTopOffset() != ppsConfWin.getWindowTopOffset(), "When picture size is equal to maximum picutre size, conformance window top offset in SPS and PPS shall be equal");
-    CHECK(spsConfWin.getWindowBottomOffset() != ppsConfWin.getWindowBottomOffset(), "When picture size is equal to maximum picutre size, conformance window bottom offset in SPS and PPS shall be equal");
+    CHECK_VTM(spsConfWin.getWindowLeftOffset() != ppsConfWin.getWindowLeftOffset(), "When picture size is equal to maximum picutre size, conformance window left offset in SPS and PPS shall be equal");
+    CHECK_VTM(spsConfWin.getWindowRightOffset() != ppsConfWin.getWindowRightOffset(), "When picture size is equal to maximum picutre size, conformance window right offset in SPS and PPS shall be equal");
+    CHECK_VTM(spsConfWin.getWindowTopOffset() != ppsConfWin.getWindowTopOffset(), "When picture size is equal to maximum picutre size, conformance window top offset in SPS and PPS shall be equal");
+    CHECK_VTM(spsConfWin.getWindowBottomOffset() != ppsConfWin.getWindowBottomOffset(), "When picture size is equal to maximum picutre size, conformance window bottom offset in SPS and PPS shall be equal");
   }
   int levelIdcSps = int(sps->getProfileTierLevel()->getLevelIdc());
   int maxLevelIdxDci = 0;
@@ -1890,19 +1890,19 @@ void DecLib::xCheckParameterSetConstraints(const int layerId)
         maxLevelIdxDci = int(m_dci->getProfileTierLevel(i).getLevelIdc());
       }
     }
-    CHECK(levelIdcSps > maxLevelIdxDci, "max level signaled in the DCI shall not be less than the level signaled in the SPS");
+    CHECK_VTM(levelIdcSps > maxLevelIdxDci, "max level signaled in the DCI shall not be less than the level signaled in the SPS");
   }
 
 
   if( slice->getPicHeader()->getGdrOrIrapPicFlag() && !slice->getPicHeader()->getGdrPicFlag() && ( !vps || vps->getIndependentLayerFlag( vps->getGeneralLayerIdx( layerId ) ) ) )
   {
-    CHECK( slice->getPicHeader()->getPicInterSliceAllowedFlag(),
+    CHECK_VTM( slice->getPicHeader()->getPicInterSliceAllowedFlag(),
       "When ph_gdr_or_irap_pic_flag is equal to 1 and ph_gdr_pic_flag is equal to 0 and vps_independent_layer_flag[ GeneralLayerIdx[ nuh_layer_id ] ] is equal to 1, ph_inter_slice_allowed_flag shall be equal to 0" );
   }
 
   if( sps->getVPSId() && vps->m_numLayersInOls[vps->m_targetOlsIdx] == 1 )
-  {    
-    CHECK( !sps->getPtlDpbHrdParamsPresentFlag(), "When sps_video_parameter_set_id is greater than 0 and there is an OLS that contains only one layer with nuh_layer_id equal to the nuh_layer_id of the SPS, the value of sps_ptl_dpb_hrd_params_present_flag shall be equal to 1" );
+  {
+    CHECK_VTM( !sps->getPtlDpbHrdParamsPresentFlag(), "When sps_video_parameter_set_id is greater than 0 and there is an OLS that contains only one layer with nuh_layer_id equal to the nuh_layer_id of the SPS, the value of sps_ptl_dpb_hrd_params_present_flag shall be equal to 1" );
   }
 
   ProfileLevelTierFeatures ptlFeatures;
@@ -1910,25 +1910,25 @@ void DecLib::xCheckParameterSetConstraints(const int layerId)
   const ProfileFeatures *profileFeatures = ptlFeatures.getProfileFeatures();
   if (profileFeatures != nullptr)
   {
-    CHECK(sps->getBitDepth(CHANNEL_TYPE_LUMA) > profileFeatures->maxBitDepth, "Bit depth exceeds profile limit");
-    CHECK(sps->getChromaFormatIdc() > profileFeatures->maxChromaFormat, "Chroma format exceeds profile limit");
+    CHECK_VTM(sps->getBitDepth(CHANNEL_TYPE_LUMA) > profileFeatures->maxBitDepth, "Bit depth exceeds profile limit");
+    CHECK_VTM(sps->getChromaFormatIdc() > profileFeatures->maxChromaFormat, "Chroma format exceeds profile limit");
   }
   else
   {
-    CHECK(sps->getProfileTierLevel()->getProfileIdc() != Profile::NONE, "Unknown profile");
+    CHECK_VTM(sps->getProfileTierLevel()->getProfileIdc() != Profile::NONE, "Unknown profile");
     msg(WARNING, "Warning: Profile set to none or unknown value\n");
   }
   const LevelTierFeatures *levelTierFeatures = ptlFeatures.getLevelTierFeatures();
   if (levelTierFeatures != nullptr)
   {
-    CHECK(pps->getNumTileColumns() > levelTierFeatures->maxTileCols,
+    CHECK_VTM(pps->getNumTileColumns() > levelTierFeatures->maxTileCols,
           "Number of tile columns signaled in PPS exceeds level limit");
-    CHECK(pps->getNumTiles() > levelTierFeatures->maxTilesPerAu, "Number of tiles signaled in PPS exceeds level limit");
+    CHECK_VTM(pps->getNumTiles() > levelTierFeatures->maxTilesPerAu, "Number of tiles signaled in PPS exceeds level limit");
   }
   else if (profileFeatures != nullptr)
   {
-    CHECK(sps->getProfileTierLevel()->getLevelIdc() == Level::LEVEL15_5, "Cannot use level 15.5 with given profile");
-    CHECK(sps->getProfileTierLevel()->getLevelIdc() != Level::NONE, "Unknown level");
+    CHECK_VTM(sps->getProfileTierLevel()->getLevelIdc() == Level::LEVEL15_5, "Cannot use level 15.5 with given profile");
+    CHECK_VTM(sps->getProfileTierLevel()->getLevelIdc() != Level::NONE, "Unknown level");
     msg(WARNING, "Warning: Level set to none, invalid or unknown value\n");
   }
 }
@@ -1985,7 +1985,7 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
   }
   else
   {
-    CHECK(nalu.m_nalUnitType != m_pcPic->slices[m_uiSliceSegmentIdx - 1]->getNalUnitType() && !m_pcPic->cs->pps->getMixedNaluTypesInPicFlag(), "If pps_mixed_nalu_types_in_pic_flag is equal to 0, the value of NAL unit type shall be the same for all coded slice NAL units of a picture");
+    CHECK_VTM(nalu.m_nalUnitType != m_pcPic->slices[m_uiSliceSegmentIdx - 1]->getNalUnitType() && !m_pcPic->cs->pps->getMixedNaluTypesInPicFlag(), "If pps_mixed_nalu_types_in_pic_flag is equal to 0, the value of NAL unit type shall be the same for all coded slice NAL units of a picture");
     m_apcSlicePilot->copySliceInfo( m_pcPic->slices[m_uiSliceSegmentIdx-1] );
   }
 
@@ -2003,13 +2003,13 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
       && naluTemporalId.m_nalUnitType != NAL_UNIT_EOB)
 
     {
-      CHECK( naluTemporalId.m_temporalId < nalu.m_temporalId, "TemporalId shall be greater than or equal to the TemporalId of the layer access unit containing the NAL unit" );
+      CHECK_VTM( naluTemporalId.m_temporalId < nalu.m_temporalId, "TemporalId shall be greater than or equal to the TemporalId of the layer access unit containing the NAL unit" );
     }
   }
 
   if (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_GDR)
   {
-    CHECK(nalu.m_temporalId != 0, "Current GDR picture has TemporalId not equal to 0");
+    CHECK_VTM(nalu.m_temporalId != 0, "Current GDR picture has TemporalId not equal to 0");
   }
 
   m_HLSReader.setBitstream( &nalu.getBitstream() );
@@ -2022,15 +2022,15 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
   }
 
   PPS *pps = m_parameterSetManager.getPPS(m_picHeader.getPPSId());
-  CHECK(pps == 0, "No PPS present");
+  CHECK_VTM(pps == 0, "No PPS present");
   SPS *sps = m_parameterSetManager.getSPS(pps->getSPSId());
-  CHECK(sps == 0, "No SPS present");
+  CHECK_VTM(sps == 0, "No SPS present");
   VPS *vps = m_parameterSetManager.getVPS(sps->getVPSId());
 
 
   if (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA && vps != nullptr && (vps->getIndependentLayerFlag(vps->getGeneralLayerIdx(nalu.m_nuhLayerId)) == 1))
   {
-    CHECK(nalu.m_temporalId == 0, "TemporalID of STSA picture shall not be zero in independent layers");
+    CHECK_VTM(nalu.m_temporalId == 0, "TemporalID of STSA picture shall not be zero in independent layers");
   }
 
   int currSubPicIdx = pps->getSubPicIdxFromSubPicId( m_apcSlicePilot->getSliceSubPicId() );
@@ -2039,8 +2039,8 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
   {
     currSliceAddr -= pps->getSubPic(sp).getNumSlicesInSubPic();
   }
-  CHECK( currSubPicIdx < m_maxDecSubPicIdx, "Error in the order of coded slice NAL units of subpictures" );
-  CHECK( currSubPicIdx == m_maxDecSubPicIdx && currSliceAddr <= m_maxDecSliceAddrInSubPic, "Error in the order of coded slice NAL units within a subpicture" );
+  CHECK_VTM( currSubPicIdx < m_maxDecSubPicIdx, "Error in the order of coded slice NAL units of subpictures" );
+  CHECK_VTM( currSubPicIdx == m_maxDecSubPicIdx && currSliceAddr <= m_maxDecSliceAddrInSubPic, "Error in the order of coded slice NAL units within a subpicture" );
   if( currSubPicIdx == m_maxDecSubPicIdx )
   {
     m_maxDecSliceAddrInSubPic = currSliceAddr;
@@ -2052,10 +2052,10 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
   }
   if ((sps->getVPSId() == 0) && (m_prevLayerID != MAX_INT))
   {
-    CHECK(m_prevLayerID != nalu.m_nuhLayerId, "All VCL NAL unit in the CVS shall have the same value of nuh_layer_id "
+    CHECK_VTM(m_prevLayerID != nalu.m_nuhLayerId, "All VCL NAL unit in the CVS shall have the same value of nuh_layer_id "
                                               "when sps_video_parameter_set_id is equal to 0");
   }
-  CHECK((sps->getVPSId() > 0) && (vps == 0), "Invalid VPS");
+  CHECK_VTM((sps->getVPSId() > 0) && (vps == 0), "Invalid VPS");
 
   if( vps != nullptr && !vps->getIndependentLayerFlag( vps->getGeneralLayerIdx( nalu.m_nuhLayerId ) ) )
   {
@@ -2171,13 +2171,13 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
 
   {
     PPS *pps = m_parameterSetManager.getPPS(m_picHeader.getPPSId());
-    CHECK(pps == 0, "No PPS present");
+    CHECK_VTM(pps == 0, "No PPS present");
     SPS *sps = m_parameterSetManager.getSPS(pps->getSPSId());
-    CHECK(sps == 0, "No SPS present");
+    CHECK_VTM(sps == 0, "No SPS present");
     if (sps->getVPSId() > 0)
     {
       VPS *vps = m_parameterSetManager.getVPS(sps->getVPSId());
-      CHECK(vps == 0, "No VPS present");
+      CHECK_VTM(vps == 0, "No VPS present");
       bool isCurLayerNotOutput = true;
       for (int i = 0; i < vps->getNumLayersInOls(vps->m_targetOlsIdx); i++)
       {
@@ -2315,12 +2315,12 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
   if (pcSlice->getSPS()->getProfileTierLevel()->getConstraintInfo()->getNoApsConstraintFlag())
   {
     bool flag = pcSlice->getSPS()->getCCALFEnabledFlag() || pcSlice->getPicHeader()->getNumAlfAps() || pcSlice->getPicHeader()->getAlfEnabledFlag(COMPONENT_Cb) || pcSlice->getPicHeader()->getAlfEnabledFlag(COMPONENT_Cr);
-    CHECK(flag, "When no_aps_constraint_flag is equal to 1, the values of ph_num_alf_aps_ids_luma, sh_num_alf_aps_ids_luma, ph_alf_cb_flag, ph_alf_cr_flag, sh_alf_cb_flag, sh_alf_cr_flag, and sps_ccalf_enabled_flag shall all be equal to 0")
+    CHECK_VTM(flag, "When no_aps_constraint_flag is equal to 1, the values of ph_num_alf_aps_ids_luma, sh_num_alf_aps_ids_luma, ph_alf_cb_flag, ph_alf_cr_flag, sh_alf_cb_flag, sh_alf_cr_flag, and sps_ccalf_enabled_flag shall all be equal to 0")
   }
   if( pcSlice->getNalUnitLayerId() != pcSlice->getSPS()->getLayerId() )
   {
-    CHECK( pcSlice->getSPS()->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of SPS cannot be greater than layer Id of VCL NAL unit the refer to it" );
-    CHECK( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of SPS and layer Id of current slice are different" );
+    CHECK_VTM( pcSlice->getSPS()->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of SPS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+    CHECK_VTM( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of SPS and layer Id of current slice are different" );
     for (int i = 0; i < pcSlice->getVPS()->getNumOutputLayerSets(); i++ )
     {
       bool isCurrLayerInOls = false;
@@ -2337,13 +2337,13 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
           isRefLayerInOls = true;
         }
       }
-      CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to SPS in layer B, all OLS that contains layer A shall also contains layer B" );
+      CHECK_VTM( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to SPS in layer B, all OLS that contains layer A shall also contains layer B" );
     }
   }
   if( pcSlice->getNalUnitLayerId() != pcSlice->getPPS()->getLayerId() )
   {
-    CHECK( pcSlice->getPPS()->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of PPS cannot be greater than layer Id of VCL NAL unit the refer to it" );
-    CHECK( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of PPS and layer Id of current slice are different" );
+    CHECK_VTM( pcSlice->getPPS()->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of PPS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+    CHECK_VTM( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of PPS and layer Id of current slice are different" );
     for (int i = 0; i < pcSlice->getVPS()->getNumOutputLayerSets(); i++ )
     {
       bool isCurrLayerInOls = false;
@@ -2360,7 +2360,7 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
           isRefLayerInOls = true;
         }
       }
-      CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to PPS in layer B, all OLS that contains layer A shall also contains layer B" );
+      CHECK_VTM( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to PPS in layer B, all OLS that contains layer A shall also contains layer B" );
     }
   }
 
@@ -2532,8 +2532,8 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
     APS* scalingListAPS = pcSlice->getPicHeader()->getScalingListAPS();
     if( pcSlice->getNalUnitLayerId() != scalingListAPS->getLayerId() )
     {
-      CHECK( scalingListAPS->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
-      CHECK( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
+      CHECK_VTM( scalingListAPS->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+      CHECK_VTM( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
       for (int i = 0; i < pcSlice->getVPS()->getNumOutputLayerSets(); i++ )
       {
         bool isCurrLayerInOls = false;
@@ -2549,7 +2549,7 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
             isRefLayerInOls = true;
           }
         }
-        CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
+        CHECK_VTM( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
       }
     }
     ScalingList scalingList = scalingListAPS->getScalingList();
@@ -2574,12 +2574,12 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
       }
       else
       {
-        CHECK(lmcsAPS->getAPSId() != m_sliceLmcsApsId, "same APS ID shall be used for all slices in one picture");
+        CHECK_VTM(lmcsAPS->getAPSId() != m_sliceLmcsApsId, "same APS ID shall be used for all slices in one picture");
       }
       if( pcSlice->getNalUnitLayerId() != lmcsAPS->getLayerId() )
       {
-        CHECK( lmcsAPS->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
-        CHECK( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
+        CHECK_VTM( lmcsAPS->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+        CHECK_VTM( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
         for (int i = 0; i < pcSlice->getVPS()->getNumOutputLayerSets(); i++ )
         {
           bool isCurrLayerInOls = false;
@@ -2595,7 +2595,7 @@ bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDispl
               isRefLayerInOls = true;
             }
           }
-          CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
+          CHECK_VTM( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
         }
       }
       SliceReshapeInfo& sInfo = lmcsAPS->getReshaperAPSInfo();
@@ -2711,7 +2711,7 @@ void DecLib::xDecodeVPS( InputNALUnit& nalu )
   VPS* vps = new VPS();
   m_HLSReader.setBitstream( &nalu.getBitstream() );
 
-  CHECK( nalu.m_temporalId, "The value of TemporalId of VPS NAL units shall be equal to 0" );
+  CHECK_VTM( nalu.m_temporalId, "The value of TemporalId of VPS NAL units shall be equal to 0" );
 
   m_HLSReader.parseVPS( vps );
 
@@ -2731,7 +2731,7 @@ void DecLib::xDecodeDCI(InputNALUnit& nalu)
 {
   m_HLSReader.setBitstream(&nalu.getBitstream());
 
-  CHECK(nalu.m_temporalId, "The value of TemporalId of DCI NAL units shall be equal to 0");
+  CHECK_VTM(nalu.m_temporalId, "The value of TemporalId of DCI NAL units shall be equal to 0");
   if (!m_dci)
   {
     m_dci = new DCI;
@@ -2741,7 +2741,7 @@ void DecLib::xDecodeDCI(InputNALUnit& nalu)
   {
     DCI dupDCI;
     m_HLSReader.parseDCI(&dupDCI);
-    CHECK( !m_dci->IsIndenticalDCI(dupDCI), "Two signaled DCIs are different");
+    CHECK_VTM( !m_dci->IsIndenticalDCI(dupDCI), "Two signaled DCIs are different");
   }
 }
 
@@ -2750,7 +2750,7 @@ void DecLib::xDecodeSPS( InputNALUnit& nalu )
   SPS* sps = new SPS();
   m_HLSReader.setBitstream( &nalu.getBitstream() );
 
-  CHECK( nalu.m_temporalId, "The value of TemporalId of SPS NAL units shall be equal to 0" );
+  CHECK_VTM( nalu.m_temporalId, "The value of TemporalId of SPS NAL units shall be equal to 0" );
 
   m_HLSReader.parseSPS( sps );
   sps->setLayerId( nalu.m_nuhLayerId );
@@ -2987,25 +2987,25 @@ void DecLib::xCheckNalUnitConstraintFlags( const ConstraintInfo *cInfo, uint32_t
 {
   if (cInfo != NULL)
   {
-    CHECK(cInfo->getNoTrailConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_TRAIL,
+    CHECK_VTM(cInfo->getNoTrailConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_TRAIL,
       "Non-conforming bitstream. no_trail_constraint_flag is equal to 1 but bitstream contains NAL unit of type TRAIL_NUT.");
-    CHECK(cInfo->getNoStsaConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_STSA,
+    CHECK_VTM(cInfo->getNoStsaConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_STSA,
       "Non-conforming bitstream. no_stsa_constraint_flag is equal to 1 but bitstream contains NAL unit of type STSA_NUT.");
-    CHECK(cInfo->getNoRaslConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_RASL,
+    CHECK_VTM(cInfo->getNoRaslConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_RASL,
       "Non-conforming bitstream. no_rasl_constraint_flag is equal to 1 but bitstream contains NAL unit of type RASL_NUT.");
-    CHECK(cInfo->getNoRadlConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_RADL,
+    CHECK_VTM(cInfo->getNoRadlConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_RADL,
       "Non-conforming bitstream. no_radl_constraint_flag is equal to 1 but bitstream contains NAL unit of type RADL_NUT.");
-    CHECK(cInfo->getNoIdrConstraintFlag() && (naluType == NAL_UNIT_CODED_SLICE_IDR_W_RADL),
+    CHECK_VTM(cInfo->getNoIdrConstraintFlag() && (naluType == NAL_UNIT_CODED_SLICE_IDR_W_RADL),
       "Non-conforming bitstream. no_idr_constraint_flag is equal to 1 but bitstream contains NAL unit of type IDR_W_RADL.");
-    CHECK(cInfo->getNoIdrConstraintFlag() && (naluType == NAL_UNIT_CODED_SLICE_IDR_N_LP),
+    CHECK_VTM(cInfo->getNoIdrConstraintFlag() && (naluType == NAL_UNIT_CODED_SLICE_IDR_N_LP),
       "Non-conforming bitstream. no_idr_constraint_flag is equal to 1 but bitstream contains NAL unit of type IDR_N_LP.");
-    CHECK(cInfo->getNoCraConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_CRA,
+    CHECK_VTM(cInfo->getNoCraConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_CRA,
       "Non-conforming bitstream. no_cra_constraint_flag is equal to 1 but bitstream contains NAL unit of type CRA_NUT.");
-    CHECK(cInfo->getNoGdrConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_GDR,
+    CHECK_VTM(cInfo->getNoGdrConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_GDR,
       "Non-conforming bitstream. no_gdr_constraint_flag is equal to 1 but bitstream contains NAL unit of type GDR_NUT.");
-    CHECK(cInfo->getNoApsConstraintFlag() && naluType == NAL_UNIT_PREFIX_APS,
+    CHECK_VTM(cInfo->getNoApsConstraintFlag() && naluType == NAL_UNIT_PREFIX_APS,
       "Non-conforming bitstream. no_aps_constraint_flag is equal to 1 but bitstream contains NAL unit of type APS_PREFIX_NUT.");
-    CHECK(cInfo->getNoApsConstraintFlag() && naluType == NAL_UNIT_SUFFIX_APS,
+    CHECK_VTM(cInfo->getNoApsConstraintFlag() && naluType == NAL_UNIT_SUFFIX_APS,
       "Non-conforming bitstream. no_aps_constraint_flag is equal to 1 but bitstream contains NAL unit of type APS_SUFFIX_NUT.");
   }
 }
@@ -3013,9 +3013,9 @@ void DecLib::xCheckMixedNalUnit(Slice* pcSlice, SPS *sps, InputNALUnit &nalu)
 {
   if (pcSlice->getPPS()->getMixedNaluTypesInPicFlag())
   {
-    CHECK(pcSlice->getPPS()->getNumSlicesInPic() < 2, "mixed nal unit type picture, but with less than 2 slices");
+    CHECK_VTM(pcSlice->getPPS()->getNumSlicesInPic() < 2, "mixed nal unit type picture, but with less than 2 slices");
 
-    CHECK( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR, "picture with mixed NAL unit type cannot have GDR slice");
+    CHECK_VTM( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR, "picture with mixed NAL unit type cannot have GDR slice");
 
     //Check that if current slice is IRAP type, the other type of NAL can only be TRAIL_NUT
     if( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )
@@ -3023,7 +3023,7 @@ void DecLib::xCheckMixedNalUnit(Slice* pcSlice, SPS *sps, InputNALUnit &nalu)
       for( int i = 0; i < m_uiSliceSegmentIdx; i++ )
       {
         Slice* PreSlice = m_pcPic->slices[i];
-        CHECK( (pcSlice->getNalUnitType() != PreSlice->getNalUnitType()) && (PreSlice->getNalUnitType() != NAL_UNIT_CODED_SLICE_TRAIL), "In a mixed NAL unt type picture, an IRAP slice can be mixed with Trail slice(s) only");
+        CHECK_VTM( (pcSlice->getNalUnitType() != PreSlice->getNalUnitType()) && (PreSlice->getNalUnitType() != NAL_UNIT_CODED_SLICE_TRAIL), "In a mixed NAL unt type picture, an IRAP slice can be mixed with Trail slice(s) only");
       }
     }
 
@@ -3040,7 +3040,7 @@ void DecLib::xCheckMixedNalUnit(Slice* pcSlice, SPS *sps, InputNALUnit &nalu)
           hasDiffTypes = true;
         }
       }
-      CHECK( !hasDiffTypes, "VCL NAL units of the picture shall have two or more different nal_unit_type values");
+      CHECK_VTM( !hasDiffTypes, "VCL NAL units of the picture shall have two or more different nal_unit_type values");
     }
 
   }
@@ -3053,7 +3053,7 @@ void DecLib::xCheckMixedNalUnit(Slice* pcSlice, SPS *sps, InputNALUnit &nalu)
       if (PreSlice->getNalUnitType() != pcSlice->getNalUnitType())
         sameNalUnitType = false;
     }
-    CHECK(!sameNalUnitType, "pps_mixed_nalu_types_in_pic_flag is zero, but have different nal unit types");
+    CHECK_VTM(!sameNalUnitType, "pps_mixed_nalu_types_in_pic_flag is zero, but have different nal unit types");
   }
 }
 /**
diff --git a/source/Lib/DecoderLib/DecSlice.cpp b/source/Lib/DecoderLib/DecSlice.cpp
index 57c1c92..1e9bb95 100644
--- a/source/Lib/DecoderLib/DecSlice.cpp
+++ b/source/Lib/DecoderLib/DecSlice.cpp
@@ -122,7 +122,7 @@ void DecSlice::decompressSlice( Slice* slice, InputBitstream* bitstream, int deb
 
   // Quantization parameter
     pic->m_prevQP[0] = pic->m_prevQP[1] = slice->getSliceQp();
-  CHECK( pic->m_prevQP[0] == std::numeric_limits<int>::max(), "Invalid previous QP" );
+    CHECK_VTM( pic->m_prevQP[0] == std::numeric_limits<int>::max(), "Invalid previous QP" );
 
   DTRACE( g_trace_ctx, D_HEADER, "=========== POC: %d ===========\n", slice->getPOC() );
 
@@ -244,7 +244,7 @@ void DecSlice::decompressSlice( Slice* slice, InputBitstream* bitstream, int deb
     if( ctuIdx == slice->getNumCtuInSlice()-1 )
     {
       unsigned binVal = cabacReader.terminating_bit();
-      CHECK( !binVal, "Expecting a terminating bit" );
+      CHECK_VTM( !binVal, "Expecting a terminating bit" );
 #if DECODER_CHECK_SUBSTREAM_AND_SLICE_TRAILING_BYTES
       cabacReader.remaining_bytes( false );
 #endif
@@ -255,7 +255,7 @@ void DecSlice::decompressSlice( Slice* slice, InputBitstream* bitstream, int deb
       // The sub-stream/stream should be terminated after this CTU.
       // (end of slice-segment, end of tile, end of wavefront-CTU-row)
       unsigned binVal = cabacReader.terminating_bit();
-      CHECK( !binVal, "Expecting a terminating bit" );
+      CHECK_VTM( !binVal, "Expecting a terminating bit" );
       if( entryPointPresent )
       {
 #if DECODER_CHECK_SUBSTREAM_AND_SLICE_TRAILING_BYTES
diff --git a/source/Lib/DecoderLib/NALread.cpp b/source/Lib/DecoderLib/NALread.cpp
index a1cbcf7..fe3babb 100644
--- a/source/Lib/DecoderLib/NALread.cpp
+++ b/source/Lib/DecoderLib/NALread.cpp
@@ -65,7 +65,7 @@ static void convertPayloadToRBSP(vector<uint8_t>& nalUnitBuf, InputBitstream *bi
   bitstream->clearEmulationPreventionByteLocation();
   for (it_read = it_write = nalUnitBuf.begin(); it_read != nalUnitBuf.end(); it_read++, it_write++, pos++)
   {
-    CHECK(zeroCount >= 2 && *it_read < 0x03, "Zero count is '2' and read value is small than '3'");
+    CHECK_VTM(zeroCount >= 2 && *it_read < 0x03, "Zero count is '2' and read value is small than '3'");
     if (zeroCount == 2 && *it_read == 0x03)
     {
       bitstream->pushEmulationPreventionByteLocation( pos );
@@ -79,12 +79,12 @@ static void convertPayloadToRBSP(vector<uint8_t>& nalUnitBuf, InputBitstream *bi
       {
         break;
       }
-      CHECK(*it_read > 0x03, "Read a value bigger than '3'");
+      CHECK_VTM(*it_read > 0x03, "Read a value bigger than '3'");
     }
     zeroCount = (*it_read == 0x00) ? zeroCount+1 : 0;
     *it_write = *it_read;
   }
-  CHECK(zeroCount != 0, "Zero count not '0'");
+  CHECK_VTM(zeroCount != 0, "Zero count not '0'");
 
   if (isVclNalUnit)
   {
@@ -129,7 +129,7 @@ void readNalUnitHeader(InputNALUnit& nalu)
   nalu.m_forbiddenZeroBit   = bs.read(1);                 // forbidden zero bit
   nalu.m_nuhReservedZeroBit = bs.read(1);                 // nuh_reserved_zero_bit
   nalu.m_nuhLayerId         = bs.read(6);                 // nuh_layer_id
-  CHECK(nalu.m_nuhLayerId > 55, "The value of nuh_layer_id shall be in the range of 0 to 55, inclusive");
+  CHECK_VTM(nalu.m_nuhLayerId > 55, "The value of nuh_layer_id shall be in the range of 0 to 55, inclusive");
   nalu.m_nalUnitType        = (NalUnitType) bs.read(5);   // nal_unit_type
   nalu.m_temporalId         = bs.read(3) - 1;             // nuh_temporal_id_plus1
 
@@ -149,7 +149,7 @@ void readNalUnitHeader(InputNALUnit& nalu)
     }
     else
     {
-      CHECK(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA
+      CHECK_VTM(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA
         , "When NAL unit type is equal to STSA_NUT, TemporalId shall not be equal to 0");
     }
   }
@@ -170,7 +170,7 @@ void read(InputNALUnit& nalu)
 bool checkPictureHeaderInSliceHeaderFlag(InputNALUnit& nalu)
 {
   InputBitstream& bitstream = nalu.getBitstream();
-  CHECK(bitstream.getByteLocation() != 2, "The picture_header_in_slice_header_flag is the first bit after the NAL unit header");
+  CHECK_VTM(bitstream.getByteLocation() != 2, "The picture_header_in_slice_header_flag is the first bit after the NAL unit header");
   return (bool)bitstream.read(1);
 }
 //! \}
diff --git a/source/Lib/DecoderLib/SEIread.cpp b/source/Lib/DecoderLib/SEIread.cpp
index d0b54d4..a6675a0 100644
--- a/source/Lib/DecoderLib/SEIread.cpp
+++ b/source/Lib/DecoderLib/SEIread.cpp
@@ -119,7 +119,7 @@ void SEIReader::parseSEImessage(InputBitstream* bs, SEIMessages& seis, const Nal
 {
   SEIMessages   seiListInCurNalu;
   setBitstream(bs);
-  CHECK(m_pcBitstream->getNumBitsUntilByteAligned(), "Bitstream not aligned");
+  CHECK_VTM(m_pcBitstream->getNumBitsUntilByteAligned(), "Bitstream not aligned");
 
   do
   {
@@ -127,14 +127,14 @@ void SEIReader::parseSEImessage(InputBitstream* bs, SEIMessages& seis, const Nal
     seiListInCurNalu.push_back(seis.back());
     /* SEI messages are an integer number of bytes, something has failed
     * in the parsing if bitstream not byte-aligned */
-    CHECK(m_pcBitstream->getNumBitsUntilByteAligned(), "Bitstream not aligned");
+    CHECK_VTM(m_pcBitstream->getNumBitsUntilByteAligned(), "Bitstream not aligned");
   }
   while (m_pcBitstream->getNumBitsLeft() > 8);
 
   const SEIMessages fillerData = getSeisByType(seiListInCurNalu, SEI::FILLER_PAYLOAD);
-  CHECK(fillerData.size() > 0 && fillerData.size() != seiListInCurNalu.size(), "When an SEI NAL unit contains an SEI message with payloadType equal to filler payload, the SEI NAL unit shall not contain any other SEI message with payloadType not equal to filler payload");
+  CHECK_VTM(fillerData.size() > 0 && fillerData.size() != seiListInCurNalu.size(), "When an SEI NAL unit contains an SEI message with payloadType equal to filler payload, the SEI NAL unit shall not contain any other SEI message with payloadType not equal to filler payload");
   const SEIMessages pictureTiming = getSeisByType(seiListInCurNalu, SEI::PICTURE_TIMING);
-  CHECK(hrd.getGeneralHrdParameters().getGeneralSamePicTimingInAllOlsFlag() && pictureTiming.size() > 0 && pictureTiming.size() != pictureTiming.size(),
+  CHECK_VTM(hrd.getGeneralHrdParameters().getGeneralSamePicTimingInAllOlsFlag() && pictureTiming.size() > 0 && pictureTiming.size() != pictureTiming.size(),
         "When general_same_pic_timing_in_all_ols_flag is equal to 1 [...], and when an SEI NAL unit contains a non-scalable-nested SEI message with "
         "payloadType equal to 1 (PT), the SEI NAL unit shall not contain any other SEI message with payloadType not equal 1.");
 
@@ -399,7 +399,7 @@ void SEIReader::xReadSEImessage(SEIMessages& seis, const NalUnitType nalUnitType
 
 void SEIReader::xParseSEIuserDataUnregistered(SEIuserDataUnregistered &sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
 {
-  CHECK(payloadSize < ISO_IEC_11578_LEN, "Payload too small");
+  CHECK_VTM(payloadSize < ISO_IEC_11578_LEN, "Payload too small");
   uint32_t val;
   output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
 
@@ -512,7 +512,7 @@ void SEIReader::xParseSEIScalableNesting(SEIScalableNesting& sei, const NalUnitT
           }
         }
       }
-      CHECK(lowestLayerId!= nuhLayerId, "nuh_layer_id is not equal to the lowest layer among Olss that the scalable SEI applies");
+      CHECK_VTM(lowestLayerId!= nuhLayerId, "nuh_layer_id is not equal to the lowest layer among Olss that the scalable SEI applies");
     }
   }
   else
@@ -539,7 +539,7 @@ void SEIReader::xParseSEIScalableNesting(SEIScalableNesting& sei, const NalUnitT
   }
 
   sei_read_uvlc(decodedMessageOutputStream, symbol, "sn_num_seis_minus1"); sei.m_snNumSEIs = symbol + 1;
-  CHECK (sei.m_snNumSEIs > 64, "The value of sn_num_seis_minus1 shall be in the range of 0 to 63");
+  CHECK_VTM(sei.m_snNumSEIs > 64, "The value of sn_num_seis_minus1 shall be in the range of 0 to 63");
 
   // byte alignment
   while (m_pcBitstream->getNumBitsRead() % 8 != 0)
@@ -583,34 +583,34 @@ void SEIReader::xCheckScalableNestingConstraints(const SEIScalableNesting& sei,
 
   for (auto nestedsei : sei.m_nestedSEIs)
   {
-    CHECK(nestedsei->payloadType() == SEI::FILLER_PAYLOAD || nestedsei->payloadType() == SEI::SCALABLE_NESTING, "An SEI message that has payloadType equal to filler payload or scalable nesting shall not be contained in a scalable nesting SEI message");
+    CHECK_VTM(nestedsei->payloadType() == SEI::FILLER_PAYLOAD || nestedsei->payloadType() == SEI::SCALABLE_NESTING, "An SEI message that has payloadType equal to filler payload or scalable nesting shall not be contained in a scalable nesting SEI message");
 
-    CHECK(nestedsei->payloadType() != SEI::FILLER_PAYLOAD && nestedsei->payloadType() != SEI::DECODED_PICTURE_HASH && nalUnitType != NAL_UNIT_PREFIX_SEI, "When a scalable nesting SEI message contains an SEI message that has payloadType not equal to filler payload or decoded picture hash, the SEI NAL unit containing the scalable nesting SEI message shall have nal_unit_type equal to PREFIX_SEI_NUT");
+    CHECK_VTM(nestedsei->payloadType() != SEI::FILLER_PAYLOAD && nestedsei->payloadType() != SEI::DECODED_PICTURE_HASH && nalUnitType != NAL_UNIT_PREFIX_SEI, "When a scalable nesting SEI message contains an SEI message that has payloadType not equal to filler payload or decoded picture hash, the SEI NAL unit containing the scalable nesting SEI message shall have nal_unit_type equal to PREFIX_SEI_NUT");
 
-    CHECK(nestedsei->payloadType() == SEI::DECODED_PICTURE_HASH && nalUnitType != NAL_UNIT_SUFFIX_SEI, "When a scalable nesting SEI message contains an SEI message that has payloadType equal to decoded picture hash, the SEI NAL unit containing the scalable nesting SEI message shall have nal_unit_type equal to SUFFIX_SEI_NUT");
+    CHECK_VTM(nestedsei->payloadType() == SEI::DECODED_PICTURE_HASH && nalUnitType != NAL_UNIT_SUFFIX_SEI, "When a scalable nesting SEI message contains an SEI message that has payloadType equal to decoded picture hash, the SEI NAL unit containing the scalable nesting SEI message shall have nal_unit_type equal to SUFFIX_SEI_NUT");
 
-    CHECK(nestedsei->payloadType() == SEI::DECODED_PICTURE_HASH && !sei.m_snSubpicFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to decoded picture hash, the value of sn_subpic_flag shall be equal to 1");
+    CHECK_VTM(nestedsei->payloadType() == SEI::DECODED_PICTURE_HASH && !sei.m_snSubpicFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to decoded picture hash, the value of sn_subpic_flag shall be equal to 1");
 
-    CHECK(nestedsei->payloadType() == SEI::SUBPICTURE_LEVEL_INFO && sei.m_snSubpicFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to SLI, the value of sn_subpic_flag shall be equal to 0");
+    CHECK_VTM(nestedsei->payloadType() == SEI::SUBPICTURE_LEVEL_INFO && sei.m_snSubpicFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to SLI, the value of sn_subpic_flag shall be equal to 0");
 
-    CHECK(vps->getGeneralHrdParameters()->getGeneralSamePicTimingInAllOlsFlag() && nestedsei->payloadType() == SEI::PICTURE_TIMING, "When general_same_pic_timing_in_all_ols_flag is equal to 1, there shall be no SEI NAL unit that contain a scalable-nested SEI message with payloadType equal to PT");
+    CHECK_VTM(vps->getGeneralHrdParameters()->getGeneralSamePicTimingInAllOlsFlag() && nestedsei->payloadType() == SEI::PICTURE_TIMING, "When general_same_pic_timing_in_all_ols_flag is equal to 1, there shall be no SEI NAL unit that contain a scalable-nested SEI message with payloadType equal to PT");
 
     for (int i = 0; i < vclAssociatedSeiList.size(); i++)
     {
-      CHECK(nestedsei->payloadType() == vclAssociatedSeiList[i] && sei.m_snOlsFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to a value in vclAssociatedSeiList, the value of sn_ols_flag shall be equal to 0");
+      CHECK_VTM(nestedsei->payloadType() == vclAssociatedSeiList[i] && sei.m_snOlsFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to a value in vclAssociatedSeiList, the value of sn_ols_flag shall be equal to 0");
     }
 
     if (nestedsei->payloadType() == SEI::BUFFERING_PERIOD || nestedsei->payloadType() == SEI::PICTURE_TIMING || nestedsei->payloadType() == SEI::DECODING_UNIT_INFO || nestedsei->payloadType() == SEI::SUBPICTURE_LEVEL_INFO)
     {
       containBPorPTorDUIorSLI = true;
-      CHECK(!sei.m_snOlsFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to BP, PT, or DUI, or SLI, the value of sn_ols_flag shall be equal to 1");
+      CHECK_VTM(!sei.m_snOlsFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to BP, PT, or DUI, or SLI, the value of sn_ols_flag shall be equal to 1");
     }
     if (!(nestedsei->payloadType() == SEI::BUFFERING_PERIOD || nestedsei->payloadType() == SEI::PICTURE_TIMING || nestedsei->payloadType() == SEI::DECODING_UNIT_INFO || nestedsei->payloadType() == SEI::SUBPICTURE_LEVEL_INFO))
     {
       containNoBPorPTorDUIorSLI = true;
     }
   }
-  CHECK(containBPorPTorDUIorSLI && containNoBPorPTorDUIorSLI, "When a scalable nesting SEI message contains a BP, PT, DUI, or SLI SEI message, the scalable nesting SEI message shall not contain any other SEI message with payloadType not equal to BP, PT, DUI, or SLI");
+  CHECK_VTM(containBPorPTorDUIorSLI && containNoBPorPTorDUIorSLI, "When a scalable nesting SEI message contains a BP, PT, DUI, or SLI SEI message, the scalable nesting SEI message shall not contain any other SEI message with payloadType not equal to BP, PT, DUI, or SLI");
 }
 
 void SEIReader::xParseSEIDecodingUnitInfo(SEIDecodingUnitInfo& sei, uint32_t payloadSize, const SEIBufferingPeriod& bp, const uint32_t temporalId, std::ostream *pDecodedMessageOutputStream)
@@ -695,7 +695,7 @@ void SEIReader::xParseSEIBufferingPeriod(SEIBufferingPeriod& sei, uint32_t paylo
     sei.m_decodingUnitDpbDuParamsInPicTimingSeiFlag = false;
   }
 
-  CHECK(sei.m_altCpbParamsPresentFlag && sei.m_bpDecodingUnitHrdParamsPresentFlag,"When bp_alt_cpb_params_present_flag is equal to 1, the value of bp_du_hrd_params_present_flag shall be equal to 0");
+  CHECK_VTM(sei.m_altCpbParamsPresentFlag && sei.m_bpDecodingUnitHrdParamsPresentFlag,"When bp_alt_cpb_params_present_flag is equal to 1, the value of bp_du_hrd_params_present_flag shall be equal to 0");
 
   sei_read_flag( pDecodedMessageOutputStream, code, "concatenation_flag");
   sei.m_concatenationFlag = code;
@@ -1033,7 +1033,7 @@ void SEIReader::xParseSEIFramePacking(SEIFramePacking& sei, uint32_t payloadSize
   if( !sei.m_arrangementCancelFlag )
   {
     sei_read_code( pDecodedMessageOutputStream, 7, val, "fp_arrangement_type" );             sei.m_arrangementType = val;
-    CHECK( ( sei.m_arrangementType <= 2 ) || ( sei.m_arrangementType >= 6 ), "Invalid arrangement type" );
+    CHECK_VTM( ( sei.m_arrangementType <= 2 ) || ( sei.m_arrangementType >= 6 ), "Invalid arrangement type" );
 
     sei_read_flag( pDecodedMessageOutputStream, val, "fp_quincunx_sampling_flag" );          sei.m_quincunxSamplingFlag = val;
 
@@ -1422,7 +1422,8 @@ void SEIReader::xParseSEISubpictureLevelInfo(SEISubpicureLevelInfo& sei, uint32_
     sei_read_flag(pDecodedMessageOutputStream,      val,    "sli_sublayer_info_present_flag");        sei.m_sliSublayerInfoPresentFlag = val;
     while (!isByteAligned())
     {
-      sei_read_flag( pDecodedMessageOutputStream,   val,    "sli_alignment_zero_bit" );           CHECK (val != 0, "sli_alignment_zero_bit not equal to zero" );
+      sei_read_flag( pDecodedMessageOutputStream,   val,    "sli_alignment_zero_bit" );
+      CHECK_VTM(val != 0, "sli_alignment_zero_bit not equal to zero" );
     }
   }
 
diff --git a/source/Lib/DecoderLib/VLCReader.cpp b/source/Lib/DecoderLib/VLCReader.cpp
index 6ee2a25..045960f 100644
--- a/source/Lib/DecoderLib/VLCReader.cpp
+++ b/source/Lib/DecoderLib/VLCReader.cpp
@@ -134,7 +134,7 @@ void VLCReader::xReadCode (uint32_t uiLength, uint32_t& ruiCode, const char *pSy
 void VLCReader::xReadCode (uint32_t uiLength, uint32_t& ruiCode)
 #endif
 {
-  CHECK( uiLength == 0, "Reading a code of length '0'" );
+  CHECK_VTM( uiLength == 0, "Reading a code of length '0'" );
   m_pcBitstream->read (uiLength, ruiCode);
 #if RExt__DECODER_DEBUG_BIT_STATISTICS
   CodingStatistics::IncrementStatisticEP(pSymbolName, uiLength, ruiCode);
@@ -233,15 +233,15 @@ void VLCReader::xReadRbspTrailingBits()
 {
   uint32_t bit;
   READ_FLAG( bit, "rbsp_stop_one_bit");
-  CHECK(bit!=1, "Trailing bit not '1'");
+  CHECK_VTM(bit!=1, "Trailing bit not '1'");
   int cnt = 0;
   while (m_pcBitstream->getNumBitsUntilByteAligned())
   {
     READ_FLAG( bit, "rbsp_alignment_zero_bit");
-    CHECK(bit!=0, "Alignment bit is not '0'");
+    CHECK_VTM(bit!=0, "Alignment bit is not '0'");
     cnt++;
   }
-  CHECK(cnt >= 8, "Read more than '8' trailing bits");
+  CHECK_VTM(cnt >= 8, "Read more than '8' trailing bits");
 }
 
 void AUDReader::parseAccessUnitDelimiter(InputBitstream* bs, uint32_t &audIrapOrGdrAuFlag, uint32_t &picType)
@@ -268,7 +268,7 @@ void FDReader::parseFillerData(InputBitstream* bs, uint32_t &fdSize)
   while( m_pcBitstream->getNumBitsLeft() >8 )
   {
     READ_CODE (8, ffByte, "ff_byte");
-    CHECK(ffByte!=0xff, "Invalid filler data : not '0xff'");
+    CHECK_VTM(ffByte!=0xff, "Invalid filler data : not '0xff'");
     fdSize++;
   }
   xReadRbspTrailingBits();
@@ -419,7 +419,7 @@ void HLSyntaxReader::parsePPS( PPS* pcPPS )
 
   int   iCode;
   READ_CODE(6, uiCode, "pps_pic_parameter_set_id");
-  CHECK(uiCode > 63, "PPS id exceeds boundary (63)");
+  CHECK_VTM(uiCode > 63, "PPS id exceeds boundary (63)");
   pcPPS->setPPSId (uiCode);
 
   READ_CODE(4, uiCode, "pps_seq_parameter_set_id");
@@ -472,12 +472,12 @@ void HLSyntaxReader::parsePPS( PPS* pcPPS )
     {
       pcPPS->setNumSubPics(1);
     }
-    CHECK( uiCode > MAX_NUM_SUB_PICS-1,  "Number of sub-pictures exceeds limit");
+    CHECK_VTM( uiCode > MAX_NUM_SUB_PICS-1,  "Number of sub-pictures exceeds limit");
 
     READ_UVLC( uiCode, "pps_subpic_id_len_minus1" );                       pcPPS->setSubPicIdLen( uiCode + 1 );
-    CHECK( uiCode > 15, "Invalid pps_subpic_id_len_minus1 signalled");
+    CHECK_VTM( uiCode > 15, "Invalid pps_subpic_id_len_minus1 signalled");
 
-    CHECK((1 << pcPPS->getSubPicIdLen()) < pcPPS->getNumSubPics(), "pps_subpic_id_len exceeds valid range");
+    CHECK_VTM((1 << pcPPS->getSubPicIdLen()) < pcPPS->getNumSubPics(), "pps_subpic_id_len exceeds valid range");
     for( int picIdx = 0; picIdx < pcPPS->getNumSubPics( ); picIdx++ )
     {
       READ_CODE( pcPPS->getSubPicIdLen( ), uiCode, "pps_subpic_id[i]" );   pcPPS->setSubPicId( picIdx, uiCode );
@@ -490,23 +490,23 @@ void HLSyntaxReader::parsePPS( PPS* pcPPS )
 
     // CTU size - required to match size in SPS
     READ_CODE(2, uiCode, "pps_log2_ctu_size_minus5");                 pcPPS->setLog2CtuSize(uiCode + 5);
-    CHECK(uiCode > 2, "pps_log2_ctu_size_minus5 must be less than or equal to 2");
+    CHECK_VTM(uiCode > 2, "pps_log2_ctu_size_minus5 must be less than or equal to 2");
 
     // number of explicit tile columns/rows
     READ_UVLC( uiCode, "pps_num_exp_tile_columns_minus1" );               pcPPS->setNumExpTileColumns( uiCode + 1 );
     READ_UVLC( uiCode, "pps_num_exp_tile_rows_minus1" );                  pcPPS->setNumExpTileRows( uiCode + 1 );
-    CHECK(pcPPS->getNumExpTileColumns() > MAX_TILE_COLS,              "Number of explicit tile columns exceeds valid range");
+    CHECK_VTM(pcPPS->getNumExpTileColumns() > MAX_TILE_COLS,              "Number of explicit tile columns exceeds valid range");
 
     // tile sizes
     for( colIdx = 0; colIdx < pcPPS->getNumExpTileColumns(); colIdx++ )
     {
       READ_UVLC( uiCode, "pps_tile_column_width_minus1[i]" );             pcPPS->addTileColumnWidth( uiCode + 1 );
-      CHECK(uiCode  > (pcPPS->getPicWidthInCtu()-1),                 "The value of pps_tile_column_width_minus1[i] shall be in the range of 0 to PicWidthInCtbY-1, inclusive");
+      CHECK_VTM(uiCode  > (pcPPS->getPicWidthInCtu()-1),                 "The value of pps_tile_column_width_minus1[i] shall be in the range of 0 to PicWidthInCtbY-1, inclusive");
     }
     for( rowIdx = 0; rowIdx < pcPPS->getNumExpTileRows(); rowIdx++ )
     {
       READ_UVLC( uiCode, "pps_tile_row_height_minus1[i]" );               pcPPS->addTileRowHeight( uiCode + 1 );
-      CHECK(uiCode > (pcPPS->getPicHeightInCtu() - 1),                "The value of pps_tile_row_height_minus shall be in the range of 0 to PicHeightInCtbY-1, inclusive");
+      CHECK_VTM(uiCode > (pcPPS->getPicHeightInCtu() - 1),                "The value of pps_tile_row_height_minus shall be in the range of 0 to PicHeightInCtbY-1, inclusive");
     }
     pcPPS->initTiles();
     // rectangular slice signalling
@@ -534,7 +534,7 @@ void HLSyntaxReader::parsePPS( PPS* pcPPS )
       int32_t tileIdx = 0;
 
       READ_UVLC( uiCode, "pps_num_slices_in_pic_minus1" );                pcPPS->setNumSlicesInPic( uiCode + 1 );
-      CHECK(pcPPS->getNumSlicesInPic() > MAX_SLICES,                  "Number of slices in picture exceeds valid range");
+      CHECK_VTM(pcPPS->getNumSlicesInPic() > MAX_SLICES,                  "Number of slices in picture exceeds valid range");
       if ((pcPPS->getNumSlicesInPic() - 1) > 1)
       {
         READ_CODE(1, uiCode, "pps_tile_idx_delta_present_flag");
@@ -641,7 +641,7 @@ void HLSyntaxReader::parsePPS( PPS* pcPPS )
             int32_t  tileIdxDelta;
             READ_SVLC( tileIdxDelta, "pps_tile_idx_delta[i]" );
             tileIdx += tileIdxDelta;
-            CHECK( tileIdx < 0 || tileIdx >= pcPPS->getNumTiles(), "Invalid pps_tile_idx_delta.");
+            CHECK_VTM( tileIdx < 0 || tileIdx >= pcPPS->getNumTiles(), "Invalid pps_tile_idx_delta.");
           }
           else
           {
@@ -673,11 +673,11 @@ void HLSyntaxReader::parsePPS( PPS* pcPPS )
   READ_FLAG( uiCode,   "pps_cabac_init_present_flag" );            pcPPS->setCabacInitPresentFlag( uiCode ? true : false );
 
   READ_UVLC(uiCode, "pps_num_ref_idx_default_active_minus1[0]");
-  CHECK(uiCode > 14, "Invalid code read");
+  CHECK_VTM(uiCode > 14, "Invalid code read");
   pcPPS->setNumRefIdxL0DefaultActive(uiCode+1);
 
   READ_UVLC(uiCode, "pps_num_ref_idx_default_active_minus1[1]");
-  CHECK(uiCode > 14, "Invalid code read");
+  CHECK_VTM(uiCode > 14, "Invalid code read");
   pcPPS->setNumRefIdxL1DefaultActive(uiCode+1);
 
   READ_FLAG(uiCode, "pps_rpl1_idx_present_flag");
@@ -705,13 +705,13 @@ void HLSyntaxReader::parsePPS( PPS* pcPPS )
   {
   READ_SVLC( iCode, "pps_cb_qp_offset");
   pcPPS->setQpOffset(COMPONENT_Cb, iCode);
-  CHECK( pcPPS->getQpOffset(COMPONENT_Cb) < -12, "Invalid Cb QP offset" );
-  CHECK( pcPPS->getQpOffset(COMPONENT_Cb) >  12, "Invalid Cb QP offset" );
+  CHECK_VTM( pcPPS->getQpOffset(COMPONENT_Cb) < -12, "Invalid Cb QP offset" );
+  CHECK_VTM( pcPPS->getQpOffset(COMPONENT_Cb) >  12, "Invalid Cb QP offset" );
 
   READ_SVLC( iCode, "pps_cr_qp_offset");
   pcPPS->setQpOffset(COMPONENT_Cr, iCode);
-  CHECK( pcPPS->getQpOffset(COMPONENT_Cr) < -12, "Invalid Cr QP offset" );
-  CHECK( pcPPS->getQpOffset(COMPONENT_Cr) >  12, "Invalid Cr QP offset" );
+  CHECK_VTM( pcPPS->getQpOffset(COMPONENT_Cr) < -12, "Invalid Cr QP offset" );
+  CHECK_VTM( pcPPS->getQpOffset(COMPONENT_Cr) >  12, "Invalid Cr QP offset" );
 
   READ_FLAG(uiCode, "pps_joint_cbcr_qp_offset_present_flag");
   pcPPS->setJointCbCrQpOffsetPresentFlag(uiCode ? true : false);
@@ -726,10 +726,10 @@ void HLSyntaxReader::parsePPS( PPS* pcPPS )
   }
   pcPPS->setQpOffset(JOINT_CbCr, iCode);
 
-  CHECK( pcPPS->getQpOffset(JOINT_CbCr) < -12, "Invalid CbCr QP offset" );
-  CHECK( pcPPS->getQpOffset(JOINT_CbCr) >  12, "Invalid CbCr QP offset" );
+  CHECK_VTM( pcPPS->getQpOffset(JOINT_CbCr) < -12, "Invalid CbCr QP offset" );
+  CHECK_VTM( pcPPS->getQpOffset(JOINT_CbCr) >  12, "Invalid CbCr QP offset" );
 
-  CHECK(MAX_NUM_COMPONENT>3, "Invalid maximal number of components");
+  CHECK_VTM(MAX_NUM_COMPONENT>3, "Invalid maximal number of components");
 
   READ_FLAG( uiCode, "pps_slice_chroma_qp_offsets_present_flag" );
   pcPPS->setSliceChromaQpFlag( uiCode ? true : false );
@@ -743,7 +743,7 @@ void HLSyntaxReader::parsePPS( PPS* pcPPS )
   {
     uint32_t tableSizeMinus1 = 0;
     READ_UVLC(tableSizeMinus1, "pps_chroma_qp_offset_list_len_minus1");
-    CHECK(tableSizeMinus1 >= MAX_QP_OFFSET_LIST_SIZE, "Table size exceeds maximum");
+    CHECK_VTM(tableSizeMinus1 >= MAX_QP_OFFSET_LIST_SIZE, "Table size exceeds maximum");
 
     for (int cuChromaQpOffsetIdx = 0; cuChromaQpOffsetIdx <= (tableSizeMinus1); cuChromaQpOffsetIdx++)
     {
@@ -751,9 +751,9 @@ void HLSyntaxReader::parsePPS( PPS* pcPPS )
       int crOffset;
       int jointCbCrOffset;
       READ_SVLC(cbOffset, "pps_cb_qp_offset_list[i]");
-      CHECK(cbOffset < -12 || cbOffset > 12, "Invalid chroma QP offset");
+      CHECK_VTM(cbOffset < -12 || cbOffset > 12, "Invalid chroma QP offset");
       READ_SVLC(crOffset, "pps_cr_qp_offset_list[i]");
-      CHECK(crOffset < -12 || crOffset > 12, "Invalid chroma QP offset");
+      CHECK_VTM(crOffset < -12 || crOffset > 12, "Invalid chroma QP offset");
       if (pcPPS->getJointCbCrQpOffsetPresentFlag())
       {
         READ_SVLC(jointCbCrOffset, "pps_joint_cbcr_qp_offset_list[i]");
@@ -762,11 +762,11 @@ void HLSyntaxReader::parsePPS( PPS* pcPPS )
       {
         jointCbCrOffset = 0;
       }
-      CHECK(jointCbCrOffset < -12 || jointCbCrOffset > 12, "Invalid chroma QP offset");
+      CHECK_VTM(jointCbCrOffset < -12 || jointCbCrOffset > 12, "Invalid chroma QP offset");
       // table uses +1 for index (see comment inside the function)
       pcPPS->setChromaQpOffsetListEntry(cuChromaQpOffsetIdx + 1, cbOffset, crOffset, jointCbCrOffset);
     }
-    CHECK(pcPPS->getChromaQpOffsetListLen() != tableSizeMinus1 + 1, "Invalid chroma QP offset list length");
+    CHECK_VTM(pcPPS->getChromaQpOffsetListLen() != tableSizeMinus1 + 1, "Invalid chroma QP offset list length");
   }
   }
   else
@@ -794,29 +794,29 @@ void HLSyntaxReader::parsePPS( PPS* pcPPS )
     if(!pcPPS->getPPSDeblockingFilterDisabledFlag())
     {
       READ_SVLC( iCode, "pps_beta_offset_div2" );                    pcPPS->setDeblockingFilterBetaOffsetDiv2( iCode );
-      CHECK(  pcPPS->getDeblockingFilterBetaOffsetDiv2() < -12 ||
+      CHECK_VTM(  pcPPS->getDeblockingFilterBetaOffsetDiv2() < -12 ||
               pcPPS->getDeblockingFilterBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
 
       READ_SVLC( iCode, "pps_tc_offset_div2");                       pcPPS->setDeblockingFilterTcOffsetDiv2( iCode );
-      CHECK(  pcPPS->getDeblockingFilterTcOffsetDiv2() < -12 ||
+      CHECK_VTM(  pcPPS->getDeblockingFilterTcOffsetDiv2() < -12 ||
               pcPPS->getDeblockingFilterTcOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
 
       if( pcPPS->getPPSChromaToolFlag() )
       {
         READ_SVLC( iCode, "pps_cb_beta_offset_div2" );                   pcPPS->setDeblockingFilterCbBetaOffsetDiv2( iCode );
-        CHECK( pcPPS->getDeblockingFilterCbBetaOffsetDiv2() < -12 ||
+        CHECK_VTM( pcPPS->getDeblockingFilterCbBetaOffsetDiv2() < -12 ||
           pcPPS->getDeblockingFilterCbBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
 
         READ_SVLC( iCode, "pps_cb_tc_offset_div2" );                     pcPPS->setDeblockingFilterCbTcOffsetDiv2( iCode );
-        CHECK( pcPPS->getDeblockingFilterCbTcOffsetDiv2() < -12 ||
+        CHECK_VTM( pcPPS->getDeblockingFilterCbTcOffsetDiv2() < -12 ||
           pcPPS->getDeblockingFilterCbTcOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
 
         READ_SVLC( iCode, "pps_cr_beta_offset_div2") ;                   pcPPS->setDeblockingFilterCrBetaOffsetDiv2( iCode );
-        CHECK( pcPPS->getDeblockingFilterCrBetaOffsetDiv2() < -12 ||
+        CHECK_VTM( pcPPS->getDeblockingFilterCrBetaOffsetDiv2() < -12 ||
           pcPPS->getDeblockingFilterCrBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
 
         READ_SVLC( iCode, "pps_cr_tc_offset_div2" );                     pcPPS->setDeblockingFilterCrTcOffsetDiv2( iCode );
-        CHECK(pcPPS->getDeblockingFilterCrTcOffsetDiv2() < -12 ||
+        CHECK_VTM(pcPPS->getDeblockingFilterCrTcOffsetDiv2() < -12 ||
           pcPPS->getDeblockingFilterCrTcOffsetDiv2() > 12, "Invalid deblocking filter configuration");
       }
       else
@@ -955,7 +955,7 @@ void HLSyntaxReader::parseAlfAps( APS* aps )
   {
     ccAlfParam.newCcAlfFilter[COMPONENT_Cr - 1] = 0;
   }
-  CHECK(param.newFilterFlag[CHANNEL_TYPE_LUMA] == 0 && param.newFilterFlag[CHANNEL_TYPE_CHROMA] == 0
+  CHECK_VTM(param.newFilterFlag[CHANNEL_TYPE_LUMA] == 0 && param.newFilterFlag[CHANNEL_TYPE_CHROMA] == 0
           && ccAlfParam.newCcAlfFilter[COMPONENT_Cb - 1] == 0 && ccAlfParam.newCcAlfFilter[COMPONENT_Cr - 1] == 0,
         "bitstream conformance error: one of alf_luma_filter_signal_flag, alf_chroma_filter_signal_flag, "
         "alf_cross_component_cb_filter_signal_flag, and alf_cross_component_cr_filter_signal_flag shall be nonzero");
@@ -1174,12 +1174,12 @@ void  HLSyntaxReader::parseVUI(VUI* pcVUI, SPS *pcSPS)
       payloadBitsRem--;
     }
     READ_FLAG(symbol, "vui_payload_bit_equal_to_one");
-    CHECK(symbol != 1, "vui_payload_bit_equal_to_one not equal to 1");
+    CHECK_VTM(symbol != 1, "vui_payload_bit_equal_to_one not equal to 1");
     payloadBitsRem--;
     while(payloadBitsRem)
     {
       READ_FLAG(symbol, "vui_payload_bit_equal_to_zero");
-      CHECK(symbol != 0, "vui_payload_bit_equal_to_zero not equal to 0");
+      CHECK_VTM(symbol != 0, "vui_payload_bit_equal_to_zero not equal to 0");
       payloadBitsRem--;
     }
   }
@@ -1194,7 +1194,7 @@ void HLSyntaxReader::parseGeneralHrdParameters(GeneralHrdParams *hrd)
   READ_CODE(32, symbol, "time_scale");                       hrd->setTimeScale(symbol);
   READ_FLAG(symbol, "general_nal_hrd_parameters_present_flag");           hrd->setGeneralNalHrdParametersPresentFlag(symbol == 1 ? true : false);
   READ_FLAG(symbol, "general_vcl_hrd_parameters_present_flag");           hrd->setGeneralVclHrdParametersPresentFlag(symbol == 1 ? true : false);
-  CHECK((hrd->getGeneralNalHrdParametersPresentFlag() == 0) && (hrd->getGeneralVclHrdParametersPresentFlag() == 0), "general_nal_hrd_params_present_flag and general_vcl_hrd_params_present_flag in each general_hrd_parameters( ) syntax structure shall not be both equal to 0.");
+  CHECK_VTM((hrd->getGeneralNalHrdParametersPresentFlag() == 0) && (hrd->getGeneralVclHrdParametersPresentFlag() == 0), "general_nal_hrd_params_present_flag and general_vcl_hrd_params_present_flag in each general_hrd_parameters( ) syntax structure shall not be both equal to 0.");
   READ_FLAG(symbol, "general_same_pic_timing_in_all_ols_flag");           hrd->setGeneralSamePicTimingInAllOlsFlag(symbol == 1 ? true : false);
   READ_FLAG(symbol, "general_decoding_unit_hrd_params_present_flag");     hrd->setGeneralDecodingUnitHrdParamsPresentFlag(symbol == 1 ? true : false);
   if (hrd->getGeneralDecodingUnitHrdParamsPresentFlag())
@@ -1208,7 +1208,7 @@ void HLSyntaxReader::parseGeneralHrdParameters(GeneralHrdParams *hrd)
     READ_CODE(4, symbol, "cpb_size_du_scale");                  hrd->setCpbSizeDuScale(symbol);
   }
   READ_UVLC(symbol, "hrd_cpb_cnt_minus1");                      hrd->setHrdCpbCntMinus1(symbol);
-  CHECK(symbol > 31,"The value of hrd_cpb_cnt_minus1 shall be in the range of 0 to 31, inclusive");
+  CHECK_VTM(symbol > 31,"The value of hrd_cpb_cnt_minus1 shall be in the range of 0 to 31, inclusive");
 }
 void HLSyntaxReader::parseOlsHrdParameters(GeneralHrdParams * generalHrd, OlsHrdParams *olsHrd, uint32_t firstSubLayer, uint32_t maxNumSubLayersMinus1)
 {
@@ -1317,13 +1317,13 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
   READ_CODE(4, uiCode, "sps_seq_parameter_set_id");              pcSPS->setSPSId(uiCode);
   READ_CODE( 4,  uiCode, "sps_video_parameter_set_id" );      pcSPS->setVPSId( uiCode );
   READ_CODE(3, uiCode, "sps_max_sub_layers_minus1");          pcSPS->setMaxTLayers   (uiCode + 1);
-  CHECK(uiCode > 6, "Invalid maximum number of T-layer signalled");
+  CHECK_VTM(uiCode > 6, "Invalid maximum number of T-layer signalled");
   READ_CODE(2, uiCode, "sps_chroma_format_idc");
   pcSPS->setChromaFormatIdc(ChromaFormat(uiCode));
 
   READ_CODE(2, uiCode, "sps_log2_ctu_size_minus5");
   pcSPS->setCTUSize(1 << (uiCode + 5));
-  CHECK(uiCode > 2, "sps_log2_ctu_size_minus5 must be less than or equal to 2");
+  CHECK_VTM(uiCode > 2, "sps_log2_ctu_size_minus5 must be less than or equal to 2");
   unsigned ctbLog2SizeY = uiCode + 5;
   pcSPS->setMaxCUWidth(pcSPS->getCTUSize());
   pcSPS->setMaxCUHeight(pcSPS->getCTUSize());
@@ -1331,7 +1331,7 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
 
   if( !pcSPS->getVPSId() )
   {
-    CHECK( !pcSPS->getPtlDpbHrdParamsPresentFlag(), "When sps_video_parameter_set_id is equal to 0, the value of sps_ptl_dpb_hrd_params_present_flag shall be equal to 1" );
+    CHECK_VTM( !pcSPS->getPtlDpbHrdParamsPresentFlag(), "When sps_video_parameter_set_id is equal to 0, the value of sps_ptl_dpb_hrd_params_present_flag shall be equal to 1" );
   }
 
   if (pcSPS->getPtlDpbHrdParamsPresentFlag())
@@ -1348,7 +1348,7 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
   READ_FLAG(uiCode, "sps_ref_pic_resampling_enabled_flag");          pcSPS->setRprEnabledFlag(uiCode);
   if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoRprConstraintFlag())
   {
-    CHECK(uiCode != 0, "When gci_no_ref_pic_resampling_constraint_flag is equal to 1, sps_ref_pic_resampling_enabled_flag shall be equal to 0");
+    CHECK_VTM(uiCode != 0, "When gci_no_ref_pic_resampling_constraint_flag is equal to 1, sps_ref_pic_resampling_enabled_flag shall be equal to 0");
   }
   if (uiCode)
   {
@@ -1361,7 +1361,7 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
 
   if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoResChangeInClvsConstraintFlag())
   {
-    CHECK(uiCode != 0, "When no_res_change_in_clvs_constraint_flag is equal to 1, sps_res_change_in_clvs_allowed_flag shall be equal to 0");
+    CHECK_VTM(uiCode != 0, "When no_res_change_in_clvs_constraint_flag is equal to 1, sps_res_change_in_clvs_allowed_flag shall be equal to 0");
   }
 
   READ_UVLC( uiCode, "sps_pic_width_max_in_luma_samples" );          pcSPS->setMaxPicWidthInLumaSamples( uiCode );
@@ -1380,13 +1380,13 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
   READ_FLAG( uiCode, "sps_subpic_info_present_flag" );               pcSPS->setSubPicInfoPresentFlag(uiCode);
   if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoSubpicInfoConstraintFlag())
   {
-    CHECK(uiCode != 0, "When gci_no_subpic_info_constraint_flag is equal to 1, the value of sps_subpic_info_present_flag shall be equal to 0");
+    CHECK_VTM(uiCode != 0, "When gci_no_subpic_info_constraint_flag is equal to 1, the value of sps_subpic_info_present_flag shall be equal to 0");
   }
 
   if (pcSPS->getSubPicInfoPresentFlag())
   {
     READ_UVLC(uiCode, "sps_num_subpics_minus1"); pcSPS->setNumSubPics(uiCode + 1);
-    CHECK(uiCode > (pcSPS->getMaxPicWidthInLumaSamples() / (1 << pcSPS->getCTUSize())) * (pcSPS->getMaxPicHeightInLumaSamples() / (1 << pcSPS->getCTUSize())) - 1, "Invalid sps_num_subpics_minus1 value");
+    CHECK_VTM(uiCode > (pcSPS->getMaxPicWidthInLumaSamples() / (1 << pcSPS->getCTUSize())) * (pcSPS->getMaxPicHeightInLumaSamples() / (1 << pcSPS->getCTUSize())) - 1, "Invalid sps_num_subpics_minus1 value");
     if( pcSPS->getNumSubPics() == 1 )
     {
       pcSPS->setSubPicCtuTopLeftX( 0, 0 );
@@ -1450,9 +1450,9 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
           if (pcSPS->getSubPicSameSizeFlag())
           {
             numSubpicCols = tmpWidthVal / pcSPS->getSubPicWidth(0);
-            CHECK(!(tmpWidthVal % pcSPS->getSubPicWidth(0) == 0), "sps_subpic_width_minus1[0] is invalid.");
-            CHECK(!(tmpHeightVal % pcSPS->getSubPicHeight(0) == 0), "sps_subpic_height_minus1[0] is invalid.");
-            CHECK(!(numSubpicCols * (tmpHeightVal / pcSPS->getSubPicHeight(0)) == pcSPS->getNumSubPics()), "when sps_subpic_same_size_flag is equal to, sps_num_subpics_minus1 is invalid");
+            CHECK_VTM(!(tmpWidthVal % pcSPS->getSubPicWidth(0) == 0), "sps_subpic_width_minus1[0] is invalid.");
+            CHECK_VTM(!(tmpHeightVal % pcSPS->getSubPicHeight(0) == 0), "sps_subpic_height_minus1[0] is invalid.");
+            CHECK_VTM(!(numSubpicCols * (tmpHeightVal / pcSPS->getSubPicHeight(0)) == pcSPS->getNumSubPics()), "when sps_subpic_same_size_flag is equal to, sps_num_subpics_minus1 is invalid");
           }
         }
         else
@@ -1473,8 +1473,8 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
     }
 
     READ_UVLC( uiCode, "sps_subpic_id_len_minus1" );                       pcSPS->setSubPicIdLen( uiCode + 1 );
-    CHECK( uiCode > 15, "Invalid sps_subpic_id_len_minus1 value" );
-    CHECK( (1 << (uiCode + 1)) < pcSPS->getNumSubPics(), "Invalid sps_subpic_id_len_minus1 value" );
+    CHECK_VTM( uiCode > 15, "Invalid sps_subpic_id_len_minus1 value" );
+    CHECK_VTM( (1 << (uiCode + 1)) < pcSPS->getNumSubPics(), "Invalid sps_subpic_id_len_minus1 value" );
     READ_FLAG( uiCode, "sps_subpic_id_mapping_explicitly_signalled_flag" );    pcSPS->setSubPicIdMappingExplicitlySignalledFlag( uiCode != 0 );
     if (pcSPS->getSubPicIdMappingExplicitlySignalledFlag())
     {
@@ -1507,11 +1507,11 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
   }
 
   READ_UVLC(uiCode, "sps_bitdepth_minus8");
-  CHECK(uiCode > 8, "Invalid bit depth signalled");
+  CHECK_VTM(uiCode > 8, "Invalid bit depth signalled");
   const Profile::Name profile = pcSPS->getProfileTierLevel()->getProfileIdc();
   if (profile != Profile::NONE)
   {
-    CHECK(uiCode + 8 > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "sps_bitdepth_minus8 exceeds range supported by signalled profile");
+    CHECK_VTM(uiCode + 8 > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "sps_bitdepth_minus8 exceeds range supported by signalled profile");
   }
   pcSPS->setBitDepth(CHANNEL_TYPE_LUMA, 8 + uiCode);
   pcSPS->setBitDepth(CHANNEL_TYPE_CHROMA, 8 + uiCode);
@@ -1521,13 +1521,13 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
   READ_FLAG( uiCode, "sps_entropy_coding_sync_enabled_flag" );       pcSPS->setEntropyCodingSyncEnabledFlag(uiCode == 1);
   READ_FLAG( uiCode, "sps_entry_point_offsets_present_flag");   pcSPS->setEntryPointsPresentFlag(uiCode == 1);
   READ_CODE(4, uiCode, "sps_log2_max_pic_order_cnt_lsb_minus4");     pcSPS->setBitsForPOC( 4 + uiCode );
-  CHECK(uiCode > 12, "sps_log2_max_pic_order_cnt_lsb_minus4 shall be in the range of 0 to 12");
+  CHECK_VTM(uiCode > 12, "sps_log2_max_pic_order_cnt_lsb_minus4 shall be in the range of 0 to 12");
   
   READ_FLAG(uiCode, "sps_poc_msb_cycle_flag");                    pcSPS->setPocMsbCycleFlag(uiCode ? true : false);
   if (pcSPS->getPocMsbCycleFlag())
   {
     READ_UVLC(uiCode, "sps_poc_msb_cycle_len_minus1");                  pcSPS->setPocMsbCycleLen(1 + uiCode);
-    CHECK(uiCode > (32 - ( pcSPS->getBitsForPOC() - 4 )- 5), "The value of sps_poc_msb_cycle_len_minus1 shall be in the range of 0 to 32 - sps_log2_max_pic_order_cnt_lsb_minus4 - 5, inclusive");
+    CHECK_VTM(uiCode > (32 - ( pcSPS->getBitsForPOC() - 4 )- 5), "The value of sps_poc_msb_cycle_len_minus1 shall be in the range of 0 to 32 - sps_log2_max_pic_order_cnt_lsb_minus4 - 5, inclusive");
   }
 
   // extra bits are for future extensions, we will read, but ignore them,
@@ -1569,30 +1569,30 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
   READ_UVLC(uiCode, "sps_log2_min_luma_coding_block_size_minus2");
   int log2MinCUSize = uiCode + 2;
   pcSPS->setLog2MinCodingBlockSize(log2MinCUSize);
-  CHECK(uiCode > ctbLog2SizeY - 2, "Invalid sps_log2_min_luma_coding_block_size_minus2 signalled");
+  CHECK_VTM(uiCode > ctbLog2SizeY - 2, "Invalid sps_log2_min_luma_coding_block_size_minus2 signalled");
 
-  CHECK(log2MinCUSize > std::min(6, (int)(ctbLog2SizeY)), "sps_log2_min_luma_coding_block_size_minus2 shall be in the range of 0 to min (4, log2_ctu_size - 2)");
+  CHECK_VTM(log2MinCUSize > std::min(6, (int)(ctbLog2SizeY)), "sps_log2_min_luma_coding_block_size_minus2 shall be in the range of 0 to min (4, log2_ctu_size - 2)");
   const int minCuSize = 1 << pcSPS->getLog2MinCodingBlockSize();
-  CHECK( ( pcSPS->getMaxPicWidthInLumaSamples() % ( std::max( 8, minCuSize ) ) ) != 0, "Coded frame width must be a multiple of Max(8, the minimum unit size)" );
-  CHECK( ( pcSPS->getMaxPicHeightInLumaSamples() % ( std::max( 8, minCuSize ) ) ) != 0, "Coded frame height must be a multiple of Max(8, the minimum unit size)" );
+  CHECK_VTM( ( pcSPS->getMaxPicWidthInLumaSamples() % ( std::max( 8, minCuSize ) ) ) != 0, "Coded frame width must be a multiple of Max(8, the minimum unit size)" );
+  CHECK_VTM( ( pcSPS->getMaxPicHeightInLumaSamples() % ( std::max( 8, minCuSize ) ) ) != 0, "Coded frame height must be a multiple of Max(8, the minimum unit size)" );
 
   READ_FLAG(uiCode, "sps_partition_constraints_override_enabled_flag"); pcSPS->setSplitConsOverrideEnabledFlag(uiCode);
   READ_UVLC(uiCode, "sps_log2_diff_min_qt_min_cb_intra_slice_luma");
   unsigned minQtLog2SizeIntraY = uiCode + pcSPS->getLog2MinCodingBlockSize();
   minQT[0] = 1 << minQtLog2SizeIntraY;
-  CHECK(minQT[0] > 64, "The value of sps_log2_diff_min_qt_min_cb_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
-  CHECK(minQT[0] > (1<<ctbLog2SizeY), "The value of sps_log2_diff_min_qt_min_cb_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
+  CHECK_VTM(minQT[0] > 64, "The value of sps_log2_diff_min_qt_min_cb_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
+  CHECK_VTM(minQT[0] > (1<<ctbLog2SizeY), "The value of sps_log2_diff_min_qt_min_cb_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
   READ_UVLC(uiCode, "sps_max_mtt_hierarchy_depth_intra_slice_luma");     maxBTD[0] = uiCode;
-  CHECK(uiCode > 2 * (ctbLog2SizeY - log2MinCUSize), "sps_max_mtt_hierarchy_depth_intra_slice_luma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
+  CHECK_VTM(uiCode > 2 * (ctbLog2SizeY - log2MinCUSize), "sps_max_mtt_hierarchy_depth_intra_slice_luma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
 
   maxTTSize[0] = maxBTSize[0] = minQT[0];
   if (maxBTD[0] != 0)
   {
     READ_UVLC(uiCode, "sps_log2_diff_max_bt_min_qt_intra_slice_luma");     maxBTSize[0] <<= uiCode;
-    CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of sps_log2_diff_max_bt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
+    CHECK_VTM(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of sps_log2_diff_max_bt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
     READ_UVLC(uiCode, "sps_log2_diff_max_tt_min_qt_intra_slice_luma");     maxTTSize[0] <<= uiCode;
-    CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of sps_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
-    CHECK(maxTTSize[0] > 64, "The value of sps_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraY");
+    CHECK_VTM(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of sps_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
+    CHECK_VTM(maxTTSize[0] > 64, "The value of sps_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraY");
   }
   if( pcSPS->getChromaFormatIdc() != CHROMA_400 )
   {
@@ -1606,29 +1606,29 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
   {
     READ_UVLC(uiCode, "sps_log2_diff_min_qt_min_cb_intra_slice_chroma"); minQT[2] = 1 << (uiCode + pcSPS->getLog2MinCodingBlockSize());
     READ_UVLC(uiCode, "sps_max_mtt_hierarchy_depth_intra_slice_chroma"); maxBTD[2] = uiCode;
-    CHECK(uiCode > 2 * (ctbLog2SizeY - log2MinCUSize), "sps_max_mtt_hierarchy_depth_intra_slice_chroma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
+    CHECK_VTM(uiCode > 2 * (ctbLog2SizeY - log2MinCUSize), "sps_max_mtt_hierarchy_depth_intra_slice_chroma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
     maxTTSize[2] = maxBTSize[2] = minQT[2];
     if (maxBTD[2] != 0)
     {
       READ_UVLC(uiCode, "sps_log2_diff_max_bt_min_qt_intra_slice_chroma");       maxBTSize[2] <<= uiCode;
       READ_UVLC(uiCode, "sps_log2_diff_max_tt_min_qt_intra_slice_chroma");       maxTTSize[2] <<= uiCode;
-      CHECK(maxTTSize[2] > 64, "The value of sps_log2_diff_max_tt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
-      CHECK(maxBTSize[2] > 64, "The value of sps_log2_diff_max_bt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
+      CHECK_VTM(maxTTSize[2] > 64, "The value of sps_log2_diff_max_tt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
+      CHECK_VTM(maxBTSize[2] > 64, "The value of sps_log2_diff_max_bt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
     }
   }
   READ_UVLC(uiCode, "sps_log2_diff_min_qt_min_cb_inter_slice");
   unsigned minQtLog2SizeInterY = uiCode + pcSPS->getLog2MinCodingBlockSize();
   minQT[1] = 1 << minQtLog2SizeInterY;
   READ_UVLC(uiCode, "sps_max_mtt_hierarchy_depth_inter_slice");     maxBTD[1] = uiCode;
-  CHECK(uiCode > 2*(ctbLog2SizeY - log2MinCUSize), "sps_max_mtt_hierarchy_depth_inter_slice shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
+  CHECK_VTM(uiCode > 2*(ctbLog2SizeY - log2MinCUSize), "sps_max_mtt_hierarchy_depth_inter_slice shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
   maxTTSize[1] = maxBTSize[1] = minQT[1];
   if (maxBTD[1] != 0)
   {
     READ_UVLC(uiCode, "sps_log2_diff_max_bt_min_qt_inter_slice");     maxBTSize[1] <<= uiCode;
-    CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of sps_log2_diff_max_bt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
+    CHECK_VTM(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of sps_log2_diff_max_bt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
     READ_UVLC(uiCode, "sps_log2_diff_max_tt_min_qt_inter_slice");     maxTTSize[1] <<= uiCode;
-    CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of sps_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
-    CHECK(maxTTSize[1] > 64, "The value of sps_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeInterY");
+    CHECK_VTM(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of sps_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
+    CHECK_VTM(maxTTSize[1] > 64, "The value of sps_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeInterY");
   }
 
   pcSPS->setMinQTSizes(minQT);
@@ -1671,11 +1671,11 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
       int32_t qpTableStart = 0;
       READ_SVLC(qpTableStart, "sps_qp_table_starts_minus26");
       chromaQpMappingTableParams.setQpTableStartMinus26(i, qpTableStart);
-      CHECK(qpTableStart < -26 - pcSPS->getQpBDOffset(CHANNEL_TYPE_LUMA) || qpTableStart > 36,
+      CHECK_VTM(qpTableStart < -26 - pcSPS->getQpBDOffset(CHANNEL_TYPE_LUMA) || qpTableStart > 36,
             "The value of sps_qp_table_start_minus26[ i ] shall be in the range of -26 - QpBdOffset to 36 inclusive");
       READ_UVLC(uiCode, "sps_num_points_in_qp_table_minus1");
       chromaQpMappingTableParams.setNumPtsInCQPTableMinus1(i, uiCode);
-      CHECK(uiCode > 36 - qpTableStart, "The value of sps_num_points_in_qp_table_minus1[ i ] shall be in the range of "
+      CHECK_VTM(uiCode > 36 - qpTableStart, "The value of sps_num_points_in_qp_table_minus1[ i ] shall be in the range of "
                                         "0 to 36 - sps_qp_table_start_minus26[ i ], inclusive");
       std::vector<int> deltaQpInValMinus1(chromaQpMappingTableParams.getNumPtsInCQPTableMinus1(i) + 1);
       std::vector<int> deltaQpOutVal(chromaQpMappingTableParams.getNumPtsInCQPTableMinus1(i) + 1);
@@ -1722,7 +1722,7 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
   READ_FLAG( uiCode, "sps_idr_rpl_present_flag" );       pcSPS->setIDRRefParamListPresent( (bool) uiCode );
   if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoIdrRplConstraintFlag())
   {
-    CHECK(uiCode != 0, "When gci_no_idr_rpl_constraint_flag equal to 1 , the value of sps_idr_rpl_present_flag shall be equal to 0");
+    CHECK_VTM(uiCode != 0, "When gci_no_idr_rpl_constraint_flag equal to 1 , the value of sps_idr_rpl_present_flag shall be equal to 0");
   }
 
   READ_FLAG(uiCode, "sps_rpl1_same_as_rpl0_flag");
@@ -1770,7 +1770,7 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
   {
     for (int i = 0; i < pcSPS->getNumSubPics(); i++)
     {
-      CHECK(pcSPS->getSubPicTreatedAsPicFlag(i) && (pcSPS->getSubPicWidth(i) != (pcSPS->getMaxPicWidthInLumaSamples() + pcSPS->getCTUSize() - 1) / pcSPS->getCTUSize()), "sps_ref_wraparound_enabled_flag cannot be equal to 1 when there is at least one subpicture with SubPicTreatedAsPicFlag equal to 1 and the subpicture's width is not equal to picture's width");
+      CHECK_VTM(pcSPS->getSubPicTreatedAsPicFlag(i) && (pcSPS->getSubPicWidth(i) != (pcSPS->getMaxPicWidthInLumaSamples() + pcSPS->getCTUSize() - 1) / pcSPS->getCTUSize()), "sps_ref_wraparound_enabled_flag cannot be equal to 1 when there is at least one subpicture with SubPicTreatedAsPicFlag equal to 1 and the subpicture's width is not equal to picture's width");
     }
   }
 
@@ -1816,17 +1816,17 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
   }
 
   READ_UVLC(uiCode, "sps_six_minus_max_num_merge_cand");
-  CHECK(MRG_MAX_NUM_CANDS <= uiCode, "Incorrrect max number of merge candidates!");
+  CHECK_VTM(MRG_MAX_NUM_CANDS <= uiCode, "Incorrrect max number of merge candidates!");
   pcSPS->setMaxNumMergeCand(MRG_MAX_NUM_CANDS - uiCode);
   READ_FLAG(uiCode, "sps_sbt_enabled_flag");                        pcSPS->setUseSBT                 ( uiCode != 0 );
   READ_FLAG( uiCode,    "sps_affine_enabled_flag" );                            pcSPS->setUseAffine              ( uiCode != 0 );
   if ( pcSPS->getUseAffine() )
   {
     READ_UVLC(uiCode, "sps_five_minus_max_num_subblock_merge_cand");
-    CHECK(
+    CHECK_VTM(
       uiCode > 5 - (pcSPS->getSbTMVPEnabledFlag() ? 1 : 0),
       "The value of sps_five_minus_max_num_subblock_merge_cand shall be in the range of 0 to 5 - sps_sbtmvp_enabled_flag");
-    CHECK(AFFINE_MRG_MAX_NUM_CANDS < uiCode, "The value of sps_five_minus_max_num_subblock_merge_cand shall be in the range of 0 to 5 - sps_sbtmvp_enabled_flag");
+    CHECK_VTM(AFFINE_MRG_MAX_NUM_CANDS < uiCode, "The value of sps_five_minus_max_num_subblock_merge_cand shall be in the range of 0 to 5 - sps_sbtmvp_enabled_flag");
     pcSPS->setMaxNumAffineMergeCand(AFFINE_MRG_MAX_NUM_CANDS - uiCode);
     READ_FLAG( uiCode,  "sps_affine_type_flag" );                       pcSPS->setUseAffineType          ( uiCode != 0 );
     if( pcSPS->getAMVREnabledFlag())
@@ -1855,7 +1855,7 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
       if (pcSPS->getMaxNumMergeCand() >= 3)
       {
         READ_UVLC(uiCode, "sps_max_num_merge_cand_minus_max_num_gpm_cand");
-        CHECK(pcSPS->getMaxNumMergeCand() - 2 < uiCode,
+        CHECK_VTM(pcSPS->getMaxNumMergeCand() - 2 < uiCode,
               "sps_max_num_merge_cand_minus_max_num_gpm_cand must not be greater than the number of merge candidates minus 2");
         pcSPS->setMaxNumGeoCand((uint32_t)(pcSPS->getMaxNumMergeCand() - uiCode));
       }
@@ -1872,7 +1872,7 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
   }
 
   READ_UVLC(uiCode, "sps_log2_parallel_merge_level_minus2");
-  CHECK(uiCode + 2 > ctbLog2SizeY, "The value of sps_log2_parallel_merge_level_minus2 shall be in the range of 0 to ctbLog2SizeY - 2");
+  CHECK_VTM(uiCode + 2 > ctbLog2SizeY, "The value of sps_log2_parallel_merge_level_minus2 shall be in the range of 0 to ctbLog2SizeY - 2");
   pcSPS->setLog2ParallelMergeLevelMinus2(uiCode);
 
 
@@ -1910,14 +1910,14 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
   {
     READ_UVLC(uiCode, "sps_internal_bit_depth_minus_input_bit_depth");
     pcSPS->setInternalMinusInputBitDepth(CHANNEL_TYPE_LUMA, uiCode);
-    CHECK(uiCode > 8, "Invalid sps_internal_bit_depth_minus_input_bit_depth signalled");
+    CHECK_VTM(uiCode > 8, "Invalid sps_internal_bit_depth_minus_input_bit_depth signalled");
     pcSPS->setInternalMinusInputBitDepth(CHANNEL_TYPE_CHROMA, uiCode);
   }
   READ_FLAG(uiCode, "sps_ibc_enabled_flag");                                    pcSPS->setIBCFlag(uiCode);
   if (pcSPS->getIBCFlag())
   {
     READ_UVLC(uiCode, "sps_six_minus_max_num_ibc_merge_cand");
-    CHECK(IBC_MRG_MAX_NUM_CANDS <= uiCode, "Incorrect max number of IBC merge candidates!");
+    CHECK_VTM(IBC_MRG_MAX_NUM_CANDS <= uiCode, "Incorrect max number of IBC merge candidates!");
     pcSPS->setMaxNumIBCMergeCand(IBC_MRG_MAX_NUM_CANDS - uiCode);
   }
   else
@@ -1942,7 +1942,7 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
   READ_FLAG(uiCode, "sps_explicit_scaling_list_enabled_flag");                 pcSPS->setScalingListFlag(uiCode);
   if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoExplicitScaleListConstraintFlag())
   {
-    CHECK(uiCode != 0, "When gci_no_explicit_scaling_list_constraint_flag is equal to 1, sps_explicit_scaling_list_enabled_flag shall be equal to 0");
+    CHECK_VTM(uiCode != 0, "When gci_no_explicit_scaling_list_constraint_flag is equal to 1, sps_explicit_scaling_list_enabled_flag shall be equal to 0");
   }
 
   if (pcSPS->getUseLFNST() && pcSPS->getScalingListFlag())
@@ -1964,7 +1964,7 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
   READ_FLAG( uiCode, "sps_virtual_boundaries_enabled_flag" ); pcSPS->setVirtualBoundariesEnabledFlag( uiCode != 0 );
   if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoVirtualBoundaryConstraintFlag())
   {
-    CHECK(uiCode != 0, "When gci_no_virtual_boundaries_constraint_flag is equal to 1, sps_virtual_boundaries_enabled_flag shall be equal to 0");
+    CHECK_VTM(uiCode != 0, "When gci_no_virtual_boundaries_constraint_flag is equal to 1, sps_virtual_boundaries_enabled_flag shall be equal to 0");
   }
 
   if( pcSPS->getVirtualBoundariesEnabledFlag() )
@@ -1975,30 +1975,30 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
     READ_UVLC(uiCode, "sps_num_ver_virtual_boundaries");        pcSPS->setNumVerVirtualBoundaries( uiCode );
     if (pcSPS->getMaxPicWidthInLumaSamples() <= 8)
     {
-      CHECK(pcSPS->getNumVerVirtualBoundaries() != 0, "SPS: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
+      CHECK_VTM(pcSPS->getNumVerVirtualBoundaries() != 0, "SPS: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
     }
     else
     {
-      CHECK(pcSPS->getNumVerVirtualBoundaries() > 3, "SPS: The number of vertical virtual boundaries shall be in the range of 0 to 3");
+      CHECK_VTM(pcSPS->getNumVerVirtualBoundaries() > 3, "SPS: The number of vertical virtual boundaries shall be in the range of 0 to 3");
     }
     for( unsigned i = 0; i < pcSPS->getNumVerVirtualBoundaries(); i++ )
     {
       READ_UVLC(uiCode, "sps_virtual_boundary_pos_x_minus1[i]");        pcSPS->setVirtualBoundariesPosX((uiCode + 1) << 3, i);
-      CHECK(uiCode > (((pcSPS->getMaxPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_width_max_in_luma_samples / 8 ) - 2, inclusive.");
+      CHECK_VTM(uiCode > (((pcSPS->getMaxPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_width_max_in_luma_samples / 8 ) - 2, inclusive.");
     }
     READ_UVLC(uiCode, "sps_num_hor_virtual_boundaries");        pcSPS->setNumHorVirtualBoundaries( uiCode );
     if (pcSPS->getMaxPicHeightInLumaSamples() <= 8)
     {
-      CHECK(pcSPS->getNumHorVirtualBoundaries() != 0, "SPS: When picture height is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
+      CHECK_VTM(pcSPS->getNumHorVirtualBoundaries() != 0, "SPS: When picture height is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
     }
     else
     {
-      CHECK(pcSPS->getNumHorVirtualBoundaries() > 3, "SPS: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
+      CHECK_VTM(pcSPS->getNumHorVirtualBoundaries() > 3, "SPS: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
     }
     for( unsigned i = 0; i < pcSPS->getNumHorVirtualBoundaries(); i++ )
     {
       READ_UVLC(uiCode, "sps_virtual_boundary_pos_y_minus1[i]");        pcSPS->setVirtualBoundariesPosY((uiCode + 1) << 3, i);
-      CHECK(uiCode > (((pcSPS->getMaxPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_height_max_in_luma_samples / 8 ) - 2, inclusive.");
+      CHECK_VTM(uiCode > (((pcSPS->getMaxPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_height_max_in_luma_samples / 8 ) - 2, inclusive.");
     }
   }
   else
@@ -2033,7 +2033,7 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
   }
 
   READ_FLAG(     uiCode, "sps_field_seq_flag");                       pcSPS->setFieldSeqFlag(uiCode);
-  CHECK( pcSPS->getProfileTierLevel()->getFrameOnlyConstraintFlag() && uiCode, "When ptl_frame_only_constraint_flag equal to 1 , the value of sps_field_seq_flag shall be equal to 0");
+  CHECK_VTM( pcSPS->getProfileTierLevel()->getFrameOnlyConstraintFlag() && uiCode, "When ptl_frame_only_constraint_flag equal to 1 , the value of sps_field_seq_flag shall be equal to 0");
 
   READ_FLAG( uiCode, "sps_vui_parameters_present_flag" );             pcSPS->setVuiParametersPresentFlag(uiCode);
 
@@ -2044,7 +2044,7 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
     while (!isByteAligned())
     {
       READ_FLAG(uiCode, "sps_vui_alignment_zero_bit");
-      CHECK(uiCode != 0, "sps_vui_alignment_zero_bit not equal to 0");
+      CHECK_VTM(uiCode != 0, "sps_vui_alignment_zero_bit not equal to 0");
     }
     parseVUI(pcSPS->getVuiParameters(), pcSPS);
   }
@@ -2080,7 +2080,7 @@ void HLSyntaxReader::parseSPS(SPS* pcSPS)
         switch (SPSExtensionFlagIndex(i))
         {
         case SPS_EXT__REXT:
-          CHECK(bSkipTrailingExtensionBits, "Skipping trailing extension bits not supported");
+          CHECK_VTM(bSkipTrailingExtensionBits, "Skipping trailing extension bits not supported");
           {
             SPSRExt &spsRangeExtension = pcSPS->getSpsRangeExtension();
             READ_FLAG( uiCode, "transform_skip_rotation_enabled_flag");     spsRangeExtension.setTransformSkipRotationEnabledFlag(uiCode != 0);
@@ -2149,15 +2149,17 @@ void HLSyntaxReader::parseVPS(VPS* pcVPS)
   uint32_t  uiCode;
 
   READ_CODE(4, uiCode, "vps_video_parameter_set_id");
-  CHECK( uiCode == 0, "vps_video_parameter_set_id equal to zero is reserved and shall not be used in a bitstream" );
+  CHECK_VTM( uiCode == 0, "vps_video_parameter_set_id equal to zero is reserved and shall not be used in a bitstream" );
   pcVPS->setVPSId(uiCode);
 
-  READ_CODE(6, uiCode, "vps_max_layers_minus1");              pcVPS->setMaxLayers(uiCode + 1);    CHECK(uiCode + 1 > MAX_VPS_LAYERS, "Signalled number of layers larger than MAX_VPS_LAYERS.");
+  READ_CODE(6, uiCode, "vps_max_layers_minus1");              pcVPS->setMaxLayers(uiCode + 1);
+  CHECK_VTM(uiCode + 1 > MAX_VPS_LAYERS, "Signalled number of layers larger than MAX_VPS_LAYERS.");
   if (pcVPS->getMaxLayers() - 1 == 0)
   {
     pcVPS->setEachLayerIsAnOlsFlag(1);
   }
-  READ_CODE(3, uiCode, "vps_max_sublayers_minus1");           pcVPS->setMaxSubLayers(uiCode + 1); CHECK(uiCode + 1 > MAX_VPS_SUBLAYERS, "Signalled number of sublayers larger than MAX_VPS_SUBLAYERS.");
+  READ_CODE(3, uiCode, "vps_max_sublayers_minus1");           pcVPS->setMaxSubLayers(uiCode + 1);
+  CHECK_VTM(uiCode + 1 > MAX_VPS_SUBLAYERS, "Signalled number of sublayers larger than MAX_VPS_SUBLAYERS.");
   if( pcVPS->getMaxLayers() > 1 && pcVPS->getMaxSubLayers() > 1)
   {
     READ_FLAG(uiCode, "vps_default_ptl_dpb_hrd_max_tid_flag"); pcVPS->setDefaultPtlDpbHrdMaxTidFlag(uiCode);
@@ -2195,7 +2197,7 @@ void HLSyntaxReader::parseVPS(VPS* pcVPS)
             sumUiCode++;
           }
         }
-        CHECK(sumUiCode == 0, "There has to be at least one value of j such that the value of vps_direct_dependency_flag[ i ][ j ] is equal to 1,when vps_independent_layer_flag[ i ] is equal to 0 ");
+        CHECK_VTM(sumUiCode == 0, "There has to be at least one value of j such that the value of vps_direct_dependency_flag[ i ][ j ] is equal to 1,when vps_independent_layer_flag[ i ] is equal to 0 ");
         READ_FLAG(uiCode, "vps_max_tid_ref_present_flag[ i ]");
         if (uiCode)
         {
@@ -2224,7 +2226,8 @@ void HLSyntaxReader::parseVPS(VPS* pcVPS)
     {
       if (!pcVPS->getAllIndependentLayersFlag())
       {
-        READ_CODE(2, uiCode, "vps_ols_mode_idc");         pcVPS->setOlsModeIdc(uiCode); CHECK(uiCode > MAX_VPS_OLS_MODE_IDC, "vps_ols_mode_idc shall be in the range of 0 to 2");
+        READ_CODE(2, uiCode, "vps_ols_mode_idc");         pcVPS->setOlsModeIdc(uiCode);
+        CHECK_VTM(uiCode > MAX_VPS_OLS_MODE_IDC, "vps_ols_mode_idc shall be in the range of 0 to 2");
       }
       if (pcVPS->getOlsModeIdc() == 2)
       {
@@ -2245,7 +2248,7 @@ void HLSyntaxReader::parseVPS(VPS* pcVPS)
     pcVPS->setNumPtls(1);
   }
   pcVPS->deriveOutputLayerSets();
-  CHECK( uiCode >= pcVPS->getTotalNumOLSs(),"The value of vps_num_ptls_minus1 shall be less than TotalNumOlss");
+  CHECK_VTM( uiCode >= pcVPS->getTotalNumOLSs(),"The value of vps_num_ptls_minus1 shall be less than TotalNumOlss");
   std::vector<bool> isPTLReferred( pcVPS->getNumPtls(), false);
 
   for (int i = 0; i < pcVPS->getNumPtls(); i++)
@@ -2271,10 +2274,10 @@ void HLSyntaxReader::parseVPS(VPS* pcVPS)
   while (m_pcBitstream->getNumBitsUntilByteAligned())
   {
     READ_FLAG( uiCode, "vps_ptl_reserved_zero_bit");
-    CHECK(uiCode!=0, "Alignment bit is not '0'");
+    CHECK_VTM(uiCode!=0, "Alignment bit is not '0'");
     cnt++;
   }
-  CHECK(cnt >= 8, "Read more than '8' alignment bits");
+  CHECK_VTM(cnt >= 8, "Read more than '8' alignment bits");
   std::vector<ProfileTierLevel> ptls;
   ptls.resize(pcVPS->getNumPtls());
   for (int i = 0; i < pcVPS->getNumPtls(); i++)
@@ -2299,14 +2302,14 @@ void HLSyntaxReader::parseVPS(VPS* pcVPS)
   }
   for( int i = 0; i < pcVPS->getNumPtls(); i++ )
   {
-    CHECK( !isPTLReferred[i],"Each profile_tier_level( ) syntax structure in the VPS shall be referred to by at least one value of vps_ols_ptl_idx[ i ] for i in the range of 0 to TotalNumOlss ? 1, inclusive");
+    CHECK_VTM( !isPTLReferred[i],"Each profile_tier_level( ) syntax structure in the VPS shall be referred to by at least one value of vps_ols_ptl_idx[ i ] for i in the range of 0 to TotalNumOlss ? 1, inclusive");
   }
 
   if( !pcVPS->getEachLayerIsAnOlsFlag() )
   {
     READ_UVLC( uiCode, "vps_num_dpb_params_minus1" ); pcVPS->m_numDpbParams = uiCode + 1;
 
-    CHECK( pcVPS->m_numDpbParams > pcVPS->getNumMultiLayeredOlss(),"The value of vps_num_dpb_params_minus1 shall be in the range of 0 to NumMultiLayerOlss - 1, inclusive");
+    CHECK_VTM( pcVPS->m_numDpbParams > pcVPS->getNumMultiLayeredOlss(),"The value of vps_num_dpb_params_minus1 shall be in the range of 0 to NumMultiLayerOlss - 1, inclusive");
     std::vector<bool> isDPBParamReferred(pcVPS->m_numDpbParams, false);
 
     if( pcVPS->m_numDpbParams > 0 && pcVPS->getMaxSubLayers() > 1 )
@@ -2322,7 +2325,7 @@ void HLSyntaxReader::parseVPS(VPS* pcVPS)
       {
         READ_CODE(3, uiCode, "vps_dpb_max_tid[i]");
         pcVPS->m_dpbMaxTemporalId.push_back(uiCode);
-        CHECK (uiCode > (pcVPS->getMaxSubLayers() - 1), "The value of vps_dpb_max_tid[i] shall be in the range of 0 to vps_max_sublayers_minus1, inclusive." )
+        CHECK_VTM(uiCode > (pcVPS->getMaxSubLayers() - 1), "The value of vps_dpb_max_tid[i] shall be in the range of 0 to vps_max_sublayers_minus1, inclusive." )
       }
       else
       {
@@ -2362,7 +2365,7 @@ void HLSyntaxReader::parseVPS(VPS* pcVPS)
         const Profile::Name profile = pcVPS->getProfileTierLevel(pcVPS->getOlsPtlIdx(i)).getProfileIdc();
         if (profile != Profile::NONE)
         {
-          CHECK(uiCode + 8 > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "vps_ols_dpb_bitdepth_minus8[ i ] exceeds range supported by signalled profile");
+          CHECK_VTM(uiCode + 8 > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "vps_ols_dpb_bitdepth_minus8[ i ] exceeds range supported by signalled profile");
         }
         if ((pcVPS->m_numDpbParams > 1) && (pcVPS->m_numDpbParams != pcVPS->m_numMultiLayeredOlss))
         {
@@ -2382,7 +2385,7 @@ void HLSyntaxReader::parseVPS(VPS* pcVPS)
     }
     for( int i = 0; i < pcVPS->m_numDpbParams; i++ )
     {
-      CHECK( !isDPBParamReferred[i],"Each dpb_parameters( ) syntax structure in the VPS shall be referred to by at least one value of vps_ols_dpb_params_idx[i] for i in the range of 0 to NumMultiLayerOlss - 1, inclusive");
+      CHECK_VTM( !isDPBParamReferred[i],"Each dpb_parameters( ) syntax structure in the VPS shall be referred to by at least one value of vps_ols_dpb_params_idx[i] for i in the range of 0 to NumMultiLayerOlss - 1, inclusive");
     }
   }
 
@@ -2402,7 +2405,7 @@ void HLSyntaxReader::parseVPS(VPS* pcVPS)
       pcVPS->setVPSSublayerCpbParamsPresentFlag(0);
     }
     READ_UVLC(uiCode, "vps_num_ols_timing_hrd_params_minus1"); pcVPS->setNumOlsTimingHrdParamsMinus1(uiCode);
-    CHECK( uiCode >= pcVPS->getNumMultiLayeredOlss(),"The value of vps_num_ols_timing_hrd_params_minus1 shall be in the range of 0 to NumMultiLayerOlss - 1, inclusive");
+    CHECK_VTM( uiCode >= pcVPS->getNumMultiLayeredOlss(),"The value of vps_num_ols_timing_hrd_params_minus1 shall be in the range of 0 to NumMultiLayerOlss - 1, inclusive");
     std::vector<bool> isHRDParamReferred( uiCode + 1, false);
     pcVPS->m_olsHrdParams.clear();
     pcVPS->m_olsHrdParams.resize(pcVPS->getNumOlsTimingHrdParamsMinus1(), std::vector<OlsHrdParams>(pcVPS->getMaxSubLayers()));
@@ -2411,7 +2414,7 @@ void HLSyntaxReader::parseVPS(VPS* pcVPS)
       if (!pcVPS->getDefaultPtlDpbHrdMaxTidFlag())
       {
         READ_CODE(3, uiCode, "vps_hrd_max_tid[i]");  pcVPS->setHrdMaxTid(i, uiCode);
-        CHECK (uiCode > (pcVPS->getMaxSubLayers() - 1), "The value of vps_hrd_max_tid[i] shall be in the range of 0 to vps_max_sublayers_minus1, inclusive." )
+        CHECK_VTM(uiCode > (pcVPS->getMaxSubLayers() - 1), "The value of vps_hrd_max_tid[i] shall be in the range of 0 to vps_max_sublayers_minus1, inclusive." )
       }
       else
       {
@@ -2429,7 +2432,7 @@ void HLSyntaxReader::parseVPS(VPS* pcVPS)
       if (((pcVPS->getNumOlsTimingHrdParamsMinus1() + 1) != pcVPS->m_numMultiLayeredOlss) && (pcVPS->getNumOlsTimingHrdParamsMinus1() > 0))
       {
         READ_UVLC(uiCode, "vps_ols_timing_hrd_idx[i]"); pcVPS->setOlsTimingHrdIdx(i, uiCode);
-        CHECK(uiCode > pcVPS->getNumOlsTimingHrdParamsMinus1(), "The value of vps_ols_timing_hrd_idx[[ i ] shall be in the range of 0 to vps_num_ols_timing_hrd_params_minus1, inclusive.");
+        CHECK_VTM(uiCode > pcVPS->getNumOlsTimingHrdParamsMinus1(), "The value of vps_ols_timing_hrd_idx[[ i ] shall be in the range of 0 to vps_num_ols_timing_hrd_params_minus1, inclusive.");
       }
       else if (pcVPS->getNumOlsTimingHrdParamsMinus1() == 0)
       {
@@ -2443,7 +2446,7 @@ void HLSyntaxReader::parseVPS(VPS* pcVPS)
     }
     for( int i = 0; i <= pcVPS->getNumOlsTimingHrdParamsMinus1(); i++ )
     {
-      CHECK( !isHRDParamReferred[i], "Each vps_ols_timing_hrd_parameters( ) syntax structure in the VPS shall be referred to by at least one value of vps_ols_timing_hrd_idx[ i ] for i in the range of 1 to NumMultiLayerOlss - 1, inclusive");
+      CHECK_VTM( !isHRDParamReferred[i], "Each vps_ols_timing_hrd_parameters( ) syntax structure in the VPS shall be referred to by at least one value of vps_ols_timing_hrd_idx[ i ] for i in the range of 1 to NumMultiLayerOlss - 1, inclusive");
     }
   }
   else
@@ -2497,15 +2500,15 @@ void HLSyntaxReader::parsePictureHeader( PicHeader* picHeader, ParameterSetManag
   {
     picHeader->setPicIntraSliceAllowedFlag(true);
   }
-  CHECK(picHeader->getPicInterSliceAllowedFlag() == 0 && picHeader->getPicIntraSliceAllowedFlag() == 0, "Invalid picture without intra or inter slice");
+  CHECK_VTM(picHeader->getPicInterSliceAllowedFlag() == 0 && picHeader->getPicIntraSliceAllowedFlag() == 0, "Invalid picture without intra or inter slice");
   // parameter sets
   READ_UVLC(uiCode, "ph_pic_parameter_set_id");
   picHeader->setPPSId(uiCode);
   pps = parameterSetManager->getPPS(picHeader->getPPSId());
-  CHECK(pps == 0, "Invalid PPS");
+  CHECK_VTM(pps == 0, "Invalid PPS");
   picHeader->setSPSId(pps->getSPSId());
   sps = parameterSetManager->getSPS(picHeader->getSPSId());
-  CHECK(sps == 0, "Invalid SPS");
+  CHECK_VTM(sps == 0, "Invalid SPS");
   READ_CODE(sps->getBitsForPOC(), uiCode, "ph_pic_order_cnt_lsb");
   picHeader->setPocLsb(uiCode);
   if( picHeader->getGdrPicFlag() )
@@ -2666,7 +2669,7 @@ void HLSyntaxReader::parsePictureHeader( PicHeader* picHeader, ParameterSetManag
   }
   if (pps->getPicWidthInLumaSamples() == sps->getMaxPicWidthInLumaSamples() && pps->getPicHeightInLumaSamples() == sps->getMaxPicHeightInLumaSamples())
   {
-    CHECK(pps->getConformanceWindowFlag(), "When pps_pic_width_in_luma_samples is equal to sps_pic_width_max_in_luma_samples and pps_pic_height_in_luma_samples is equal to sps_pic_height_max_in_luma_samples, the value of pps_conformance_window_flag shall be equal to 0");
+    CHECK_VTM(pps->getConformanceWindowFlag(), "When pps_pic_width_in_luma_samples is equal to sps_pic_width_max_in_luma_samples and pps_pic_height_in_luma_samples is equal to sps_pic_height_max_in_luma_samples, the value of pps_conformance_window_flag shall be equal to 0");
     pps->getConformanceWindow().setWindowLeftOffset(sps->getConformanceWindow().getWindowLeftOffset());
     pps->getConformanceWindow().setWindowRightOffset(sps->getConformanceWindow().getWindowRightOffset());
     pps->getConformanceWindow().setWindowTopOffset(sps->getConformanceWindow().getWindowTopOffset());
@@ -2691,11 +2694,11 @@ void HLSyntaxReader::parsePictureHeader( PicHeader* picHeader, ParameterSetManag
     pps->setSliceTileIdx( 0, 0 );
     pps->initRectSliceMap(sps);
     // when no Pic partition, number of sub picture shall be less than 2
-    CHECK(pps->getNumSubPics()>=2, "error, no picture partitions, but have equal to or more than 2 sub pictures");
+    CHECK_VTM(pps->getNumSubPics()>=2, "error, no picture partitions, but have equal to or more than 2 sub pictures");
   }
   else
   {
-    CHECK(pps->getCtuSize() != sps->getCTUSize(), "PPS CTU size does not match CTU size in SPS");
+    CHECK_VTM(pps->getCtuSize() != sps->getCTUSize(), "PPS CTU size does not match CTU size in SPS");
     if (pps->getRectSliceFlag())
     {
       pps->initRectSliceMap(sps);
@@ -2706,11 +2709,11 @@ void HLSyntaxReader::parsePictureHeader( PicHeader* picHeader, ParameterSetManag
 
   // set wraparound offset from PPS and SPS info
   int minCbSizeY = (1 << sps->getLog2MinCodingBlockSize());
-  CHECK( !sps->getWrapAroundEnabledFlag() && pps->getWrapAroundEnabledFlag(), "When sps_ref_wraparound_enabled_flag is equal to 0, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
-  CHECK( (((sps->getCTUSize() / minCbSizeY) + 1) > ((pps->getPicWidthInLumaSamples() / minCbSizeY) - 1)) && pps->getWrapAroundEnabledFlag(), "When the value of CtbSizeY / MinCbSizeY + 1 is greater than pps_pic_width_in_luma_samples / MinCbSizeY - 1, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
+  CHECK_VTM( !sps->getWrapAroundEnabledFlag() && pps->getWrapAroundEnabledFlag(), "When sps_ref_wraparound_enabled_flag is equal to 0, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
+  CHECK_VTM( (((sps->getCTUSize() / minCbSizeY) + 1) > ((pps->getPicWidthInLumaSamples() / minCbSizeY) - 1)) && pps->getWrapAroundEnabledFlag(), "When the value of CtbSizeY / MinCbSizeY + 1 is greater than pps_pic_width_in_luma_samples / MinCbSizeY - 1, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
   if( pps->getWrapAroundEnabledFlag() )
   {
-    CHECK((pps->getPicWidthMinusWrapAroundOffset() > (pps->getPicWidthInLumaSamples() / minCbSizeY - sps->getCTUSize() / minCbSizeY - 2)), "pps_pic_width_minus_wraparound_ofsfet shall be less than or equal to pps_pic_width_in_luma_samples/MinCbSizeY - CtbSizeY/MinCbSizeY-2");
+    CHECK_VTM((pps->getPicWidthMinusWrapAroundOffset() > (pps->getPicWidthInLumaSamples() / minCbSizeY - sps->getCTUSize() / minCbSizeY - 2)), "pps_pic_width_minus_wraparound_ofsfet shall be less than or equal to pps_pic_width_in_luma_samples/MinCbSizeY - CtbSizeY/MinCbSizeY-2");
     pps->setWrapAroundOffset(minCbSizeY * (pps->getPicWidthInLumaSamples()/minCbSizeY- pps->getPicWidthMinusWrapAroundOffset()));
   }
   else
@@ -2728,30 +2731,30 @@ void HLSyntaxReader::parsePictureHeader( PicHeader* picHeader, ParameterSetManag
       READ_UVLC(uiCode, "ph_num_ver_virtual_boundaries");        picHeader->setNumVerVirtualBoundaries( uiCode );
       if (pps->getPicWidthInLumaSamples() <= 8)
       {
-        CHECK(picHeader->getNumVerVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
+        CHECK_VTM(picHeader->getNumVerVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
       }
       else
       {
-        CHECK(picHeader->getNumVerVirtualBoundaries() > 3, "PH: The number of vertical virtual boundaries shall be in the range of 0 to 3");
+        CHECK_VTM(picHeader->getNumVerVirtualBoundaries() > 3, "PH: The number of vertical virtual boundaries shall be in the range of 0 to 3");
       }
       for( unsigned i = 0; i < picHeader->getNumVerVirtualBoundaries(); i++ )
       {
         READ_UVLC(uiCode, "ph_virtual_boundary_pos_x_minus1[i]");        picHeader->setVirtualBoundariesPosX((uiCode + 1) << 3, i);
-        CHECK(uiCode > (((pps->getPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_width_in_luma_samples / 8 ) - 2, inclusive.");
+        CHECK_VTM(uiCode > (((pps->getPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_width_in_luma_samples / 8 ) - 2, inclusive.");
       }
       READ_UVLC(uiCode, "ph_num_hor_virtual_boundaries");        picHeader->setNumHorVirtualBoundaries( uiCode );
       if (pps->getPicHeightInLumaSamples() <= 8)
       {
-        CHECK(picHeader->getNumHorVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
+        CHECK_VTM(picHeader->getNumHorVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
       }
       else
       {
-        CHECK(picHeader->getNumHorVirtualBoundaries() > 3, "PH: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
+        CHECK_VTM(picHeader->getNumHorVirtualBoundaries() > 3, "PH: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
       }
       for( unsigned i = 0; i < picHeader->getNumHorVirtualBoundaries(); i++ )
       {
         READ_UVLC(uiCode, "ph_virtual_boundary_pos_y_minus1[i]");        picHeader->setVirtualBoundariesPosY((uiCode + 1) << 3, i);
-        CHECK(uiCode > (((pps->getPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_height_in_luma_samples / 8 ) - 2, inclusive.");
+        CHECK_VTM(uiCode > (((pps->getPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_height_in_luma_samples / 8 ) - 2, inclusive.");
       }
     }
     else
@@ -2918,31 +2921,31 @@ void HLSyntaxReader::parsePictureHeader( PicHeader* picHeader, ParameterSetManag
       READ_UVLC(uiCode, "ph_log2_diff_min_qt_min_cb_intra_slice_luma");
       unsigned minQtLog2SizeIntraY = uiCode + sps->getLog2MinCodingBlockSize();
       minQT[0] = 1 << minQtLog2SizeIntraY;
-      CHECK(minQT[0] > 64, "The value of ph_log2_diff_min_qt_min_cb_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
+      CHECK_VTM(minQT[0] > 64, "The value of ph_log2_diff_min_qt_min_cb_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
       READ_UVLC(uiCode, "ph_max_mtt_hierarchy_depth_intra_slice_luma");         maxBTD[0] = uiCode;
 
       maxTTSize[0] = maxBTSize[0] = minQT[0];
       if (maxBTD[0] != 0)
       {
         READ_UVLC(uiCode, "ph_log2_diff_max_bt_min_qt_intra_slice_luma");       maxBTSize[0] <<= uiCode;
-        CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of ph_log2_diff_max_bt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
+        CHECK_VTM(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of ph_log2_diff_max_bt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
         READ_UVLC(uiCode, "ph_log2_diff_max_tt_min_qt_intra_slice_luma");       maxTTSize[0] <<= uiCode;
-        CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of ph_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
-        CHECK(maxTTSize[0] > 64, "The value of ph_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraY");
+        CHECK_VTM(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of ph_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
+        CHECK_VTM(maxTTSize[0] > 64, "The value of ph_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraY");
       }
 
       if (sps->getUseDualITree())
       {
         READ_UVLC(uiCode, "ph_log2_diff_min_qt_min_cb_intra_slice_chroma");     minQT[2] = 1 << (uiCode + sps->getLog2MinCodingBlockSize());
-        CHECK(minQT[2] > 64, "The value of ph_log2_diff_min_qt_min_cb_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
+        CHECK_VTM(minQT[2] > 64, "The value of ph_log2_diff_min_qt_min_cb_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
         READ_UVLC(uiCode, "ph_max_mtt_hierarchy_depth_intra_slice_chroma");     maxBTD[2] = uiCode;
         maxTTSize[2] = maxBTSize[2] = minQT[2];
         if (maxBTD[2] != 0)
         {
           READ_UVLC(uiCode, "ph_log2_diff_max_bt_min_qt_intra_slice_chroma");   maxBTSize[2] <<= uiCode;
           READ_UVLC(uiCode, "ph_log2_diff_max_tt_min_qt_intra_slice_chroma");   maxTTSize[2] <<= uiCode;
-          CHECK(maxBTSize[2] > 64, "The value of ph_log2_diff_max_bt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
-          CHECK(maxTTSize[2] > 64, "The value of ph_log2_diff_max_tt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
+          CHECK_VTM(maxBTSize[2] > 64, "The value of ph_log2_diff_max_bt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
+          CHECK_VTM(maxTTSize[2] > 64, "The value of ph_log2_diff_max_tt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
         }
       }
     }
@@ -2978,18 +2981,18 @@ void HLSyntaxReader::parsePictureHeader( PicHeader* picHeader, ParameterSetManag
       READ_UVLC(uiCode, "ph_log2_diff_min_qt_min_cb_inter_slice");
       unsigned minQtLog2SizeInterY = uiCode + sps->getLog2MinCodingBlockSize();
       minQT[1] = 1 << minQtLog2SizeInterY;
-      CHECK(minQT[1] > 64, "The value of ph_log2_diff_min_qt_min_cb_inter_slice shall be in the range of 0 to min(6, CtbLog2SizeY) - MinCbLog2SizeY.");
-      CHECK(minQT[1] > (1<<ctbLog2SizeY), "The value of ph_log2_diff_min_qt_min_cb_inter_slice shall be in the range of 0 to min(6, CtbLog2SizeY) - MinCbLog2SizeY");
+      CHECK_VTM(minQT[1] > 64, "The value of ph_log2_diff_min_qt_min_cb_inter_slice shall be in the range of 0 to min(6, CtbLog2SizeY) - MinCbLog2SizeY.");
+      CHECK_VTM(minQT[1] > (1<<ctbLog2SizeY), "The value of ph_log2_diff_min_qt_min_cb_inter_slice shall be in the range of 0 to min(6, CtbLog2SizeY) - MinCbLog2SizeY");
       READ_UVLC(uiCode, "ph_max_mtt_hierarchy_depth_inter_slice");              maxBTD[1] = uiCode;
 
       maxTTSize[1] = maxBTSize[1] = minQT[1];
       if (maxBTD[1] != 0)
       {
         READ_UVLC(uiCode, "ph_log2_diff_max_bt_min_qt_inter_slice");            maxBTSize[1] <<= uiCode;
-        CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of ph_log2_diff_max_bt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
+        CHECK_VTM(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of ph_log2_diff_max_bt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
         READ_UVLC(uiCode, "ph_log2_diff_max_tt_min_qt_inter_slice");            maxTTSize[1] <<= uiCode;
-        CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of ph_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
-        CHECK(maxTTSize[1] > 64, "The value of ph_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeInterY.");
+        CHECK_VTM(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of ph_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
+        CHECK_VTM(maxTTSize[1] > 64, "The value of ph_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeInterY.");
       }
     }
     // delta quantization and chrom and chroma offset
@@ -3221,34 +3224,34 @@ void HLSyntaxReader::parsePictureHeader( PicHeader* picHeader, ParameterSetManag
       {
         READ_SVLC( iCode, "ph_beta_offset_div2" );
         picHeader->setDeblockingFilterBetaOffsetDiv2(iCode);
-        CHECK(  picHeader->getDeblockingFilterBetaOffsetDiv2() < -12 ||
+        CHECK_VTM(  picHeader->getDeblockingFilterBetaOffsetDiv2() < -12 ||
                 picHeader->getDeblockingFilterBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration");
 
         READ_SVLC( iCode, "ph_tc_offset_div2" );
         picHeader->setDeblockingFilterTcOffsetDiv2(iCode);
-        CHECK(  picHeader->getDeblockingFilterTcOffsetDiv2() < -12 ||
+        CHECK_VTM(  picHeader->getDeblockingFilterTcOffsetDiv2() < -12 ||
                 picHeader->getDeblockingFilterTcOffsetDiv2() > 12, "Invalid deblocking filter configuration");
 
         if( pps->getPPSChromaToolFlag() )
         {
           READ_SVLC( iCode, "ph_cb_beta_offset_div2" );
           picHeader->setDeblockingFilterCbBetaOffsetDiv2(iCode);
-          CHECK(  picHeader->getDeblockingFilterCbBetaOffsetDiv2() < -12 ||
+          CHECK_VTM(  picHeader->getDeblockingFilterCbBetaOffsetDiv2() < -12 ||
                   picHeader->getDeblockingFilterCbBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration");
 
           READ_SVLC( iCode, "ph_cb_tc_offset_div2" );
           picHeader->setDeblockingFilterCbTcOffsetDiv2(iCode);
-          CHECK(  picHeader->getDeblockingFilterCbTcOffsetDiv2() < -12 ||
+          CHECK_VTM(  picHeader->getDeblockingFilterCbTcOffsetDiv2() < -12 ||
                   picHeader->getDeblockingFilterCbTcOffsetDiv2() > 12, "Invalid deblocking filter configuration");
 
           READ_SVLC( iCode, "ph_cr_beta_offset_div2" );
           picHeader->setDeblockingFilterCrBetaOffsetDiv2(iCode);
-          CHECK(  picHeader->getDeblockingFilterCrBetaOffsetDiv2() < -12 ||
+          CHECK_VTM(  picHeader->getDeblockingFilterCrBetaOffsetDiv2() < -12 ||
                   picHeader->getDeblockingFilterCrBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration");
 
           READ_SVLC( iCode, "ph_cr_tc_offset_div2" );
           picHeader->setDeblockingFilterCrTcOffsetDiv2(iCode);
-          CHECK(  picHeader->getDeblockingFilterCrTcOffsetDiv2() < -12 ||
+          CHECK_VTM(  picHeader->getDeblockingFilterCrTcOffsetDiv2() < -12 ||
                   picHeader->getDeblockingFilterCrTcOffsetDiv2() > 12, "Invalid deblocking filter configuration");
         }
         else
@@ -3314,11 +3317,11 @@ void  HLSyntaxReader::checkAlfNaluTidAndPicTid(Slice* pcSlice, PicHeader* picHea
     for (int i = 0; i < picHeader->getNumAlfAps(); i++)
     {
       aps = parameterSetManager->getAPS(apsId[i], ALF_APS);
-      CHECK(aps->getTemporalId() > curPicTid, "The TemporalId of the APS NAL unit having aps_params_type equal to ALF_APS and adaptation_parameter_set_id equal to ph_alf_aps_id_luma[ i ] shall be less than or equal to the TemporalId of the picture associated with the PH.");
+      CHECK_VTM(aps->getTemporalId() > curPicTid, "The TemporalId of the APS NAL unit having aps_params_type equal to ALF_APS and adaptation_parameter_set_id equal to ph_alf_aps_id_luma[ i ] shall be less than or equal to the TemporalId of the picture associated with the PH.");
       if( pcSlice->getNalUnitLayerId() != aps->getLayerId() )
       {
-        CHECK( aps->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
-        CHECK( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
+        CHECK_VTM( aps->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+        CHECK_VTM( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
         for (int i = 0; i < pcSlice->getVPS()->getNumOutputLayerSets(); i++ )
         {
           bool isCurrLayerInOls = false;
@@ -3334,7 +3337,7 @@ void  HLSyntaxReader::checkAlfNaluTidAndPicTid(Slice* pcSlice, PicHeader* picHea
               isRefLayerInOls = true;
             }
           }
-          CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
+          CHECK_VTM( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
         }
       }
     }
@@ -3343,11 +3346,11 @@ void  HLSyntaxReader::checkAlfNaluTidAndPicTid(Slice* pcSlice, PicHeader* picHea
     {
       int chromaAlfApsId = picHeader->getAlfApsIdChroma();
       aps = parameterSetManager->getAPS(chromaAlfApsId, ALF_APS);
-      CHECK(aps->getTemporalId() > curPicTid, "The TemporalId of the APS NAL unit having aps_params_type equal to ALF_APS and adaptation_parameter_set_id equal to ph_alf_aps_id_chroma shall be less than or equal to the TemporalId of the picture associated with the PH.");
+      CHECK_VTM(aps->getTemporalId() > curPicTid, "The TemporalId of the APS NAL unit having aps_params_type equal to ALF_APS and adaptation_parameter_set_id equal to ph_alf_aps_id_chroma shall be less than or equal to the TemporalId of the picture associated with the PH.");
       if( pcSlice->getNalUnitLayerId() != aps->getLayerId() )
       {
-        CHECK( aps->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
-        CHECK( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
+        CHECK_VTM( aps->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+        CHECK_VTM( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
         for (int i = 0; i < pcSlice->getVPS()->getNumOutputLayerSets(); i++ )
         {
           bool isCurrLayerInOls = false;
@@ -3363,7 +3366,7 @@ void  HLSyntaxReader::checkAlfNaluTidAndPicTid(Slice* pcSlice, PicHeader* picHea
               isRefLayerInOls = true;
             }
           }
-          CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
+          CHECK_VTM( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
         }
       }
     }
@@ -3386,27 +3389,27 @@ void HLSyntaxReader::parseSliceHeader (Slice* pcSlice, PicHeader* picHeader, Par
     parsePictureHeader(picHeader, parameterSetManager, false);
     picHeader->setValid();
   }
-  CHECK(picHeader==0, "Invalid Picture Header");
-  CHECK(picHeader->isValid()==false, "Invalid Picture Header");
+  CHECK_VTM(picHeader==0, "Invalid Picture Header");
+  CHECK_VTM(picHeader->isValid()==false, "Invalid Picture Header");
   checkAlfNaluTidAndPicTid(pcSlice, picHeader, parameterSetManager);
   pps = parameterSetManager->getPPS( picHeader->getPPSId() );
   //!KS: need to add error handling code here, if PPS is not available
-  CHECK(pps==0, "Invalid PPS");
+  CHECK_VTM(pps==0, "Invalid PPS");
   sps = parameterSetManager->getSPS(pps->getSPSId());
   //!KS: need to add error handling code here, if SPS is not available
-  CHECK(sps==0, "Invalid SPS");
+  CHECK_VTM(sps==0, "Invalid SPS");
   if (sps->getProfileTierLevel()->getConstraintInfo()->getPicHeaderInSliceHeaderConstraintFlag())
   {
-    CHECK(pcSlice->getPictureHeaderInSliceHeader() == false, "PH shall be present in SH, when pic_header_in_slice_header_constraint_flag is equal to 1");
+    CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() == false, "PH shall be present in SH, when pic_header_in_slice_header_constraint_flag is equal to 1");
   }
-  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getRplInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, rpl_info_in_ph_flag shall be equal to 0");
-  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getDbfInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, dbf_info_in_ph_flag shall be equal to 0");
-  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getSaoInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, sao_info_in_ph_flag shall be equal to 0");
-  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getAlfInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, alf_info_in_ph_flag shall be equal to 0");
-  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getWpInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, wp_info_in_ph_flag shall be equal to 0");
-  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getQpDeltaInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, qp_delta_info_in_ph_flag shall be equal to 0");
-  CHECK(pcSlice->getPictureHeaderInSliceHeader() && sps->getSubPicInfoPresentFlag() == 1, "When sps_subpic_info_present_flag is equal to 1, the value of sh_picture_header_in_slice_header_flag shall be equal to 0");
-  CHECK(sps->getSubPicInfoPresentFlag() == 1 && sps->getVirtualBoundariesEnabledFlag() == 1 && sps->getVirtualBoundariesPresentFlag() == 0,
+  CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() && pps->getRplInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, rpl_info_in_ph_flag shall be equal to 0");
+  CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() && pps->getDbfInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, dbf_info_in_ph_flag shall be equal to 0");
+  CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() && pps->getSaoInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, sao_info_in_ph_flag shall be equal to 0");
+  CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() && pps->getAlfInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, alf_info_in_ph_flag shall be equal to 0");
+  CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() && pps->getWpInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, wp_info_in_ph_flag shall be equal to 0");
+  CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() && pps->getQpDeltaInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, qp_delta_info_in_ph_flag shall be equal to 0");
+  CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() && sps->getSubPicInfoPresentFlag() == 1, "When sps_subpic_info_present_flag is equal to 1, the value of sh_picture_header_in_slice_header_flag shall be equal to 0");
+  CHECK_VTM(sps->getSubPicInfoPresentFlag() == 1 && sps->getVirtualBoundariesEnabledFlag() == 1 && sps->getVirtualBoundariesPresentFlag() == 0,
         "when sps_subpic_info_present_flag is equal to 1 and sps_virtual_boundaries_enabled_flag is equal to 1, sps_virtual_boundaries_present_flag shall be equal 1");
 
   const ChromaFormat chFmt = sps->getChromaFormatIdc();
@@ -3489,7 +3492,7 @@ void HLSyntaxReader::parseSliceHeader (Slice* pcSlice, PicHeader* picHeader, Par
     {
       int bitsSliceAddress = ceilLog2(currSubPic.getNumSlicesInSubPic());
       READ_CODE(bitsSliceAddress, uiCode, "sh_slice_address");  sliceAddr = uiCode;
-      CHECK(sliceAddr >= currSubPic.getNumSlicesInSubPic(), "Invalid slice address");
+      CHECK_VTM(sliceAddr >= currSubPic.getNumSlicesInSubPic(), "Invalid slice address");
     }
     uint32_t picLevelSliceIdx = sliceAddr;
     for(int subpic = 0; subpic < currSubPicIdx; subpic++)
@@ -3521,10 +3524,10 @@ void HLSyntaxReader::parseSliceHeader (Slice* pcSlice, PicHeader* picHeader, Par
       }
       if (!pps->getRectSliceFlag() && sps->getProfileTierLevel()->getConstraintInfo()->getOneSlicePerPicConstraintFlag())
       {
-        CHECK(pps->getNumTiles() != uiCode + 1, "When pps_rect_slice_flag is equal to 0 and one_slice_per_pic_constraint_flag equal to 1, the value of sh_num_tiles_in_slice_minus1 present in each slice header shall be equal to NumTilesInPic - 1");
+        CHECK_VTM(pps->getNumTiles() != uiCode + 1, "When pps_rect_slice_flag is equal to 0 and one_slice_per_pic_constraint_flag equal to 1, the value of sh_num_tiles_in_slice_minus1 present in each slice header shall be equal to NumTilesInPic - 1");
       }
     }
-    CHECK(sliceAddr >= pps->getNumTiles(), "Invalid slice address");
+    CHECK_VTM(sliceAddr >= pps->getNumTiles(), "Invalid slice address");
     pcSlice->initSliceMap();
     pcSlice->setSliceID(sliceAddr);
 
@@ -3532,7 +3535,7 @@ void HLSyntaxReader::parseSliceHeader (Slice* pcSlice, PicHeader* picHeader, Par
     {
       uint32_t tileX = tileIdx % pps->getNumTileColumns();
       uint32_t tileY = tileIdx / pps->getNumTileColumns();
-      CHECK(tileY >= pps->getNumTileRows(), "Number of tiles in slice exceeds the remaining number of tiles in picture");
+      CHECK_VTM(tileY >= pps->getNumTileRows(), "Number of tiles in slice exceeds the remaining number of tiles in picture");
 
       pcSlice->addCtusToSlice(pps->getTileColumnBd(tileX), pps->getTileColumnBd(tileX + 1),
                               pps->getTileRowBd(tileY), pps->getTileRowBd(tileY + 1), pps->getPicWidthInCtu());
@@ -3545,7 +3548,7 @@ void HLSyntaxReader::parseSliceHeader (Slice* pcSlice, PicHeader* picHeader, Par
     VPS *vps = parameterSetManager->getVPS(sps->getVPSId());
     if (pcSlice->isIRAP() && (sps->getVPSId() == 0 || pcSlice->getPOC() != prevPicPOC || vps->getIndependentLayerFlag(vps->getGeneralLayerIdx(pcSlice->getNalUnitLayerId())) == 1))
     {
-      CHECK(uiCode != 2, "When nal_unit_type is in the range of IDR_W_RADL to CRA_NUT, inclusive, and vps_independent_layer_flag[ GeneralLayerIdx[ nuh_layer_id ] ] is equal to 1 or the current picture is the first picture in the current AU, sh_slice_type shall be equal to 2");
+      CHECK_VTM(uiCode != 2, "When nal_unit_type is in the range of IDR_W_RADL to CRA_NUT, inclusive, and vps_independent_layer_flag[ GeneralLayerIdx[ nuh_layer_id ] ] is equal to 1 or the current picture is the first picture in the current AU, sh_slice_type shall be equal to 2");
     }
   }
   else
@@ -3554,7 +3557,7 @@ void HLSyntaxReader::parseSliceHeader (Slice* pcSlice, PicHeader* picHeader, Par
   }
   if (!picHeader->getPicIntraSliceAllowedFlag())
   {
-    CHECK(pcSlice->getSliceType() == I_SLICE, "when ph_intra_slice_allowed_flag = 0, no I_Slice is allowed");
+    CHECK_VTM(pcSlice->getSliceType() == I_SLICE, "when ph_intra_slice_allowed_flag = 0, no I_Slice is allowed");
   }
   if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR)
   {
@@ -3582,8 +3585,8 @@ void HLSyntaxReader::parseSliceHeader (Slice* pcSlice, PicHeader* picHeader, Par
         READ_CODE(3, uiCode, "sh_alf_aps_id_luma[i]");
         apsId[i] = uiCode;
         APS* APStoCheckLuma = parameterSetManager->getAPS(apsId[i], ALF_APS);
-        CHECK(APStoCheckLuma == nullptr, "referenced APS not found");
-        CHECK(APStoCheckLuma->getAlfAPSParam().newFilterFlag[CHANNEL_TYPE_LUMA] != 1, "bitstream conformance error, alf_luma_filter_signal_flag shall be equal to 1");
+        CHECK_VTM(APStoCheckLuma == nullptr, "referenced APS not found");
+        CHECK_VTM(APStoCheckLuma->getAlfAPSParam().newFilterFlag[CHANNEL_TYPE_LUMA] != 1, "bitstream conformance error, alf_luma_filter_signal_flag shall be equal to 1");
       }
 
 
@@ -3603,8 +3606,8 @@ void HLSyntaxReader::parseSliceHeader (Slice* pcSlice, PicHeader* picHeader, Par
         READ_CODE(3, uiCode, "sh_alf_aps_id_chroma");
         pcSlice->setTileGroupApsIdChroma(uiCode);
         APS* APStoCheckChroma = parameterSetManager->getAPS(uiCode, ALF_APS);
-        CHECK(APStoCheckChroma == nullptr, "referenced APS not found");
-        CHECK(APStoCheckChroma->getAlfAPSParam().newFilterFlag[CHANNEL_TYPE_CHROMA] != 1, "bitstream conformance error, alf_chroma_filter_signal_flag shall be equal to 1");
+        CHECK_VTM(APStoCheckChroma == nullptr, "referenced APS not found");
+        CHECK_VTM(APStoCheckChroma->getAlfAPSParam().newFilterFlag[CHANNEL_TYPE_CHROMA] != 1, "bitstream conformance error, alf_chroma_filter_signal_flag shall be equal to 1");
       }
     }
     else
@@ -3927,9 +3930,9 @@ void HLSyntaxReader::parseSliceHeader (Slice* pcSlice, PicHeader* picHeader, Par
 
     if (pcSlice->isInterP() || pcSlice->isInterB())
     {
-      CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_0) == 0, "Number of active entries in RPL0 of P or B picture shall be greater than 0");
+      CHECK_VTM(pcSlice->getNumRefIdx(REF_PIC_LIST_0) == 0, "Number of active entries in RPL0 of P or B picture shall be greater than 0");
       if (pcSlice->isInterB())
-        CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0, "Number of active entries in RPL1 of B picture shall be greater than 0");
+        CHECK_VTM(pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0, "Number of active entries in RPL1 of B picture shall be greater than 0");
     }
 
 
@@ -3981,8 +3984,8 @@ void HLSyntaxReader::parseSliceHeader (Slice* pcSlice, PicHeader* picHeader, Par
     {
       if (pps->getWpInfoInPhFlag())
       {
-        CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_0) > picHeader->getNumL0Weights(), "ERROR: Number of active reference picture L0 is greater than the number of weighted prediction signalled in Picture Header");
-        CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_1) > picHeader->getNumL1Weights(), "ERROR: Number of active reference picture L1 is greater than the number of weighted prediction signalled in Picture Header");
+        CHECK_VTM(pcSlice->getNumRefIdx(REF_PIC_LIST_0) > picHeader->getNumL0Weights(), "ERROR: Number of active reference picture L0 is greater than the number of weighted prediction signalled in Picture Header");
+        CHECK_VTM(pcSlice->getNumRefIdx(REF_PIC_LIST_1) > picHeader->getNumL1Weights(), "ERROR: Number of active reference picture L1 is greater than the number of weighted prediction signalled in Picture Header");
         pcSlice->setWpScaling(picHeader->getWpScalingAll());
       }
       else
@@ -4020,8 +4023,8 @@ void HLSyntaxReader::parseSliceHeader (Slice* pcSlice, PicHeader* picHeader, Par
     pcSlice->setSliceQp(26 + pps->getPicInitQPMinus26() + qpDelta);
     pcSlice->setSliceQpBase(pcSlice->getSliceQp());
 
-    CHECK( pcSlice->getSliceQp() < -sps->getQpBDOffset(CHANNEL_TYPE_LUMA), "Invalid slice QP delta" );
-    CHECK( pcSlice->getSliceQp() > MAX_QP, "Invalid slice QP" );
+    CHECK_VTM( pcSlice->getSliceQp() < -sps->getQpBDOffset(CHANNEL_TYPE_LUMA), "Invalid slice QP delta" );
+    CHECK_VTM( pcSlice->getSliceQp() > MAX_QP, "Invalid slice QP" );
 
     if (pps->getSliceChromaQpFlag())
     {
@@ -4029,28 +4032,28 @@ void HLSyntaxReader::parseSliceHeader (Slice* pcSlice, PicHeader* picHeader, Par
       {
         READ_SVLC( iCode, "sh_cb_qp_offset" );
         pcSlice->setSliceChromaQpDelta(COMPONENT_Cb, iCode );
-        CHECK( pcSlice->getSliceChromaQpDelta(COMPONENT_Cb) < -12, "Invalid chroma QP offset" );
-        CHECK( pcSlice->getSliceChromaQpDelta(COMPONENT_Cb) >  12, "Invalid chroma QP offset" );
-        CHECK( (pps->getQpOffset(COMPONENT_Cb) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cb)) < -12, "Invalid chroma QP offset" );
-        CHECK( (pps->getQpOffset(COMPONENT_Cb) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cb)) >  12, "Invalid chroma QP offset" );
+        CHECK_VTM( pcSlice->getSliceChromaQpDelta(COMPONENT_Cb) < -12, "Invalid chroma QP offset" );
+        CHECK_VTM( pcSlice->getSliceChromaQpDelta(COMPONENT_Cb) >  12, "Invalid chroma QP offset" );
+        CHECK_VTM( (pps->getQpOffset(COMPONENT_Cb) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cb)) < -12, "Invalid chroma QP offset" );
+        CHECK_VTM( (pps->getQpOffset(COMPONENT_Cb) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cb)) >  12, "Invalid chroma QP offset" );
       }
 
       if (numValidComp>COMPONENT_Cr)
       {
         READ_SVLC( iCode, "sh_cr_qp_offset" );
         pcSlice->setSliceChromaQpDelta(COMPONENT_Cr, iCode );
-        CHECK( pcSlice->getSliceChromaQpDelta(COMPONENT_Cr) < -12, "Invalid chroma QP offset" );
-        CHECK( pcSlice->getSliceChromaQpDelta(COMPONENT_Cr) >  12, "Invalid chroma QP offset" );
-        CHECK( (pps->getQpOffset(COMPONENT_Cr) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cr)) < -12, "Invalid chroma QP offset" );
-        CHECK( (pps->getQpOffset(COMPONENT_Cr) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cr)) >  12, "Invalid chroma QP offset" );
+        CHECK_VTM( pcSlice->getSliceChromaQpDelta(COMPONENT_Cr) < -12, "Invalid chroma QP offset" );
+        CHECK_VTM( pcSlice->getSliceChromaQpDelta(COMPONENT_Cr) >  12, "Invalid chroma QP offset" );
+        CHECK_VTM( (pps->getQpOffset(COMPONENT_Cr) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cr)) < -12, "Invalid chroma QP offset" );
+        CHECK_VTM( (pps->getQpOffset(COMPONENT_Cr) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cr)) >  12, "Invalid chroma QP offset" );
         if (sps->getJointCbCrEnabledFlag())
         {
           READ_SVLC(iCode, "sh_joint_cbcr_qp_offset" );
           pcSlice->setSliceChromaQpDelta(JOINT_CbCr, iCode);
-          CHECK( pcSlice->getSliceChromaQpDelta(JOINT_CbCr) < -12, "Invalid chroma QP offset");
-          CHECK( pcSlice->getSliceChromaQpDelta(JOINT_CbCr) >  12, "Invalid chroma QP offset");
-          CHECK( (pps->getQpOffset(JOINT_CbCr) + pcSlice->getSliceChromaQpDelta(JOINT_CbCr)) < -12, "Invalid chroma QP offset");
-          CHECK( (pps->getQpOffset(JOINT_CbCr) + pcSlice->getSliceChromaQpDelta(JOINT_CbCr)) >  12, "Invalid chroma QP offset");
+          CHECK_VTM( pcSlice->getSliceChromaQpDelta(JOINT_CbCr) < -12, "Invalid chroma QP offset");
+          CHECK_VTM( pcSlice->getSliceChromaQpDelta(JOINT_CbCr) >  12, "Invalid chroma QP offset");
+          CHECK_VTM( (pps->getQpOffset(JOINT_CbCr) + pcSlice->getSliceChromaQpDelta(JOINT_CbCr)) < -12, "Invalid chroma QP offset");
+          CHECK_VTM( (pps->getQpOffset(JOINT_CbCr) + pcSlice->getSliceChromaQpDelta(JOINT_CbCr)) >  12, "Invalid chroma QP offset");
         }
       }
     }
@@ -4098,26 +4101,26 @@ void HLSyntaxReader::parseSliceHeader (Slice* pcSlice, PicHeader* picHeader, Par
         if(!pcSlice->getDeblockingFilterDisable())
         {
           READ_SVLC( iCode, "sh_luma_beta_offset_div2" );                     pcSlice->setDeblockingFilterBetaOffsetDiv2( iCode );
-          CHECK(  pcSlice->getDeblockingFilterBetaOffsetDiv2() < -12 ||
+          CHECK_VTM(  pcSlice->getDeblockingFilterBetaOffsetDiv2() < -12 ||
                   pcSlice->getDeblockingFilterBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration");
           READ_SVLC( iCode, "sh_luma_tc_offset_div2" );                       pcSlice->setDeblockingFilterTcOffsetDiv2( iCode );
-          CHECK(  pcSlice->getDeblockingFilterTcOffsetDiv2() < -12 ||
+          CHECK_VTM(  pcSlice->getDeblockingFilterTcOffsetDiv2() < -12 ||
                   pcSlice->getDeblockingFilterTcOffsetDiv2() > 12, "Invalid deblocking filter configuration");
 
           if( pps->getPPSChromaToolFlag() )
           {
             READ_SVLC( iCode, "sh_cb_beta_offset_div2" );                  pcSlice->setDeblockingFilterCbBetaOffsetDiv2( iCode );
-            CHECK( pcSlice->getDeblockingFilterCbBetaOffsetDiv2() < -12 ||
+            CHECK_VTM( pcSlice->getDeblockingFilterCbBetaOffsetDiv2() < -12 ||
               pcSlice->getDeblockingFilterCbBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
             READ_SVLC( iCode, "sh_cb_tc_offset_div2" );                    pcSlice->setDeblockingFilterCbTcOffsetDiv2( iCode );
-            CHECK( pcSlice->getDeblockingFilterCbTcOffsetDiv2() < -12 ||
+            CHECK_VTM( pcSlice->getDeblockingFilterCbTcOffsetDiv2() < -12 ||
               pcSlice->getDeblockingFilterCbTcOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
 
             READ_SVLC( iCode, "sh_cr_beta_offset_div2" );                  pcSlice->setDeblockingFilterCrBetaOffsetDiv2( iCode );
-            CHECK( pcSlice->getDeblockingFilterCrBetaOffsetDiv2() < -12 ||
+            CHECK_VTM( pcSlice->getDeblockingFilterCrBetaOffsetDiv2() < -12 ||
               pcSlice->getDeblockingFilterCrBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
             READ_SVLC( iCode, "sh_cr_tc_offset_div2" );                    pcSlice->setDeblockingFilterCrTcOffsetDiv2( iCode );
-            CHECK( pcSlice->getDeblockingFilterCrTcOffsetDiv2() < -12 ||
+            CHECK_VTM( pcSlice->getDeblockingFilterCrTcOffsetDiv2() < -12 ||
               pcSlice->getDeblockingFilterCrTcOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
           }
           else
@@ -4270,14 +4273,14 @@ void HLSyntaxReader::getSlicePoc(Slice* pcSlice, PicHeader* picHeader, Parameter
   PPS* pps = NULL;
   SPS* sps = NULL;
 
-  CHECK(picHeader==0, "Invalid Picture Header");
-  CHECK(picHeader->isValid()==false, "Invalid Picture Header");
+  CHECK_VTM(picHeader==0, "Invalid Picture Header");
+  CHECK_VTM(picHeader->isValid()==false, "Invalid Picture Header");
   pps = parameterSetManager->getPPS( picHeader->getPPSId() );
   //!KS: need to add error handling code here, if PPS is not available
-  CHECK(pps==0, "Invalid PPS");
+  CHECK_VTM(pps==0, "Invalid PPS");
   sps = parameterSetManager->getSPS(pps->getSPSId());
   //!KS: need to add error handling code here, if SPS is not available
-  CHECK(sps==0, "Invalid SPS");
+  CHECK_VTM(sps==0, "Invalid SPS");
 
   DTRACE_UPDATE( g_trace_ctx, std::make_pair( "final", 0 ) );
 
@@ -4361,7 +4364,7 @@ void HLSyntaxReader::parseConstraintInfo(ConstraintInfo *cinfo)
 
     /* picture format */
     READ_CODE(4, symbol, "gci_sixteen_minus_max_bitdepth_constraint_idc"); cinfo->setMaxBitDepthConstraintIdc(symbol>8 ? 16 : (16 - symbol));
-    CHECK(symbol>8, "gci_sixteen_minus_max_bitdepth_constraint_idc shall be in the range 0 to 8, inclusive");
+    CHECK_VTM(symbol>8, "gci_sixteen_minus_max_bitdepth_constraint_idc shall be in the range 0 to 8, inclusive");
     READ_CODE(2, symbol, "gci_three_minus_max_chroma_format_constraint_idc"); cinfo->setMaxChromaFormatConstraintIdc((ChromaFormat)(3 - symbol));
 
     /* NAL unit type related */
@@ -4442,12 +4445,14 @@ void HLSyntaxReader::parseConstraintInfo(ConstraintInfo *cinfo)
     uint32_t const numReservedBits = symbol;
     for (int i = 0; i < numReservedBits; i++)
     {
-      READ_FLAG(symbol, "gci_reserved_zero_bit");                    CHECK(symbol != 0, "gci_reserved_zero_bit not equal to zero");
+      READ_FLAG(symbol, "gci_reserved_zero_bit");
+      CHECK_VTM(symbol != 0, "gci_reserved_zero_bit not equal to zero");
     }
   }
   while (!isByteAligned())
   {
-    READ_FLAG(symbol, "gci_alignment_zero_bit");                     CHECK(symbol != 0, "gci_alignment_zero_bit not equal to zero");
+    READ_FLAG(symbol, "gci_alignment_zero_bit");
+    CHECK_VTM(symbol != 0, "gci_alignment_zero_bit not equal to zero");
   }
 }
 
@@ -4465,7 +4470,7 @@ void HLSyntaxReader::parseProfileTierLevel(ProfileTierLevel *ptl, bool profileTi
 
   READ_FLAG(      symbol,   "ptl_frame_only_constraint_flag"   ); ptl->setFrameOnlyConstraintFlag(symbol);
   READ_FLAG(      symbol,   "ptl_multilayer_enabled_flag"      ); ptl->setMultiLayerEnabledFlag(symbol);
-  CHECK((ptl->getProfileIdc() == Profile::MAIN_10 || ptl->getProfileIdc() == Profile::MAIN_10_444
+  CHECK_VTM((ptl->getProfileIdc() == Profile::MAIN_10 || ptl->getProfileIdc() == Profile::MAIN_10_444
          || ptl->getProfileIdc() == Profile::MAIN_10_STILL_PICTURE
          || ptl->getProfileIdc() == Profile::MAIN_10_444_STILL_PICTURE)
           && symbol,
@@ -4483,7 +4488,8 @@ void HLSyntaxReader::parseProfileTierLevel(ProfileTierLevel *ptl, bool profileTi
 
   while (!isByteAligned())
   {
-    READ_FLAG(    symbol,   "ptl_reserved_zero_bit"         ); CHECK (symbol != 0, "ptl_reserved_zero_bit not equal to zero");
+    READ_FLAG(    symbol,   "ptl_reserved_zero_bit"         );
+    CHECK_VTM(symbol != 0, "ptl_reserved_zero_bit not equal to zero");
   }
 
   for (int i = maxNumSubLayersMinus1 - 1; i >= 0; i--)
@@ -4535,7 +4541,7 @@ void HLSyntaxReader::parseRemainingBytes( bool noTrailingBytesExpected )
 {
   if (noTrailingBytesExpected)
   {
-    CHECK( 0 != m_pcBitstream->getNumBitsLeft(), "Bits left although no bits expected" );
+    CHECK_VTM( 0 != m_pcBitstream->getNumBitsLeft(), "Bits left although no bits expected" );
   }
   else
   {
@@ -4572,12 +4578,12 @@ void HLSyntaxReader::parsePredWeightTable( Slice* pcSlice, const SPS *sps )
   int iDeltaDenom;
   // decode delta_luma_log2_weight_denom :
   READ_UVLC( uiLog2WeightDenomLuma, "luma_log2_weight_denom" );
-  CHECK( uiLog2WeightDenomLuma > 7, "The value of luma_log2_weight_denom shall be in the range of 0 to 7" );
+  CHECK_VTM( uiLog2WeightDenomLuma > 7, "The value of luma_log2_weight_denom shall be in the range of 0 to 7" );
   if( bChroma )
   {
     READ_SVLC( iDeltaDenom, "delta_chroma_log2_weight_denom" );
-    CHECK((iDeltaDenom + (int)uiLog2WeightDenomLuma)<0, "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
-    CHECK((iDeltaDenom + (int)uiLog2WeightDenomLuma)>7, "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
+    CHECK_VTM((iDeltaDenom + (int)uiLog2WeightDenomLuma)<0, "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
+    CHECK_VTM((iDeltaDenom + (int)uiLog2WeightDenomLuma)>7, "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
     uiLog2WeightDenomChroma = (uint32_t)(iDeltaDenom + uiLog2WeightDenomLuma);
   }
 
@@ -4630,13 +4636,13 @@ void HLSyntaxReader::parsePredWeightTable( Slice* pcSlice, const SPS *sps )
       {
         int iDeltaWeight;
         READ_SVLC( iDeltaWeight, iNumRef==0?"delta_luma_weight_l0[i]":"delta_luma_weight_l1[i]" );
-        CHECK( iDeltaWeight < -128, "delta_luma_weight_lx shall be in the rage of -128 to 127" );
-        CHECK( iDeltaWeight >  127, "delta_luma_weight_lx shall be in the rage of -128 to 127" );
+        CHECK_VTM( iDeltaWeight < -128, "delta_luma_weight_lx shall be in the rage of -128 to 127" );
+        CHECK_VTM( iDeltaWeight >  127, "delta_luma_weight_lx shall be in the rage of -128 to 127" );
         wp[COMPONENT_Y].codedWeight = (iDeltaWeight + (1 << wp[COMPONENT_Y].log2WeightDenom));
         READ_SVLC(wp[COMPONENT_Y].codedOffset, iNumRef == 0 ? "luma_offset_l0[i]" : "luma_offset_l1[i]");
         const int range=sps->getSpsRangeExtension().getHighPrecisionOffsetsEnabledFlag() ? (1<<sps->getBitDepth(CHANNEL_TYPE_LUMA))/2 : 128;
-        CHECK(wp[0].codedOffset < -range, "luma_offset_lx shall be in the rage of -128 to 127");
-        CHECK(wp[0].codedOffset >= range, "luma_offset_lx shall be in the rage of -128 to 127");
+        CHECK_VTM(wp[0].codedOffset < -range, "luma_offset_lx shall be in the rage of -128 to 127");
+        CHECK_VTM(wp[0].codedOffset >= range, "luma_offset_lx shall be in the rage of -128 to 127");
       }
       else
       {
@@ -4652,14 +4658,14 @@ void HLSyntaxReader::parsePredWeightTable( Slice* pcSlice, const SPS *sps )
           {
             int iDeltaWeight;
             READ_SVLC( iDeltaWeight, iNumRef==0?"delta_chroma_weight_l0[i]":"delta_chroma_weight_l1[i]" );
-            CHECK( iDeltaWeight < -128, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
-            CHECK( iDeltaWeight >  127, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
+            CHECK_VTM( iDeltaWeight < -128, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
+            CHECK_VTM( iDeltaWeight >  127, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
             wp[j].codedWeight = (iDeltaWeight + (1 << wp[j].log2WeightDenom));
 
             int iDeltaChroma;
             READ_SVLC( iDeltaChroma, iNumRef==0?"delta_chroma_offset_l0[i]":"delta_chroma_offset_l1[i]" );
-            CHECK( iDeltaChroma <  -4*range, "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
-            CHECK( iDeltaChroma >  4*(range-1), "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
+            CHECK_VTM( iDeltaChroma <  -4*range, "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
+            CHECK_VTM( iDeltaChroma >  4*(range-1), "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
             int pred          = (range - ((range * wp[j].codedWeight) >> (wp[j].log2WeightDenom)));
             wp[j].codedOffset = Clip3(-range, range - 1, (iDeltaChroma + pred));
           }
@@ -4684,7 +4690,7 @@ void HLSyntaxReader::parsePredWeightTable( Slice* pcSlice, const SPS *sps )
       wp[COMPONENT_Cr].presentFlag = false;
     }
   }
-  CHECK(uiTotalSignalledWeightFlags>24, "Too many weight flag signalled");
+  CHECK_VTM(uiTotalSignalledWeightFlags>24, "Too many weight flag signalled");
 }
 
 void HLSyntaxReader::parsePredWeightTable(PicHeader *picHeader, const SPS *sps)
@@ -4699,12 +4705,12 @@ void HLSyntaxReader::parsePredWeightTable(PicHeader *picHeader, const SPS *sps)
 
   int deltaDenom;
   READ_UVLC(log2WeightDenomLuma, "luma_log2_weight_denom");
-  CHECK(log2WeightDenomLuma > 7, "The value of luma_log2_weight_denom shall be in the range of 0 to 7");
+  CHECK_VTM(log2WeightDenomLuma > 7, "The value of luma_log2_weight_denom shall be in the range of 0 to 7");
   if (chroma)
   {
     READ_SVLC(deltaDenom, "delta_chroma_log2_weight_denom");
-    CHECK((deltaDenom + (int) log2WeightDenomLuma) < 0, "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
-    CHECK((deltaDenom + (int) log2WeightDenomLuma) > 7, "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
+    CHECK_VTM((deltaDenom + (int) log2WeightDenomLuma) < 0, "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
+    CHECK_VTM((deltaDenom + (int) log2WeightDenomLuma) > 7, "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
     log2WeightDenomChroma = (uint32_t)(deltaDenom + log2WeightDenomLuma);
   }
 
@@ -4762,13 +4768,13 @@ void HLSyntaxReader::parsePredWeightTable(PicHeader *picHeader, const SPS *sps)
       {
         int deltaWeight;
         READ_SVLC(deltaWeight, numRef == 0 ? "delta_luma_weight_l0[i]" : "delta_luma_weight_l1[i]");
-        CHECK(deltaWeight < -128, "delta_luma_weight_lx shall be in the rage of -128 to 127");
-        CHECK(deltaWeight > 127, "delta_luma_weight_lx shall be in the rage of -128 to 127");
+        CHECK_VTM(deltaWeight < -128, "delta_luma_weight_lx shall be in the rage of -128 to 127");
+        CHECK_VTM(deltaWeight > 127, "delta_luma_weight_lx shall be in the rage of -128 to 127");
         wp[COMPONENT_Y].codedWeight = (deltaWeight + (1 << wp[COMPONENT_Y].log2WeightDenom));
         READ_SVLC(wp[COMPONENT_Y].codedOffset, numRef == 0 ? "luma_offset_l0[i]" : "luma_offset_l1[i]");
         const int range = sps->getSpsRangeExtension().getHighPrecisionOffsetsEnabledFlag() ? (1 << sps->getBitDepth(CHANNEL_TYPE_LUMA)) / 2 : 128;
-        CHECK(wp[0].codedOffset < -range, "luma_offset_lx shall be in the rage of -128 to 127");
-        CHECK(wp[0].codedOffset >= range, "luma_offset_lx shall be in the rage of -128 to 127");
+        CHECK_VTM(wp[0].codedOffset < -range, "luma_offset_lx shall be in the rage of -128 to 127");
+        CHECK_VTM(wp[0].codedOffset >= range, "luma_offset_lx shall be in the rage of -128 to 127");
       }
       else
       {
@@ -4784,14 +4790,14 @@ void HLSyntaxReader::parsePredWeightTable(PicHeader *picHeader, const SPS *sps)
           {
             int deltaWeight;
             READ_SVLC(deltaWeight, numRef == 0 ? "delta_chroma_weight_l0[i]" : "delta_chroma_weight_l1[i]");
-            CHECK( deltaWeight < -128, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
-            CHECK( deltaWeight >  127, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
+            CHECK_VTM( deltaWeight < -128, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
+            CHECK_VTM( deltaWeight >  127, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
             wp[j].codedWeight = (deltaWeight + (1 << wp[j].log2WeightDenom));
 
             int deltaChroma;
             READ_SVLC(deltaChroma, numRef == 0 ? "delta_chroma_offset_l0[i]" : "delta_chroma_offset_l1[i]");
-            CHECK( deltaChroma <  -4*range, "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
-            CHECK( deltaChroma >=  4*range, "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
+            CHECK_VTM( deltaChroma <  -4*range, "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
+            CHECK_VTM( deltaChroma >=  4*range, "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
             int pred          = (range - ((range * wp[j].codedWeight) >> (wp[j].log2WeightDenom)));
             wp[j].codedOffset = Clip3(-range, range - 1, (deltaChroma + pred));
           }
@@ -4830,7 +4836,7 @@ void HLSyntaxReader::parsePredWeightTable(PicHeader *picHeader, const SPS *sps)
       picHeader->setNumL1Weights(numLxWeights);
     }
   }
-  CHECK(totalSignalledWeightFlags > 24, "Too many weight flag signalled");
+  CHECK_VTM(totalSignalledWeightFlags > 24, "Too many weight flag signalled");
 }
 
 /** decode quantization matrix
@@ -4912,7 +4918,7 @@ void HLSyntaxReader::decodeScalingList(ScalingList *scalingList, uint32_t scalin
   int *dst = scalingList->getScalingListAddress(scalingListId);
 
   int PredListId = scalingList->getRefMatrixId(scalingListId);
-  CHECK(isPredictor && PredListId > scalingListId, "Scaling List error predictor!");
+  CHECK_VTM(isPredictor && PredListId > scalingListId, "Scaling List error predictor!");
   const int *srcPred = (isPredictor) ? ((scalingListId == PredListId) ? scalingList->getScalingListDefaultAddress(scalingListId) : scalingList->getScalingListAddress(PredListId)) : NULL;
   if(isPredictor && scalingListId == PredListId)
     scalingList->setScalingListDC(PredListId, SCALING_LIST_DC);
@@ -4966,7 +4972,7 @@ bool HLSyntaxReader::xMoreRbspData()
   cnt--;
 
   // we should not have a negative number of bits
-  CHECK (cnt<0, "Negative number of bits");
+  CHECK_VTM(cnt<0, "Negative number of bits");
 
   // we have more data, if cnt is not zero
   return (cnt>0);
@@ -4997,7 +5003,7 @@ void HLSyntaxReader::alfFilter( AlfParam& alfParam, const bool isChroma, const i
         READ_FLAG( code, isChroma ? "alf_chroma_coeff_sign" : "alf_luma_coeff_sign" );
         coeff[ ind * MAX_NUM_ALF_LUMA_COEFF + i ] = ( code ) ? -coeff[ ind * MAX_NUM_ALF_LUMA_COEFF + i ] : coeff[ ind * MAX_NUM_ALF_LUMA_COEFF + i ];
        }
-      CHECK( isChroma &&
+       CHECK_VTM( isChroma &&
              ( coeff[ind * MAX_NUM_ALF_LUMA_COEFF + i] > 127 || coeff[ind * MAX_NUM_ALF_LUMA_COEFF + i] < -128 )
              , "AlfCoeffC shall be in the range of -128 to 127, inclusive" );
     }
diff --git a/source/Lib/EncoderLib/AQp.cpp b/source/Lib/EncoderLib/AQp.cpp
index a157e1c..6e2a13e 100644
--- a/source/Lib/EncoderLib/AQp.cpp
+++ b/source/Lib/EncoderLib/AQp.cpp
@@ -123,8 +123,8 @@ void AQpPreanalyzer::preanalyze( Picture* pcEPic )
           pBlkY += iStride;
         }
 
-        CHECK((uiCurrAQPartWidth&1)!=0,  "Odd part width unsupported");
-        CHECK((uiCurrAQPartHeight&1)!=0, "Odd part height unsupported");
+        CHECK_VTM((uiCurrAQPartWidth&1)!=0,  "Odd part width unsupported");
+        CHECK_VTM((uiCurrAQPartHeight&1)!=0, "Odd part height unsupported");
         const uint32_t pixelWidthOfQuadrants  = uiCurrAQPartWidth >>1;
         const uint32_t pixelHeightOfQuadrants = uiCurrAQPartHeight>>1;
         const uint32_t numPixInAQPart         = pixelWidthOfQuadrants * pixelHeightOfQuadrants;
diff --git a/source/Lib/EncoderLib/CABACWriter.cpp b/source/Lib/EncoderLib/CABACWriter.cpp
index 087cb0c..6d2c9cf 100644
--- a/source/Lib/EncoderLib/CABACWriter.cpp
+++ b/source/Lib/EncoderLib/CABACWriter.cpp
@@ -306,7 +306,7 @@ void CABACWriter::sao_offset_pars( const SAOOffset& ctbPars, ComponentID compID,
 {
   if( !sliceEnabled )
   {
-    CHECK( ctbPars.modeIdc != SAO_MODE_OFF, "Sao must be off, if it is disabled on slice level" );
+    CHECK_VTM( ctbPars.modeIdc != SAO_MODE_OFF, "Sao must be off, if it is disabled on slice level" );
     return;
   }
   const bool isFirstCompOfChType = ( getFirstComponentOfChannel( toChannelType(compID) ) == compID );
@@ -325,7 +325,7 @@ void CABACWriter::sao_offset_pars( const SAOOffset& ctbPars, ComponentID compID,
     }
     else
     {
-      CHECK(!( ctbPars.typeIdc < SAO_TYPE_START_BO ), "Unspecified error");
+      CHECK_VTM(!( ctbPars.typeIdc < SAO_TYPE_START_BO ), "Unspecified error");
       m_BinEncoder.encodeBin  ( 1, Ctx::SaoTypeIdx() );
       m_BinEncoder.encodeBinEP( 1 );
     }
@@ -374,7 +374,7 @@ void CABACWriter::sao_offset_pars( const SAOOffset& ctbPars, ComponentID compID,
       if( isFirstCompOfChType )
       {
         // sao_eo_class_luma / sao_eo_class_chroma
-        CHECK( ctbPars.typeIdc - SAO_TYPE_START_EO < 0, "sao edge offset class is outside valid range" );
+        CHECK_VTM( ctbPars.typeIdc - SAO_TYPE_START_EO < 0, "sao edge offset class is outside valid range" );
         m_BinEncoder.encodeBinsEP( ctbPars.typeIdc - SAO_TYPE_START_EO, NUM_SAO_EO_TYPES_LOG2 );
       }
     }
@@ -426,7 +426,7 @@ void CABACWriter::coding_tree(const CodingStructure& cs, Partitioner& partitione
 
   split_cu_mode( splitMode, cs, partitioner );
 
-  CHECK( !partitioner.canSplit( splitMode, cs ), "The chosen split mode is invalid!" );
+  CHECK_VTM( !partitioner.canSplit( splitMode, cs ), "The chosen split mode is invalid!" );
 
   if( splitMode != CU_DONT_SPLIT )
   {
@@ -448,7 +448,7 @@ void CABACWriter::coding_tree(const CodingStructure& cs, Partitioner& partitione
             }
             lumaContinue = partitioner.nextPart(cs);
             chromaContinue = pPartitionerChroma->nextPart(cs);
-            CHECK(lumaContinue != chromaContinue, "luma chroma partition should be matched");
+            CHECK_VTM(lumaContinue != chromaContinue, "luma chroma partition should be matched");
             beContinue = lumaContinue;
           }
           else
@@ -464,7 +464,7 @@ void CABACWriter::coding_tree(const CodingStructure& cs, Partitioner& partitione
               coding_tree(cs, *pPartitionerChroma, *pCuCtxChroma);
             }
             chromaContinue = pPartitionerChroma->nextPart(cs);
-            CHECK(lumaContinue != chromaContinue, "luma chroma partition should be matched");
+            CHECK_VTM(lumaContinue != chromaContinue, "luma chroma partition should be matched");
             beContinue = lumaContinue;
           }
         }
@@ -480,7 +480,7 @@ void CABACWriter::coding_tree(const CodingStructure& cs, Partitioner& partitione
         partitioner.modeType = modeTypeChild;
 
         bool chromaNotSplit = modeTypeParent == MODE_TYPE_ALL && modeTypeChild == MODE_TYPE_INTRA ? true : false;
-        CHECK( chromaNotSplit && partitioner.chType != CHANNEL_TYPE_LUMA, "chType must be luma" );
+        CHECK_VTM( chromaNotSplit && partitioner.chType != CHANNEL_TYPE_LUMA, "chType must be luma" );
         if( partitioner.treeType == TREE_D )
         {
           partitioner.treeType = chromaNotSplit ? TREE_L : TREE_D;
@@ -500,7 +500,7 @@ void CABACWriter::coding_tree(const CodingStructure& cs, Partitioner& partitione
       {
         if (isChromaEnabled(cs.pcv->chrFormat))
         {
-        CHECK( partitioner.chType != CHANNEL_TYPE_LUMA, "must be luma status" );
+          CHECK_VTM( partitioner.chType != CHANNEL_TYPE_LUMA, "must be luma status" );
         partitioner.chType = CHANNEL_TYPE_CHROMA;
         partitioner.treeType = TREE_C;
 
@@ -525,7 +525,7 @@ void CABACWriter::coding_tree(const CodingStructure& cs, Partitioner& partitione
     cuCtx.qgStart = false;
     cuCtx.qp = CU::predictQP( cu, cuCtx.qp );
   }
-  CHECK( cu.treeType != partitioner.treeType, "treeType mismatch" );
+  CHECK_VTM( cu.treeType != partitioner.treeType, "treeType mismatch" );
 
 
   // coding unit
@@ -544,11 +544,11 @@ void CABACWriter::coding_tree(const CodingStructure& cs, Partitioner& partitione
 
 void CABACWriter::mode_constraint( const PartSplit split, const CodingStructure& cs, Partitioner& partitioner, const ModeType modeType )
 {
-  CHECK( split == CU_DONT_SPLIT, "splitMode shall not be no split" );
+  CHECK_VTM( split == CU_DONT_SPLIT, "splitMode shall not be no split" );
   int val = cs.signalModeCons( split, partitioner, partitioner.modeType );
   if( val == LDT_MODE_TYPE_SIGNAL )
   {
-    CHECK( modeType == MODE_TYPE_ALL, "shall not be no constraint case" );
+    CHECK_VTM( modeType == MODE_TYPE_ALL, "shall not be no constraint case" );
     bool flag = modeType == MODE_TYPE_INTRA;
     int ctxIdx = DeriveCtx::CtxModeConsFlag( cs, partitioner );
     m_BinEncoder.encodeBin( flag, Ctx::ModeConsFlag( ctxIdx ) );
@@ -656,8 +656,8 @@ void CABACWriter::coding_unit( const CodingUnit& cu, Partitioner& partitioner, C
   // skip data
   if( cu.skip )
   {
-    CHECK( !cu.firstPU->mergeFlag, "Merge flag has to be on!" );
-    CHECK(cu.colorTransform, "ACT should not be enabled for skip mode");
+    CHECK_VTM( !cu.firstPU->mergeFlag, "Merge flag has to be on!" );
+    CHECK_VTM(cu.colorTransform, "ACT should not be enabled for skip mode");
     PredictionUnit&   pu = *cu.firstPU;
     prediction_unit ( pu );
     end_of_ctu      ( cu, cuCtx );
@@ -673,7 +673,7 @@ void CABACWriter::coding_unit( const CodingUnit& cu, Partitioner& partitioner, C
   }
   if (CU::isPLT(cu))
   {
-    CHECK(cu.colorTransform, "ACT should not be enabled for PLT mode");
+    CHECK_VTM(cu.colorTransform, "ACT should not be enabled for PLT mode");
     if (cu.isSepTree())
     {
       if (isLuma(partitioner.chType))
@@ -881,7 +881,7 @@ void CABACWriter::cu_bcw_flag(const CodingUnit& cu)
     return;
   }
 
-  CHECK(!(BCW_NUM > 1 && (BCW_NUM == 2 || (BCW_NUM & 0x01) == 1)), " !( BCW_NUM > 1 && ( BCW_NUM == 2 || ( BCW_NUM & 0x01 ) == 1 ) ) ");
+  CHECK_VTM(!(BCW_NUM > 1 && (BCW_NUM == 2 || (BCW_NUM & 0x01) == 1)), " !( BCW_NUM > 1 && ( BCW_NUM == 2 || ( BCW_NUM & 0x01 ) == 1 ) ) ");
   const uint8_t bcwCodingIdx = (uint8_t)g_BcwCodingOrder[CU::getValidBcwIdx(cu)];
 
   const int32_t numBcw = (cu.slice->getCheckLDC()) ? 5 : 3;
@@ -1064,7 +1064,7 @@ void CABACWriter::intra_luma_pred_modes( const CodingUnit& cu )
     }
     if ( pu->multiRefIdx )
     {
-      CHECK(mpm_idx >= numMPMs, "use of non-MPM");
+      CHECK_VTM(mpm_idx >= numMPMs, "use of non-MPM");
     }
     else
     {
@@ -1120,7 +1120,7 @@ void CABACWriter::intra_luma_pred_modes( const CodingUnit& cu )
             ipred_mode--;
           }
         }
-        CHECK(ipred_mode >= 64, "Incorrect mode");
+        CHECK_VTM(ipred_mode >= 64, "Incorrect mode");
         xWriteTruncBinCode(ipred_mode, NUM_LUMA_MODE - NUM_MOST_PROBABLE_MODES);  // Remaining mode is truncated binary coded
       }
     }
@@ -1163,7 +1163,7 @@ void CABACWriter::intra_luma_pred_mode( const PredictionUnit& pu )
   }
   if ( pu.multiRefIdx )
   {
-    CHECK(mpm_idx >= numMPMs, "use of non-MPM");
+    CHECK_VTM(mpm_idx >= numMPMs, "use of non-MPM");
   }
   else
   {
@@ -1242,13 +1242,13 @@ void CABACWriter::intra_chroma_lmc_mode(const PredictionUnit& pu)
       break;
     }
   }
-  CHECK(symbol < 0, "invalid symbol found");
+  CHECK_VTM(symbol < 0, "invalid symbol found");
 
   m_BinEncoder.encodeBin(symbol == 0 ? 0 : 1, Ctx::CclmModeIdx(0));
 
   if (symbol > 0)
   {
-    CHECK(symbol > 2, "invalid symbol for MMLM");
+    CHECK_VTM(symbol > 2, "invalid symbol for MMLM");
     unsigned int symbol_minus_1 = symbol - 1;
     m_BinEncoder.encodeBinEP(symbol_minus_1);
   }
@@ -1261,7 +1261,7 @@ void CABACWriter::intra_chroma_pred_mode(const PredictionUnit& pu)
   const unsigned intraDir = pu.intraDir[1];
   if (pu.cu->colorTransform)
   {
-    CHECK(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "chroma should use DM for adaptive color transform");
+    CHECK_VTM(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "chroma should use DM for adaptive color transform");
     return;
   }
   if (pu.cs->sps->getUseLMChroma() && pu.cu->checkCCLMAllowed())
@@ -1294,8 +1294,8 @@ void CABACWriter::intra_chroma_pred_mode(const PredictionUnit& pu)
     }
   }
 
-  CHECK(candId >= NUM_CHROMA_MODE, "Chroma prediction mode index out of bounds");
-  CHECK(chromaCandModes[candId] == DM_CHROMA_IDX, "The intra dir cannot be DM_CHROMA for this path");
+  CHECK_VTM(candId >= NUM_CHROMA_MODE, "Chroma prediction mode index out of bounds");
+  CHECK_VTM(chromaCandModes[candId] == DM_CHROMA_IDX, "The intra dir cannot be DM_CHROMA for this path");
   {
     m_BinEncoder.encodeBinsEP(candId, 2);
   }
@@ -1317,7 +1317,7 @@ void CABACWriter::cu_residual( const CodingUnit& cu, Partitioner& partitioner, C
 
     if( !cu.rootCbf )
     {
-      CHECK(cu.colorTransform, "ACT should not be enabled for root_cbf = 0");
+      CHECK_VTM(cu.colorTransform, "ACT should not be enabled for root_cbf = 0");
       return;
     }
   }
@@ -1363,7 +1363,7 @@ void CABACWriter::adaptive_color_transform(const CodingUnit& cu)
 
   if (cu.isSepTree())
   {
-    CHECK(cu.colorTransform, "adaptive color transform should be disabled when dualtree and localtree are enabled");
+    CHECK_VTM(cu.colorTransform, "adaptive color transform should be disabled when dualtree and localtree are enabled");
     return;
   }
 
@@ -1517,7 +1517,7 @@ void CABACWriter::cu_palette_info(const CodingUnit& cu, ComponentID compBegin, u
   {
     cuPaletteSubblockInfo(cu, compBegin, numComp, subSetId, prevRunPos, prevRunType);
   }
-  CHECK(cu.curPLTSize[compBegin] > maxPltSize, " Current palette size is larger than maximum palette size");
+  CHECK_VTM(cu.curPLTSize[compBegin] > maxPltSize, " Current palette size is larger than maximum palette size");
 }
 void CABACWriter::cuPaletteSubblockInfo(const CodingUnit& cu, ComponentID compBegin, uint32_t numComp, int subSetId, uint32_t& prevRunPos, unsigned& prevRunType)
 {
@@ -1738,7 +1738,7 @@ Pel CABACWriter::writePLTIndex(const CodingUnit& cu, uint32_t idx, PelBuf& palet
 
 void CABACWriter::prediction_unit( const PredictionUnit& pu )
 {
-  CHECK( pu.cu->treeType == TREE_C, "cannot be chroma CU" );
+  CHECK_VTM( pu.cu->treeType == TREE_C, "cannot be chroma CU" );
 #if ENABLE_SPLIT_PARALLELISM
   CHECK( pu.cacheUsed, "Processing a PU that should be in cache!" );
   CHECK( pu.cu->cacheUsed, "Processing a CU that should be in cache!" );
@@ -1746,7 +1746,7 @@ void CABACWriter::prediction_unit( const PredictionUnit& pu )
 #endif
   if( pu.cu->skip )
   {
-    CHECK( !pu.mergeFlag, "merge_flag must be true for skipped CUs" );
+    CHECK_VTM( !pu.mergeFlag, "merge_flag must be true for skipped CUs" );
   }
   else
   {
@@ -1764,7 +1764,7 @@ void CABACWriter::prediction_unit( const PredictionUnit& pu )
     mvd_coding(mvd, 0); // already changed to signaling precision
     if (pu.cs->sps->getMaxNumIBCMergeCand() == 1)
     {
-      CHECK( pu.mvpIdx[REF_PIC_LIST_0], "mvpIdx for IBC mode should be 0" );
+      CHECK_VTM( pu.mvpIdx[REF_PIC_LIST_0], "mvpIdx for IBC mode should be 0" );
     }
     else
     mvp_flag(pu, REF_PIC_LIST_0);
@@ -2044,9 +2044,9 @@ void CABACWriter::merge_idx( const PredictionUnit& pu )
       xWriteTruncBinCode(splitDir, GEO_NUM_PARTITION_MODE);
       candIdx1 -= candIdx1 < candIdx0 ? 0 : 1;
       const int maxNumGeoCand = pu.cs->sps->getMaxNumGeoCand();
-      CHECK(maxNumGeoCand < 2, "Incorrect max number of geo candidates");
-      CHECK(candIdx0 >= maxNumGeoCand, "Incorrect candIdx0");
-      CHECK(candIdx1 >= maxNumGeoCand, "Incorrect candIdx1");
+      CHECK_VTM(maxNumGeoCand < 2, "Incorrect max number of geo candidates");
+      CHECK_VTM(candIdx0 >= maxNumGeoCand, "Incorrect candIdx0");
+      CHECK_VTM(candIdx1 >= maxNumGeoCand, "Incorrect candIdx1");
       int numCandminus2 = maxNumGeoCand - 2;
       m_BinEncoder.encodeBin( candIdx0 == 0 ? 0 : 1, Ctx::MergeIdx() );
       if( candIdx0 > 0 )
@@ -2163,7 +2163,7 @@ void CABACWriter::ref_idx( const PredictionUnit& pu, RefPicList eRefList )
 {
   if ( pu.cu->smvdMode )
   {
-    CHECK( pu.refIdx[eRefList] != pu.cs->slice->getSymRefIdx( eRefList ), "Invalid reference index!\n" );
+    CHECK_VTM( pu.refIdx[eRefList] != pu.cs->slice->getSymRefIdx( eRefList ), "Invalid reference index!\n" );
     return;
   }
 
@@ -2218,12 +2218,12 @@ void CABACWriter::Ciip_flag(const PredictionUnit& pu)
 {
   if (!pu.cs->sps->getUseCiip())
   {
-    CHECK(pu.ciipFlag == true, "invalid Ciip SPS");
+    CHECK_VTM(pu.ciipFlag == true, "invalid Ciip SPS");
     return;
   }
   if (pu.cu->skip)
   {
-    CHECK(pu.ciipFlag == true, "invalid Ciip and skip");
+    CHECK_VTM(pu.ciipFlag == true, "invalid Ciip and skip");
     return;
   }
   m_BinEncoder.encodeBin(pu.ciipFlag, Ctx::CiipFlag());
@@ -2253,14 +2253,14 @@ void CABACWriter::transform_tree( const CodingStructure& cs, Partitioner& partit
   // split_transform_flag
   if( partitioner.canSplit( TU_MAX_TR_SPLIT, cs ) )
   {
-    CHECK( !split, "transform split implied" );
+    CHECK_VTM( !split, "transform split implied" );
   }
   else if( cu.sbtInfo && partitioner.canSplit( PartSplit( cu.getSbtTuSplit() ), cs ) )
   {
-    CHECK( !split, "transform split implied - sbt" );
+    CHECK_VTM( !split, "transform split implied - sbt" );
   }
   else
-  CHECK( split && !cu.ispMode, "transform split not allowed with QTBT" );
+    CHECK_VTM( split && !cu.ispMode, "transform split not allowed with QTBT" );
 
 
   if( split )
@@ -2340,17 +2340,17 @@ void CABACWriter::mvd_coding( const Mv &rMvd, int8_t imv )
   int       verMvd = rMvd.getVer();
   if ( imv > 0 )
   {
-    CHECK((horMvd % 2) != 0 && (verMvd % 2) != 0, "IMV: MVD is not a multiple of 2");
+    CHECK_VTM((horMvd % 2) != 0 && (verMvd % 2) != 0, "IMV: MVD is not a multiple of 2");
     horMvd >>= 1;
     verMvd >>= 1;
     if (imv < IMV_HPEL)
     {
-      CHECK((horMvd % 2) != 0 && (verMvd % 2) != 0, "IMV: MVD is not a multiple of 4");
+      CHECK_VTM((horMvd % 2) != 0 && (verMvd % 2) != 0, "IMV: MVD is not a multiple of 4");
       horMvd >>= 1;
       verMvd >>= 1;
       if (imv == IMV_4PEL)//IMV_4PEL
       {
-        CHECK((horMvd % 4) != 0 && (verMvd % 4) != 0, "IMV: MVD is not a multiple of 16");
+        CHECK_VTM((horMvd % 4) != 0 && (verMvd % 4) != 0, "IMV: MVD is not a multiple of 16");
         horMvd >>= 2;
         verMvd >>= 2;
       }
@@ -2410,7 +2410,7 @@ void CABACWriter::transform_unit( const TransformUnit& tu, CUCtx& cuCtx, Partiti
   const UnitArea&         area = partitioner.currArea();
   const unsigned          trDepth = partitioner.currTrDepth;
   ChromaCbfs              chromaCbfs;
-  CHECK(tu.depth != trDepth, " transform unit should be not be futher partitioned");
+  CHECK_VTM(tu.depth != trDepth, " transform unit should be not be futher partitioned");
 
   // cbf_cb & cbf_cr
   if (area.chromaFormat != CHROMA_400)
@@ -2449,21 +2449,21 @@ void CABACWriter::transform_unit( const TransformUnit& tu, CUCtx& cuCtx, Partiti
   {
     if (!CU::isIntra(cu) && trDepth == 0 && !chromaCbfs.sigChroma(area.chromaFormat))
     {
-      CHECK(!TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "Luma cbf must be true for inter units with no chroma coeffs");
+      CHECK_VTM(!TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "Luma cbf must be true for inter units with no chroma coeffs");
     }
     else if (cu.sbtInfo && tu.noResidual)
     {
-      CHECK(TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "Luma cbf must be false for inter sbt no-residual tu");
+      CHECK_VTM(TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "Luma cbf must be false for inter sbt no-residual tu");
     }
     else if (cu.sbtInfo && !chromaCbfs.sigChroma(area.chromaFormat))
     {
       assert(!tu.noResidual);
-      CHECK(!TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "Luma cbf must be true for inter sbt residual tu");
+      CHECK_VTM(!TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "Luma cbf must be true for inter sbt residual tu");
     }
     else
     {
       bool lumaCbfIsInferredACT = (cu.colorTransform && cu.predMode == MODE_INTRA && trDepth == 0 && !chromaCbfs.sigChroma(area.chromaFormat));
-      CHECK(lumaCbfIsInferredACT && !TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "adaptive color transform cannot have all zero coefficients");
+      CHECK_VTM(lumaCbfIsInferredACT && !TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "adaptive color transform cannot have all zero coefficients");
       bool lastCbfIsInferred    = lumaCbfIsInferredACT; // ISP and ACT are mutually exclusive
       bool previousCbf          = false;
       bool rootCbfSoFar         = false;
@@ -2554,7 +2554,7 @@ void CABACWriter::transform_unit( const TransformUnit& tu, CUCtx& cuCtx, Partiti
 
 void CABACWriter::cu_qp_delta( const CodingUnit& cu, int predQP, const int8_t qp )
 {
-  CHECK(!( predQP != std::numeric_limits<int>::max()), "Unspecified error");
+  CHECK_VTM(!( predQP != std::numeric_limits<int>::max()), "Unspecified error");
   int       DQp         = qp - predQP;
   int       qpBdOffsetY = cu.cs->sps->getQpBDOffset( CHANNEL_TYPE_LUMA );
   DQp                   = ( DQp + (MAX_QP + 1) + (MAX_QP + 1) / 2 + qpBdOffsetY + (qpBdOffsetY / 2)) % ((MAX_QP + 1) + qpBdOffsetY) - (MAX_QP + 1) / 2 - (qpBdOffsetY / 2);
@@ -2614,7 +2614,7 @@ void CABACWriter::joint_cb_cr( const TransformUnit& tu, const int cbfMask )
     return;
   }
 
-  CHECK( tu.jointCbCr && tu.jointCbCr != cbfMask, "wrong value of jointCbCr (" << (int)tu.jointCbCr << " vs " << (int)cbfMask << ")" );
+  CHECK_VTM( tu.jointCbCr && tu.jointCbCr != cbfMask, "wrong value of jointCbCr (" << (int)tu.jointCbCr << " vs " << (int)cbfMask << ")" );
   if( ( CU::isIntra( *tu.cu ) && cbfMask ) || ( cbfMask == 3 ) )
   {
     m_BinEncoder.encodeBin( tu.jointCbCr ? 1 : 0, Ctx::JointCbCrFlag( cbfMask - 1 ) );
@@ -2656,7 +2656,7 @@ void CABACWriter::residual_coding( const TransformUnit& tu, ComponentID compID,
       sigGroupFlags.set( scanPos >> cctx.log2CGSize() );
     }
   }
-  CHECK( scanPosLast < 0, "Coefficient coding called for empty TU" );
+  CHECK_VTM( scanPosLast < 0, "Coefficient coding called for empty TU" );
   cctx.setScanPosLast(scanPosLast);
 
   if (cuCtx && tu.mtsIdx[compID] != MTS_SKIP && tu.blocks[compID].height >= 4 && tu.blocks[compID].width >= 4)
@@ -2753,7 +2753,7 @@ void CABACWriter::isp_mode( const CodingUnit& cu )
 {
   if( !CU::isIntra( cu ) || !isLuma( cu.chType ) || cu.firstPU->multiRefIdx || !cu.cs->sps->getUseISP() || cu.bdpcmMode || !CU::canUseISP( cu, getFirstComponentOfChannel( cu.chType ) ) || cu.colorTransform )
   {
-    CHECK( cu.ispMode != NOT_INTRA_SUBPARTITIONS, "cu.ispMode != 0" );
+    CHECK_VTM( cu.ispMode != NOT_INTRA_SUBPARTITIONS, "cu.ispMode != 0" );
     return;
   }
   if ( cu.ispMode == NOT_INTRA_SUBPARTITIONS )
@@ -3181,7 +3181,7 @@ void CABACWriter::residual_coding_subblockTS( CoeffCodingContext& cctx, const TC
 
 void CABACWriter::unary_max_symbol( unsigned symbol, unsigned ctxId0, unsigned ctxIdN, unsigned maxSymbol )
 {
-  CHECK( symbol > maxSymbol, "symbol > maxSymbol" );
+  CHECK_VTM( symbol > maxSymbol, "symbol > maxSymbol" );
   const unsigned totalBinsToWrite = std::min( symbol + 1, maxSymbol );
   for( unsigned binsWritten = 0; binsWritten < totalBinsToWrite; ++binsWritten )
   {
@@ -3211,7 +3211,7 @@ void CABACWriter::unary_max_eqprob( unsigned symbol, unsigned maxSymbol )
     bins  <<= 1;
     numBins++;
   }
-  CHECK(!( numBins <= 32 ), "Unspecified error");
+  CHECK_VTM(!( numBins <= 32 ), "Unspecified error");
   m_BinEncoder.encodeBinsEP( bins, numBins );
 }
 
@@ -3291,7 +3291,7 @@ void CABACWriter::codeCcAlfFilterControlIdc(uint8_t idcVal, CodingStructure &cs,
                                             const int curIdx, const uint8_t *filterControlIdc, Position lumaPos,
                                             const int filterCount)
 {
-  CHECK(idcVal > filterCount, "Filter index is too large");
+  CHECK_VTM(idcVal > filterCount, "Filter index is too large");
 
   const uint32_t curSliceIdx    = cs.slice->getIndependentSliceIdx();
   const uint32_t curTileIdx     = cs.pps->getTileIdx( lumaPos );
@@ -3404,7 +3404,7 @@ void CABACWriter::codeAlfCtuFilterIndex(CodingStructure& cs, uint32_t ctuRsAddr,
     m_BinEncoder.encodeBin(useTemporalFilt, Ctx::AlfUseTemporalFilt());
     if (useTemporalFilt)
     {
-      CHECK((filterSetIdx - NUM_FIXED_FILTER_SETS) >= (numAvailableFiltSets - NUM_FIXED_FILTER_SETS), "temporal non-latest set");
+      CHECK_VTM((filterSetIdx - NUM_FIXED_FILTER_SETS) >= (numAvailableFiltSets - NUM_FIXED_FILTER_SETS), "temporal non-latest set");
       if (numAps > 1)
       {
         xWriteTruncBinCode(filterSetIdx - NUM_FIXED_FILTER_SETS, numAvailableFiltSets - NUM_FIXED_FILTER_SETS);
@@ -3412,13 +3412,13 @@ void CABACWriter::codeAlfCtuFilterIndex(CodingStructure& cs, uint32_t ctuRsAddr,
     }
     else
     {
-      CHECK(filterSetIdx >= NUM_FIXED_FILTER_SETS, "fixed set larger than temporal");
+      CHECK_VTM(filterSetIdx >= NUM_FIXED_FILTER_SETS, "fixed set larger than temporal");
       xWriteTruncBinCode(filterSetIdx, NUM_FIXED_FILTER_SETS);
     }
   }
   else
   {
-    CHECK(filterSetIdx >= NUM_FIXED_FILTER_SETS, "fixed set numavail < num_fixed");
+    CHECK_VTM(filterSetIdx >= NUM_FIXED_FILTER_SETS, "fixed set numavail < num_fixed");
     xWriteTruncBinCode(filterSetIdx, NUM_FIXED_FILTER_SETS);
   }
 }
diff --git a/source/Lib/EncoderLib/EncAdaptiveLoopFilter.cpp b/source/Lib/EncoderLib/EncAdaptiveLoopFilter.cpp
index f034b57..a20b43b 100644
--- a/source/Lib/EncoderLib/EncAdaptiveLoopFilter.cpp
+++ b/source/Lib/EncoderLib/EncAdaptiveLoopFilter.cpp
@@ -465,7 +465,7 @@ EncAdaptiveLoopFilter::EncAdaptiveLoopFilter( int& apsIdStart )
 void EncAdaptiveLoopFilter::create( const EncCfg* encCfg, const int picWidth, const int picHeight, const ChromaFormat chromaFormatIDC, const int maxCUWidth, const int maxCUHeight, const int maxCUDepth, const int inputBitDepth[MAX_NUM_CHANNEL_TYPE], const int internalBitDepth[MAX_NUM_CHANNEL_TYPE] )
 {
   AdaptiveLoopFilter::create( picWidth, picHeight, chromaFormatIDC, maxCUWidth, maxCUHeight, maxCUDepth, inputBitDepth );
-  CHECK( encCfg == nullptr, "encCfg must not be null" );
+  CHECK_VTM( encCfg == nullptr, "encCfg must not be null" );
   m_encCfg = encCfg;
 
   for( int channelIdx = 0; channelIdx < MAX_NUM_CHANNEL_TYPE; channelIdx++ )
@@ -1126,7 +1126,7 @@ double EncAdaptiveLoopFilter::deriveCtbAlfEnableFlags( CodingStructure& cs, cons
 
   setEnableFlag(m_alfParamTemp, channel, true);
 #if ENABLE_QPA
-  CHECK ((chromaWeight > 0.0) && (cs.slice->getFirstCtuRsAddrInSlice() != 0), "incompatible start CTU address, must be 0");
+  CHECK_VTM((chromaWeight > 0.0) && (cs.slice->getFirstCtuRsAddrInSlice() != 0), "incompatible start CTU address, must be 0");
 #endif
 
   reconstructCoeff(m_alfParamTemp, channel, true, isLuma(channel));
@@ -1772,7 +1772,7 @@ int EncAdaptiveLoopFilter::lengthUvlc( int uiCode )
   int uiLength = 1;
   int uiTemp = ++uiCode;
 
-  CHECK( !uiTemp, "Integer overflow" );
+  CHECK_VTM( !uiTemp, "Integer overflow" );
 
   while( 1 != uiTemp )
   {
@@ -2557,7 +2557,7 @@ std::vector<int> EncAdaptiveLoopFilter::getAvaiApsIdsLuma(CodingStructure& cs, i
   {
     newApsId = ALF_CTB_MAX_NUM_APS - 1;
   }
-  CHECK(newApsId >= ALF_CTB_MAX_NUM_APS, "Wrong APS index assignment in getAvaiApsIdsLuma");
+  CHECK_VTM(newApsId >= ALF_CTB_MAX_NUM_APS, "Wrong APS index assignment in getAvaiApsIdsLuma");
   return result;
 }
 void  EncAdaptiveLoopFilter::initDistortion()
@@ -3291,7 +3291,7 @@ int EncAdaptiveLoopFilter::getCoeffRateCcAlf(short chromaCoeff[MAX_NUM_CC_ALF_FI
         signaledFilterCount++;
       }
     }
-    CHECK(signaledFilterCount != filterCount, "Number of filter signaled not same as indicated");
+    CHECK_VTM(signaledFilterCount != filterCount, "Number of filter signaled not same as indicated");
   }
 
   return bits;
@@ -3331,8 +3331,8 @@ void EncAdaptiveLoopFilter::deriveCcAlfFilterCoeff( ComponentID compID, const Pe
 
   for (int k = 0; k < size; k++)
   {
-    CHECK( filterCoeffInt[k] < -(1 << CCALF_DYNAMIC_RANGE), "this is not possible: filterCoeffInt[k] <  -(1 << CCALF_DYNAMIC_RANGE)");
-    CHECK( filterCoeffInt[k] > (1 << CCALF_DYNAMIC_RANGE), "this is not possible: filterCoeffInt[k] >  (1 << CCALF_DYNAMIC_RANGE)");
+    CHECK_VTM( filterCoeffInt[k] < -(1 << CCALF_DYNAMIC_RANGE), "this is not possible: filterCoeffInt[k] <  -(1 << CCALF_DYNAMIC_RANGE)");
+    CHECK_VTM( filterCoeffInt[k] > (1 << CCALF_DYNAMIC_RANGE), "this is not possible: filterCoeffInt[k] >  (1 << CCALF_DYNAMIC_RANGE)");
   }
 
   // Refine quanitzation
@@ -3358,7 +3358,7 @@ void EncAdaptiveLoopFilter::deriveCcAlfFilterCoeff( ComponentID compID, const Pe
             break;
           }
         }
-        CHECK( org_idx < 0, "this is wrong, does not find coeff from forward_tab");
+        CHECK_VTM( org_idx < 0, "this is wrong, does not find coeff from forward_tab");
         if ( (org_idx - delta < 0) || (org_idx - delta >= CCALF_CANDS_COEFF_NR * 2 - 1) )
           continue;
 
@@ -3375,8 +3375,8 @@ void EncAdaptiveLoopFilter::deriveCcAlfFilterCoeff( ComponentID compID, const Pe
       if (errMin < errRef)
       {
         minIndex -= delta;
-        CHECK( minIndex < 0, "this is wrong, index - delta < 0");
-        CHECK( minIndex >= CCALF_CANDS_COEFF_NR * 2 - 1, "this is wrong, index - delta >= CCALF_CANDS_COEFF_NR * 2 - 1");
+        CHECK_VTM( minIndex < 0, "this is wrong, index - delta < 0");
+        CHECK_VTM( minIndex >= CCALF_CANDS_COEFF_NR * 2 - 1, "this is wrong, index - delta >= CCALF_CANDS_COEFF_NR * 2 - 1");
         filterCoeffInt[idxMin] = forward_tab[minIndex];
         modified++;
         errRef = errMin;
@@ -3386,7 +3386,7 @@ void EncAdaptiveLoopFilter::deriveCcAlfFilterCoeff( ComponentID compID, const Pe
 
   for (int k = 0; k < (size + 1); k++)
   {
-    CHECK((filterCoeffInt[k] < -(1 << CCALF_DYNAMIC_RANGE)) || (filterCoeffInt[k] > (1 << CCALF_DYNAMIC_RANGE)), "Exceeded valid range for CC ALF coefficient");
+    CHECK_VTM((filterCoeffInt[k] < -(1 << CCALF_DYNAMIC_RANGE)) || (filterCoeffInt[k] > (1 << CCALF_DYNAMIC_RANGE)), "Exceeded valid range for CC ALF coefficient");
     filterCoeff[filterIdx][k] = filterCoeffInt[k];
   }
 }
@@ -3874,7 +3874,7 @@ void EncAdaptiveLoopFilter::deriveCcAlfFilter( CodingStructure& cs, ComponentID
         }
         m_bestFilterIdxEnabled[filterIdx] = ( filterIdx < m_bestFilterCount ) ? true : false;
       }
-      CHECK( filterCount != m_bestFilterCount, "Number of filters enabled did not match the filter count");
+      CHECK_VTM( filterCount != m_bestFilterCount, "Number of filters enabled did not match the filter count");
     }
 
     m_ccAlfFilterParam.ccAlfFilterCount[compID - 1] = m_bestFilterCount;
@@ -4146,7 +4146,7 @@ void EncAdaptiveLoopFilter::getBlkStatsCcAlf(AlfCovariance &alfCovariance, const
 
 void EncAdaptiveLoopFilter::calcCovarianceCcAlf(Pel ELocal[MAX_NUM_CC_ALF_CHROMA_COEFF][1], const Pel *rec, const int stride, const AlfFilterShape& shape, int vbDistance)
 {
-  CHECK(shape.filterType != CC_ALF, "Bad CC ALF shape");
+  CHECK_VTM(shape.filterType != CC_ALF, "Bad CC ALF shape");
 
   const Pel *recYM1 = rec - 1 * stride;
   const Pel *recY0  = rec;
diff --git a/source/Lib/EncoderLib/EncCfg.h b/source/Lib/EncoderLib/EncCfg.h
index 1f15e50..508f5dc 100644
--- a/source/Lib/EncoderLib/EncCfg.h
+++ b/source/Lib/EncoderLib/EncCfg.h
@@ -981,7 +981,8 @@ public:
   void      setDualITree                    ( bool b )       { m_dualITree = b; }
   bool      getDualITree                    ()         const { return m_dualITree; }
   void      setSubPicInfoPresentFlag                        (bool b)                    { m_subPicInfoPresentFlag = b; }
-  void      setNumSubPics                               ( uint32_t u )              { CHECK( u >= MAX_NUM_SUB_PICS, "Maximum number of subpictures exceeded" );
+  void      setNumSubPics                               ( uint32_t u )              {
+    CHECK_VTM( u >= MAX_NUM_SUB_PICS, "Maximum number of subpictures exceeded" );
                                                                                       m_numSubPics = u;
                                                                                       m_subPicCtuTopLeftX.resize(m_numSubPics);
                                                                                       m_subPicCtuTopLeftY.resize(m_numSubPics);
@@ -998,18 +999,25 @@ public:
   void      setSubPicHeight                             (uint32_t u, int i)         { m_subPicHeight[i] = u; }
   void      setSubPicTreatedAsPicFlag                   (bool b, int i)             { m_subPicTreatedAsPicFlag[i] = b; }
   void      setLoopFilterAcrossSubpicEnabledFlag        (bool b, int i)             { m_loopFilterAcrossSubpicEnabledFlag[i] = b; }
-  void      setSubPicCtuTopLeftX                        (const std::vector<uint32_t> &v)   { CHECK(v.size() != (m_subPicSameSizeFlag ? 0 : m_numSubPics), "number of vector entries must be equal to numSubPics(subPicSameSize=0) or 0(subPicSameSize=1)"); m_subPicCtuTopLeftX = v; }
-  void      setSubPicCtuTopLeftY                        (const std::vector<uint32_t> &v)   { CHECK(v.size() != (m_subPicSameSizeFlag ? 0 : m_numSubPics), "number of vector entries must be equal to numSubPics(subPicSameSize=0) or 0(subPicSameSize=1)"); m_subPicCtuTopLeftY = v; }
-  void      setSubPicWidth                              (const std::vector<uint32_t> &v)   { CHECK(v.size() != (m_subPicSameSizeFlag ? 1 : m_numSubPics), "number of vector entries must be equal to numSubPics(subPicSameSize=0) or 1(subPicSameSize=1)"); m_subPicWidth = v; }
-  void      setSubPicHeight                             (const std::vector<uint32_t> &v)   { CHECK(v.size() != (m_subPicSameSizeFlag ? 1 : m_numSubPics), "number of vector entries must be equal to numSubPics(subPicSameSize=0) or 1(subPicSameSize=1)"); m_subPicHeight = v; }
-  void      setSubPicTreatedAsPicFlag                   (const std::vector<bool> &v)       { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicTreatedAsPicFlag = v; }
-  void      setLoopFilterAcrossSubpicEnabledFlag        (const std::vector<bool> &v)       { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_loopFilterAcrossSubpicEnabledFlag = v; }
+  void      setSubPicCtuTopLeftX                        (const std::vector<uint32_t> &v)   {
+    CHECK_VTM(v.size() != (m_subPicSameSizeFlag ? 0 : m_numSubPics), "number of vector entries must be equal to numSubPics(subPicSameSize=0) or 0(subPicSameSize=1)"); m_subPicCtuTopLeftX = v; }
+  void      setSubPicCtuTopLeftY                        (const std::vector<uint32_t> &v)   {
+    CHECK_VTM(v.size() != (m_subPicSameSizeFlag ? 0 : m_numSubPics), "number of vector entries must be equal to numSubPics(subPicSameSize=0) or 0(subPicSameSize=1)"); m_subPicCtuTopLeftY = v; }
+  void      setSubPicWidth                              (const std::vector<uint32_t> &v)   {
+    CHECK_VTM(v.size() != (m_subPicSameSizeFlag ? 1 : m_numSubPics), "number of vector entries must be equal to numSubPics(subPicSameSize=0) or 1(subPicSameSize=1)"); m_subPicWidth = v; }
+  void      setSubPicHeight                             (const std::vector<uint32_t> &v)   {
+    CHECK_VTM(v.size() != (m_subPicSameSizeFlag ? 1 : m_numSubPics), "number of vector entries must be equal to numSubPics(subPicSameSize=0) or 1(subPicSameSize=1)"); m_subPicHeight = v; }
+  void      setSubPicTreatedAsPicFlag                   (const std::vector<bool> &v)       {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicTreatedAsPicFlag = v; }
+  void      setLoopFilterAcrossSubpicEnabledFlag        (const std::vector<bool> &v)       {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_loopFilterAcrossSubpicEnabledFlag = v; }
 
   void      setSubPicIdMappingExplicitlySignalledFlag   (bool b)                    { m_subPicIdMappingExplicitlySignalledFlag = b; }
   void      setSubPicIdMappingInSpsFlag                 (bool b)                    { m_subPicIdMappingInSpsFlag = b; }
   void      setSubPicIdLen                              (uint32_t u)                { m_subPicIdLen = u; }
   void      setSubPicId                                 (uint32_t b, int i)         { m_subPicId[i] = b; }
-  void      setSubPicId                                 (const std::vector<uint16_t> &v)   { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics"); m_subPicId = v; }
+  void      setSubPicId                                 (const std::vector<uint16_t> &v)   {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics"); m_subPicId = v; }
 
   bool      getSubPicInfoPresentFlag                    ()                          { return m_subPicInfoPresentFlag; }
   bool      getSubPicSameSizeFlag                       ()                          { return m_subPicSameSizeFlag; }
@@ -1301,7 +1309,8 @@ public:
 #else
   int       getBaseQP                       ()       { return  m_iQP; }
 #endif
-  int       getPad                          ( int i )      { CHECK(i >= 2, "Invalid index");                      return  m_aiPad[i]; }
+  int       getPad                          ( int i )      {
+    CHECK_VTM(i >= 2, "Invalid index");                      return  m_aiPad[i]; }
 
   bool      getAccessUnitDelimiter() const  { return m_AccessUnitDelimiter; }
   void      setAccessUnitDelimiter(bool val){ m_AccessUnitDelimiter = val; }
diff --git a/source/Lib/EncoderLib/EncCu.cpp b/source/Lib/EncoderLib/EncCu.cpp
index 7997786..5057690 100644
--- a/source/Lib/EncoderLib/EncCu.cpp
+++ b/source/Lib/EncoderLib/EncCu.cpp
@@ -48,6 +48,8 @@
 
 
 #include "CommonLib/dtrace_buffer.h"
+#include "PartitionGlobalManager.h"
+#include "PartitionUtils.h"
 
 #include <stdio.h>
 #include <cmath>
@@ -253,7 +255,7 @@ void EncCu::init( EncLib* pcEncLib, const SPS& sps PARL_PARAM( const int tId ) )
 // Public member functions
 // ====================================================================================================================
 
-void EncCu::compressCtu( CodingStructure& cs, const UnitArea& area, const unsigned ctuRsAddr, const int prevQP[], const int currQP[] )
+void EncCu::compressCtu( CodingStructure& cs, const UnitArea& area, const unsigned ctuRsAddr, const int prevQP[], const int currQP[], PartitionTree *luma_tree, PartitionTree *chroma_tree )
 {
   m_modeCtrl->initCTUEncoding( *cs.slice );
   cs.treeType = TREE_D;
@@ -332,7 +334,38 @@ void EncCu::compressCtu( CodingStructure& cs, const UnitArea& area, const unsign
   tempCS->baseQP       = bestCS->baseQP       = currQP[CH_L];
   tempCS->prevQP[CH_L] = bestCS->prevQP[CH_L] = prevQP[CH_L];
 
-  xCompressCU(tempCS, bestCS, partitioner);
+  //Load the best partition of the CTU
+  if(param_partition->is_readPartition()){
+    load_partition->load_ctu(load_partition->getM_cur_tree());
+  }
+
+  Mv* mvUni = (Mv *) malloc(2*sizeof(Mv));
+  int * pocRef = (int *) malloc(2 * sizeof(int));
+  mvUni[0].setHor(9999);
+
+
+  if(tempCS->slice->getSliceType()!=I_SLICE && (param_partition->is_predictPartitionInter() || param_partition->is_writePartition())){
+    vector<float> *pred_vector_luma = new vector<float>();
+    xCompressCU(tempCS, bestCS, partitioner, luma_tree, mvUni, pocRef, MAX_DOUBLE, pred_vector_luma);
+    delete pred_vector_luma;
+  }
+  else{
+    xCompressCU(tempCS, bestCS, partitioner, luma_tree);
+  }
+
+
+  if(param_partition->is_writePartition()){
+    luma_tree->set_mvUni(mvUni);
+    luma_tree->set_pocRef(pocRef);
+  }
+  free(mvUni);
+  free(pocRef);
+
+  //Reset the CTU at starting point
+  if(param_partition->is_readPartition()){
+    load_partition->reset_ctu();
+  }
+
   cs.slice->m_mapPltCost[0].clear();
   cs.slice->m_mapPltCost[1].clear();
   // all signals were already copied during compression if the CTU was split - at this point only the structures are copied to the top level CS
@@ -352,7 +385,17 @@ void EncCu::compressCtu( CodingStructure& cs, const UnitArea& area, const unsign
     tempCS->baseQP       = bestCS->baseQP       = currQP[CH_C];
     tempCS->prevQP[CH_C] = bestCS->prevQP[CH_C] = prevQP[CH_C];
 
-    xCompressCU(tempCS, bestCS, partitioner);
+    //Load chroma CTU partition
+    if(param_partition->is_readPartition()){
+      load_partition->load_ctu(load_partition->getM_cur_tree());
+    }
+
+    xCompressCU(tempCS, bestCS, partitioner, chroma_tree);
+
+    //Reset the CTU at starting point
+    if(param_partition->is_readPartition()){
+      load_partition->reset_ctu();
+    }
 
     const bool copyUnsplitCTUSignals = bestCS->cus.size() == 1;
     cs.useSubStructure(*bestCS, partitioner.chType, CS::getArea(*bestCS, area, partitioner.chType),
@@ -370,9 +413,9 @@ void EncCu::compressCtu( CodingStructure& cs, const UnitArea& area, const unsign
 
   // Ensure that a coding was found
   // Selected mode's RD-cost must be not MAX_DOUBLE.
-  CHECK( bestCS->cus.empty()                                   , "No possible encoding found" );
-  CHECK( bestCS->cus[0]->predMode == NUMBER_OF_PREDICTION_MODES, "No possible encoding found" );
-  CHECK( bestCS->cost             == MAX_DOUBLE                , "No possible encoding found" );
+  CHECK_VTM( bestCS->cus.empty()                                   , "No possible encoding found" );
+  CHECK_VTM( bestCS->cus[0]->predMode == NUMBER_OF_PREDICTION_MODES, "No possible encoding found" );
+  CHECK_VTM( bestCS->cost             == MAX_DOUBLE                , "No possible encoding found" );
 }
 
 // ====================================================================================================================
@@ -501,7 +544,7 @@ bool EncCu::xCheckBestMode( CodingStructure *&tempCS, CodingStructure *&bestCS,
     if( tempCS->cus.size() == 1 )
     {
       const CodingUnit& cu = *tempCS->cus.front();
-      CHECK( cu.skip && !cu.firstPU->mergeFlag, "Skip flag without a merge flag is not allowed!" );
+      CHECK_VTM( cu.skip && !cu.firstPU->mergeFlag, "Skip flag without a merge flag is not allowed!" );
     }
 
 #if WCG_EXT
@@ -527,9 +570,9 @@ bool EncCu::xCheckBestMode( CodingStructure *&tempCS, CodingStructure *&bestCS,
 
 }
 
-void EncCu::xCompressCU( CodingStructure*& tempCS, CodingStructure*& bestCS, Partitioner& partitioner, double maxCostAllowed )
+void EncCu::xCompressCU( CodingStructure*& tempCS, CodingStructure*& bestCS, Partitioner& partitioner, PartitionTree *tree, Mv* mvUni, int * pocRef, double maxCostAllowed, vector<float> *pred_vector_luma)
 {
-  CHECK(maxCostAllowed < 0, "Wrong value of maxCostAllowed!");
+  CHECK_VTM(maxCostAllowed < 0, "Wrong value of maxCostAllowed!");
 #if ENABLE_SPLIT_PARALLELISM
   CHECK( m_dataId != tempCS->picture->scheduler.getDataId(), "Working in the wrong dataId!" );
 
@@ -674,6 +717,29 @@ void EncCu::xCompressCU( CodingStructure*& tempCS, CodingStructure*& bestCS, Par
     }
   }
 
+  //Get the split from the saved dat file
+  bool try_split[5] = {false};
+  if (param_partition->is_readPartition() && !tree->get_chroma_stop()) {
+    load_partition->shall_we_split(try_split);
+  }
+
+  double curRdCost = bestCS->cost;
+  PartitionTree qtTree(tree->getM_width(), tree->getM_height(), nullptr, nullptr, tree->getM_cur_param(),
+                       tree->isM_is_bin(), tree->isM_is_tern(), curRdCost);
+  PartitionTree bthTree(tree->getM_width(), tree->getM_height(), nullptr, nullptr, tree->getM_cur_param(),
+                        tree->isM_is_bin(), tree->isM_is_tern(), curRdCost);
+  PartitionTree btvTree(tree->getM_width(), tree->getM_height(), nullptr, nullptr, tree->getM_cur_param(),
+                        tree->isM_is_bin(), tree->isM_is_tern(), curRdCost);
+  PartitionTree tthTree(tree->getM_width(), tree->getM_height(), nullptr, nullptr, tree->getM_cur_param(),
+                        tree->isM_is_bin(), tree->isM_is_tern(), curRdCost);
+  PartitionTree ttvTree(tree->getM_width(), tree->getM_height(), nullptr, nullptr, tree->getM_cur_param(),
+                        tree->isM_is_bin(), tree->isM_is_tern(), curRdCost);
+
+  uint8_t * splitDecision = nullptr;
+  bool firstPass = true;
+  EncTestModeType previous_mode = ETM_INVALID;
+  bool firstPassInter = true;
+
   do
   {
     for (int i = compBegin; i < (compBegin + numComp); i++)
@@ -685,6 +751,87 @@ void EncCu::xCompressCU( CodingStructure*& tempCS, CodingStructure*& bestCS, Par
     EncTestMode currTestMode = m_modeCtrl->currTestMode();
     currTestMode.maxCostAllowed = maxCostAllowed;
 
+    if (param_partition->is_predictPartition() && tempCS->area.blocks[0].height == 64 &&
+        tempCS->area.blocks[0].width == 64 && firstPass && isLuma( partitioner.chType )) {
+      clock_t start = clock();
+      firstPass=false;
+      std::vector<fdeep::internal::tensor> result;
+      std::vector<float> currPixels = getCurrCuLuma(tempCS);
+      result = predict_partition->model->predict({fdeep::tensor(fdeep::tensor_shape(68, 68, 1), currPixels),fdeep::tensor(fdeep::tensor_shape(1), predict_partition->getQp())});
+
+      pred_vector_luma = new vector<float>();
+      for(int i=0;i<result[0].as_vector()->size();i++){
+        pred_vector_luma->push_back(result[0].as_vector()->at(i));
+      }
+      time_cnn += ((double) clock() - start) / CLOCKS_PER_SEC;
+    }
+
+//    if (param_partition->is_predictPartitionInter() && tempCS->area.blocks[0].height == 64 &&
+//        tempCS->area.blocks[0].width == 64 && firstPass && tempCS->picture->poc!=0) {
+//      clock_t start = clock();
+//      firstPass=false;
+//      std::vector<fdeep::internal::tensor> result;
+//      std::vector<float> currPixels = getCurrCuLuma(tempCS);
+//      result = predict_partitionInter->model->predict({fdeep::tensor(fdeep::tensor_shape(68, 68, 1), currPixels),fdeep::tensor(fdeep::tensor_shape(1), tempCS->baseQP)});
+//
+//      pred_vector_luma = new vector<float>();
+//      for(int i=0;i<result[0].as_vector()->size();i++){
+//        pred_vector_luma->push_back(result[0].as_vector()->at(i));
+//      }
+//      time_cnn += ((double) clock() - start) / CLOCKS_PER_SEC;
+//    }
+
+    if(param_partition->is_predictPartition() && ((isLuma( partitioner.chType ) && currTestMode.type == ETM_INTRA && tempCS->area.blocks[0].height !=128 && tempCS->area.blocks[0].width !=128 && !(tempCS->area.blocks[0].width ==4 && tempCS->area.blocks[0].height ==4)))){
+      clock_t start = clock();
+      splitDecision = splitChoiceML(predict_partition->getQp(), tempCS->area.blocks[0].width, tempCS->area.blocks[0].height, tempCS->area.blocks[0].x%64, tempCS->area.blocks[0].y%64, pred_vector_luma);
+      time_cnn += ((double) clock() - start) / CLOCKS_PER_SEC;
+    }
+
+    if(param_partition->is_predictPartitionInter() && firstPassInter && previous_mode == ETM_INTER_ME && !(tempCS->area.blocks[0].width ==4 && tempCS->area.blocks[0].height ==4) /*&& pred_vector_luma != nullptr && pred_vector_luma->size() != 0 && tempCS->area.blocks[0].x + tempCS->area.blocks[0].width <= tempCS->picture->lwidth() &&  tempCS->area.blocks[0].y + tempCS->area.blocks[0].height <= tempCS->picture->lheight()*/){
+      clock_t start = clock();
+      firstPassInter = false;
+      //std::cout<<tempCS->area.blocks[0].width<<"x"<<tempCS->area.blocks[0].height<<" / "<<tempCS->area.blocks[0].x<<"x"<<tempCS->area.blocks[0].y<<std::endl;
+      //int * mean_split = predictSplit(pred_vector_luma, tempCS->area.blocks[0].x%128, tempCS->area.blocks[0].y%128, tempCS->area.blocks[0].width, tempCS->area.blocks[0].height);
+      //call boolean function
+      //splitDecision = splitChoice(mean_split);
+      splitDecision = splitChoiceML_inter(tempCS->baseQP, tempCS->area.blocks[0].width, tempCS->area.blocks[0].height, tempCS->area.blocks[0].x%128, tempCS->area.blocks[0].y%128, pred_vector_luma);
+      //delete [] mean_split;
+      time_cnn += ((double) clock() - start) / CLOCKS_PER_SEC;
+      if(tempCS->area.blocks[0].height !=128 && tempCS->area.blocks[0].width !=128 /*&& tempCS->area.blocks[0].height !=64 && tempCS->area.blocks[0].width !=64*/){ //if when using intra cnn
+        start = clock();
+        firstPassInter = false;
+        //int * mean_split = predictSplitIntra(pred_vector_luma, tempCS->area.blocks[0].x%64, tempCS->area.blocks[0].y%64, tempCS->area.blocks[0].width, tempCS->area.blocks[0].height);
+        //call boolean function
+        //splitDecision = splitChoice(mean_split);
+        splitDecision = splitChoiceML_inter(tempCS->baseQP, tempCS->area.blocks[0].width, tempCS->area.blocks[0].height, tempCS->area.blocks[0].x%64, tempCS->area.blocks[0].y%64, pred_vector_luma);
+        //delete [] mean_split;
+        time_cnn += ((double) clock() - start) / CLOCKS_PER_SEC;
+      }
+    }
+
+    uint8_t splitDecisionCNN = 1;
+    if(param_partition->is_predictPartition() && splitDecision!= nullptr && tempCS->area.blocks[0].height !=128 && tempCS->area.blocks[0].width !=128 && getInverseSplit(currTestMode.type) != -1){
+      splitDecisionCNN = splitDecision[getInverseSplit(currTestMode.type)];
+    }
+    if(param_partition->is_predictPartitionInter() && splitDecision!= nullptr && getInverseSplit(currTestMode.type) != -1){
+      splitDecisionCNN = splitDecision[getInverseSplit(currTestMode.type)];
+    }
+
+
+    bool isTestMode = true;
+    if (param_partition->is_readPartition() && !tree->get_chroma_stop()) {
+      isTestMode = false;
+      int tmp = -1;
+      for (int i = 0; i < 5; i++) {
+        if (try_split[i]) {
+          tmp = i;
+        }
+      }
+      if (getSplit(tmp) == currTestMode.type) {
+        isTestMode = true;
+      }
+    }
+
     if (pps.getUseDQP() && partitioner.isSepTree(*tempCS) && isChroma( partitioner.chType ))
     {
       const Position chromaCentral(tempCS->area.Cb().chromaPos().offset(tempCS->area.Cb().chromaSize().width >> 1, tempCS->area.Cb().chromaSize().height >> 1));
@@ -726,48 +873,173 @@ void EncCu::xCompressCU( CodingStructure*& tempCS, CodingStructure*& bestCS, Par
 
     if( currTestMode.type == ETM_INTER_ME )
     {
-      if( ( currTestMode.opts & ETO_IMV ) != 0 )
-      {
-        const bool skipAltHpelIF = ( int( ( currTestMode.opts & ETO_IMV ) >> ETO_IMV_SHIFT ) == 4 ) && ( bestIntPelCost > 1.25 * bestCS->cost );
-        if (!skipAltHpelIF)
-        {
+
+      if(param_partition->is_readPartition()) {
+        if (load_partition->getM_cur_tree()->getM_leaves() == nullptr) {
+          if( ( currTestMode.opts & ETO_IMV ) != 0 )
+          {
+            const bool skipAltHpelIF = ( int( ( currTestMode.opts & ETO_IMV ) >> ETO_IMV_SHIFT ) == 4 ) && ( bestIntPelCost > 1.25 * bestCS->cost );
+            if (!skipAltHpelIF)
+            {
+              tempCS->bestCS = bestCS;
+              xCheckRDCostInterIMV(tempCS, bestCS, partitioner, currTestMode, bestIntPelCost);
+              tempCS->bestCS = nullptr;
+            }
+          }
+          else
+          {
+            tempCS->bestCS = bestCS;
+            xCheckRDCostInter( tempCS, bestCS, partitioner, currTestMode );
+            tempCS->bestCS = nullptr;
+          }
+        }
+      }
+      else {
+        if ((currTestMode.opts & ETO_IMV) != 0) {
+          const bool skipAltHpelIF =
+                  (int((currTestMode.opts & ETO_IMV) >> ETO_IMV_SHIFT) == 4) && (bestIntPelCost > 1.25 * bestCS->cost);
+          if (!skipAltHpelIF) {
+            tempCS->bestCS = bestCS;
+            xCheckRDCostInterIMV(tempCS, bestCS, partitioner, currTestMode, bestIntPelCost);
+            tempCS->bestCS = nullptr;
+          }
+        } else {
           tempCS->bestCS = bestCS;
-          xCheckRDCostInterIMV(tempCS, bestCS, partitioner, currTestMode, bestIntPelCost);
+
+          Mv* mvUniBis = (Mv *) malloc(2*sizeof(Mv));
+          int * pocRefBis = (int *) malloc(2 * sizeof(int));
+          unsigned long * costRef = (unsigned long *) malloc(2 * sizeof(unsigned long));
+          costRef[0]=std::numeric_limits<Distortion>::max();
+          costRef[1]=std::numeric_limits<Distortion>::max();
+          RefPicList * refPicList = (RefPicList *) malloc(2 * sizeof(RefPicList));
+          int * pocRefIdx = (int *) malloc(2 * sizeof(int));
+
+          xCheckRDCostInter(tempCS, bestCS, partitioner, currTestMode, mvUniBis, pocRefBis, costRef, refPicList, pocRefIdx);
+
+          if((param_partition->is_writePartition() || param_partition->is_predictPartitionInter()) && mvUni[0].getHor()==9999){
+            clock_t start = clock();
+            if(costRef[1]==std::numeric_limits<Distortion>::max()){
+              mvUniBis[1]=mvUniBis[0];
+              pocRefBis[1]=pocRefBis[0];
+              refPicList[1] = refPicList[0];
+              pocRefIdx[1] = pocRefIdx[0];
+            }
+            mvUni[0].set(mvUniBis[0].getHor(),mvUniBis[0].getVer());
+            mvUni[1].set(mvUniBis[1].getHor(),mvUniBis[1].getVer());
+            mvUni[0].changePrecision(MV_PRECISION_INTERNAL, MV_PRECISION_INT);
+            mvUni[1].changePrecision(MV_PRECISION_INTERNAL, MV_PRECISION_INT);
+            pocRef[0] = pocRefBis[0];
+            pocRef[1] = pocRefBis[1];
+
+
+            if(param_partition->is_predictPartitionInter()){
+              Picture * pic = tempCS->picture;
+              Picture * pic_ref0 = tempCS->slice->getRefPic(refPicList[0], pocRefIdx[0]);
+              Picture * pic_ref1 = tempCS->slice->getRefPic(refPicList[1], pocRefIdx[1]);
+              std::vector<float> currPixels = getCtusLumaInter(pic, pic_ref0, pic_ref1, tempCS->area.blocks[0].x, tempCS->area.blocks[0].y, mvUni);
+              std::vector<fdeep::internal::tensor> result;
+              result = predict_partitionInter->model->predict({fdeep::tensor(fdeep::tensor_shape(128,128, 3), currPixels),fdeep::tensor(fdeep::tensor_shape(1), tempCS->baseQP)});
+
+              //pred_vector_luma = new vector<float>();
+              for(int i=0;i<result[0].as_vector()->size();i++){
+                pred_vector_luma->push_back(result[0].as_vector()->at(i));
+                //std::cout<<pred_vector_luma->at(i)<<" ";
+              }
+              //std::cout<<pred_vector_luma->at(0)<<" "<<pred_vector_luma->at(1)<<" "<<pred_vector_luma->at(result[0].as_vector()->size()-2)<<" "<<pred_vector_luma->at(result[0].as_vector()->size()-1)<<std::endl;
+              //std::cout<<std::endl;
+            }
+
+            // Added by Souhaiel
+//            if(param_partition->is_predictPartitionInter()){
+//              Picture * pic = tempCS->picture;
+//              std::vector<float> currPixels = getCtusLumaInterBenchmark(pic, tempCS->area.blocks[0].x, tempCS->area.blocks[0].y);
+//              std::vector<fdeep::internal::tensor> result;
+//              result = predict_partitionInter->model->predict({fdeep::tensor(fdeep::tensor_shape(128,128, 1), currPixels),fdeep::tensor(fdeep::tensor_shape(1), tempCS->baseQP)});
+////              pred_vector_luma = new vector<float>();
+//              for(int i=0;i<result[0].as_vector()->size();i++){
+//                pred_vector_luma->push_back(result[0].as_vector()->at(i));
+// //                std::cout<<pred_vector_luma->at(i)<<" ";
+//              }
+//            }
+            // added by souhaiel ends here
+
+            time_cnn += ((double) clock() - start) / CLOCKS_PER_SEC;
+
+            //std::cout<<"OUT : Im ref 0 : "<<pocRef[0]<<" / X : "<<mvUni[0].getHor()<<" / Y : "<<mvUni[0].getVer()<<" / Cost : "<<costRef[0]<<std::endl;
+            //std::cout<<"OUT : Im ref 1 : "<<pocRef[1]<<" / X : "<<mvUni[1].getHor()<<" / Y : "<<mvUni[1].getVer()<<" / Cost : "<<costRef[1]<<std::endl;
+          }
+
+          free(mvUniBis);
+          free(pocRefBis);
+          free(costRef);
+          free(refPicList);
+          free(pocRefIdx);
           tempCS->bestCS = nullptr;
         }
       }
-      else
-      {
-        tempCS->bestCS = bestCS;
-        xCheckRDCostInter( tempCS, bestCS, partitioner, currTestMode );
-        tempCS->bestCS = nullptr;
-      }
-
     }
     else if (currTestMode.type == ETM_HASH_INTER)
     {
-      xCheckRDCostHashInter( tempCS, bestCS, partitioner, currTestMode );
+      if(param_partition->is_readPartition()) {
+        if (load_partition->getM_cur_tree()->getM_leaves() == nullptr) {
+          xCheckRDCostHashInter( tempCS, bestCS, partitioner, currTestMode );
+        }
+      }
+      else{
+        xCheckRDCostHashInter( tempCS, bestCS, partitioner, currTestMode );
+      }
     }
     else if( currTestMode.type == ETM_AFFINE )
     {
-      xCheckRDCostAffineMerge2Nx2N( tempCS, bestCS, partitioner, currTestMode );
+      if(param_partition->is_readPartition()) {
+        if (load_partition->getM_cur_tree()->getM_leaves() == nullptr) {
+          xCheckRDCostAffineMerge2Nx2N( tempCS, bestCS, partitioner, currTestMode );
+        }
+      }
+      else{
+        xCheckRDCostAffineMerge2Nx2N( tempCS, bestCS, partitioner, currTestMode );
+      }
     }
 #if REUSE_CU_RESULTS
     else if( currTestMode.type == ETM_RECO_CACHED )
     {
-      xReuseCachedResult( tempCS, bestCS, partitioner );
+      if(param_partition->is_readPartition()) {
+        if (load_partition->getM_cur_tree()->getM_leaves() == nullptr) {
+          xReuseCachedResult( tempCS, bestCS, partitioner );
+        }
+      }
+      else{
+        xReuseCachedResult( tempCS, bestCS, partitioner );
+      }
     }
 #endif
     else if( currTestMode.type == ETM_MERGE_SKIP )
     {
-      xCheckRDCostMerge2Nx2N( tempCS, bestCS, partitioner, currTestMode );
-      CodingUnit* cu = bestCS->getCU(partitioner.chType);
-      if (cu)
-      cu->mmvdSkip = cu->skip == false ? false : cu->mmvdSkip;
+      if(param_partition->is_readPartition()) {
+        if (load_partition->getM_cur_tree()->getM_leaves() == nullptr) {
+          xCheckRDCostMerge2Nx2N( tempCS, bestCS, partitioner, currTestMode );
+          CodingUnit* cu = bestCS->getCU(partitioner.chType);
+          if (cu)
+          cu->mmvdSkip = cu->skip == false ? false : cu->mmvdSkip;
+        }
+      }
+      else{
+        xCheckRDCostMerge2Nx2N( tempCS, bestCS, partitioner, currTestMode );
+        CodingUnit* cu = bestCS->getCU(partitioner.chType);
+        if (cu)
+        cu->mmvdSkip = cu->skip == false ? false : cu->mmvdSkip;
+      }
     }
     else if( currTestMode.type == ETM_MERGE_GEO )
     {
-      xCheckRDCostMergeGeo2Nx2N( tempCS, bestCS, partitioner, currTestMode );
+      if(param_partition->is_readPartition()) {
+        if (load_partition->getM_cur_tree()->getM_leaves() == nullptr) {
+          xCheckRDCostMergeGeo2Nx2N(tempCS, bestCS, partitioner, currTestMode);
+        }
+      }
+      else{
+        xCheckRDCostMergeGeo2Nx2N(tempCS, bestCS, partitioner, currTestMode);
+      }
     }
     else if( currTestMode.type == ETM_INTRA )
     {
@@ -797,98 +1069,129 @@ void EncCu::xCompressCU( CodingStructure*& tempCS, CodingStructure*& bestCS, Par
         }
         else
         {
-          CHECK(tempCS->tmpColorSpaceIntraCost[1] != MAX_DOUBLE, "the RD test of the second color space should be skipped");
+          CHECK_VTM(tempCS->tmpColorSpaceIntraCost[1] != MAX_DOUBLE, "the RD test of the second color space should be skipped");
         }
       }
       else
       {
-        xCheckRDCostIntra(tempCS, bestCS, partitioner, currTestMode, false);
+        if(param_partition->is_readPartition() && !tree->get_chroma_stop()){
+          if(load_partition->getM_cur_tree()->getM_leaves() == nullptr){
+            xCheckRDCostIntra(tempCS, bestCS, partitioner, currTestMode, false);
+          }
+        }
+        else{
+          xCheckRDCostIntra(tempCS, bestCS, partitioner, currTestMode, false);
+        }
       }
     }
     else if (currTestMode.type == ETM_PALETTE)
     {
-      xCheckPLT( tempCS, bestCS, partitioner, currTestMode );
+      if(param_partition->is_readPartition()) {
+        if (load_partition->getM_cur_tree()->getM_leaves() == nullptr) {
+          xCheckPLT( tempCS, bestCS, partitioner, currTestMode );
+        }
+      }
+      else {
+        xCheckPLT(tempCS, bestCS, partitioner, currTestMode);
+      }
     }
     else if (currTestMode.type == ETM_IBC)
     {
-      xCheckRDCostIBCMode(tempCS, bestCS, partitioner, currTestMode);
+      if(param_partition->is_readPartition()) {
+        if (load_partition->getM_cur_tree()->getM_leaves() == nullptr) {
+          xCheckRDCostIBCMode(tempCS, bestCS, partitioner, currTestMode);
+        }
+      }
+      else{
+        xCheckRDCostIBCMode(tempCS, bestCS, partitioner, currTestMode);
+      }
     }
     else if (currTestMode.type == ETM_IBC_MERGE)
     {
-      xCheckRDCostIBCModeMerge2Nx2N(tempCS, bestCS, partitioner, currTestMode);
+      if(param_partition->is_readPartition()){
+        if(load_partition->getM_cur_tree()->getM_leaves() == nullptr){
+          xCheckRDCostIBCModeMerge2Nx2N(tempCS, bestCS, partitioner, currTestMode);
+        }
+      }
+      else{
+        xCheckRDCostIBCModeMerge2Nx2N(tempCS, bestCS, partitioner, currTestMode);
+      }
     }
-    else if( isModeSplit( currTestMode ) )
+    else if( isModeSplit( currTestMode ))
     {
-      if (bestCS->cus.size() != 0)
-      {
-        splitmode = bestCS->cus[0]->splitSeries;
-      }
-      assert( partitioner.modeType == tempCS->modeType );
-      int signalModeConsVal = tempCS->signalModeCons( getPartSplit( currTestMode ), partitioner, modeTypeParent );
-      int numRoundRdo = signalModeConsVal == LDT_MODE_TYPE_SIGNAL ? 2 : 1;
-      bool skipInterPass = false;
-      for( int i = 0; i < numRoundRdo; i++ )
-      {
-        //change cons modes
-        if( signalModeConsVal == LDT_MODE_TYPE_SIGNAL )
+      if(isTestMode && splitDecisionCNN){
+        if (bestCS->cus.size() != 0)
         {
-          CHECK( numRoundRdo != 2, "numRoundRdo shall be 2 - [LDT_MODE_TYPE_SIGNAL]" );
-          tempCS->modeType = partitioner.modeType = (i == 0) ? MODE_TYPE_INTER : MODE_TYPE_INTRA;
+          splitmode = bestCS->cus[0]->splitSeries;
         }
-        else if( signalModeConsVal == LDT_MODE_TYPE_INFER )
+        assert( partitioner.modeType == tempCS->modeType );
+        int signalModeConsVal = tempCS->signalModeCons( getPartSplit( currTestMode ), partitioner, modeTypeParent );
+        int numRoundRdo = signalModeConsVal == LDT_MODE_TYPE_SIGNAL ? 2 : 1;
+        bool skipInterPass = false;
+        for( int i = 0; i < numRoundRdo; i++ )
         {
-          CHECK( numRoundRdo != 1, "numRoundRdo shall be 1 - [LDT_MODE_TYPE_INFER]" );
-          tempCS->modeType = partitioner.modeType = MODE_TYPE_INTRA;
-        }
-        else if( signalModeConsVal == LDT_MODE_TYPE_INHERIT )
-        {
-          CHECK( numRoundRdo != 1, "numRoundRdo shall be 1 - [LDT_MODE_TYPE_INHERIT]" );
-          tempCS->modeType = partitioner.modeType = modeTypeParent;
-        }
+          //change cons modes
+          if( signalModeConsVal == LDT_MODE_TYPE_SIGNAL )
+          {
+            CHECK_VTM( numRoundRdo != 2, "numRoundRdo shall be 2 - [LDT_MODE_TYPE_SIGNAL]" );
+            tempCS->modeType = partitioner.modeType = (i == 0) ? MODE_TYPE_INTER : MODE_TYPE_INTRA;
+          }
+          else if( signalModeConsVal == LDT_MODE_TYPE_INFER )
+          {
+            CHECK_VTM( numRoundRdo != 1, "numRoundRdo shall be 1 - [LDT_MODE_TYPE_INFER]" );
+            tempCS->modeType = partitioner.modeType = MODE_TYPE_INTRA;
+          }
+          else if( signalModeConsVal == LDT_MODE_TYPE_INHERIT )
+          {
+            CHECK_VTM( numRoundRdo != 1, "numRoundRdo shall be 1 - [LDT_MODE_TYPE_INHERIT]" );
+            tempCS->modeType = partitioner.modeType = modeTypeParent;
+          }
 
-        //for lite intra encoding fast algorithm, set the status to save inter coding info
-        if( modeTypeParent == MODE_TYPE_ALL && tempCS->modeType == MODE_TYPE_INTER )
-        {
-          m_pcIntraSearch->setSaveCuCostInSCIPU( true );
-          m_pcIntraSearch->setNumCuInSCIPU( 0 );
-        }
-        else if( modeTypeParent == MODE_TYPE_ALL && tempCS->modeType != MODE_TYPE_INTER )
-        {
-          m_pcIntraSearch->setSaveCuCostInSCIPU( false );
-          if( tempCS->modeType == MODE_TYPE_ALL )
+          //for lite intra encoding fast algorithm, set the status to save inter coding info
+          if( modeTypeParent == MODE_TYPE_ALL && tempCS->modeType == MODE_TYPE_INTER )
           {
+            m_pcIntraSearch->setSaveCuCostInSCIPU( true );
             m_pcIntraSearch->setNumCuInSCIPU( 0 );
           }
-        }
+          else if( modeTypeParent == MODE_TYPE_ALL && tempCS->modeType != MODE_TYPE_INTER )
+          {
+            m_pcIntraSearch->setSaveCuCostInSCIPU( false );
+            if( tempCS->modeType == MODE_TYPE_ALL )
+            {
+              m_pcIntraSearch->setNumCuInSCIPU( 0 );
+            }
+          }
 
-        xCheckModeSplit( tempCS, bestCS, partitioner, currTestMode, modeTypeParent, skipInterPass );
-        //recover cons modes
-        tempCS->modeType = partitioner.modeType = modeTypeParent;
-        tempCS->treeType = partitioner.treeType = treeTypeParent;
-        partitioner.chType = chTypeParent;
-        if( modeTypeParent == MODE_TYPE_ALL )
-        {
-          m_pcIntraSearch->setSaveCuCostInSCIPU( false );
-          if( numRoundRdo == 2 && tempCS->modeType == MODE_TYPE_INTRA )
+          xCheckModeSplit( tempCS, bestCS, partitioner, currTestMode, modeTypeParent, skipInterPass, &qtTree, &bthTree,
+                           &btvTree, &tthTree, &ttvTree, mvUni, pocRef, pred_vector_luma );
+          //recover cons modes
+          tempCS->modeType = partitioner.modeType = modeTypeParent;
+          tempCS->treeType = partitioner.treeType = treeTypeParent;
+          partitioner.chType = chTypeParent;
+          if( modeTypeParent == MODE_TYPE_ALL )
           {
-            m_pcIntraSearch->initCuAreaCostInSCIPU();
+            m_pcIntraSearch->setSaveCuCostInSCIPU( false );
+            if( numRoundRdo == 2 && tempCS->modeType == MODE_TYPE_INTRA )
+            {
+              m_pcIntraSearch->initCuAreaCostInSCIPU();
+            }
+          }
+          if( skipInterPass )
+          {
+            break;
           }
         }
-        if( skipInterPass )
-        {
-          break;
-        }
-      }
-      if (splitmode != bestCS->cus[0]->splitSeries)
-      {
-        splitmode = bestCS->cus[0]->splitSeries;
-        const CodingUnit&     cu = *bestCS->cus.front();
-        cu.cs->prevPLT = bestCS->prevPLT;
-        for (int i = compBegin; i < (compBegin + numComp); i++)
+        if (splitmode != bestCS->cus[0]->splitSeries)
         {
-          ComponentID comID = jointPLT ? (ComponentID)compBegin : ((i > 0) ? COMPONENT_Cb : COMPONENT_Y);
-          bestLastPLTSize[comID] = bestCS->cus[0]->cs->prevPLT.curPLTSize[comID];
-          memcpy(bestLastPLT[i], bestCS->cus[0]->cs->prevPLT.curPLT[i], bestCS->cus[0]->cs->prevPLT.curPLTSize[comID] * sizeof(Pel));
+          splitmode = bestCS->cus[0]->splitSeries;
+          const CodingUnit&     cu = *bestCS->cus.front();
+          cu.cs->prevPLT = bestCS->prevPLT;
+          for (int i = compBegin; i < (compBegin + numComp); i++)
+          {
+            ComponentID comID = jointPLT ? (ComponentID)compBegin : ((i > 0) ? COMPONENT_Cb : COMPONENT_Y);
+            bestLastPLTSize[comID] = bestCS->cus[0]->cs->prevPLT.curPLTSize[comID];
+            memcpy(bestLastPLT[i], bestCS->cus[0]->cs->prevPLT.curPLT[i], bestCS->cus[0]->cs->prevPLT.curPLTSize[comID] * sizeof(Pel));
+          }
         }
       }
     }
@@ -896,8 +1199,50 @@ void EncCu::xCompressCU( CodingStructure*& tempCS, CodingStructure*& bestCS, Par
     {
       THROW( "Don't know how to handle mode: type = " << currTestMode.type << ", options = " << currTestMode.opts );
     }
+    previous_mode = currTestMode.type;
   } while( m_modeCtrl->nextMode( *tempCS, partitioner ) );
 
+  /*if(tempCS->picture->getPOC()!=0 && firstPassInter){
+    std::cout<<tempCS->area.blocks[0].width<<"x"<<tempCS->area.blocks[0].height<<" / "<<tempCS->area.blocks[0].x<<"x"<<tempCS->area.blocks[0].y<<std::endl;
+  }*/
+
+  if (param_partition->is_writePartition() && !tree->get_chroma_stop()) {
+    double bestCost = bestCS->cost;
+    double qtCost = qtTree.get_rd_cost();
+    double bthCost = bthTree.get_rd_cost();
+    double btvCost = btvTree.get_rd_cost();
+    double tthCost = tthTree.get_rd_cost();
+    double ttvCost = ttvTree.get_rd_cost();
+
+    bestCost = (qtCost < bestCost) ? qtCost : bestCost;
+    bestCost = (bthCost < bestCost) ? bthCost : bestCost;
+    bestCost = (btvCost < bestCost) ? btvCost : bestCost;
+    bestCost = (tthCost < bestCost) ? tthCost : bestCost;
+    bestCost = (ttvCost < bestCost) ? ttvCost : bestCost;
+
+    // Second conditions means "there was a split"
+    if (bestCost == bthCost && bthCost != curRdCost) {
+      PartitionTree::transfer_leaves(&bthTree, tree);
+    } else if (bestCost == btvCost && btvCost != curRdCost) {
+      PartitionTree::transfer_leaves(&btvTree, tree);
+    } else if (bestCost == tthCost && tthCost != curRdCost) {
+      PartitionTree::transfer_leaves(&tthTree, tree);
+    } else if (bestCost == ttvCost && ttvCost != curRdCost) {
+      PartitionTree::transfer_leaves(&ttvTree, tree);
+    } else if (bestCost == qtCost && qtCost != curRdCost) {
+      PartitionTree::transfer_leaves(&qtTree, tree);
+    }
+    /*if(bestCS->picture[0].lwidth() < bestCS->area[0].x + bestCS->area[0].width || bestCS->picture[0].lheight() < bestCS->area[0].y + bestCS->area[0].height || costActualBlock==MAX_DOUBLE){
+      costActualBlock = bestCost;
+    }*/
+    //tree->set_rd_cost_without_split(costActualBlock);
+    tree->set_rd_cost(bestCost);
+  }
+
+  if(splitDecision!= nullptr){
+    delete [] splitDecision;
+  }
+
 
   //////////////////////////////////////////////////////////////////////////
   // Finishing CU
@@ -928,7 +1273,7 @@ void EncCu::xCompressCU( CodingStructure*& tempCS, CodingStructure*& bestCS, Par
   int numCUInThisNode = (int)bestCS->cus.size();
   if( numCUInThisNode > 1 && bestCS->cus.back()->chType == CHANNEL_TYPE_CHROMA && !CS::isDualITree( *bestCS ) )
   {
-    CHECK( bestCS->cus[numCUInThisNode-2]->chType != CHANNEL_TYPE_LUMA, "wrong chType" );
+    CHECK_VTM( bestCS->cus[numCUInThisNode-2]->chType != CHANNEL_TYPE_LUMA, "wrong chType" );
     bestCS->prevQP[partitioner.chType] = bestCS->cus[numCUInThisNode-2]->qp;
   }
   else
@@ -963,7 +1308,7 @@ void EncCu::xCompressCU( CodingStructure*& tempCS, CodingStructure*& bestCS, Par
 #endif
   if (bestCS->cus.size() == 1) // no partition
   {
-    CHECK(bestCS->cus[0]->tileIdx != bestCS->pps->getTileIdx(bestCS->area.lumaPos()), "Wrong tile index!");
+    CHECK_VTM(bestCS->cus[0]->tileIdx != bestCS->pps->getTileIdx(bestCS->area.lumaPos()), "Wrong tile index!");
     if (bestCS->cus[0]->predMode == MODE_PLT)
     {
       for (int i = compBegin; i < (compBegin + numComp); i++)
@@ -997,9 +1342,9 @@ void EncCu::xCompressCU( CodingStructure*& tempCS, CodingStructure*& bestCS, Par
   cu.cs->prevPLT = bestCS->prevPLT;
   // Assert if Best prediction mode is NONE
   // Selected mode's RD-cost must be not MAX_DOUBLE.
-  CHECK( bestCS->cus.empty()                                   , "No possible encoding found" );
-  CHECK( bestCS->cus[0]->predMode == NUMBER_OF_PREDICTION_MODES, "No possible encoding found" );
-  CHECK( bestCS->cost             == MAX_DOUBLE                , "No possible encoding found" );
+  CHECK_VTM( bestCS->cus.empty()                                   , "No possible encoding found" );
+  CHECK_VTM( bestCS->cus[0]->predMode == NUMBER_OF_PREDICTION_MODES, "No possible encoding found" );
+  CHECK_VTM( bestCS->cost             == MAX_DOUBLE                , "No possible encoding found" );
 }
 
 #if SHARP_LUMA_DELTA_QP || ENABLE_QPA_SUB_CTU
@@ -1207,7 +1552,7 @@ void EncCu::copyState( EncCu* other, Partitioner& partitioner, const UnitArea& c
 }
 #endif
 
-void EncCu::xCheckModeSplit(CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &partitioner, const EncTestMode& encTestMode, const ModeType modeTypeParent, bool &skipInterPass )
+void EncCu::xCheckModeSplit(CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &partitioner, const EncTestMode& encTestMode, const ModeType modeTypeParent, bool &skipInterPass, PartitionTree *qtTree, PartitionTree *bthTree, PartitionTree *btvTree, PartitionTree *tthTree, PartitionTree *ttvTree, Mv* mvUni, int * pocRef, vector<float> * pred_vector_luma)
 {
   const int qp                = encTestMode.qp;
   const Slice &slice          = *tempCS->slice;
@@ -1222,7 +1567,7 @@ void EncCu::xCheckModeSplit(CodingStructure *&tempCS, CodingStructure *&bestCS,
   const PartSplit split = getPartSplit( encTestMode );
   const ModeType modeTypeChild = partitioner.modeType;
 
-  CHECK( split == CU_DONT_SPLIT, "No proper split provided!" );
+  CHECK_VTM( split == CU_DONT_SPLIT, "No proper split provided!" );
 
   tempCS->initStructData( qp );
 
@@ -1241,7 +1586,7 @@ void EncCu::xCheckModeSplit(CodingStructure *&tempCS, CodingStructure *&bestCS,
   const double factor = ( tempCS->currQP[partitioner.chType] > 30 ? 1.1 : 1.075 );
   tempCS->useDbCost = m_pcEncCfg->getUseEncDbOpt();
   if (!tempCS->useDbCost)
-    CHECK(bestCS->costDbOffset != 0, "error");
+    CHECK_VTM(bestCS->costDbOffset != 0, "error");
   const double cost   = m_pcRdCost->calcRdCost( uint64_t( m_CABACEstimator->getEstFracBits() + ( ( bestCS->fracBits ) / factor ) ), Distortion( bestCS->dist / factor ) ) + bestCS->costDbOffset / factor;
 
   m_CABACEstimator->getCtx() = SubCtx( Ctx::SplitFlag,   ctxStartSP );
@@ -1269,7 +1614,7 @@ void EncCu::xCheckModeSplit(CodingStructure *&tempCS, CodingStructure *&bestCS,
   {
     if( chromaNotSplit )
     {
-      CHECK( partitioner.chType != CHANNEL_TYPE_LUMA, "chType must be luma" );
+      CHECK_VTM( partitioner.chType != CHANNEL_TYPE_LUMA, "chType must be luma" );
       tempCS->treeType = partitioner.treeType = TREE_L;
     }
     else
@@ -1280,6 +1625,26 @@ void EncCu::xCheckModeSplit(CodingStructure *&tempCS, CodingStructure *&bestCS,
 
 
   partitioner.splitCurrArea( split, *tempCS );
+
+  //altissie added => choose the right tree
+  PartitionTree *tmpTree = nullptr;
+  if (split == CU_QUAD_SPLIT) {
+    qtTree->qt_split();
+    tmpTree = qtTree;
+  } else if (split == CU_HORZ_SPLIT) {
+    bthTree->bth_split();
+    tmpTree = bthTree;
+  } else if (split == CU_VERT_SPLIT) {
+    btvTree->btv_split();
+    tmpTree = btvTree;
+  } else if (split == CU_TRIH_SPLIT) {
+    tthTree->tth_split();
+    tmpTree = tthTree;
+  } else if (split == CU_TRIV_SPLIT) {
+    ttvTree->ttv_split();
+    tmpTree = ttvTree;
+  }
+
   bool qgEnableChildren = partitioner.currQgEnable(); // QG possible at children level
 
   m_CurrCtx++;
@@ -1314,12 +1679,23 @@ void EncCu::xCheckModeSplit(CodingStructure *&tempCS, CodingStructure *&bestCS,
       tempSubCS->bestParent = bestSubCS->bestParent = bestCS;
       double newMaxCostAllowed = isLuma(partitioner.chType) ? std::min(encTestMode.maxCostAllowed, bestCS->cost - m_pcRdCost->calcRdCost(tempCS->fracBits, tempCS->dist)) : MAX_DOUBLE;
       newMaxCostAllowed = std::max(0.0, newMaxCostAllowed);
-      xCompressCU(tempSubCS, bestSubCS, partitioner, newMaxCostAllowed);
+
+      //Set current tree to the leaves we are currently exploring
+      if(param_partition->is_readPartition()){
+        load_partition->setM_cur_tree(load_partition->getM_cur_tree()->getM_leaves((partitioner.getPartStack().end() - 1)->idx));
+      }
+
+      xCompressCU(tempSubCS, bestSubCS, partitioner, tmpTree->getM_leaves((partitioner.getPartStack().end() - 1)->idx), mvUni, pocRef, newMaxCostAllowed, pred_vector_luma);
+
+      if(param_partition->is_readPartition()){
+        load_partition->setM_cur_tree(load_partition->getM_cur_tree()->getM_root());
+      }
+
       tempSubCS->bestParent = bestSubCS->bestParent = nullptr;
 
       if( bestSubCS->cost == MAX_DOUBLE )
       {
-        CHECK( split == CU_QUAD_SPLIT, "Split decision reusing cannot skip quad split" );
+        CHECK_VTM( split == CU_QUAD_SPLIT, "Split decision reusing cannot skip quad split" );
         tempCS->cost = MAX_DOUBLE;
         tempCS->costDbOffset = 0;
         tempCS->useDbCost = m_pcEncCfg->getUseEncDbOpt();
@@ -1344,14 +1720,14 @@ void EncCu::xCheckModeSplit(CodingStructure *&tempCS, CodingStructure *&bestCS,
       {
         for( int i = 0; i < bestSubCS->cus.size(); i++ )
         {
-          CHECK( bestSubCS->cus[i]->predMode != MODE_INTER, "all CUs must be inter mode in an Inter coding region (SCIPU)" );
+          CHECK_VTM( bestSubCS->cus[i]->predMode != MODE_INTER, "all CUs must be inter mode in an Inter coding region (SCIPU)" );
         }
       }
       else if( partitioner.isConsIntra() )
       {
         for( int i = 0; i < bestSubCS->cus.size(); i++ )
         {
-          CHECK( bestSubCS->cus[i]->predMode == MODE_INTER, "all CUs must not be inter mode in an Intra coding region (SCIPU)" );
+          CHECK_VTM( bestSubCS->cus[i]->predMode == MODE_INTER, "all CUs must not be inter mode in an Intra coding region (SCIPU)" );
         }
       }
 
@@ -1397,7 +1773,7 @@ void EncCu::xCheckModeSplit(CodingStructure *&tempCS, CodingStructure *&bestCS,
         int numParentNodeToQgCS = 0;
         while( qgCS->area.lumaPos() != partitioner.currQgPos )
         {
-          CHECK( qgCS->parent == nullptr, "parent of qgCS shall exsit" );
+          CHECK_VTM( qgCS->parent == nullptr, "parent of qgCS shall exsit" );
           qgCS = qgCS->parent;
           numParentNodeToQgCS++;
         }
@@ -1407,7 +1783,7 @@ void EncCu::xCheckModeSplit(CodingStructure *&tempCS, CodingStructure *&bestCS,
         for( int i = 0; i < numParentNodeToQgCS; i++ )
         {
           //checking each parent
-          CHECK( parentCS == nullptr, "parentCS shall exsit" );
+          CHECK_VTM( parentCS == nullptr, "parentCS shall exsit" );
           for( const auto &cu : parentCS->cus )
           {
             if( cu->rootCbf && !isChroma( cu->chType ) )
@@ -1425,7 +1801,7 @@ void EncCu::xCheckModeSplit(CodingStructure *&tempCS, CodingStructure *&bestCS,
       {
         //get pred QP of the QG
         const CodingUnit* cuFirst = qgCS->getCU( CHANNEL_TYPE_LUMA );
-        CHECK( cuFirst->lumaPos() != partitioner.currQgPos, "First cu of the Qg is wrong" );
+        CHECK_VTM( cuFirst->lumaPos() != partitioner.currQgPos, "First cu of the Qg is wrong" );
         int predQp = CU::predictQP( *cuFirst, qgCS->prevQP[CHANNEL_TYPE_LUMA] );
 
         //revise to predQP
@@ -1464,12 +1840,27 @@ void EncCu::xCheckModeSplit(CodingStructure *&tempCS, CodingStructure *&bestCS,
     tempCS->initSubStructure( *tempCSChroma, partitioner.chType, partitioner.currArea(), false );
     tempCS->initSubStructure( *bestCSChroma, partitioner.chType, partitioner.currArea(), false );
     tempCS->treeType = TREE_D;
-    xCompressCU( tempCSChroma, bestCSChroma, partitioner );
 
+    //Set current tree to the leaves we are currently exploring
+    /*if(param_partition->is_readPartition() && ){
+      load_partition->setM_cur_tree(load_partition->getM_cur_tree()->getM_leaves((partitioner.getPartStack().end() - 1)->idx));
+    }*/
+
+    PartitionTree treeChroma(param_partition->ctuSize, param_partition->ctuSize, nullptr, nullptr, param_partition, false, false, MAX_DOUBLE);
+    treeChroma.set_chroma_stop(true);
+
+    xCompressCU( tempCSChroma, bestCSChroma, partitioner, &treeChroma);
+
+
+
+    /*if(param_partition->is_readPartition()){
+      load_partition->setM_cur_tree(load_partition->getM_cur_tree()->getM_root());
+    }*/
+    
     //attach chromaCS to luma CS and update cost
     bool keepResi = KEEP_PRED_AND_RESI_SIGNALS;
     //bestCSChroma->treeType = tempCSChroma->treeType = TREE_C;
-    CHECK( bestCSChroma->treeType != TREE_C || tempCSChroma->treeType != TREE_C, "wrong treeType for chroma CS" );
+    CHECK_VTM( bestCSChroma->treeType != TREE_C || tempCSChroma->treeType != TREE_C, "wrong treeType for chroma CS" );
     tempCS->useSubStructure( *bestCSChroma, partitioner.chType, CS::getArea( *bestCSChroma, partitioner.currArea(), partitioner.chType ), KEEP_PRED_AND_RESI_SIGNALS, true, keepResi, true, true );
 
     //release tmp resource
@@ -1554,6 +1945,23 @@ void EncCu::xCheckModeSplit(CodingStructure *&tempCS, CodingStructure *&bestCS,
     }
   }
 
+  // -----------------------------------------altissie added-----------------------------------------
+
+  if (split == CU_QUAD_SPLIT) {
+    qtTree->set_rd_cost(tempCS->cost);
+  } else if (split == CU_HORZ_SPLIT) {
+    bthTree->set_rd_cost(tempCS->cost);
+  } else if (split == CU_VERT_SPLIT) {
+    btvTree->set_rd_cost(tempCS->cost);
+  } else if (split == CU_TRIH_SPLIT) {
+    tthTree->set_rd_cost(tempCS->cost);
+  } else if (split == CU_TRIV_SPLIT) {
+    ttvTree->set_rd_cost(tempCS->cost);
+  }
+  tmpTree->set_rd_cost(tempCS->cost);
+
+  // --------------------------------------------end add---------------------------------------------
+
   // RD check for sub partitioned coding structure.
   xCheckBestMode( tempCS, bestCS, partitioner, encTestMode );
 
@@ -1620,9 +2028,9 @@ bool EncCu::xCheckRDCostIntra(CodingStructure *&tempCS, CodingStructure *&bestCS
   bool foundZeroRootCbf = false;
   if (sps.getUseColorTrans())
   {
-    CHECK(tempCS->treeType != TREE_D || partitioner.treeType != TREE_D, "localtree should not be applied when adaptive color transform is enabled");
-    CHECK(tempCS->modeType != MODE_TYPE_ALL || partitioner.modeType != MODE_TYPE_ALL, "localtree should not be applied when adaptive color transform is enabled");
-    CHECK(adaptiveColorTrans && (CS::isDualITree(*tempCS) || partitioner.chType != CHANNEL_TYPE_LUMA), "adaptive color transform cannot be applied to dual-tree");
+    CHECK_VTM(tempCS->treeType != TREE_D || partitioner.treeType != TREE_D, "localtree should not be applied when adaptive color transform is enabled");
+    CHECK_VTM(tempCS->modeType != MODE_TYPE_ALL || partitioner.modeType != MODE_TYPE_ALL, "localtree should not be applied when adaptive color transform is enabled");
+    CHECK_VTM(adaptiveColorTrans && (CS::isDualITree(*tempCS) || partitioner.chType != CHANNEL_TYPE_LUMA), "adaptive color transform cannot be applied to dual-tree");
   }
 
   for( int trGrpIdx = 0; trGrpIdx < grpNumMax; trGrpIdx++ )
@@ -1810,7 +2218,7 @@ bool EncCu::xCheckRDCostIntra(CodingStructure *&tempCS, CodingStructure *&bestCS
 
           if (isLuma(partitioner.chType) && cu.firstTU->mtsIdx[COMPONENT_Y] > MTS_SKIP)
           {
-            CHECK(!cuCtx.mtsLastScanPos, "MTS is disallowed to only contain DC coefficient");
+            CHECK_VTM(!cuCtx.mtsLastScanPos, "MTS is disallowed to only contain DC coefficient");
           }
 
           if( mtsFlag == 0 && lfnstIdx == 0 )
@@ -2043,8 +2451,8 @@ void EncCu::xCheckPLT(CodingStructure *&tempCS, CodingStructure *&bestCS, Partit
 
 void EncCu::xCheckDQP( CodingStructure& cs, Partitioner& partitioner, bool bKeepCtx )
 {
-  CHECK( bKeepCtx && cs.cus.size() <= 1 && partitioner.getImplicitSplit( cs ) == CU_DONT_SPLIT, "bKeepCtx should only be set in split case" );
-  CHECK( !bKeepCtx && cs.cus.size() > 1, "bKeepCtx should never be set for non-split case" );
+  CHECK_VTM( bKeepCtx && cs.cus.size() <= 1 && partitioner.getImplicitSplit( cs ) == CU_DONT_SPLIT, "bKeepCtx should only be set in split case" );
+  CHECK_VTM( !bKeepCtx && cs.cus.size() > 1, "bKeepCtx should never be set for non-split case" );
 
   if( !cs.pps->getUseDQP() )
   {
@@ -2064,7 +2472,7 @@ void EncCu::xCheckDQP( CodingStructure& cs, Partitioner& partitioner, bool bKeep
 
   CodingUnit* cuFirst = cs.getCU( partitioner.chType );
 
-  CHECK( !cuFirst, "No CU available" );
+  CHECK_VTM( !cuFirst, "No CU available" );
 
   bool hasResidual = false;
   for( const auto &cu : cs.cus )
@@ -2245,7 +2653,7 @@ void EncCu::xCheckRDCostMerge2Nx2N( CodingStructure *&tempCS, CodingStructure *&
 {
   const Slice &slice = *tempCS->slice;
 
-  CHECK( slice.getSliceType() == I_SLICE, "Merge modes not available for I-slices" );
+  CHECK_VTM( slice.getSliceType() == I_SLICE, "Merge modes not available for I-slices" );
 
   tempCS->initStructData( encTestMode.qp );
 
@@ -2457,7 +2865,7 @@ void EncCu::xCheckRDCostMerge2Nx2N( CodingStructure *&tempCS, CodingStructure *&
             swap(singleMergeTempBuffer, acMergeTempBuffer[insertPos]);
           }
         }
-        CHECK(std::min(uiMergeCand + 1, uiNumMrgSATDCand) != RdModeList.size(), "");
+        CHECK_VTM(std::min(uiMergeCand + 1, uiNumMrgSATDCand) != RdModeList.size(), "");
       }
 
       if (isIntrainterEnabled)
@@ -2541,7 +2949,7 @@ void EncCu::xCheckRDCostMerge2Nx2N( CodingStructure *&tempCS, CodingStructure *&
           pu.mvRefine = true;
           distParam.cur = singleMergeTempBuffer->Y();
           pu.mmvdEncOptMode = (refineStep > 2 ? 2 : 1);
-          CHECK(!pu.mmvdMergeFlag, "MMVD merge should be set");
+          CHECK_VTM(!pu.mmvdMergeFlag, "MMVD merge should be set");
           // Don't do chroma MC here
           m_pcInterSearch->motionCompensation(pu, *singleMergeTempBuffer, REF_PIC_LIST_X, true, false);
           pu.mmvdEncOptMode = 0;
@@ -2661,7 +3069,7 @@ void EncCu::xCheckRDCostMerge2Nx2N( CodingStructure *&tempCS, CodingStructure *&
         pu.ciipFlag = true;
         pu.regularMergeFlag = false;
         pu.intraDir[0] = PLANAR_IDX;
-        CHECK(pu.intraDir[0]<0 || pu.intraDir[0]>(NUM_LUMA_MODE - 1), "out of intra mode");
+        CHECK_VTM(pu.intraDir[0]<0 || pu.intraDir[0]>(NUM_LUMA_MODE - 1), "out of intra mode");
         pu.intraDir[1] = DM_CHROMA_IDX;
       }
       else if (RdModeList[uiMrgHADIdx].isMMVD)
@@ -2761,7 +3169,7 @@ void EncCu::xCheckRDCostMerge2Nx2N( CodingStructure *&tempCS, CodingStructure *&
       }
       if (!cu.mmvdSkip && !pu.ciipFlag && uiNoResidualPass != 0)
       {
-        CHECK(uiMergeCand >= mergeCtx.numValidMergeCand, "out of normal merge");
+        CHECK_VTM(uiMergeCand >= mergeCtx.numValidMergeCand, "out of normal merge");
         isTestSkipMerge[uiMergeCand] = true;
       }
 
@@ -2814,7 +3222,7 @@ void EncCu::xCheckRDCostMerge2Nx2N( CodingStructure *&tempCS, CodingStructure *&
 void EncCu::xCheckRDCostMergeGeo2Nx2N(CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestMode)
 {
   const Slice &slice = *tempCS->slice;
-  CHECK(slice.getSliceType() == I_SLICE, "Merge modes not available for I-slices");
+  CHECK_VTM(slice.getSliceType() == I_SLICE, "Merge modes not available for I-slices");
 
   tempCS->initStructData(encTestMode.qp);
 
@@ -3104,7 +3512,7 @@ void EncCu::xCheckRDCostAffineMerge2Nx2N( CodingStructure *&tempCS, CodingStruct
   m_bestModeUpdated = tempCS->useDbCost = bestCS->useDbCost = false;
   const Slice &slice = *tempCS->slice;
 
-  CHECK( slice.getSliceType() == I_SLICE, "Affine Merge modes not available for I-slices" );
+  CHECK_VTM( slice.getSliceType() == I_SLICE, "Affine Merge modes not available for I-slices" );
 
   tempCS->initStructData( encTestMode.qp );
 
@@ -3242,7 +3650,7 @@ void EncCu::xCheckRDCostAffineMerge2Nx2N( CodingStructure *&tempCS, CodingStruct
         updateCandList( uiMergeCand, cost, RdModeList, candCostList
           , uiNumMrgSATDCand );
 
-        CHECK( std::min( uiMergeCand + 1, uiNumMrgSATDCand ) != RdModeList.size(), "" );
+        CHECK_VTM( std::min( uiMergeCand + 1, uiNumMrgSATDCand ) != RdModeList.size(), "" );
       }
 
       // Try to limit number of candidates using SATD-costs
@@ -3705,7 +4113,7 @@ void EncCu::xCheckRDCostIBCMode(CodingStructure *&tempCS, CodingStructure *&best
   // check ibc mode in encoder RD
   //////////////////////////////////////////////////////////////////////////////////////////////
 
-void EncCu::xCheckRDCostInter( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &partitioner, const EncTestMode& encTestMode )
+void EncCu::xCheckRDCostInter( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &partitioner, const EncTestMode& encTestMode, Mv* mvUni, int * pocRef, unsigned long * costRef, RefPicList * refPicList, int* pocRefIdx )
 {
   tempCS->initStructData( encTestMode.qp );
 
@@ -3774,7 +4182,7 @@ void EncCu::xCheckRDCostInter( CodingStructure *&tempCS, CodingStructure *&bestC
   uint8_t bcwIdx = cu.BcwIdx;
   bool  testBcw = (bcwIdx != BCW_DEFAULT);
 
-  m_pcInterSearch->predInterSearch( cu, partitioner );
+  m_pcInterSearch->predInterSearch( cu, partitioner, mvUni, pocRef, costRef, refPicList, pocRefIdx );
 
   bcwIdx = CU::getValidBcwIdx(cu);
   if( testBcw && bcwIdx == BCW_DEFAULT ) // Enabled Bcw but the search results is uni.
@@ -3782,7 +4190,7 @@ void EncCu::xCheckRDCostInter( CodingStructure *&tempCS, CodingStructure *&bestC
     tempCS->initStructData(encTestMode.qp);
     continue;
   }
-  CHECK(!(testBcw || (!testBcw && bcwIdx == BCW_DEFAULT)), " !( bTestBcw || (!bTestBcw && bcwIdx == BCW_DEFAULT ) )");
+  CHECK_VTM(!(testBcw || (!testBcw && bcwIdx == BCW_DEFAULT)), " !( bTestBcw || (!bTestBcw && bcwIdx == BCW_DEFAULT ) )");
 
   bool isEqualUni = false;
   if( m_pcEncCfg->getUseBcwFast() )
@@ -3836,7 +4244,7 @@ bool EncCu::xCheckRDCostInterIMV(CodingStructure *&tempCS, CodingStructure *&bes
   int iIMV = int( ( encTestMode.opts & ETO_IMV ) >> ETO_IMV_SHIFT );
   m_pcInterSearch->setAffineModeSelected(false);
   // Only Half-Pel, int-Pel, 4-Pel and fast 4-Pel allowed
-  CHECK(iIMV < 1 || iIMV > 4, "Unsupported IMV Mode");
+  CHECK_VTM(iIMV < 1 || iIMV > 4, "Unsupported IMV Mode");
   const bool testAltHpelFilter = iIMV == 4;
   // Fast 4-Pel Mode
 
@@ -3948,7 +4356,7 @@ bool EncCu::xCheckRDCostInterIMV(CodingStructure *&tempCS, CodingStructure *&bes
     tempCS->initStructData(encTestMode.qp);
     continue;
   }
-  CHECK(!(testBcw || (!testBcw && bcwIdx == BCW_DEFAULT)), " !( bTestBcw || (!bTestBcw && bcwIdx == BCW_DEFAULT ) )");
+  CHECK_VTM(!(testBcw || (!testBcw && bcwIdx == BCW_DEFAULT)), " !( bTestBcw || (!bTestBcw && bcwIdx == BCW_DEFAULT ) )");
 
   bool isEqualUni = false;
   if( m_pcEncCfg->getUseBcwFast() )
@@ -4591,7 +4999,7 @@ void EncCu::xEncodeInterResidual(   CodingStructure *&tempCS
     }
     else
     {
-      CHECK( equBcwCost == NULL, "equBcwCost == NULL" );
+      CHECK_VTM( equBcwCost == NULL, "equBcwCost == NULL" );
     }
     if( tempCS->slice->getCheckLDC() && !cu->imv && cu->BcwIdx != BCW_DEFAULT && tempCS->cost < m_bestBcwCost[1] )
     {
@@ -4618,7 +5026,7 @@ void EncCu::xEncodeDontSplit( CodingStructure &cs, Partitioner &partitioner )
 
   m_CABACEstimator->split_cu_mode( CU_DONT_SPLIT, cs, partitioner );
   if( partitioner.treeType == TREE_C )
-    CHECK( m_CABACEstimator->getEstFracBits() != 0, "must be 0 bit" );
+    CHECK_VTM( m_CABACEstimator->getEstFracBits() != 0, "must be 0 bit" );
 
   cs.fracBits += m_CABACEstimator->getEstFracBits(); // split bits
   cs.cost      = m_pcRdCost->calcRdCost( cs.fracBits, cs.dist );
@@ -4630,7 +5038,7 @@ void EncCu::xReuseCachedResult( CodingStructure *&tempCS, CodingStructure *&best
 {
   m_pcRdCost->setChromaFormat(tempCS->sps->getChromaFormatIdc());
   BestEncInfoCache* bestEncCache = dynamic_cast<BestEncInfoCache*>( m_modeCtrl );
-  CHECK( !bestEncCache, "If this mode is chosen, mode controller has to implement the mode caching capabilities" );
+  CHECK_VTM( !bestEncCache, "If this mode is chosen, mode controller has to implement the mode caching capabilities" );
   EncTestMode cachedMode;
 
   if( bestEncCache->setCsFrom( *tempCS, cachedMode, partitioner ) )
diff --git a/source/Lib/EncoderLib/EncCu.h b/source/Lib/EncoderLib/EncCu.h
index 07d4848..03ee82f 100644
--- a/source/Lib/EncoderLib/EncCu.h
+++ b/source/Lib/EncoderLib/EncCu.h
@@ -55,6 +55,7 @@
 #include "InterSearch.h"
 #include "RateCtrl.h"
 #include "EncModeCtrl.h"
+#include "PartitionTree.h"
 //! \ingroup EncoderLib
 //! \{
 
@@ -225,7 +226,7 @@ public:
   void  destroy             ();
 
   /// CTU analysis function
-  void  compressCtu         ( CodingStructure& cs, const UnitArea& area, const unsigned ctuRsAddr, const int prevQP[], const int currQP[] );
+  void  compressCtu         ( CodingStructure& cs, const UnitArea& area, const unsigned ctuRsAddr, const int prevQP[], const int currQP[], PartitionTree *luma_tree, PartitionTree *chroma_tree );
   /// CTU encoding function
   int   updateCtuDataISlice ( const CPelBuf buf );
 
@@ -247,7 +248,7 @@ protected:
   void xCalDebCost            ( CodingStructure &cs, Partitioner &partitioner, bool calDist = false );
   Distortion getDistortionDb  ( CodingStructure &cs, CPelBuf org, CPelBuf reco, ComponentID compID, const CompArea& compArea, bool afterDb );
 
-  void xCompressCU            ( CodingStructure*& tempCS, CodingStructure*& bestCS, Partitioner& pm, double maxCostAllowed = MAX_DOUBLE );
+  void xCompressCU            ( CodingStructure*& tempCS, CodingStructure*& bestCS, Partitioner& pm, PartitionTree *tree, Mv* mvUni = nullptr, int * pocRef = nullptr, double maxCostAllowed = MAX_DOUBLE, vector<float> *pred_vector_luma = nullptr);
 #if ENABLE_SPLIT_PARALLELISM
   void xCompressCUParallel    ( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm );
   void copyState              ( EncCu* other, Partitioner& pm, const UnitArea& currArea, const bool isDist );
@@ -256,7 +257,7 @@ protected:
   bool
     xCheckBestMode         ( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestmode );
 
-  void xCheckModeSplit        ( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestMode, const ModeType modeTypeParent, bool &skipInterPass );
+  void xCheckModeSplit        ( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestMode, const ModeType modeTypeParent, bool &skipInterPass, PartitionTree *qtTree, PartitionTree *bthTree, PartitionTree *btvTree, PartitionTree *tthTree, PartitionTree *ttvTree, Mv* mvUni, int * pocRef, vector<float> * pred_vector_luma = nullptr );
 
   bool xCheckRDCostIntra(CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestMode, bool adaptiveColorTrans);
 
@@ -267,7 +268,7 @@ protected:
   void xCheckRDCostHashInter  ( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestMode );
   void xCheckRDCostAffineMerge2Nx2N
                               ( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &partitioner, const EncTestMode& encTestMode );
-  void xCheckRDCostInter      ( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestMode );
+  void xCheckRDCostInter      ( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestMode, Mv* mvUni= nullptr, int * pocRef = nullptr, unsigned long * costRef = nullptr, RefPicList * refPicList = nullptr, int * pocRefIdx = nullptr);
   bool xCheckRDCostInterIMV(CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestMode, double &bestIntPelCost);
   void xEncodeDontSplit       ( CodingStructure &cs, Partitioner &partitioner);
 
diff --git a/source/Lib/EncoderLib/EncGOP.cpp b/source/Lib/EncoderLib/EncGOP.cpp
index 4e6d94b..e6079ea 100644
--- a/source/Lib/EncoderLib/EncGOP.cpp
+++ b/source/Lib/EncoderLib/EncGOP.cpp
@@ -58,6 +58,7 @@
 #include "CommonLib/ProfileLevelTier.h"
 
 #include "DecoderLib/DecLib.h"
+#include "PartitionGlobalManager.h"
 
 #define ENCODE_SUB_SET 0
 
@@ -314,7 +315,7 @@ int EncGOP::xWriteVPS (AccessUnit &accessUnit, const VPS *vps)
 {
   OutputNALUnit nalu(NAL_UNIT_VPS);
   m_HLSWriter->setBitstream( &nalu.m_Bitstream );
-  CHECK( nalu.m_temporalId, "The value of TemporalId of VPS NAL units shall be equal to 0" );
+  CHECK_VTM( nalu.m_temporalId, "The value of TemporalId of VPS NAL units shall be equal to 0" );
   m_HLSWriter->codeVPS( vps );
   accessUnit.push_back(new NALUnitEBSP(nalu));
   return (int)(accessUnit.back()->m_nalUnitData.str().size()) * 8;
@@ -323,7 +324,7 @@ int EncGOP::xWriteDCI(AccessUnit& accessUnit, const DCI* dci)
 {
   OutputNALUnit nalu(NAL_UNIT_DCI);
   m_HLSWriter->setBitstream(&nalu.m_Bitstream);
-  CHECK(nalu.m_temporalId, "The value of TemporalId of DCI NAL units shall be equal to 0");
+  CHECK_VTM(nalu.m_temporalId, "The value of TemporalId of DCI NAL units shall be equal to 0");
   m_HLSWriter->codeDCI(dci);
   accessUnit.push_back(new NALUnitEBSP(nalu));
   return (int)(accessUnit.back()->m_nalUnitData.str().size()) * 8;
@@ -334,7 +335,7 @@ int EncGOP::xWriteSPS( AccessUnit &accessUnit, const SPS *sps, const int layerId
   OutputNALUnit nalu(NAL_UNIT_SPS);
   m_HLSWriter->setBitstream( &nalu.m_Bitstream );
   nalu.m_nuhLayerId = layerId;
-  CHECK( nalu.m_temporalId, "The value of TemporalId of SPS NAL units shall be equal to 0" );
+  CHECK_VTM( nalu.m_temporalId, "The value of TemporalId of SPS NAL units shall be equal to 0" );
   m_HLSWriter->codeSPS( sps );
   accessUnit.push_back(new NALUnitEBSP(nalu));
   return (int)(accessUnit.back()->m_nalUnitData.str().size()) * 8;
@@ -346,7 +347,7 @@ int EncGOP::xWritePPS( AccessUnit &accessUnit, const PPS *pps, const int layerId
   OutputNALUnit nalu(NAL_UNIT_PPS);
   m_HLSWriter->setBitstream( &nalu.m_Bitstream );
   nalu.m_nuhLayerId = layerId;
-  CHECK( nalu.m_temporalId < accessUnit.temporalId, "TemporalId shall be greater than or equal to the TemporalId of the layer access unit containing the NAL unit" );
+  CHECK_VTM( nalu.m_temporalId < accessUnit.temporalId, "TemporalId shall be greater than or equal to the TemporalId of the layer access unit containing the NAL unit" );
   m_HLSWriter->codePPS( pps );
   accessUnit.push_back(new NALUnitEBSP(nalu));
   return (int)(accessUnit.back()->m_nalUnitData.str().size()) * 8;
@@ -359,7 +360,7 @@ int EncGOP::xWriteAPS( AccessUnit &accessUnit, APS *aps, const int layerId, cons
   nalu.m_nuhLayerId = layerId;
   nalu.m_temporalId = aps->getTemporalId();
   aps->setLayerId( layerId );
-  CHECK( nalu.m_temporalId < accessUnit.temporalId, "TemporalId shall be greater than or equal to the TemporalId of the layer access unit containing the NAL unit" );
+  CHECK_VTM( nalu.m_temporalId < accessUnit.temporalId, "TemporalId shall be greater than or equal to the TemporalId of the layer access unit containing the NAL unit" );
   m_HLSWriter->codeAPS(aps);
   accessUnit.push_back(new NALUnitEBSP(nalu));
   return (int)(accessUnit.back()->m_nalUnitData.str().size()) * 8;
@@ -384,7 +385,7 @@ int EncGOP::xWriteParameterSets(AccessUnit &accessUnit, Slice *slice, const bool
     }
     if( m_pcEncLib->SPSNeedsWriting( slice->getSPS()->getSPSId() ) ) // Note this assumes that all changes to the SPS are made at the EncLib level prior to picture creation (EncLib::xGetNewPicBuffer).
     {
-      CHECK( !( bSeqFirst ), "Unspecified error" ); // Implementations that use more than 1 SPS need to be aware of activation issues.
+      CHECK_VTM( !( bSeqFirst ), "Unspecified error" ); // Implementations that use more than 1 SPS need to be aware of activation issues.
       actualTotalBits += xWriteSPS( accessUnit, slice->getSPS(), m_pcEncLib->getLayerId() );
     }
   }
@@ -422,7 +423,7 @@ void EncGOP::xWriteAccessUnitDelimiter (AccessUnit &accessUnit, Slice *slice)
   {
     nalu.m_nuhLayerId = slice->getVPS()->getLayerId(0);
   }
-  CHECK( nalu.m_temporalId != accessUnit.temporalId, "TemporalId shall be equal to the TemporalId of the AU containing the NAL unit" );
+  CHECK_VTM( nalu.m_temporalId != accessUnit.temporalId, "TemporalId shall be equal to the TemporalId of the AU containing the NAL unit" );
   int picType = slice->isIntra() ? 0 : (slice->isInterP() ? 1 : 2);
   audWriter.codeAUD(nalu.m_Bitstream, m_audIrapOrGdrAuFlag, picType);
   accessUnit.push_front(new NALUnitEBSP(nalu));
@@ -442,7 +443,7 @@ void EncGOP::xWriteFillerData (AccessUnit &accessUnit, Slice *slice, uint32_t &f
   {
     nalu.m_nuhLayerId = slice->getVPS()->getLayerId(0);
   }
-  CHECK( nalu.m_temporalId != accessUnit.temporalId, "TemporalId shall be equal to the TemporalId of the AU containing the NAL unit" );
+  CHECK_VTM( nalu.m_temporalId != accessUnit.temporalId, "TemporalId shall be equal to the TemporalId of the AU containing the NAL unit" );
   fdWriter.codeFD(nalu.m_Bitstream, fdSize);
   accessUnit.push_back(new NALUnitEBSP(nalu));
 }
@@ -518,7 +519,7 @@ void EncGOP::xWriteLeadingSEIOrdered (SEIMessages& seiMessages, SEIMessages& duI
 
   // Buffering period SEI must always be following active parameter sets
   currentMessages = extractSeisByType(localMessages, SEI::BUFFERING_PERIOD);
-  CHECK(!(currentMessages.size() <= 1), "Unspecified error");
+  CHECK_VTM(!(currentMessages.size() <= 1), "Unspecified error");
   xWriteSEI(NAL_UNIT_PREFIX_SEI, currentMessages, accessUnit, itNalu, temporalId);
   xClearSEIs(currentMessages, !testWrite);
 
@@ -527,7 +528,7 @@ void EncGOP::xWriteLeadingSEIOrdered (SEIMessages& seiMessages, SEIMessages& duI
   //       to be placed into separate NAL units. The code below conforms to the constraint even if
   //       general_same_pic_timing_in_all_ols_flag is equal to 0
   currentMessages = extractSeisByType(localMessages, SEI::PICTURE_TIMING);
-  CHECK(!(currentMessages.size() <= 1), "Unspecified error");
+  CHECK_VTM(!(currentMessages.size() <= 1), "Unspecified error");
   xWriteSEI(NAL_UNIT_PREFIX_SEI, currentMessages, accessUnit, itNalu, temporalId);
   xClearSEIs(currentMessages, !testWrite);
 
@@ -567,7 +568,7 @@ void EncGOP::xWriteLeadingSEIMessages (SEIMessages& seiMessages, SEIMessages& du
 {
   AccessUnit testAU;
   SEIMessages picTimingSEIs = getSeisByType(seiMessages, SEI::PICTURE_TIMING);
-  CHECK(!(picTimingSEIs.size() < 2), "Unspecified error");
+  CHECK_VTM(!(picTimingSEIs.size() < 2), "Unspecified error");
   SEIPictureTiming * picTiming = picTimingSEIs.empty() ? NULL : (SEIPictureTiming*) picTimingSEIs.front();
 
   // test writing
@@ -611,7 +612,7 @@ void EncGOP::xWriteDuSEIMessages (SEIMessages& duInfoSeiMessages, AccessUnit &ac
       if (duSEI == duInfoSeiMessages.end())
       {
         // if the number of generated SEIs matches the number of DUs, this should not happen
-        CHECK(!(false), "Unspecified error");
+        CHECK_VTM(!(false), "Unspecified error");
         return;
       }
       // write the next SEI
@@ -837,7 +838,7 @@ void EncGOP::xCreatePictureTimingSEI  (int IRAPGOPid, SEIMessages& seiMessages,
     const uint32_t cpbRemovalDelayLegth = m_HRD->getBufferingPeriodSEI()->m_cpbRemovalDelayLength;
     const uint32_t maxNumSubLayers = slice->getSPS()->getMaxTLayers();
     pictureTimingSEI->m_auCpbRemovalDelay[maxNumSubLayers-1] = std::min<int>(std::max<int>(1, m_totalCoded[maxNumSubLayers-1] - m_lastBPSEI[maxNumSubLayers-1]), static_cast<int>(pow(2, static_cast<double>(cpbRemovalDelayLegth)))); // Syntax element signalled as minus, hence the .
-    CHECK( (m_totalCoded[maxNumSubLayers-1] - m_lastBPSEI[maxNumSubLayers-1]) > pow(2, static_cast<double>(cpbRemovalDelayLegth)), " cpbRemovalDelayLegth too small for m_auCpbRemovalDelay[pt_max_sub_layers_minus1] at picture timing SEI " );
+    CHECK_VTM( (m_totalCoded[maxNumSubLayers-1] - m_lastBPSEI[maxNumSubLayers-1]) > pow(2, static_cast<double>(cpbRemovalDelayLegth)), " cpbRemovalDelayLegth too small for m_auCpbRemovalDelay[pt_max_sub_layers_minus1] at picture timing SEI " );
     const uint32_t temporalId = slice->getTLayer();
     if (maxNumSubLayers == 1)
     {
@@ -1004,7 +1005,7 @@ void EncGOP::xCreatePictureTimingSEI  (int IRAPGOPid, SEIMessages& seiMessages,
       {
         int scaledDistToBuffPeriod = (m_totalCoded[i] - m_lastBPSEI[i]) * static_cast<int>(pow(2, static_cast<double>(maxNumSubLayers - 1 - i)));
         pictureTimingSEI->m_auCpbRemovalDelay[i] = std::min<int>(std::max<int>(1, scaledDistToBuffPeriod), static_cast<int>(pow(2, static_cast<double>(cpbRemovalDelayLegth)))); // Syntax element signalled as minus, hence the .
-        CHECK( (scaledDistToBuffPeriod) > pow(2, static_cast<double>(cpbRemovalDelayLegth)), " cpbRemovalDelayLegth too small for m_auCpbRemovalDelay[i] at picture timing SEI " );
+        CHECK_VTM( (scaledDistToBuffPeriod) > pow(2, static_cast<double>(cpbRemovalDelayLegth)), " cpbRemovalDelayLegth too small for m_auCpbRemovalDelay[i] at picture timing SEI " );
       }
     }
     pictureTimingSEI->m_picDpbOutputDelay = slice->getSPS()->getMaxNumReorderPics(slice->getSPS()->getMaxTLayers()-1) + slice->getPOC() - m_totalCoded[maxNumSubLayers-1];
@@ -2180,7 +2181,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
       {
         int pocCycle = 1 << (pcSlice->getSPS()->getBitsForPOC());
         int deltaPOC = pocCurr > pcSlice->getAssociatedIRAPPOC() ? pocCurr - pcSlice->getAssociatedIRAPPOC() : pocCurr - ( pcSlice->getAssociatedIRAPPOC() & (pocCycle -1) );
-        CHECK(deltaPOC > (pocCycle >> 1), "Use a greater value for POC wraparound to enable a POC distance between IRAP and DRAP of " << deltaPOC << ".");
+        CHECK_VTM(deltaPOC > (pocCycle >> 1), "Use a greater value for POC wraparound to enable a POC distance between IRAP and DRAP of " << deltaPOC << ".");
         m_latestDRAPPOC = pocCurr;
         pcSlice->setTLayer(0); // Force DRAP picture to have temporal layer 0
       }
@@ -2323,7 +2324,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
           m_bInitAMaxBT = false;
         }
 
-        if( refLayer >= 0 && m_uiNumBlk[refLayer] != 0 )
+        if( refLayer >= 0 && m_uiNumBlk[refLayer] != 0 && !param_partition->is_readPartition())
         {
           picHeader->setSplitConsOverrideFlag(true);
           double dBlkSize = sqrt( ( double ) m_uiBlkSize[refLayer] / m_uiNumBlk[refLayer] );
@@ -2490,7 +2491,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
 
       for( int refIdx = 0; refIdx < pcSlice->getNumRefIdx( REF_PIC_LIST_0 ); refIdx++ )
       {
-        CHECK( pcSlice->getRefPic( REF_PIC_LIST_0, refIdx )->unscaledPic == nullptr, "unscaledPic is not set for L0 reference picture" );
+        CHECK_VTM( pcSlice->getRefPic( REF_PIC_LIST_0, refIdx )->unscaledPic == nullptr, "unscaledPic is not set for L0 reference picture" );
 
         if( pcSlice->getRefPic( REF_PIC_LIST_0, refIdx )->isRefScaled( pcSlice->getPPS() ) == false )
         {
@@ -2503,7 +2504,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
       {
         for( int refIdx = 0; refIdx < pcSlice->getNumRefIdx( REF_PIC_LIST_1 ); refIdx++ )
         {
-          CHECK( pcSlice->getRefPic( REF_PIC_LIST_1, refIdx )->unscaledPic == nullptr, "unscaledPic is not set for L1 reference picture" );
+          CHECK_VTM( pcSlice->getRefPic( REF_PIC_LIST_1, refIdx )->unscaledPic == nullptr, "unscaledPic is not set for L1 reference picture" );
 
           if( pcSlice->getRefPic( REF_PIC_LIST_1, refIdx )->isRefScaled( pcSlice->getPPS() ) == false )
           {
@@ -2527,8 +2528,8 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
           refPicL1 = refPicL1->unscaledPic;
         }
 
-        CHECK( !refPicL0->slices.size(), "Wrong L0 reference picture" );
-        CHECK( !refPicL1->slices.size(), "Wrong L1 reference picture" );
+        CHECK_VTM( !refPicL0->slices.size(), "Wrong L0 reference picture" );
+        CHECK_VTM( !refPicL1->slices.size(), "Wrong L1 reference picture" );
 
         const uint32_t uiColFromL0 = refPicL0->slices[0]->getSliceQp() > refPicL1->slices[0]->getSliceQp();
         picHeader->setPicColFromL0Flag( uiColFromL0 );
@@ -2796,7 +2797,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
               break;
             }
           }
-          CHECK( subPicIdx == NOT_VALID, "Sub-picture was not found" );
+          CHECK_VTM( subPicIdx == NOT_VALID, "Sub-picture was not found" );
 
           pcSlice->setSliceSubPicId( pcPic->cs->pps->getSubPic( subPicIdx ).getSubPicID() );
         }
@@ -2857,7 +2858,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
           m_pcSliceEncoder->setSliceSegmentIdx      (uiNumSliceSegments);
           // prepare for next slice
           pcSlice = pcPic->slices[uiNumSliceSegments];
-          CHECK(!(pcSlice->getPPS() != 0), "Unspecified error");
+          CHECK_VTM(!(pcSlice->getPPS() != 0), "Unspecified error");
           pcSlice->copySliceInfo(pcPic->slices[uiNumSliceSegments - 1]);
           pcSlice->setSliceBits(0);
           independentSliceIdx++;
@@ -2985,7 +2986,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
           else
           {
             pcPic->slices[s]->setSaoEnabledFlag(CHANNEL_TYPE_LUMA, sliceEnabled[COMPONENT_Y]);
-            CHECK(!(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]), "Unspecified error");
+            CHECK_VTM(!(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]), "Unspecified error");
             pcPic->slices[s]->setSaoEnabledFlag(CHANNEL_TYPE_CHROMA, sliceEnabled[COMPONENT_Cb]);
 
         }
@@ -3192,7 +3193,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
       if (writePS)
       {
         // create prefix SEI messages at the beginning of the sequence
-        CHECK(!(leadingSeiMessages.empty()), "Unspecified error");
+        CHECK_VTM(!(leadingSeiMessages.empty()), "Unspecified error");
         xCreateIRAPLeadingSEIMessages(leadingSeiMessages, pcSlice->getSPS(), pcSlice->getPPS());
 
         m_bSeqFirst = false;
@@ -3213,7 +3214,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
           aps->chromaPresentFlag = pcSlice->getSPS()->getChromaFormatIdc() != CHROMA_400;
           actualTotalBits += xWriteAPS( accessUnit, aps, m_pcEncLib->getLayerId(), true );
           apsMap->clearChangedFlag((apsId << NUM_APS_TYPE_LEN) + LMCS_APS);
-          CHECK(aps != picHeader->getLmcsAPS(), "Wrong LMCS APS pointer in compressGOP");
+          CHECK_VTM(aps != picHeader->getLmcsAPS(), "Wrong LMCS APS pointer in compressGOP");
         }
       }
 
@@ -3229,7 +3230,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
           aps->chromaPresentFlag = pcSlice->getSPS()->getChromaFormatIdc() != CHROMA_400;
           actualTotalBits += xWriteAPS( accessUnit, aps, m_pcEncLib->getLayerId(), true );
           apsMap->clearChangedFlag( ( apsId << NUM_APS_TYPE_LEN ) + SCALING_LIST_APS );
-          CHECK( aps != picHeader->getScalingListAPS(), "Wrong SCALING LIST APS pointer in compressGOP" );
+          CHECK_VTM( aps != picHeader->getScalingListAPS(), "Wrong SCALING LIST APS pointer in compressGOP" );
         }
       }
 
@@ -3264,7 +3265,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
             aps->chromaPresentFlag = pcSlice->getSPS()->getChromaFormatIdc() != CHROMA_400;
             actualTotalBits += xWriteAPS( accessUnit, aps, m_pcEncLib->getLayerId(), true );
             apsMap->clearChangedFlag((apsId << NUM_APS_TYPE_LEN) + ALF_APS);
-            CHECK(aps != pcSlice->getAlfAPSs()[apsId] && apsId != pcSlice->getTileGroupCcAlfCbApsId() && apsId != pcSlice->getTileGroupCcAlfCrApsId(), "Wrong APS pointer in compressGOP");
+            CHECK_VTM(aps != pcSlice->getAlfAPSs()[apsId] && apsId != pcSlice->getTileGroupCcAlfCbApsId() && apsId != pcSlice->getTileGroupCcAlfCrApsId(), "Wrong APS pointer in compressGOP");
           }
         }
       }
@@ -3385,7 +3386,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
           }
           if (pcSlice->getSPS()->getProfileTierLevel()->getConstraintInfo()->getPicHeaderInSliceHeaderConstraintFlag())
           {
-            CHECK(pcSlice->getPictureHeaderInSliceHeader() == false, "PH shall be present in SH, when pic_header_in_slice_header_constraint_flag is equal to 1");
+            CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() == false, "PH shall be present in SH, when pic_header_in_slice_header_constraint_flag is equal to 1");
           }
         }
         pcSlice->setPicHeader( pcPic->cs->picHeader );
@@ -3633,7 +3634,7 @@ void EncGOP::compressGOP( int iPOCLast, int iNumPicRcvd, PicList& rcListPic,
 
   delete pcBitstreamRedirect;
 
-  CHECK( m_iNumPicCoded > 1, "Unspecified error" );
+  CHECK_VTM( m_iNumPicCoded > 1, "Unspecified error" );
 }
 
 void EncGOP::printOutSummary( uint32_t uiNumAllPicCoded, bool isField, const bool printMSEBasedSNR, const bool printSequenceMSE, const bool printHexPsnr, const bool printRprPSNR, const BitDepths &bitDepths )
@@ -3647,7 +3648,7 @@ void EncGOP::printOutSummary( uint32_t uiNumAllPicCoded, bool isField, const boo
 
   if( m_pcCfg->getDecodeBitstream(0).empty() && m_pcCfg->getDecodeBitstream(1).empty() && !m_pcCfg->useFastForwardToPOC() )
   {
-    CHECK( !( uiNumAllPicCoded == m_gcAnalyzeAll.getNumPic() ), "Unspecified error" );
+    CHECK_VTM( !( uiNumAllPicCoded == m_gcAnalyzeAll.getNumPic() ), "Unspecified error" );
   }
 
   //--CFG_KDY
@@ -3761,7 +3762,7 @@ uint64_t EncGOP::preLoopFilterPicAndCalcDist( Picture* pcPic )
     const ComponentID compID = ComponentID(comp);
     const uint32_t rshift = 2 * DISTORTION_PRECISION_ADJUSTMENT(cs.sps->getBitDepth(toChannelType(compID)));
 #if ENABLE_QPA
-    CHECK( rshift >= 8, "shifts greater than 7 are not supported." );
+    CHECK_VTM( rshift >= 8, "shifts greater than 7 are not supported." );
 #endif
     uiDist += xFindDistortionPlane( picOrg.get(compID), picRec.get(compID), rshift );
   }
@@ -3776,7 +3777,7 @@ void EncGOP::xInitGOP( int iPOCLast, int iNumPicRcvd, bool isField
   , bool isEncodeLtRef
 )
 {
-  CHECK(!( iNumPicRcvd > 0 ), "Unspecified error");
+  CHECK_VTM(!( iNumPicRcvd > 0 ), "Unspecified error");
   //  Exception for the first frames
   if ((isField && (iPOCLast == 0 || iPOCLast == 1)) || (!isField && (iPOCLast == 0)) || isEncodeLtRef)
   {
@@ -3786,7 +3787,7 @@ void EncGOP::xInitGOP( int iPOCLast, int iNumPicRcvd, bool isField
   {
     m_iGopSize    = m_pcCfg->getGOPSize();
   }
-  CHECK(!(m_iGopSize > 0), "Unspecified error");
+  CHECK_VTM(!(m_iGopSize > 0), "Unspecified error");
 
   return;
 }
@@ -3827,8 +3828,8 @@ void EncGOP::xGetBuffer( PicList&                  rcListPic,
     iterPic++;
   }
 
-  CHECK(!(rpcPic != NULL), "Unspecified error");
-  CHECK(!(rpcPic->getPOC() == pocCurr), "Unspecified error");
+  CHECK_VTM(!(rpcPic != NULL), "Unspecified error");
+  CHECK_VTM(!(rpcPic->getPOC() == pocCurr), "Unspecified error");
 
   (**iterPicYuvRec) = rpcPic->getRecoBuf();
   return;
@@ -3909,8 +3910,8 @@ uint64_t EncGOP::xFindDistortionPlane(const CPelBuf& pic0, const CPelBuf& pic1,
   const  Pel*  pSrc0 = pic0.bufAt(0, 0);
   const  Pel*  pSrc1 = pic1.bufAt(0, 0);
 
-  CHECK(pic0.width  != pic1.width , "Unspecified error");
-  CHECK(pic0.height != pic1.height, "Unspecified error");
+  CHECK_VTM(pic0.width  != pic1.width , "Unspecified error");
+  CHECK_VTM(pic0.height != pic1.height, "Unspecified error");
 
   if( rshift > 0 )
   {
@@ -4004,8 +4005,8 @@ double EncGOP::xFindDistortionPlaneWPSNR(const CPelBuf& pic0, const CPelBuf& pic
   const  Pel*  pSrc0 = pic0.bufAt(0, 0);
   const  Pel*  pSrc1 = pic1.bufAt(0, 0);
   const  Pel*  pSrcLuma = picLuma0.bufAt(0, 0);
-  CHECK(pic0.width  != pic1.width , "Unspecified error");
-  CHECK(pic0.height != pic1.height, "Unspecified error");
+  CHECK_VTM(pic0.width  != pic1.width , "Unspecified error");
+  CHECK_VTM(pic0.height != pic1.height, "Unspecified error");
 
   if( rshift > 0 )
   {
@@ -4125,7 +4126,7 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
 {
   const SPS&         sps = *pcPic->cs->sps;
   const CPelUnitBuf& pic = cPicD;
-  CHECK(!(conversion == IPCOLOURSPACE_UNCHANGED), "Unspecified error");
+  CHECK_VTM(!(conversion == IPCOLOURSPACE_UNCHANGED), "Unspecified error");
 //  const CPelUnitBuf& org = (conversion != IPCOLOURSPACE_UNCHANGED) ? pcPic->getPicYuvTrueOrg()->getBuf() : pcPic->getPicYuvOrg()->getBuf();
   const CPelUnitBuf& org = (sps.getUseLmcs() || m_pcCfg->getGopBasedTemporalFilterEnabled()) ? pcPic->getTrueOrigBuf() : pcPic->getOrigBuf();
 #if ENABLE_QPA
@@ -4197,8 +4198,8 @@ void EncGOP::xCalculateAddPSNR(Picture* pcPic, PelUnitBuf cPicD, const AccessUni
     const CPelBuf&    p = picC.get(compID);
     const CPelBuf&    o = org.get(compID);
 
-    CHECK(!( p.width  == o.width), "Unspecified error");
-    CHECK(!( p.height == o.height), "Unspecified error");
+    CHECK_VTM(!( p.width  == o.width), "Unspecified error");
+    CHECK_VTM(!( p.height == o.height), "Unspecified error");
 
     int padX = m_pcEncLib->getPad( 0 );
     int padY = m_pcEncLib->getPad( 1 );
@@ -4658,14 +4659,14 @@ void EncGOP::xCalculateInterlacedAddPSNR( Picture* pcPicOrgFirstField, Picture*
   //===== calculate PSNR =====
   double MSEyuvframe[MAX_NUM_COMPONENT] = {0, 0, 0};
 
-  CHECK(!(acPicRecFields[0].chromaFormat==acPicRecFields[1].chromaFormat), "Unspecified error");
+  CHECK_VTM(!(acPicRecFields[0].chromaFormat==acPicRecFields[1].chromaFormat), "Unspecified error");
   const uint32_t numValidComponents = ::getNumberValidComponents( acPicRecFields[0].chromaFormat );
 
   for (int chan = 0; chan < numValidComponents; chan++)
   {
     const ComponentID ch=ComponentID(chan);
-    CHECK(!(acPicRecFields[0].get(ch).width==acPicRecFields[1].get(ch).width), "Unspecified error");
-    CHECK(!(acPicRecFields[0].get(ch).height==acPicRecFields[0].get(ch).height), "Unspecified error");
+    CHECK_VTM(!(acPicRecFields[0].get(ch).width==acPicRecFields[1].get(ch).width), "Unspecified error");
+    CHECK_VTM(!(acPicRecFields[0].get(ch).height==acPicRecFields[0].get(ch).height), "Unspecified error");
 
     uint64_t uiSSDtemp=0;
     const uint32_t width    = acPicRecFields[0].get(ch).width - (m_pcEncLib->getPad(0) >> ::getComponentScaleX(ch, format));
@@ -4674,7 +4675,7 @@ void EncGOP::xCalculateInterlacedAddPSNR( Picture* pcPicOrgFirstField, Picture*
 
     for(uint32_t fieldNum=0; fieldNum<2; fieldNum++)
     {
-      CHECK(!(conversion == IPCOLOURSPACE_UNCHANGED), "Unspecified error");
+      CHECK_VTM(!(conversion == IPCOLOURSPACE_UNCHANGED), "Unspecified error");
 #if ENABLE_QPA
       uiSSDtemp += xFindDistortionPlane( acPicRecFields[fieldNum].get(ch), apcPicOrgFields[fieldNum]->getOrigBuf().get(ch), useWPSNR ? bitDepth : 0, ::getComponentScaleX(ch, format), ::getComponentScaleY(ch, format) );
 #else
@@ -5073,8 +5074,8 @@ void EncGOP::applyDeblockingFilterMetric( Picture* pcPic, uint32_t uiNumSlices )
   const uint32_t minBlockArtSize = 8;
   const uint32_t noCol = (picWidth>>log2maxTB);
   const uint32_t noRows = (picHeight>>log2maxTB);
-  CHECK(!(noCol > 1), "Unspecified error");
-  CHECK(!(noRows > 1), "Unspecified error");
+  CHECK_VTM(!(noCol > 1), "Unspecified error");
+  CHECK_VTM(!(noRows > 1), "Unspecified error");
   std::vector<uint64_t> colSAD(noCol,  uint64_t(0));
   std::vector<uint64_t> rowSAD(noRows, uint64_t(0));
   uint32_t colIdx = 0;
@@ -5209,7 +5210,7 @@ void EncGOP::applyDeblockingFilterParameterSelection( Picture* pcPic, const uint
   PelUnitBuf reco = pcPic->getRecoBuf();
 
   const int currQualityLayer = (!pcPic->slices[0]->isIRAP()) ? m_pcCfg->getGOPEntry(gopID).m_temporalId+1 : 0;
-  CHECK(!(currQualityLayer <MAX_ENCODER_DEBLOCKING_QUALITY_LAYERS), "Unspecified error");
+  CHECK_VTM(!(currQualityLayer <MAX_ENCODER_DEBLOCKING_QUALITY_LAYERS), "Unspecified error");
 
   CodingStructure& cs = *pcPic->cs;
 
diff --git a/source/Lib/EncoderLib/EncHRD.cpp b/source/Lib/EncoderLib/EncHRD.cpp
index 1b4d2ce..714e5db 100644
--- a/source/Lib/EncoderLib/EncHRD.cpp
+++ b/source/Lib/EncoderLib/EncHRD.cpp
@@ -61,7 +61,7 @@ void EncHRD::initHRDParameters(EncCfg* encCfg)
   int  bitRate = encCfg->getTargetBitrate();
 # if U0132_TARGET_BITS_SATURATION
   int cpbSize = encCfg->getCpbSize();
-  CHECK(!(cpbSize != 0), "Unspecified error");  // CPB size may not be equal to zero. ToDo: have a better default and check for level constraints
+  CHECK_VTM(!(cpbSize != 0), "Unspecified error");  // CPB size may not be equal to zero. ToDo: have a better default and check for level constraints
   if (!encCfg->getHrdParametersPresentFlag() && !encCfg->getCpbSaturationEnabled())
 #else
   if (!encCfg->getHrdParametersPresentFlag())
diff --git a/source/Lib/EncoderLib/EncLib.cpp b/source/Lib/EncoderLib/EncLib.cpp
index aa9ee11..0a8bf14 100644
--- a/source/Lib/EncoderLib/EncLib.cpp
+++ b/source/Lib/EncoderLib/EncLib.cpp
@@ -531,7 +531,7 @@ void EncLib::xInitScalingLists( SPS &sps, APS &aps )
   else if(getUseScalingListId() == SCALING_LIST_FILE_READ)
   {
     aps.getScalingList().setDefaultScalingList();
-    CHECK( aps.getScalingList().xParseScalingList( getScalingListFileName() ), "Error Parsing Scaling List Input File" );
+    CHECK_VTM( aps.getScalingList().xParseScalingList( getScalingListFileName() ), "Error Parsing Scaling List Input File" );
     aps.getScalingList().checkDcOfMatrix();
     if( aps.getScalingList().isNotDefaultScalingList() == false )
     {
@@ -952,11 +952,11 @@ void EncLib::xGetNewPicBuffer ( std::list<PelUnitBuf*>& rcListPicYuvRecOut, Pict
 
   // At this point, the SPS and PPS can be considered activated - they are copied to the new Pic.
   const PPS *pPPS=(ppsId<0) ? m_ppsMap.getFirstPS() : m_ppsMap.getPS(ppsId);
-  CHECK(!(pPPS!=0), "Unspecified error");
+  CHECK_VTM(!(pPPS!=0), "Unspecified error");
   const PPS &pps=*pPPS;
 
   const SPS *pSPS=m_spsMap.getPS(pps.getSPSId());
-  CHECK(!(pSPS!=0), "Unspecified error");
+  CHECK_VTM(!(pSPS!=0), "Unspecified error");
   const SPS &sps=*pSPS;
 
   Slice::sortPicList(m_cListPic);
@@ -1117,7 +1117,7 @@ void EncLib::xInitVPS( const SPS& sps )
         m_vps->m_dpbParameters[dpbIdx].m_maxNumReorderPics[j] = m_vps->m_dpbParameters[dpbIdx].m_maxDecPicBuffering[j] - 1;
         m_vps->m_dpbParameters[dpbIdx].m_maxLatencyIncreasePlus1[j] = 0;
 
-        CHECK( m_vps->m_dpbParameters[dpbIdx].m_maxDecPicBuffering[j] > profileLevelTierFeatures.getMaxDpbSize( m_vps->getOlsDpbPicSize( i ).width * m_vps->getOlsDpbPicSize( i ).height ), "DPB size is not sufficient" );
+        CHECK_VTM( m_vps->m_dpbParameters[dpbIdx].m_maxDecPicBuffering[j] > profileLevelTierFeatures.getMaxDpbSize( m_vps->getOlsDpbPicSize( i ).width * m_vps->getOlsDpbPicSize( i ).height ), "DPB size is not sufficient" );
       }
 
       for( int j = ( m_vps->m_sublayerDpbParamsPresentFlag ? m_vps->m_dpbMaxTemporalId[dpbIdx] : 0 ); j < m_vps->m_dpbMaxTemporalId[dpbIdx]; j++ )
@@ -1304,7 +1304,7 @@ void EncLib::xInitSPS( SPS& sps )
       sps.setLadfQpOffset( m_LadfQpOffset[k], k );
       sps.setLadfIntervalLowerBound( m_LadfIntervalLowerBound[k], k );
     }
-    CHECK( m_LadfIntervalLowerBound[0] != 0, "abnormal value set to LadfIntervalLowerBound[0]" );
+    CHECK_VTM( m_LadfIntervalLowerBound[0] != 0, "abnormal value set to LadfIntervalLowerBound[0]" );
   }
 #endif
 
@@ -1326,10 +1326,10 @@ void EncLib::xInitSPS( SPS& sps )
   sps.setUseLmcs                            ( m_lmcsEnabled );
   sps.setUseMRL                ( m_MRL );
   sps.setUseMIP                ( m_MIP );
-  CHECK(m_log2MinCUSize > std::min(6, floorLog2(sps.getMaxCUWidth())), "sps_log2_min_luma_coding_block_size_minus2 shall be in the range of 0 to min (4, log2_ctu_size - 2)");
-  CHECK(m_uiMaxMTTHierarchyDepth > 2 * (floorLog2(sps.getCTUSize()) - sps.getLog2MinCodingBlockSize()), "sps_max_mtt_hierarchy_depth_inter_slice shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
-  CHECK(m_uiMaxMTTHierarchyDepthI > 2 * (floorLog2(sps.getCTUSize()) - sps.getLog2MinCodingBlockSize()), "sps_max_mtt_hierarchy_depth_intra_slice_luma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
-  CHECK(m_uiMaxMTTHierarchyDepthIChroma > 2 * (floorLog2(sps.getCTUSize()) - sps.getLog2MinCodingBlockSize()), "sps_max_mtt_hierarchy_depth_intra_slice_chroma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
+  CHECK_VTM(m_log2MinCUSize > std::min(6, floorLog2(sps.getMaxCUWidth())), "sps_log2_min_luma_coding_block_size_minus2 shall be in the range of 0 to min (4, log2_ctu_size - 2)");
+  CHECK_VTM(m_uiMaxMTTHierarchyDepth > 2 * (floorLog2(sps.getCTUSize()) - sps.getLog2MinCodingBlockSize()), "sps_max_mtt_hierarchy_depth_inter_slice shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
+  CHECK_VTM(m_uiMaxMTTHierarchyDepthI > 2 * (floorLog2(sps.getCTUSize()) - sps.getLog2MinCodingBlockSize()), "sps_max_mtt_hierarchy_depth_intra_slice_luma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
+  CHECK_VTM(m_uiMaxMTTHierarchyDepthIChroma > 2 * (floorLog2(sps.getCTUSize()) - sps.getLog2MinCodingBlockSize()), "sps_max_mtt_hierarchy_depth_intra_slice_chroma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
 
   sps.setTransformSkipEnabledFlag(m_useTransformSkip);
   sps.setLog2MaxTransformSkipBlockSize(m_log2MaxTransformSkipBlockSize);
@@ -1411,7 +1411,7 @@ void EncLib::xInitSPS( SPS& sps )
   }
 
   sps.setNumLongTermRefPicSPS(NUM_LONG_TERM_REF_PIC_SPS);
-  CHECK(!(NUM_LONG_TERM_REF_PIC_SPS <= MAX_NUM_LONG_TERM_REF_PICS), "Unspecified error");
+  CHECK_VTM(!(NUM_LONG_TERM_REF_PIC_SPS <= MAX_NUM_LONG_TERM_REF_PICS), "Unspecified error");
   for (int k = 0; k < NUM_LONG_TERM_REF_PIC_SPS; k++)
   {
     sps.setLtRefPicPocLsbSps(k, 0);
@@ -1505,7 +1505,7 @@ void EncLib::xInitSPS( SPS& sps )
   if( sps.getVirtualBoundariesEnabledFlag() )
   {
     sps.setVirtualBoundariesPresentFlag( m_virtualBoundariesPresentFlag );
-    CHECK( sps.getSubPicInfoPresentFlag() && sps.getVirtualBoundariesPresentFlag() != 1, "When subpicture signalling if present, the signalling of virtual boundaries, is present, shall be in the SPS" );
+    CHECK_VTM( sps.getSubPicInfoPresentFlag() && sps.getVirtualBoundariesPresentFlag() != 1, "When subpicture signalling if present, the signalling of virtual boundaries, is present, shall be in the SPS" );
     sps.setNumVerVirtualBoundaries            ( m_numVerVirtualBoundaries );
     sps.setNumHorVirtualBoundaries            ( m_numHorVirtualBoundaries );
     for( unsigned int i = 0; i < m_numVerVirtualBoundaries; i++ )
@@ -1519,14 +1519,14 @@ void EncLib::xInitSPS( SPS& sps )
   }
 
   sps.setInterLayerPresentFlag( m_layerId > 0 && m_vps->getMaxLayers() > 1 && !m_vps->getAllIndependentLayersFlag() && !m_vps->getIndependentLayerFlag( m_vps->getGeneralLayerIdx( m_layerId ) ) );
-  CHECK( m_vps->getIndependentLayerFlag( m_vps->getGeneralLayerIdx( m_layerId ) ) && sps.getInterLayerPresentFlag(), " When vps_independent_layer_flag[GeneralLayerIdx[nuh_layer_id ]]  is equal to 1, the value of inter_layer_ref_pics_present_flag shall be equal to 0." );
+  CHECK_VTM( m_vps->getIndependentLayerFlag( m_vps->getGeneralLayerIdx( m_layerId ) ) && sps.getInterLayerPresentFlag(), " When vps_independent_layer_flag[GeneralLayerIdx[nuh_layer_id ]]  is equal to 1, the value of inter_layer_ref_pics_present_flag shall be equal to 0." );
 
   sps.setResChangeInClvsEnabledFlag(m_resChangeInClvsEnabled);
   sps.setRprEnabledFlag(m_rprEnabledFlag);
 
   sps.setLog2ParallelMergeLevelMinus2( m_log2ParallelMergeLevelMinus2 );
 
-  CHECK(sps.getResChangeInClvsEnabledFlag() && sps.getVirtualBoundariesEnabledFlag(), "when the value of sps_res_change_in_clvs_allowed_flag is equal to 1, the value of sps_virtual_boundaries_present_flag shall be equal to 0");
+  CHECK_VTM(sps.getResChangeInClvsEnabledFlag() && sps.getVirtualBoundariesEnabledFlag(), "when the value of sps_res_change_in_clvs_allowed_flag is equal to 1, the value of sps_virtual_boundaries_present_flag shall be equal to 0");
 }
 
 void EncLib::xInitHrdParameters(SPS &sps)
@@ -1572,7 +1572,7 @@ void EncLib::xInitPPS(PPS &pps, const SPS &sps)
 #if ENABLE_QPA
   if (getUsePerceptQPA() && !bUseDQP)
   {
-    CHECK( m_cuQpDeltaSubdiv != 0, "max. delta-QP subdiv must be zero!" );
+    CHECK_VTM( m_cuQpDeltaSubdiv != 0, "max. delta-QP subdiv must be zero!" );
     bUseDQP = (getBaseQP() < 38) && (getSourceWidth() > 512 || getSourceHeight() > 320);
   }
 #endif
@@ -1702,8 +1702,8 @@ void EncLib::xInitPPS(PPS &pps, const SPS &sps)
     pps.setPicWidthMinusWrapAroundOffset      ( 0 );
     pps.setWrapAroundOffset                   ( 0 );       
   }
-  CHECK( !sps.getWrapAroundEnabledFlag() && pps.getWrapAroundEnabledFlag(), "When sps_ref_wraparound_enabled_flag is equal to 0, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
-  CHECK( (((sps.getCTUSize() / minCbSizeY) + 1) > ((pps.getPicWidthInLumaSamples() / minCbSizeY) - 1)) && pps.getWrapAroundEnabledFlag(), "When the value of CtbSizeY / MinCbSizeY + 1 is greater than pps_pic_width_in_luma_samples / MinCbSizeY - 1, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
+  CHECK_VTM( !sps.getWrapAroundEnabledFlag() && pps.getWrapAroundEnabledFlag(), "When sps_ref_wraparound_enabled_flag is equal to 0, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
+  CHECK_VTM( (((sps.getCTUSize() / minCbSizeY) + 1) > ((pps.getPicWidthInLumaSamples() / minCbSizeY) - 1)) && pps.getWrapAroundEnabledFlag(), "When the value of CtbSizeY / MinCbSizeY + 1 is greater than pps_pic_width_in_luma_samples / MinCbSizeY - 1, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
 
   pps.setNoPicPartitionFlag( m_noPicPartitionFlag );
   if( m_noPicPartitionFlag == false )
@@ -1826,7 +1826,7 @@ void EncLib::xInitPPS(PPS &pps, const SPS &sps)
   }
   for( int i = 0; i < getGOPSize(); i++)
   {
-    CHECK(!(getRPLEntry(0, i).m_numRefPicsActive >= 0 && getRPLEntry(0, i).m_numRefPicsActive <= MAX_NUM_REF), "Unspecified error");
+    CHECK_VTM(!(getRPLEntry(0, i).m_numRefPicsActive >= 0 && getRPLEntry(0, i).m_numRefPicsActive <= MAX_NUM_REF), "Unspecified error");
     histogram[getRPLEntry(0, i).m_numRefPicsActive]++;
   }
 
@@ -1840,7 +1840,7 @@ void EncLib::xInitPPS(PPS &pps, const SPS &sps)
       bestPos=i;
     }
   }
-  CHECK(!(bestPos <= 15), "Unspecified error");
+  CHECK_VTM(!(bestPos <= 15), "Unspecified error");
     pps.setNumRefIdxL0DefaultActive(bestPos);
   pps.setNumRefIdxL1DefaultActive(bestPos);
   pps.setPictureHeaderExtensionPresentFlag(false);
@@ -1890,7 +1890,7 @@ void EncLib::xInitPicHeader(PicHeader &picHeader, const SPS &sps, const PPS &pps
 #if ENABLE_QPA
   if( getUsePerceptQPA() && !bUseDQP )
   {
-    CHECK( m_cuQpDeltaSubdiv != 0, "max. delta-QP subdiv must be zero!" );
+    CHECK_VTM( m_cuQpDeltaSubdiv != 0, "max. delta-QP subdiv must be zero!" );
     bUseDQP = (getBaseQP() < 38) && (getSourceWidth() > 512 || getSourceHeight() > 320);
   }
 #endif
diff --git a/source/Lib/EncoderLib/EncModeCtrl.cpp b/source/Lib/EncoderLib/EncModeCtrl.cpp
index 8585001..587ba48 100644
--- a/source/Lib/EncoderLib/EncModeCtrl.cpp
+++ b/source/Lib/EncoderLib/EncModeCtrl.cpp
@@ -83,7 +83,7 @@ void EncModeCtrl::setEarlySkipDetected()
 
 void EncModeCtrl::xExtractFeatures( const EncTestMode encTestmode, CodingStructure& cs )
 {
-  CHECK( cs.features.size() < NUM_ENC_FEATURES, "Features vector is not initialized" );
+  CHECK_VTM( cs.features.size() < NUM_ENC_FEATURES, "Features vector is not initialized" );
 
   cs.features[ENC_FT_DISTORTION     ] = double( cs.dist              );
   cs.features[ENC_FT_FRAC_BITS      ] = double( cs.fracBits          );
@@ -214,7 +214,7 @@ int EncModeCtrl::calculateLumaDQP( const CPelBuf& rcOrg )
 #if !WCG_EXT
   if( m_pcEncCfg->getLumaLevelToDeltaQPMapping().mode == LUMALVL_TO_DQP_AVG_METHOD )
 #else
-  CHECK( m_pcEncCfg->getLumaLevelToDeltaQPMapping().mode != LUMALVL_TO_DQP_AVG_METHOD, "invalid delta qp mode" );
+  CHECK_VTM( m_pcEncCfg->getLumaLevelToDeltaQPMapping().mode != LUMALVL_TO_DQP_AVG_METHOD, "invalid delta qp mode" );
 #endif
   {
     // Use average luma value
@@ -1099,7 +1099,7 @@ void EncModeCtrlMTnoRQT::initCTUEncoding( const Slice &slice )
 #endif
   SaveLoadEncInfoSbt::init( slice );
 
-  CHECK( !m_ComprCUCtxList.empty(), "Mode list is not empty at the beginning of a CTU" );
+  CHECK_VTM( !m_ComprCUCtxList.empty(), "Mode list is not empty at the beginning of a CTU" );
 
   m_slice             = &slice;
 #if ENABLE_SPLIT_PARALLELISM
@@ -1598,7 +1598,7 @@ bool EncModeCtrlMTnoRQT::tryMode( const EncTestMode& encTestmode, const CodingSt
   else if( isModeInter( encTestmode ) )
   {
     // INTER MODES (ME + MERGE/SKIP)
-    CHECK( slice.isIntra(), "Inter-mode should not be in the I-Slice mode list!" );
+    CHECK_VTM( slice.isIntra(), "Inter-mode should not be in the I-Slice mode list!" );
 
     if( getFastDeltaQp() )
     {
@@ -1852,7 +1852,7 @@ bool EncModeCtrlMTnoRQT::tryMode( const EncTestMode& encTestmode, const CodingSt
   }
   else
   {
-    CHECK( encTestmode.type != ETM_POST_DONT_SPLIT, "Unknown mode" );
+    CHECK_VTM( encTestmode.type != ETM_POST_DONT_SPLIT, "Unknown mode" );
     if ((cuECtx.get<double>(BEST_NO_IMV_COST) == (MAX_DOUBLE * .5) || cuECtx.get<bool>(IS_REUSING_CU)) && !slice.isIntra())
     {
       unsigned idx1, idx2, idx3, idx4;
diff --git a/source/Lib/EncoderLib/EncModeCtrl.h b/source/Lib/EncoderLib/EncModeCtrl.h
index 0eb7a33..d5affd3 100644
--- a/source/Lib/EncoderLib/EncModeCtrl.h
+++ b/source/Lib/EncoderLib/EncModeCtrl.h
@@ -330,7 +330,8 @@ public:
   virtual void setBest              ( CodingStructure& cs );
   bool         anyMode              () const;
 
-  const ComprCUCtx& getComprCUCtx   () { CHECK( m_ComprCUCtxList.empty(), "Accessing empty list!"); return m_ComprCUCtxList.back(); }
+  const ComprCUCtx& getComprCUCtx   () {
+    CHECK_VTM( m_ComprCUCtxList.empty(), "Accessing empty list!"); return m_ComprCUCtxList.back(); }
 
 #if SHARP_LUMA_DELTA_QP
   void                  initLumaDeltaQpLUT();
diff --git a/source/Lib/EncoderLib/EncReshape.cpp b/source/Lib/EncoderLib/EncReshape.cpp
index 1af97f0..41a1977 100644
--- a/source/Lib/EncoderLib/EncReshape.cpp
+++ b/source/Lib/EncoderLib/EncReshape.cpp
@@ -1294,7 +1294,7 @@ void EncReshape::constructReshaperLMCS()
 
   int sumBins = 0;
   for (i = 0; i < PIC_CODE_CW_BINS; i++) { sumBins += m_binCW[i]; }
-  CHECK(sumBins >= m_reshapeLUTSize, "SDR CW assignment is wrong!!");
+  CHECK_VTM(sumBins >= m_reshapeLUTSize, "SDR CW assignment is wrong!!");
   for (int i = 0; i < PIC_CODE_CW_BINS; i++)
   {
     m_reshapePivot[i + 1] = m_reshapePivot[i] + m_binCW[i];
diff --git a/source/Lib/EncoderLib/EncSampleAdaptiveOffset.cpp b/source/Lib/EncoderLib/EncSampleAdaptiveOffset.cpp
index 90583a5..d26ed73 100644
--- a/source/Lib/EncoderLib/EncSampleAdaptiveOffset.cpp
+++ b/source/Lib/EncoderLib/EncSampleAdaptiveOffset.cpp
@@ -833,7 +833,7 @@ void EncSampleAdaptiveOffset::decideBlkParams(CodingStructure& cs, bool* sliceEn
 
   int ctuRsAddr = 0;
 #if ENABLE_QPA
-  CHECK ((chromaWeight > 0.0) && (cs.slice->getFirstCtuRsAddrInSlice() != 0), "incompatible start CTU address, must be 0");
+  CHECK_VTM((chromaWeight > 0.0) && (cs.slice->getFirstCtuRsAddrInSlice() != 0), "incompatible start CTU address, must be 0");
 #endif
 
   for( uint32_t yPos = 0; yPos < pcv.lumaHeight; yPos += pcv.maxCUHeight )
diff --git a/source/Lib/EncoderLib/EncSlice.cpp b/source/Lib/EncoderLib/EncSlice.cpp
index 5ac5644..39851bf 100644
--- a/source/Lib/EncoderLib/EncSlice.cpp
+++ b/source/Lib/EncoderLib/EncSlice.cpp
@@ -40,6 +40,8 @@
 #include "EncLib.h"
 #include "CommonLib/UnitTools.h"
 #include "CommonLib/Picture.h"
+#include "PartitionGlobalManager.h"
+
 #if K0149_BLOCK_STATISTICS
 #include "CommonLib/dtrace_blockstatistics.h"
 #endif
@@ -231,7 +233,7 @@ static int getGlaringColorQPOffset (Picture* const pcPic, const int ctuAddr, Sli
 
     if (chrValue > avgCompValue) chrValue = avgCompValue; // minimum of the DC offsets
   }
-  CHECK (chrValue < 0, "DC offset cannot be negative!");
+  CHECK_VTM(chrValue < 0, "DC offset cannot be negative!");
 
   chrValue = (int)avgLumaValue - chrValue;
 
@@ -347,7 +349,7 @@ void EncSlice::initEncSlice(Picture* pcPic, const int pocLast, const int pocCurr
     rpcSlice->setSignDataHidingEnabledFlag( m_pcCfg->getSignDataHidingEnabledFlag() );
     rpcSlice->setTSResidualCodingDisabledFlag( false );
 
-    CHECK( (m_pcCfg->getDepQuantEnabledFlag() || m_pcCfg->getSignDataHidingEnabledFlag() ) 
+    CHECK_VTM( (m_pcCfg->getDepQuantEnabledFlag() || m_pcCfg->getSignDataHidingEnabledFlag() )
            && rpcSlice->getTSResidualCodingDisabledFlag() , "TSRC cannot be bypassed if either DQ or SDH are enabled at slice level.");
   }
   else
@@ -533,9 +535,9 @@ void EncSlice::initEncSlice(Picture* pcPic, const int pocLast, const int pocCurr
     cbQP = Clip3( -12, 12, cbQP + rpcSlice->getPPS()->getQpOffset(COMPONENT_Cb) ) - rpcSlice->getPPS()->getQpOffset(COMPONENT_Cb);
     crQP = Clip3( -12, 12, crQP + rpcSlice->getPPS()->getQpOffset(COMPONENT_Cr) ) - rpcSlice->getPPS()->getQpOffset(COMPONENT_Cr);
     rpcSlice->setSliceChromaQpDelta(COMPONENT_Cb, Clip3( -12, 12, cbQP));
-    CHECK(!(rpcSlice->getSliceChromaQpDelta(COMPONENT_Cb)+rpcSlice->getPPS()->getQpOffset(COMPONENT_Cb)<=12 && rpcSlice->getSliceChromaQpDelta(COMPONENT_Cb)+rpcSlice->getPPS()->getQpOffset(COMPONENT_Cb)>=-12), "Unspecified error");
+    CHECK_VTM(!(rpcSlice->getSliceChromaQpDelta(COMPONENT_Cb)+rpcSlice->getPPS()->getQpOffset(COMPONENT_Cb)<=12 && rpcSlice->getSliceChromaQpDelta(COMPONENT_Cb)+rpcSlice->getPPS()->getQpOffset(COMPONENT_Cb)>=-12), "Unspecified error");
     rpcSlice->setSliceChromaQpDelta(COMPONENT_Cr, Clip3( -12, 12, crQP));
-    CHECK(!(rpcSlice->getSliceChromaQpDelta(COMPONENT_Cr)+rpcSlice->getPPS()->getQpOffset(COMPONENT_Cr)<=12 && rpcSlice->getSliceChromaQpDelta(COMPONENT_Cr)+rpcSlice->getPPS()->getQpOffset(COMPONENT_Cr)>=-12), "Unspecified error");
+    CHECK_VTM(!(rpcSlice->getSliceChromaQpDelta(COMPONENT_Cr)+rpcSlice->getPPS()->getQpOffset(COMPONENT_Cr)<=12 && rpcSlice->getSliceChromaQpDelta(COMPONENT_Cr)+rpcSlice->getPPS()->getQpOffset(COMPONENT_Cr)>=-12), "Unspecified error");
     if (rpcSlice->getSPS()->getJointCbCrEnabledFlag())
     {
       cbCrQP = Clip3(-12, 12, cbCrQP + rpcSlice->getPPS()->getQpOffset(JOINT_CbCr)) - rpcSlice->getPPS()->getQpOffset(JOINT_CbCr);
@@ -886,7 +888,7 @@ static bool applyQPAdaptation (Picture* const pcPic,       Slice* const pcSlice,
       const double  corrFactor = pow (2.0, double(iQPFixed - iQPIndex) / 3.0);
       const double  newLambdas[MAX_NUM_COMPONENT] = {oldLambdas[0] * corrFactor, oldLambdas[1] * corrFactor, oldLambdas[2] * corrFactor};
 
-      CHECK (iQPIndex != pcSlice->getSliceQpBase(), "Invalid slice QP!");
+      CHECK_VTM(iQPIndex != pcSlice->getSliceQpBase(), "Invalid slice QP!");
       pcSlice->setLambdas (newLambdas);
       pcSlice->setSliceQp (iQPFixed); // update the slice/base QPs
       pcSlice->setSliceQpBase (iQPFixed);
@@ -922,7 +924,7 @@ static bool applyQPAdaptation (Picture* const pcPic,       Slice* const pcSlice,
               && !useSharpLumaDQP
 #endif
               ) iQPAdapt = MAX_QP;
-          CHECK (meanLuma != (uint32_t)pcPic->m_iOffsetCtu[ctuRsAddr], "luma DC offsets don't match");
+          CHECK_VTM(meanLuma != (uint32_t)pcPic->m_iOffsetCtu[ctuRsAddr], "luma DC offsets don't match");
         }
 #if SHARP_LUMA_DELTA_QP
 
@@ -1044,7 +1046,7 @@ static int applyQPAdaptationSubCtu (CodingStructure &cs, const UnitArea ctuArea,
     uint32_t subMLV[16];   // individual mean luma values
 #endif
 
-    CHECK (mts * 4 < pcv.maxCUWidth || mts * 4 < pcv.maxCUHeight, "max. transform size is too small for given CTU size");
+    CHECK_VTM(mts * 4 < pcv.maxCUWidth || mts * 4 < pcv.maxCUHeight, "max. transform size is too small for given CTU size");
 
     for (unsigned h = 0; h < (pcv.maxCUHeight >> mtsLog2); h++)
     {
@@ -1334,7 +1336,7 @@ void EncSlice::compressSlice( Picture* pcPic, const bool bCompressEntireSlice, c
 
     pcPic->m_prevQP[0] = pcPic->m_prevQP[1] = pcSlice->getSliceQp();
 
-  CHECK( pcPic->m_prevQP[0] == std::numeric_limits<int>::max(), "Invalid previous QP" );
+    CHECK_VTM( pcPic->m_prevQP[0] == std::numeric_limits<int>::max(), "Invalid previous QP" );
 
   CodingStructure&  cs          = *pcPic->cs;
   cs.slice    = pcSlice;
@@ -1689,8 +1691,21 @@ void EncSlice::encodeCtus( Picture* pcPic, const bool bCompressEntireSlice, cons
       pcPic->mctsInfo.init( &cs, ctuRsAddr );
     }
 
+
+  //altissie added => create luma and chroma tree for the ctu
+  PartitionTree luma_tree(param_partition->ctuSize, param_partition->ctuSize, nullptr, nullptr, param_partition, false, false, cs.cost);
+  PartitionTree chroma_tree(param_partition->ctuSize, param_partition->ctuSize, nullptr, nullptr, param_partition, false, false, cs.cost);
+
   if (pCfg->getSwitchPOC() != pcPic->poc || ctuRsAddr >= pCfg->getDebugCTU())
-    m_pcCuEncoder->compressCtu( cs, ctuArea, ctuRsAddr, prevQP, currQP );
+    m_pcCuEncoder->compressCtu( cs, ctuArea, ctuRsAddr, prevQP, currQP, &luma_tree, &chroma_tree );
+
+
+  if(param_partition->is_writePartition()){
+    store_partition->store_ctu(&luma_tree, !pcSlice->isIntra());
+    if(pcSlice->isIntra()){
+      store_partition->store_ctu(&chroma_tree, !pcSlice->isIntra());
+    }
+  }
 
 #if K0149_BLOCK_STATISTICS
     getAndStoreBlockStatistics(cs, ctuArea);
diff --git a/source/Lib/EncoderLib/InterSearch.cpp b/source/Lib/EncoderLib/InterSearch.cpp
index ff9ba84..275bd5e 100644
--- a/source/Lib/EncoderLib/InterSearch.cpp
+++ b/source/Lib/EncoderLib/InterSearch.cpp
@@ -123,7 +123,7 @@ InterSearch::InterSearch()
 
 void InterSearch::destroy()
 {
-  CHECK(!m_isInitialized, "Not initialized");
+  CHECK_VTM(!m_isInitialized, "Not initialized");
   if ( m_pTempPel )
   {
     delete [] m_pTempPel;
@@ -207,7 +207,7 @@ void InterSearch::init( EncCfg*        pcEncCfg,
                       , EncReshape*    pcReshape
 )
 {
-  CHECK(m_isInitialized, "Already initialized");
+  CHECK_VTM(m_isInitialized, "Already initialized");
   m_numBVs = 0;
   for (int i = 0; i < IBC_NUM_CANDIDATES; i++)
   {
@@ -453,7 +453,7 @@ inline void InterSearch::xTZ8PointSquareSearch( IntTZSearchStruct& rcStruct, con
   // 8 point search,                   //   1 2 3
   // search around the start point     //   4 0 5
   // with the required  distance       //   6 7 8
-  CHECK( iDist == 0 , "Invalid distance");
+  CHECK_VTM( iDist == 0 , "Invalid distance");
   const int iTop        = iStartY - iDist;
   const int iBottom     = iStartY + iDist;
   const int iLeft       = iStartX - iDist;
@@ -511,7 +511,7 @@ inline void InterSearch::xTZ8PointDiamondSearch( IntTZSearchStruct& rcStruct,
   // 8 point search,                   //   1 2 3
   // search around the start point     //   4 0 5
   // with the required  distance       //   6 7 8
-  CHECK( iDist == 0, "Invalid distance" );
+  CHECK_VTM( iDist == 0, "Invalid distance" );
   const int iTop        = iStartY - iDist;
   const int iBottom     = iStartY + iDist;
   const int iLeft       = iStartX - iDist;
@@ -1282,7 +1282,7 @@ void InterSearch::xIBCEstimation(PredictionUnit& pu, PelUnitBuf& origBuf,
   cStruct.pcPatternKey = pcPatternKey;
   cStruct.iRefStride = refBuf.stride;
   cStruct.piRefY = refBuf.buf;
-  CHECK(pu.cu->imv == IMV_HPEL, "IF_IBC");
+  CHECK_VTM(pu.cu->imv == IMV_HPEL, "IF_IBC");
   cStruct.imvShift = pu.cu->imv << 1;
   cStruct.subShiftMode = 0; // used by intra pattern search function
 
@@ -1437,7 +1437,7 @@ bool InterSearch::predIBCSearch(CodingUnit& cu, Partitioner& partitioner, const
   {
     m_maxCompIDToPred = MAX_NUM_COMPONENT;
 
-    CHECK(pu.cu != &cu, "PU is contained in another CU");
+    CHECK_VTM(pu.cu != &cu, "PU is contained in another CU");
     //////////////////////////////////////////////////////////
     /// ibc search
     pu.cu->imv = 2;
@@ -1850,7 +1850,7 @@ bool InterSearch::xRectHashInterEstimation(PredictionUnit& pu, RefPicList& bestR
         continue;
       }
 
-      CHECK( pu.cu->slice->getRefPic( eRefPicList, refIdx )->getHashMap() == nullptr, "Hash table is not initialized" );
+      CHECK_VTM( pu.cu->slice->getRefPic( eRefPicList, refIdx )->getHashMap() == nullptr, "Hash table is not initialized" );
 
       if (refList == 0 || pu.cu->slice->getList1IdxToList0Idx(refIdx) < 0)
       {
@@ -2049,7 +2049,7 @@ bool InterSearch::xHashInterEstimation(PredictionUnit& pu, RefPicList& bestRefPi
         continue;
       }
 
-      CHECK( pu.cu->slice->getRefPic( eRefPicList, refIdx )->getHashMap() == nullptr, "Hash table is not initialized" );
+      CHECK_VTM( pu.cu->slice->getRefPic( eRefPicList, refIdx )->getHashMap() == nullptr, "Hash table is not initialized" );
 
       if (refList == 0 || pu.cu->slice->getList1IdxToList0Idx(refIdx) < 0)
       {
@@ -2075,7 +2075,7 @@ bool InterSearch::xHashInterEstimation(PredictionUnit& pu, RefPicList& bestRefPi
         AMVPInfo currAMVPInfoQPel;
         pu.cu->imv = 0;
         PU::fillMvpCand(pu, eRefPicList, refIdx, currAMVPInfoQPel);
-        CHECK(currAMVPInfoPel.numCand <= 1, "Wrong")
+        CHECK_VTM(currAMVPInfoPel.numCand <= 1, "Wrong")
         for (int mvpIdxTemp = 0; mvpIdxTemp < 2; mvpIdxTemp++)
         {
           currAMVPInfoQPel.mvCand[mvpIdxTemp].changePrecision(MV_PRECISION_INTERNAL, MV_PRECISION_QUARTER);
@@ -2242,7 +2242,7 @@ bool InterSearch::predInterHashSearch(CodingUnit& cu, Partitioner& partitioner,
 
 
 //! search of the best candidate for inter prediction
-void InterSearch::predInterSearch(CodingUnit& cu, Partitioner& partitioner)
+void InterSearch::predInterSearch(CodingUnit& cu, Partitioner& partitioner, Mv* mvUni, int * pocRef, unsigned long * costRef, RefPicList * refPicList, int * pocRefIdx)
 {
   CodingStructure& cs = *cu.cs;
 
@@ -2288,7 +2288,7 @@ void InterSearch::predInterSearch(CodingUnit& cu, Partitioner& partitioner)
   MergeCtx     mergeCtx;
 
   // Loop over Prediction Units
-  CHECK(!cu.firstPU, "CU does not contain any PUs");
+  CHECK_VTM(!cu.firstPU, "CU does not contain any PUs");
   uint32_t         puIdx = 0;
   auto &pu = *cu.firstPU;
   WPScalingParam *wp0;
@@ -2319,7 +2319,7 @@ void InterSearch::predInterSearch(CodingUnit& cu, Partitioner& partitioner)
     m_maxCompIDToPred = MAX_NUM_COMPONENT;
 //    m_maxCompIDToPred = COMPONENT_Y;
 
-    CHECK(pu.cu != &cu, "PU is contained in another CU");
+    CHECK_VTM(pu.cu != &cu, "PU is contained in another CU");
 
     if (cu.cs->sps->getSbTMVPEnabledFlag())
     {
@@ -2435,6 +2435,28 @@ void InterSearch::predInterSearch(CodingUnit& cu, Partitioner& partitioner)
             iRefIdx[iRefList] = iRefIdxTemp;
           }
 
+          //store the mv and poc reference frame to get the reference ctu
+          if(mvUni!= nullptr && uiCostTemp < costRef[iRefList] /*&& cu.lheight()==128 && cu.lwidth() == 128*/){
+            if(iRefList==0){
+              mvUni[iRefList] = cMvTemp[iRefList][iRefIdxTemp];
+              pocRef[iRefList] = cs.slice->getPOC()+cs.slice->getRPL0()->getRefPicIdentifier(iRefIdxTemp);
+              //std::cout<<"poc: "<<cs.slice->getPOC()<<" ref: "<<cs.slice->getRPL0()->getRefPicIdentifier(iRefIdxTemp)<<std::endl;
+              costRef[iRefList] = uiCostTemp;
+              refPicList[iRefList] = REF_PIC_LIST_0;
+              pocRefIdx[iRefList] = iRefIdxTemp;
+            }
+            else{
+              if(mvUni[0].getHor()!=cMvTemp[iRefList][iRefIdxTemp].getHor() || mvUni[0].getVer()!=cMvTemp[iRefList][iRefIdxTemp].getVer() || pocRef[0]!=cs.slice->getPOC()+cs.slice->getRPL1()->getRefPicIdentifier(iRefIdxTemp)){
+                mvUni[iRefList] = cMvTemp[iRefList][iRefIdxTemp];
+                pocRef[iRefList] = cs.slice->getPOC()+cs.slice->getRPL1()->getRefPicIdentifier(iRefIdxTemp);
+                costRef[iRefList] = uiCostTemp;
+                refPicList[iRefList] = REF_PIC_LIST_1;
+                pocRefIdx[iRefList] = iRefIdxTemp;
+              }
+            }
+            //std::cout<<uiCost[iRefList]<<std::endl;
+          }
+
           if ( iRefList == 1 && uiCostTemp < costValidList1 && cs.slice->getList1IdxToList0Idx( iRefIdxTemp ) < 0 )
           {
             costValidList1 = uiCostTemp;
@@ -2447,6 +2469,11 @@ void InterSearch::predInterSearch(CodingUnit& cu, Partitioner& partitioner)
         }
       }
 
+      /*if(cu.lheight()==128 && cu.lwidth() == 128){
+        std::cout<<"Im ref 0 : "<<iRefIdx[0]<<" // "<<cs.slice->getPOC()+cs.slice->getRPL0()->getRefPicIdentifier(iRefIdx[0])<<" / X : "<<cMv[0].getHor()<<" / Y : "<<cMv[0].getVer()<<std::endl;
+        std::cout<<"Im ref 1 : "<<iRefIdx[1]<<" // "<<cs.slice->getPOC()+cs.slice->getRPL1()->getRefPicIdentifier(iRefIdx[1])<<" / X : "<<cMv[1].getHor()<<" / Y : "<<cMv[1].getVer()<<std::endl;
+      }*/
+
       ::memcpy(cMvHevcTemp, cMvTemp, sizeof(cMvTemp));
       if (cu.imv == 0 && (!cu.slice->getSPS()->getUseBcw() || bcwIdx == BCW_DEFAULT))
       {
@@ -2664,7 +2691,7 @@ void InterSearch::predInterSearch(CodingUnit& cu, Partitioner& partitioner)
           RefPicList eCurRefList = (curRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
           int refIdxCur = cs.slice->getSymRefIdx( curRefList );
           int refIdxTar = cs.slice->getSymRefIdx( tarRefList );
-          CHECK (refIdxCur==-1 || refIdxTar==-1, "Uninitialized reference index not allowed");
+          CHECK_VTM(refIdxCur==-1 || refIdxTar==-1, "Uninitialized reference index not allowed");
 
           if ( aacAMVPInfo[curRefList][refIdxCur].mvCand[0] == aacAMVPInfo[curRefList][refIdxCur].mvCand[1] )
             aacAMVPInfo[curRefList][refIdxCur].numCand = 1;
@@ -2830,8 +2857,8 @@ void InterSearch::predInterSearch(CodingUnit& cu, Partitioner& partitioner)
     uiCost [1] = costValidList1;
     if (cu.cs->pps->getWPBiPred() == true && tryBipred && (bcwIdx != BCW_DEFAULT))
     {
-      CHECK(iRefIdxBi[0]<0, "Invalid picture reference index");
-      CHECK(iRefIdxBi[1]<0, "Invalid picture reference index");
+      CHECK_VTM(iRefIdxBi[0]<0, "Invalid picture reference index");
+      CHECK_VTM(iRefIdxBi[1]<0, "Invalid picture reference index");
       wp0 = cu.cs->slice->getWpScaling(REF_PIC_LIST_0, iRefIdxBi[0]);
       wp1 = cu.cs->slice->getWpScaling(REF_PIC_LIST_1, iRefIdxBi[1]);
       if (WPScalingParam::isWeighted(wp0) || WPScalingParam::isWeighted(wp1))
@@ -3029,7 +3056,7 @@ void InterSearch::predInterSearch(CodingUnit& cu, Partitioner& partitioner)
       else
       {
         cu.smvdMode = 0;
-        CHECK( !cu.affine, "Wrong." );
+        CHECK_VTM( !cu.affine, "Wrong." );
         uiLastMode = uiLastModeTemp;
       }
     }
@@ -3129,7 +3156,7 @@ void InterSearch::xEstimateMvPredAMVP( PredictionUnit& pu, PelUnitBuf& origBuf,
 
 uint32_t InterSearch::xGetMvpIdxBits(int iIdx, int iNum)
 {
-  CHECK(iIdx < 0 || iNum < 0 || iIdx >= iNum, "Invalid parameters");
+  CHECK_VTM(iIdx < 0 || iNum < 0 || iIdx >= iNum, "Invalid parameters");
 
   if (iNum == 1)
   {
@@ -3180,7 +3207,7 @@ void InterSearch::xCheckBestMVP ( RefPicList eRefPicList, Mv cMv, Mv& rcMvPred,
 
   AMVPInfo* pcAMVPInfo = &amvpInfo;
 
-  CHECK(pcAMVPInfo->mvCand[riMVPIdx] != rcMvPred, "Invalid MV prediction candidate");
+  CHECK_VTM(pcAMVPInfo->mvCand[riMVPIdx] != rcMvPred, "Invalid MV prediction candidate");
 
   if (pcAMVPInfo->numCand < 2)
   {
@@ -3305,7 +3332,7 @@ void InterSearch::xMotionEstimation(PredictionUnit& pu, PelUnitBuf& origBuf, Ref
 
   Mv cMvHalf, cMvQter;
 
-  CHECK(eRefPicList >= MAX_NUM_REF_LIST_ADAPT_SR || iRefIdxPred>=int(MAX_IDX_ADAPT_SR), "Invalid reference picture list");
+  CHECK_VTM(eRefPicList >= MAX_NUM_REF_LIST_ADAPT_SR || iRefIdxPred>=int(MAX_IDX_ADAPT_SR), "Invalid reference picture list");
   m_iSearchRange = m_aaiAdaptSR[eRefPicList][iRefIdxPred];
 
   int    iSrchRng   = (bBi ? m_bipredSearchRange : m_iSearchRange);
@@ -4171,9 +4198,8 @@ void InterSearch::xTZSearchSelective( const PredictionUnit& pu,
 
 void InterSearch::xPatternSearchIntRefine(PredictionUnit& pu, IntTZSearchStruct&  cStruct, Mv& rcMv, Mv& rcMvPred, int& riMVPIdx, uint32_t& ruiBits, Distortion& ruiCost, const AMVPInfo& amvpInfo, double fWeight)
 {
-
-  CHECK( pu.cu->imv == 0 || pu.cu->imv == IMV_HPEL , "xPatternSearchIntRefine(): Sub-pel MV used.");
-  CHECK( amvpInfo.mvCand[riMVPIdx] != rcMvPred, "xPatternSearchIntRefine(): MvPred issue.");
+  CHECK_VTM( pu.cu->imv == 0 || pu.cu->imv == IMV_HPEL , "xPatternSearchIntRefine(): Sub-pel MV used.");
+  CHECK_VTM( amvpInfo.mvCand[riMVPIdx] != rcMvPred, "xPatternSearchIntRefine(): MvPred issue.");
 
   const SPS &sps = *pu.cs->sps;
   m_pcRdCost->setDistParam(m_cDistParam, *cStruct.pcPatternKey, cStruct.piRefY, cStruct.iRefStride, m_lumaClpRng.bd, COMPONENT_Y, 0, 1, m_pcEncCfg->getUseHADME() && !pu.cs->slice->getDisableSATDForRD());
@@ -4195,8 +4221,8 @@ void InterSearch::xPatternSearchIntRefine(PredictionUnit& pu, IntTZSearchStruct&
 
   cBaseMvd[0] = (rcMv - amvpInfo.mvCand[0]);
   cBaseMvd[1] = (rcMv - amvpInfo.mvCand[1]);
-  CHECK( (cBaseMvd[0].getHor() & 0x03) != 0 || (cBaseMvd[0].getVer() & 0x03) != 0 , "xPatternSearchIntRefine(): AMVP cand 0 Mvd issue.");
-  CHECK( (cBaseMvd[1].getHor() & 0x03) != 0 || (cBaseMvd[1].getVer() & 0x03) != 0 , "xPatternSearchIntRefine(): AMVP cand 1 Mvd issue.");
+  CHECK_VTM( (cBaseMvd[0].getHor() & 0x03) != 0 || (cBaseMvd[0].getVer() & 0x03) != 0 , "xPatternSearchIntRefine(): AMVP cand 0 Mvd issue.");
+  CHECK_VTM( (cBaseMvd[1].getHor() & 0x03) != 0 || (cBaseMvd[1].getVer() & 0x03) != 0 , "xPatternSearchIntRefine(): AMVP cand 1 Mvd issue.");
 
   cBaseMvd[0].roundTransPrecInternal2Amvr(pu.cu->imv);
   cBaseMvd[1].roundTransPrecInternal2Amvr(pu.cu->imv);
@@ -5122,8 +5148,8 @@ void InterSearch::xPredAffineInterSearch( PredictionUnit&       pu,
   uiCost[1]  = costValidList1;
   if (pu.cs->pps->getWPBiPred() == true && tryBipred && (bcwIdx != BCW_DEFAULT))
   {
-    CHECK(iRefIdxBi[0]<0, "Invalid picture reference index");
-    CHECK(iRefIdxBi[1]<0, "Invalid picture reference index");
+    CHECK_VTM(iRefIdxBi[0]<0, "Invalid picture reference index");
+    CHECK_VTM(iRefIdxBi[1]<0, "Invalid picture reference index");
     wp0 = pu.cs->slice->getWpScaling(REF_PIC_LIST_0, iRefIdxBi[0]);
     wp1 = pu.cs->slice->getWpScaling(REF_PIC_LIST_1, iRefIdxBi[1]);
 
@@ -5788,7 +5814,7 @@ void InterSearch::xEstimateAffineAMVP( PredictionUnit&  pu,
 
   // Fill the MV Candidates
   PU::fillAffineMvpCand( pu, eRefPicList, iRefIdx, affineAMVPInfo );
-  CHECK( affineAMVPInfo.numCand == 0, "Assertion failed." );
+  CHECK_VTM( affineAMVPInfo.numCand == 0, "Assertion failed." );
 
   PelUnitBuf predBuf = m_tmpStorageLCU.getBuf( UnitAreaRelative(*pu.cu, pu) );
 
@@ -6110,18 +6136,18 @@ void InterSearch::xEncodeInterResidualQT(CodingStructure &cs, Partitioner &parti
   {
     if( partitioner.canSplit( TU_MAX_TR_SPLIT, cs ) )
     {
-      CHECK( !bSubdiv, "Not performing the implicit TU split" );
+      CHECK_VTM( !bSubdiv, "Not performing the implicit TU split" );
     }
     else if( cu.sbtInfo && partitioner.canSplit( PartSplit( cu.getSbtTuSplit() ), cs ) )
     {
-      CHECK( !bSubdiv, "Not performing the implicit TU split - sbt" );
+      CHECK_VTM( !bSubdiv, "Not performing the implicit TU split - sbt" );
     }
     else
     {
-      CHECK( bSubdiv, "transformsplit not supported" );
+      CHECK_VTM( bSubdiv, "transformsplit not supported" );
     }
 
-    CHECK(CU::isIntra(cu), "Inter search provided with intra CU");
+    CHECK_VTM(CU::isIntra(cu), "Inter search provided with intra CU");
 
     if( cu.chromaFormat != CHROMA_400
       && (!cu.isSepTree() || isChroma(partitioner.chType))
@@ -6799,7 +6825,7 @@ void InterSearch::xEstimateInterResidualQT(CodingStructure &cs, Partitioner &par
           }
           if( tu.noResidual )
           {
-            CHECK( currCompFracBits > 0 || currAbsSum, "currCompFracBits > 0 when tu noResidual" );
+            CHECK_VTM( currCompFracBits > 0 || currAbsSum, "currCompFracBits > 0 when tu noResidual" );
           }
       }
 
@@ -7120,7 +7146,7 @@ void InterSearch::xEstimateInterResidualQT(CodingStructure &cs, Partitioner &par
     }
     if( tu.noResidual )
     {
-      CHECK( m_CABACEstimator->getEstFracBits() > 0, "no residual TU's bits shall be 0" );
+      CHECK_VTM( m_CABACEstimator->getEstFracBits() > 0, "no residual TU's bits shall be 0" );
     }
     if (colorTransFlag)
     {
@@ -7251,7 +7277,7 @@ void InterSearch::encodeResAndCalcRdInterCU(CodingStructure &cs, Partitioner &pa
 
   CodingUnit &cu = *cs.getCU( partitioner.chType );
   if( cu.predMode == MODE_INTER )
-    CHECK( cu.isSepTree(), "CU with Inter mode must be in single tree" );
+    CHECK_VTM( cu.isSepTree(), "CU with Inter mode must be in single tree" );
 
   const ChromaFormat format     = cs.area.chromaFormat;;
   const int  numValidComponents = getNumberValidComponents(format);
@@ -7260,8 +7286,8 @@ void InterSearch::encodeResAndCalcRdInterCU(CodingStructure &cs, Partitioner &pa
   bool colorTransAllowed = cs.slice->getSPS()->getUseColorTrans() && luma && chroma;
   if (cs.slice->getSPS()->getUseColorTrans())
   {
-    CHECK(cu.treeType != TREE_D || partitioner.treeType != TREE_D, "localtree should not be applied when adaptive color transform is enabled");
-    CHECK(cu.modeType != MODE_TYPE_ALL || partitioner.modeType != MODE_TYPE_ALL, "localtree should not be applied when adaptive color transform is enabled");
+    CHECK_VTM(cu.treeType != TREE_D || partitioner.treeType != TREE_D, "localtree should not be applied when adaptive color transform is enabled");
+    CHECK_VTM(cu.modeType != MODE_TYPE_ALL || partitioner.modeType != MODE_TYPE_ALL, "localtree should not be applied when adaptive color transform is enabled");
   }
 
   if( skipResidual ) //  No residual coding : SKIP mode
@@ -7269,7 +7295,7 @@ void InterSearch::encodeResAndCalcRdInterCU(CodingStructure &cs, Partitioner &pa
     cu.skip    = true;
     cu.rootCbf = false;
     cu.colorTransform = false;
-    CHECK( cu.sbtInfo != 0, "sbtInfo shall be 0 if CU has no residual" );
+    CHECK_VTM( cu.sbtInfo != 0, "sbtInfo shall be 0 if CU has no residual" );
     cs.getResiBuf().fill(0);
     {
       cs.getRecoBuf().copyFrom(cs.getPredBuf() );
@@ -7404,7 +7430,7 @@ void InterSearch::encodeResAndCalcRdInterCU(CodingStructure &cs, Partitioner &pa
     {
       if (colorSpaceOption)
       {
-        CHECK(colorSpaceOption > 2 || colorSpaceOption < 0, "invalid color space selection option");
+        CHECK_VTM(colorSpaceOption > 2 || colorSpaceOption < 0, "invalid color space selection option");
         if (colorSpaceOption == 1 && iter)
         {
           continue;
@@ -7661,7 +7687,7 @@ void InterSearch::encodeResAndCalcRdInterCU(CodingStructure &cs, Partitioner &pa
     }
   }
 
-  CHECK(cs.tus.size() == 0, "No TUs present");
+  CHECK_VTM(cs.tus.size() == 0, "No TUs present");
 }
 
 uint64_t InterSearch::xGetSymbolFracBitsInter(CodingStructure &cs, Partitioner &partitioner)
@@ -7674,7 +7700,7 @@ uint64_t InterSearch::xGetSymbolFracBitsInter(CodingStructure &cs, Partitioner &
   if( cu.firstPU->mergeFlag && !cu.rootCbf )
   {
     cu.skip = true;
-    CHECK(cu.colorTransform, "ACT should not be enabled for skip mode");
+    CHECK_VTM(cu.colorTransform, "ACT should not be enabled for skip mode");
     m_CABACEstimator->cu_skip_flag  ( cu );
     if (cu.firstPU->ciipFlag)
     {
@@ -7688,7 +7714,7 @@ uint64_t InterSearch::xGetSymbolFracBitsInter(CodingStructure &cs, Partitioner &
   }
   else
   {
-    CHECK( cu.skip, "Skip flag has to be off at this point!" );
+    CHECK_VTM( cu.skip, "Skip flag has to be off at this point!" );
 
     if (cu.Y().valid())
     m_CABACEstimator->cu_skip_flag( cu );
@@ -7821,7 +7847,7 @@ uint32_t InterSearch::xDetermineBestMvp( PredictionUnit& pu, Mv acMvTemp[3], int
       mvpUpdated = true;
     }
   }
-  CHECK( !mvpUpdated, "xDetermineBestMvp() error" );
+  CHECK_VTM( !mvpUpdated, "xDetermineBestMvp() error" );
   return minBits;
 }
 
diff --git a/source/Lib/EncoderLib/InterSearch.h b/source/Lib/EncoderLib/InterSearch.h
index 5e9df41..f95837e 100644
--- a/source/Lib/EncoderLib/InterSearch.h
+++ b/source/Lib/EncoderLib/InterSearch.h
@@ -363,10 +363,11 @@ public:
 
   void setModeCtrl( EncModeCtrl *modeCtrl ) { m_modeCtrl = modeCtrl;}
 
-  void predInterSearch(CodingUnit& cu, Partitioner& partitioner );
+  void predInterSearch(CodingUnit& cu, Partitioner& partitioner, Mv* mvUni = nullptr, int * pocRef = nullptr, unsigned long * costRef = nullptr, RefPicList * refPicList = nullptr, int * pocRefIdx= nullptr);
 
   /// set ME search range
-  void setAdaptiveSearchRange       ( int iDir, int iRefIdx, int iSearchRange) { CHECK(iDir >= MAX_NUM_REF_LIST_ADAPT_SR || iRefIdx>=int(MAX_IDX_ADAPT_SR), "Invalid index"); m_aaiAdaptSR[iDir][iRefIdx] = iSearchRange; }
+  void setAdaptiveSearchRange       ( int iDir, int iRefIdx, int iSearchRange) {
+    CHECK_VTM(iDir >= MAX_NUM_REF_LIST_ADAPT_SR || iRefIdx>=int(MAX_IDX_ADAPT_SR), "Invalid index"); m_aaiAdaptSR[iDir][iRefIdx] = iSearchRange; }
   bool  predIBCSearch           ( CodingUnit& cu, Partitioner& partitioner, const int localSearchRangeX, const int localSearchRangeY, IbcHashMap& ibcHashMap);
   void  xIntraPatternSearch         ( PredictionUnit& pu, IntTZSearchStruct&  cStruct, Mv& rcMv, Distortion&  ruiCost, Mv* cMvSrchRngLT, Mv* cMvSrchRngRB, Mv* pcMvPred);
   void  xSetIntraSearchRange        ( PredictionUnit& pu, int iRoiWidth, int iRoiHeight, const int localSearchRangeX, const int localSearchRangeY, Mv& rcMvSrchRngLT, Mv& rcMvSrchRngRB);
diff --git a/source/Lib/EncoderLib/IntraSearch.cpp b/source/Lib/EncoderLib/IntraSearch.cpp
index 063ef8b..b2d81b7 100644
--- a/source/Lib/EncoderLib/IntraSearch.cpp
+++ b/source/Lib/EncoderLib/IntraSearch.cpp
@@ -84,7 +84,7 @@ IntraSearch::IntraSearch()
 
 void IntraSearch::destroy()
 {
-  CHECK( !m_isInitialized, "Not initialized" );
+  CHECK_VTM( !m_isInitialized, "Not initialized" );
 
   if( m_pcEncCfg )
   {
@@ -221,7 +221,7 @@ void IntraSearch::init( EncCfg*        pcEncCfg,
                        , const unsigned bitDepthY
 )
 {
-  CHECK(m_isInitialized, "Already initialized");
+  CHECK_VTM(m_isInitialized, "Already initialized");
   m_pcEncCfg                     = pcEncCfg;
   m_pcTrQuant                    = pcTrQuant;
   m_pcRdCost                     = pcRdCost;
@@ -386,7 +386,7 @@ bool IntraSearch::estIntraPredLumaQT(CodingUnit &cu, Partitioner &partitioner, c
   const TempCtx ctxStartIntraMode(m_CtxCache, SubCtx(Ctx::IntraLumaMpmFlag, m_CABACEstimator->getCtx()));
   const TempCtx ctxStartMrlIdx      ( m_CtxCache, SubCtx( Ctx::MultiRefLineIdx,        m_CABACEstimator->getCtx() ) );
 
-  CHECK( !cu.firstPU, "CU has no PUs" );
+  CHECK_VTM( !cu.firstPU, "CU has no PUs" );
   // variables for saving fast intra modes scan results across multiple LFNST passes
   bool LFNSTLoadFlag = sps.getUseLFNST() && cu.lfnstIdx != 0;
   bool LFNSTSaveFlag = sps.getUseLFNST() && cu.lfnstIdx == 0;
@@ -458,7 +458,7 @@ bool IntraSearch::estIntraPredLumaQT(CodingUnit &cu, Partitioner &partitioner, c
     CandCostList.clear();
     uiHadModeList.clear();
 
-    CHECK(pu.cu != &cu, "PU is not contained in the CU");
+    CHECK_VTM(pu.cu != &cu, "PU is not contained in the CU");
 
     //===== determine set of modes to be tested (using prediction signal only) =====
     int numModesAvailable = NUM_LUMA_MODE; // total number of Intra modes
@@ -496,14 +496,14 @@ bool IntraSearch::estIntraPredLumaQT(CodingUnit &cu, Partitioner &partitioner, c
       if (mtsUsageFlag != 2)
       {
         // this should always be true
-        CHECK(!pu.Y().valid(), "PU is not valid");
+        CHECK_VTM(!pu.Y().valid(), "PU is not valid");
         bool isFirstLineOfCtu     = (((pu.block(COMPONENT_Y).y) & ((pu.cs->sps)->getMaxCUWidth() - 1)) == 0);
         int  numOfPassesExtendRef = ((!sps.getUseMRL() || isFirstLineOfCtu) ? 1 : MRL_NUM_REF_LINES);
         pu.multiRefIdx            = 0;
 
         if (numModesForFullRD != numModesAvailable)
         {
-          CHECK(numModesForFullRD >= numModesAvailable, "Too many modes for full RD search");
+          CHECK_VTM(numModesForFullRD >= numModesAvailable, "Too many modes for full RD search");
 
           const CompArea &area = pu.Y();
 
@@ -899,7 +899,7 @@ bool IntraSearch::estIntraPredLumaQT(CodingUnit &cu, Partitioner &partitioner, c
         }
       }
 
-      CHECK(numModesForFullRD != uiRdModeList.size(), "Inconsistent state!");
+      CHECK_VTM(numModesForFullRD != uiRdModeList.size(), "Inconsistent state!");
 
       // after this point, don't use numModesForFullRD
 
@@ -1044,11 +1044,11 @@ bool IntraSearch::estIntraPredLumaQT(CodingUnit &cu, Partitioner &partitioner, c
       pu.multiRefIdx                 = uiOrgMode.mRefId;
       pu.intraDir[CHANNEL_TYPE_LUMA] = uiOrgMode.modeId;
 
-      CHECK(cu.mipFlag && pu.multiRefIdx, "Error: combination of MIP and MRL not supported");
-      CHECK(pu.multiRefIdx && (pu.intraDir[0] == PLANAR_IDX), "Error: combination of MRL and Planar mode not supported");
-      CHECK(cu.ispMode && cu.mipFlag, "Error: combination of ISP and MIP not supported");
-      CHECK(cu.ispMode && pu.multiRefIdx, "Error: combination of ISP and MRL not supported");
-      CHECK(cu.ispMode&& cu.colorTransform, "Error: combination of ISP and ACT not supported");
+      CHECK_VTM(cu.mipFlag && pu.multiRefIdx, "Error: combination of MIP and MRL not supported");
+      CHECK_VTM(pu.multiRefIdx && (pu.intraDir[0] == PLANAR_IDX), "Error: combination of MRL and Planar mode not supported");
+      CHECK_VTM(cu.ispMode && cu.mipFlag, "Error: combination of ISP and MIP not supported");
+      CHECK_VTM(cu.ispMode && pu.multiRefIdx, "Error: combination of ISP and MRL not supported");
+      CHECK_VTM(cu.ispMode&& cu.colorTransform, "Error: combination of ISP and ACT not supported");
 
       pu.intraDir[CHANNEL_TYPE_CHROMA] = cu.colorTransform ? DM_CHROMA_IDX : pu.intraDir[CHANNEL_TYPE_CHROMA];
 
@@ -1209,7 +1209,7 @@ bool IntraSearch::estIntraPredLumaQT(CodingUnit &cu, Partitioner &partitioner, c
       cu.bdpcmMode = bestBDPCMMode;
       if (cu.colorTransform)
       {
-        CHECK(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "chroma should use DM mode for adaptive color transform");
+        CHECK_VTM(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "chroma should use DM mode for adaptive color transform");
       }
     }
   }
@@ -1232,7 +1232,7 @@ void IntraSearch::estIntraPredChromaQT( CodingUnit &cu, Partitioner &partitioner
   double    bestCostSoFar = maxCostAllowed;
   bool      lumaUsesISP   = !cu.isSepTree() && cu.ispMode;
   PartSplit ispType       = lumaUsesISP ? CU::getISPType( cu, COMPONENT_Y ) : TU_NO_ISP;
-  CHECK( cu.ispMode && bestCostSoFar < 0, "bestCostSoFar must be positive!" );
+  CHECK_VTM( cu.ispMode && bestCostSoFar < 0, "bestCostSoFar must be positive!" );
 
   auto &pu = *cu.firstPU;
 
@@ -2769,11 +2769,11 @@ void IntraSearch::xEncSubdivCbfQT( CodingStructure &cs, Partitioner &partitioner
 
   if( partitioner.canSplit( TU_MAX_TR_SPLIT, cs ) )
   {
-    CHECK( !subdiv, "TU split implied" );
+    CHECK_VTM( !subdiv, "TU split implied" );
   }
   else
   {
-    CHECK( subdiv && !currCU.ispMode && isLuma( compID ), "No TU subdivision is allowed with QTBT" );
+    CHECK_VTM( subdiv && !currCU.ispMode && isLuma( compID ), "No TU subdivision is allowed with QTBT" );
   }
 
   if (bChroma)
@@ -2953,7 +2953,7 @@ uint64_t IntraSearch::xGetIntraFracBitsQTSingleChromaComponent( CodingStructure
     m_CABACEstimator->intra_chroma_pred_mode( pu );
     //xEncIntraHeader(cs, partitioner, false, true);
   }
-  CHECK( partitioner.currTrDepth != 1, "error in the depth!" );
+  CHECK_VTM( partitioner.currTrDepth != 1, "error in the depth!" );
   const UnitArea &currArea = partitioner.currArea();
 
   TransformUnit &currTU = *cs.getTU( currArea.blocks[partitioner.chType], partitioner.chType );
@@ -3045,7 +3045,7 @@ void IntraSearch::xIntraCodingTUBlock(TransformUnit &tu, const ComponentID &comp
   const uint32_t           uiChFinalMode        = PU::getFinalIntraMode(pu, chType);
 
   //===== init availability pattern =====
-  CHECK( tu.jointCbCr && compID == COMPONENT_Cr, "wrong combination of compID and jointCbCr" );
+  CHECK_VTM( tu.jointCbCr && compID == COMPONENT_Cr, "wrong combination of compID and jointCbCr" );
   bool jointCbCr = tu.jointCbCr && compID == COMPONENT_Cb;
 
   if (compID == COMPONENT_Y)
@@ -3356,7 +3356,7 @@ void IntraSearch::xIntraCodingACTTUBlock(TransformUnit &tu, const ComponentID &c
 {
   if (!tu.blocks[compID].valid())
   {
-    CHECK(1, "tu does not exist");
+    CHECK_VTM(1, "tu does not exist");
   }
 
   CodingStructure     &cs = *tu.cs;
@@ -3371,7 +3371,7 @@ void IntraSearch::xIntraCodingACTTUBlock(TransformUnit &tu, const ComponentID &c
   PelBuf              crResi = cs.getResiBuf(crArea);
   TCoeff              uiAbsSum = 0;
 
-  CHECK(tu.jointCbCr && compID == COMPONENT_Cr, "wrong combination of compID and jointCbCr");
+  CHECK_VTM(tu.jointCbCr && compID == COMPONENT_Cr, "wrong combination of compID and jointCbCr");
   bool jointCbCr = tu.jointCbCr && compID == COMPONENT_Cb;
 
   m_pcRdCost->setChromaFormat(cs.sps->getChromaFormatIdc());
@@ -3694,7 +3694,7 @@ bool IntraSearch::xRecurIntraCodingLumaQT( CodingStructure &cs, Partitioner &par
       if (m_pcEncCfg->getCostMode() == COST_LOSSLESS_CODING && slice.isLossless())
       {
         nNumTransformCands = 1;
-        CHECK(!tsAllowed && !cu.bdpcmMode, "transform skip should be enabled for LS");
+        CHECK_VTM(!tsAllowed && !cu.bdpcmMode, "transform skip should be enabled for LS");
         if (cu.bdpcmMode)
         {
           trModes.push_back(TrMode(0, true));
@@ -3721,7 +3721,7 @@ bool IntraSearch::xRecurIntraCodingLumaQT( CodingStructure &cs, Partitioner &par
       }
     }
 
-    CHECK( !tu.Y().valid(), "Invalid TU" );
+    CHECK_VTM( !tu.Y().valid(), "Invalid TU" );
 
     CodingStructure &saveCS = *m_pSaveCS[0];
 
@@ -4172,10 +4172,10 @@ bool IntraSearch::xRecurIntraCodingACTQT(CodingStructure &cs, Partitioner &parti
     tu.depth = currDepth;
     const CodingUnit     &cu = *csFull->getCU(tu.Y().pos(), CHANNEL_TYPE_LUMA);
     const PredictionUnit &pu = *csFull->getPU(tu.Y().pos(), CHANNEL_TYPE_LUMA);
-    CHECK(!tu.Y().valid() || !tu.Cb().valid() || !tu.Cr().valid(), "Invalid TU");
-    CHECK(tu.cu != &cu, "wrong CU fetch");
-    CHECK(cu.ispMode, "adaptive color transform cannot be applied to ISP");
-    CHECK(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "chroma should use DM mode for adaptive color transform");
+    CHECK_VTM(!tu.Y().valid() || !tu.Cb().valid() || !tu.Cr().valid(), "Invalid TU");
+    CHECK_VTM(tu.cu != &cu, "wrong CU fetch");
+    CHECK_VTM(cu.ispMode, "adaptive color transform cannot be applied to ISP");
+    CHECK_VTM(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "chroma should use DM mode for adaptive color transform");
 
     // 1. intra prediction and forward color transform
 
@@ -4264,7 +4264,7 @@ bool IntraSearch::xRecurIntraCodingACTQT(CodingStructure &cs, Partitioner &parti
       if (m_pcEncCfg->getCostMode() == COST_LOSSLESS_CODING && slice.isLossless())
       {
         nNumTransformCands = 1;
-        CHECK(!tsAllowed && !cu.bdpcmMode, "transform skip should be enabled for LS");
+        CHECK_VTM(!tsAllowed && !cu.bdpcmMode, "transform skip should be enabled for LS");
         if (cu.bdpcmMode)
         {
           trModes.push_back(TrMode(0, true));
@@ -4501,7 +4501,7 @@ bool IntraSearch::xRecurIntraCodingACTQT(CodingStructure &cs, Partitioner &parti
     }
     else
     {
-      CHECK(!validReturnFull, "no transform mode was tested for luma");
+      CHECK_VTM(!validReturnFull, "no transform mode was tested for luma");
     }
 
     csFull->setDecomp(currArea.Y(), true);
@@ -4551,7 +4551,7 @@ bool IntraSearch::xRecurIntraCodingACTQT(CodingStructure &cs, Partitioner &parti
       if (m_pcEncCfg->getCostMode() == COST_LOSSLESS_CODING && slice.isLossless())
       {
         numTransformCands = 1;
-        CHECK(!tsAllowed && !cu.bdpcmModeChroma, "transform skip should be enabled for LS");
+        CHECK_VTM(!tsAllowed && !cu.bdpcmModeChroma, "transform skip should be enabled for LS");
         if (cu.bdpcmModeChroma)
         {
           trModes.push_back(TrMode(0, true));
@@ -4877,7 +4877,7 @@ bool IntraSearch::xRecurIntraCodingACTQT(CodingStructure &cs, Partitioner &parti
       }
       else
       {
-        CHECK(!tmpValidReturnSplit, "invalid RD of sub-TU partitions for ACT");
+        CHECK_VTM(!tmpValidReturnSplit, "invalid RD of sub-TU partitions for ACT");
       }
     } while (partitioner.nextPart(*csSplit));
 
@@ -4921,7 +4921,7 @@ bool IntraSearch::xRecurIntraCodingACTQT(CodingStructure &cs, Partitioner &parti
     }
     else
     {
-      CHECK(!validReturnFull && !validReturnSplit, "illegal TU optimization");
+      CHECK_VTM(!validReturnFull && !validReturnSplit, "illegal TU optimization");
       retVal = true;
     }
   }
@@ -5065,7 +5065,7 @@ ChromaCbfs IntraSearch::xRecurIntraChromaCodingQT( CodingStructure &cs, Partitio
       if (m_pcEncCfg->getCostMode() == COST_LOSSLESS_CODING && slice.isLossless())
       {
         nNumTransformCands = 1;
-        CHECK(!tsAllowed && !currTU.cu->bdpcmModeChroma, "transform skip should be enabled for LS");
+        CHECK_VTM(!tsAllowed && !currTU.cu->bdpcmModeChroma, "transform skip should be enabled for LS");
         if (currTU.cu->bdpcmModeChroma)
         {
           trModes.push_back(TrMode(0, true));
@@ -5084,7 +5084,7 @@ ChromaCbfs IntraSearch::xRecurIntraChromaCodingQT( CodingStructure &cs, Partitio
           trModes.push_back(TrMode(1, true));   // TS
         }
       }
-      CHECK(!currTU.Cb().valid(), "Invalid TU");
+      CHECK_VTM(!currTU.Cb().valid(), "Invalid TU");
 
       const int  totalModesToTest            = nNumTransformCands;
       bool cbfDCT2 = true;
@@ -5249,7 +5249,7 @@ ChromaCbfs IntraSearch::xRecurIntraChromaCodingQT( CodingStructure &cs, Partitio
 
       if (jointCbfMasksToTest.size() && currTU.cu->bdpcmModeChroma)
       {
-        CHECK(!checkTSOnly || checkDCTOnly, "bdpcm only allows transform skip");
+        CHECK_VTM(!checkTSOnly || checkDCTOnly, "bdpcm only allows transform skip");
       }
       for( int cbfMask : jointCbfMasksToTest )
       {
@@ -5506,7 +5506,7 @@ void IntraSearch::sortRdModeListFirstColorSpace(ModeInfo mode, double cost, char
     candNum++;
   }
 
-  CHECK(candNum > FAST_UDI_MAX_RDMODE_NUM, "exceed intra mode candidate list capacity");
+  CHECK_VTM(candNum > FAST_UDI_MAX_RDMODE_NUM, "exceed intra mode candidate list capacity");
 
   return;
 }
@@ -5646,7 +5646,7 @@ void IntraSearch::xGetNextISPMode(ModeInfo& modeInfo, const ModeInfo* lastMode,
   {
     int firstModeThisSplit = ispTestedModes.getTestedIntraMode(nextISPcandSplitType, 0);
     int numSubPartsFirstModeThisSplit = ispTestedModes.getNumCompletedSubParts(nextISPcandSplitType, firstModeThisSplit);
-    CHECK(numSubPartsFirstModeThisSplit < 0, "wrong number of subpartitions!");
+    CHECK_VTM(numSubPartsFirstModeThisSplit < 0, "wrong number of subpartitions!");
     bool stopThisSplit = false;
     bool stopThisSplitAllLfnsts = false;
     if (numSubPartsFirstModeThisSplit < maxNumSubPartitions)
@@ -5790,9 +5790,9 @@ void IntraSearch::xGetNextISPMode(ModeInfo& modeInfo, const ModeInfo* lastMode,
 
       if (refLfnstIdx != -1 && refLfnstIdx != curIspLfnstIdx)
       {
-        CHECK(leftIntraMode != candidate.modeId || rightIntraMode != candidate.modeId, "wrong intra mode and lfnstIdx values!");
+        CHECK_VTM(leftIntraMode != candidate.modeId || rightIntraMode != candidate.modeId, "wrong intra mode and lfnstIdx values!");
         numSubPartsRefMode = m_ispTestedModes[refLfnstIdx].getNumCompletedSubParts((ISPType)candidate.ispMod, candidate.modeId);
-        CHECK(numSubPartsRefMode <= 0, "Wrong value of the number of subpartitions completed!");
+        CHECK_VTM(numSubPartsRefMode <= 0, "Wrong value of the number of subpartitions completed!");
       }
       else
       {
diff --git a/source/Lib/EncoderLib/IntraSearch.h b/source/Lib/EncoderLib/IntraSearch.h
index f911e0f..6f5587c 100644
--- a/source/Lib/EncoderLib/IntraSearch.h
+++ b/source/Lib/EncoderLib/IntraSearch.h
@@ -290,8 +290,8 @@ private:
     int getNumCompletedSubParts(ISPType splitType, int iModeIdx)
     {
       const unsigned st = splitType - 1;
-      CHECK(st < 0 || st > 1, "The split type is invalid!");
-      CHECK(iModeIdx < 0 || iModeIdx >(NUM_LUMA_MODE - 1), "The modeIdx is invalid");
+      CHECK_VTM(st < 0 || st > 1, "The split type is invalid!");
+      CHECK_VTM(iModeIdx < 0 || iModeIdx >(NUM_LUMA_MODE - 1), "The modeIdx is invalid");
       return modeHasBeenTested[iModeIdx][st] ? intraMode[iModeIdx][st].numCompSubParts : -1;
     }
 
diff --git a/source/Lib/EncoderLib/NALwrite.cpp b/source/Lib/EncoderLib/NALwrite.cpp
index 49cc9aa..0a12912 100644
--- a/source/Lib/EncoderLib/NALwrite.cpp
+++ b/source/Lib/EncoderLib/NALwrite.cpp
@@ -53,7 +53,7 @@ OutputBitstream bsNALUHeader;
   bsNALUHeader.write(forbiddenZero, 1);   // forbidden_zero_bit
   int nuhReservedZeroBit = 0;
   bsNALUHeader.write(nuhReservedZeroBit, 1);   // nuh_reserved_zero_bit
-  CHECK(nalu.m_nuhLayerId > 55, "The value of nuh_layer_id shall be in the range of 0 to 55, inclusive");
+  CHECK_VTM(nalu.m_nuhLayerId > 55, "The value of nuh_layer_id shall be in the range of 0 to 55, inclusive");
   bsNALUHeader.write(nalu.m_nuhLayerId, 6);       // nuh_layer_id
   bsNALUHeader.write(nalu.m_nalUnitType, 5);      // nal_unit_type
   bsNALUHeader.write(nalu.m_temporalId + 1, 3);   // nuh_temporal_id_plus1
diff --git a/source/Lib/EncoderLib/PartitionPrediction.cpp b/source/Lib/EncoderLib/PartitionPrediction.cpp
index 265a730..553e1be 100644
--- a/source/Lib/EncoderLib/PartitionPrediction.cpp
+++ b/source/Lib/EncoderLib/PartitionPrediction.cpp
@@ -74,12 +74,12 @@ PartitionPrediction::~PartitionPrediction(){
   //free(this->model);
 }
 
-void PartitionPrediction::initializeModels(std::string mode){
+void PartitionPrediction::initializeModels(std::string mode, std::string modelFolder){
   for (int i = 0; i < partsize_list.size(); ++i) {
     //load model file
     std::ifstream model_file ;
 //    std::string filename = "MODEL_DIRECTORY_HERE/ML_model/"+mode+"/lgbm_"+std::to_string(partsize_list[i].first)+"x"+std::to_string(partsize_list[i].second)+".txt";
-    std::string filename = "/home/sbelhadj/workspaces/cworkspace/intra_models/nonfiltered/ML_model/"+mode+"/lgbm_"+std::to_string(partsize_list[i].first)+"x"+std::to_string(partsize_list[i].second)+".txt";
+    std::string filename = modelFolder+"/ML_model/"+mode+"/lgbm_"+std::to_string(partsize_list[i].first)+"x"+std::to_string(partsize_list[i].second)+".txt";
 
     const char * charFilename = filename.c_str();
     model_file.open(filename, std::ifstream::in) ;
diff --git a/source/Lib/EncoderLib/PartitionPrediction.h b/source/Lib/EncoderLib/PartitionPrediction.h
index e5ad767..6447741 100644
--- a/source/Lib/EncoderLib/PartitionPrediction.h
+++ b/source/Lib/EncoderLib/PartitionPrediction.h
@@ -20,7 +20,7 @@ public:
     PartitionPrediction(std::string model_str, int qp, bool intra);
     ~PartitionPrediction();
 
-    void initializeModels(std::string mode);
+    void initializeModels(std::string mode, std::string modelFolder);
     void predict_once(double* input, double* output, partsize size);
     void predict_once_inter(double* input, double* output, partsize size);
 
diff --git a/source/Lib/EncoderLib/RateCtrl.cpp b/source/Lib/EncoderLib/RateCtrl.cpp
index 878aa62..01e260f 100644
--- a/source/Lib/EncoderLib/RateCtrl.cpp
+++ b/source/Lib/EncoderLib/RateCtrl.cpp
@@ -216,7 +216,7 @@ void EncRCSeq::initGOPID2Level( int GOPID2Level[] )
 
 void EncRCSeq::initPicPara( TRCParameter* picPara )
 {
-  CHECK( m_picPara == NULL, "Object does not exist" );
+  CHECK_VTM( m_picPara == NULL, "Object does not exist" );
 
   if ( picPara == NULL )
   {
diff --git a/source/Lib/EncoderLib/RateCtrl.h b/source/Lib/EncoderLib/RateCtrl.h
index 078c271..d1bb389 100644
--- a/source/Lib/EncoderLib/RateCtrl.h
+++ b/source/Lib/EncoderLib/RateCtrl.h
@@ -123,23 +123,32 @@ public:
   int  getLCUHeight()                   { return m_LCUHeight; }
   int  getNumberOfLevel()               { return m_numberOfLevel; }
   int  getAverageBits()                 { return m_averageBits; }
-  int  getLeftAverageBits()             { CHECK(!( m_framesLeft > 0 ), "No frames left"); return (int)(m_bitsLeft / m_framesLeft); }
+  int  getLeftAverageBits()             {
+    CHECK_VTM(!( m_framesLeft > 0 ), "No frames left"); return (int)(m_bitsLeft / m_framesLeft); }
   bool getUseLCUSeparateModel()         { return m_useLCUSeparateModel; }
 
   int  getNumPixel()                    { return m_numberOfPixel; }
   int64_t  getTargetBits()                { return m_targetBits; }
   int  getNumberOfLCU()                 { return m_numberOfLCU; }
   int* getBitRatio()                    { return m_bitsRatio; }
-  int  getBitRatio( int idx )           { CHECK(!( idx<m_GOPSize), "Idx exceeds GOP size"); return m_bitsRatio[idx]; }
+  int  getBitRatio( int idx )           {
+    CHECK_VTM(!( idx<m_GOPSize), "Idx exceeds GOP size"); return m_bitsRatio[idx]; }
   int* getGOPID2Level()                 { return m_GOPID2Level; }
-  int  getGOPID2Level( int ID )         { CHECK(!( ID < m_GOPSize ), "Idx exceeds GOP size"); return m_GOPID2Level[ID]; }
+  int  getGOPID2Level( int ID )         {
+    CHECK_VTM(!( ID < m_GOPSize ), "Idx exceeds GOP size"); return m_GOPID2Level[ID]; }
   TRCParameter*  getPicPara()                                   { return m_picPara; }
-  TRCParameter   getPicPara( int level )                        { CHECK(!( level < m_numberOfLevel ), "Level too big"); return m_picPara[level]; }
-  void           setPicPara( int level, TRCParameter para )     { CHECK(!( level < m_numberOfLevel ), "Level too big"); m_picPara[level] = para; }
+  TRCParameter   getPicPara( int level )                        {
+    CHECK_VTM(!( level < m_numberOfLevel ), "Level too big"); return m_picPara[level]; }
+  void           setPicPara( int level, TRCParameter para )     {
+    CHECK_VTM(!( level < m_numberOfLevel ), "Level too big"); m_picPara[level] = para; }
   TRCParameter** getLCUPara()                                   { return m_LCUPara; }
-  TRCParameter*  getLCUPara( int level )                        { CHECK(!( level < m_numberOfLevel ), "Level too big"); return m_LCUPara[level]; }
-  TRCParameter   getLCUPara( int level, int LCUIdx )            { CHECK(!( LCUIdx  < m_numberOfLCU ), "LCU id exceeds number of LCU"); return getLCUPara(level)[LCUIdx]; }
-  void           setLCUPara( int level, int LCUIdx, TRCParameter para ) { CHECK(!( level < m_numberOfLevel ), "Level too big"); CHECK(!( LCUIdx  < m_numberOfLCU ), "LCU id exceeds number of LCU"); m_LCUPara[level][LCUIdx] = para; }
+  TRCParameter*  getLCUPara( int level )                        {
+    CHECK_VTM(!( level < m_numberOfLevel ), "Level too big"); return m_LCUPara[level]; }
+  TRCParameter   getLCUPara( int level, int LCUIdx )            {
+    CHECK_VTM(!( LCUIdx  < m_numberOfLCU ), "LCU id exceeds number of LCU"); return getLCUPara(level)[LCUIdx]; }
+  void           setLCUPara( int level, int LCUIdx, TRCParameter para ) {
+    CHECK_VTM(!( level < m_numberOfLevel ), "Level too big");
+    CHECK_VTM(!( LCUIdx  < m_numberOfLCU ), "LCU id exceeds number of LCU"); m_LCUPara[level][LCUIdx] = para; }
 
   int  getFramesLeft()                  { return m_framesLeft; }
   int64_t  getBitsLeft()                  { return m_bitsLeft; }
@@ -344,9 +353,12 @@ public:
 public:
   void       setRCQP ( int QP ) { m_RCQP = QP;   }
   int        getRCQP () const   { return m_RCQP; }
-  EncRCSeq* getRCSeq()          { CHECK( m_encRCSeq == NULL, "Object does not exist" ); return m_encRCSeq; }
-  EncRCGOP* getRCGOP()          { CHECK( m_encRCGOP == NULL, "Object does not exist" ); return m_encRCGOP; }
-  EncRCPic* getRCPic()          { CHECK( m_encRCPic == NULL, "Object does not exist" ); return m_encRCPic; }
+  EncRCSeq* getRCSeq()          {
+    CHECK_VTM( m_encRCSeq == NULL, "Object does not exist" ); return m_encRCSeq; }
+  EncRCGOP* getRCGOP()          {
+    CHECK_VTM( m_encRCGOP == NULL, "Object does not exist" ); return m_encRCGOP; }
+  EncRCPic* getRCPic()          {
+    CHECK_VTM( m_encRCPic == NULL, "Object does not exist" ); return m_encRCPic; }
   list<EncRCPic*>& getPicList() { return m_listRCPictures; }
 #if U0132_TARGET_BITS_SATURATION
   bool       getCpbSaturationEnabled()  { return m_CpbSaturationEnabled;  }
diff --git a/source/Lib/EncoderLib/SEIEncoder.cpp b/source/Lib/EncoderLib/SEIEncoder.cpp
index a9ecad7..6c85c34 100644
--- a/source/Lib/EncoderLib/SEIEncoder.cpp
+++ b/source/Lib/EncoderLib/SEIEncoder.cpp
@@ -46,13 +46,13 @@ std::string hashToString(const PictureHash &digest, int numChar);
 
 void SEIEncoder::initSEIFramePacking(SEIFramePacking *seiFramePacking, int currPicNum)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(seiFramePacking!=NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(seiFramePacking!=NULL), "Unspecified error");
 
   seiFramePacking->m_arrangementId = m_pcCfg->getFramePackingArrangementSEIId();
   seiFramePacking->m_arrangementCancelFlag = 0;
   seiFramePacking->m_arrangementType = m_pcCfg->getFramePackingArrangementSEIType();
-  CHECK(!((seiFramePacking->m_arrangementType > 2) && (seiFramePacking->m_arrangementType < 6) ), "Unspecified error");
+  CHECK_VTM(!((seiFramePacking->m_arrangementType > 2) && (seiFramePacking->m_arrangementType < 6) ), "Unspecified error");
   seiFramePacking->m_quincunxSamplingFlag = m_pcCfg->getFramePackingArrangementSEIQuincunx();
   seiFramePacking->m_contentInterpretationType = m_pcCfg->getFramePackingArrangementSEIInterpretation();
   seiFramePacking->m_spatialFlippingFlag = 0;
@@ -73,16 +73,16 @@ void SEIEncoder::initSEIFramePacking(SEIFramePacking *seiFramePacking, int currP
 
 void SEIEncoder::initSEIParameterSetsInclusionIndication(SEIParameterSetsInclusionIndication* seiParameterSetsInclusionIndication)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(seiParameterSetsInclusionIndication != NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(seiParameterSetsInclusionIndication != NULL), "Unspecified error");
 
   seiParameterSetsInclusionIndication->m_selfContainedClvsFlag = m_pcCfg->getSelfContainedClvsFlag();
 }
 
 void SEIEncoder::initSEIBufferingPeriod(SEIBufferingPeriod *bufferingPeriodSEI, bool noLeadingPictures)
 {
-  CHECK(!(m_isInitialized), "bufferingPeriodSEI already initialized");
-  CHECK(!(bufferingPeriodSEI != nullptr), "Need a bufferingPeriodSEI for initialization (got nullptr)");
+  CHECK_VTM(!(m_isInitialized), "bufferingPeriodSEI already initialized");
+  CHECK_VTM(!(bufferingPeriodSEI != nullptr), "Need a bufferingPeriodSEI for initialization (got nullptr)");
 
   uint32_t uiInitialCpbRemovalDelay = (90000/2);                      // 0.5 sec
   bufferingPeriodSEI->m_bpNalCpbParamsPresentFlag = true;
@@ -212,8 +212,8 @@ void SEIEncoder::initSEIBufferingPeriod(SEIBufferingPeriod *bufferingPeriodSEI,
 
 void SEIEncoder::initSEIErp(SEIEquirectangularProjection* seiEquirectangularProjection)
 {
-  CHECK(!(m_isInitialized), "seiEquirectangularProjection already initialized");
-  CHECK(!(seiEquirectangularProjection != nullptr), "Need a seiEquirectangularProjection for initialization (got nullptr)");
+  CHECK_VTM(!(m_isInitialized), "seiEquirectangularProjection already initialized");
+  CHECK_VTM(!(seiEquirectangularProjection != nullptr), "Need a seiEquirectangularProjection for initialization (got nullptr)");
 
   seiEquirectangularProjection->m_erpCancelFlag = m_pcCfg->getErpSEICancelFlag();
   if (!seiEquirectangularProjection->m_erpCancelFlag)
@@ -231,8 +231,8 @@ void SEIEncoder::initSEIErp(SEIEquirectangularProjection* seiEquirectangularProj
 
 void SEIEncoder::initSEISphereRotation(SEISphereRotation* seiSphereRotation)
 {
-  CHECK(!(m_isInitialized), "seiSphereRotation already initialized");
-  CHECK(!(seiSphereRotation != nullptr), "Need a seiSphereRotation for initialization (got nullptr)");
+  CHECK_VTM(!(m_isInitialized), "seiSphereRotation already initialized");
+  CHECK_VTM(!(seiSphereRotation != nullptr), "Need a seiSphereRotation for initialization (got nullptr)");
 
   seiSphereRotation->m_sphereRotationCancelFlag = m_pcCfg->getSphereRotationSEICancelFlag();
   if ( !seiSphereRotation->m_sphereRotationCancelFlag )
@@ -246,8 +246,8 @@ void SEIEncoder::initSEISphereRotation(SEISphereRotation* seiSphereRotation)
 
 void SEIEncoder::initSEIOmniViewport(SEIOmniViewport* seiOmniViewport)
 {
-  CHECK(!(m_isInitialized), "seiOmniViewport already initialized");
-  CHECK(!(seiOmniViewport != nullptr), "Need a seiOmniViewport for initialization (got nullptr)");
+  CHECK_VTM(!(m_isInitialized), "seiOmniViewport already initialized");
+  CHECK_VTM(!(seiOmniViewport != nullptr), "Need a seiOmniViewport for initialization (got nullptr)");
 
   seiOmniViewport->m_omniViewportId = m_pcCfg->getOmniViewportSEIId();
   seiOmniViewport->m_omniViewportCancelFlag = m_pcCfg->getOmniViewportSEICancelFlag();
@@ -271,8 +271,8 @@ void SEIEncoder::initSEIOmniViewport(SEIOmniViewport* seiOmniViewport)
 
 void SEIEncoder::initSEIRegionWisePacking(SEIRegionWisePacking *seiRegionWisePacking)
 {
-  CHECK(!(m_isInitialized), "seiRegionWisePacking already initialized");
-  CHECK(!(seiRegionWisePacking != nullptr), "Need a seiRegionWisePacking for initialization (got nullptr)");
+  CHECK_VTM(!(m_isInitialized), "seiRegionWisePacking already initialized");
+  CHECK_VTM(!(seiRegionWisePacking != nullptr), "Need a seiRegionWisePacking for initialization (got nullptr)");
 
   seiRegionWisePacking->m_rwpCancelFlag                          = m_pcCfg->getRwpSEIRwpCancelFlag();
   seiRegionWisePacking->m_rwpPersistenceFlag                     = m_pcCfg->getRwpSEIRwpPersistenceFlag();
@@ -327,8 +327,8 @@ void SEIEncoder::initSEIRegionWisePacking(SEIRegionWisePacking *seiRegionWisePac
 
 void SEIEncoder::initSEIGcmp(SEIGeneralizedCubemapProjection* seiGeneralizedCubemapProjection)
 {
-  CHECK(!(m_isInitialized), "seiGeneralizedCubemapProjection already initialized");
-  CHECK(!(seiGeneralizedCubemapProjection != nullptr), "Need a seiGeneralizedCubemapProjection for initialization (got nullptr)");
+  CHECK_VTM(!(m_isInitialized), "seiGeneralizedCubemapProjection already initialized");
+  CHECK_VTM(!(seiGeneralizedCubemapProjection != nullptr), "Need a seiGeneralizedCubemapProjection for initialization (got nullptr)");
 
   seiGeneralizedCubemapProjection->m_gcmpCancelFlag                      = m_pcCfg->getGcmpSEICancelFlag();
   if (!seiGeneralizedCubemapProjection->m_gcmpCancelFlag)
@@ -372,8 +372,8 @@ void SEIEncoder::initSEIGcmp(SEIGeneralizedCubemapProjection* seiGeneralizedCube
 
 void SEIEncoder::initSEISampleAspectRatioInfo(SEISampleAspectRatioInfo* seiSampleAspectRatioInfo)
 {
-  CHECK(!(m_isInitialized), "seiSampleAspectRatioInfo already initialized");
-  CHECK(!(seiSampleAspectRatioInfo != nullptr), "Need a seiSampleAspectRatioInfo for initialization (got nullptr)");
+  CHECK_VTM(!(m_isInitialized), "seiSampleAspectRatioInfo already initialized");
+  CHECK_VTM(!(seiSampleAspectRatioInfo != nullptr), "Need a seiSampleAspectRatioInfo for initialization (got nullptr)");
 
   seiSampleAspectRatioInfo->m_sariCancelFlag = m_pcCfg->getSariCancelFlag();
   if (!seiSampleAspectRatioInfo->m_sariCancelFlag)
@@ -399,9 +399,9 @@ void SEIEncoder::initSEISampleAspectRatioInfo(SEISampleAspectRatioInfo* seiSampl
 //  either targetOLS or targetLayer should be active, call with empty vector for the inactive mode
 void SEIEncoder::initSEIScalableNesting(SEIScalableNesting *scalableNestingSEI, SEIMessages &nestedSEIs, const std::vector<int> &targetOLSs, const std::vector<int> &targetLayers, const std::vector<uint16_t> &subpictureIDs)
 {
-  CHECK(!(m_isInitialized), "Scalable Nesting SEI already initialized ");
-  CHECK(!(scalableNestingSEI != NULL), "No Scalable Nesting SEI object passed");
-  CHECK (targetOLSs.size() > 0 && targetLayers.size() > 0, "Scalable Nesting SEI can apply to either OLS or layer(s), not both");
+  CHECK_VTM(!(m_isInitialized), "Scalable Nesting SEI already initialized ");
+  CHECK_VTM(!(scalableNestingSEI != NULL), "No Scalable Nesting SEI object passed");
+  CHECK_VTM(targetOLSs.size() > 0 && targetLayers.size() > 0, "Scalable Nesting SEI can apply to either OLS or layer(s), not both");
 
   scalableNestingSEI->m_snOlsFlag = (targetOLSs.size() > 0) ? 1 : 0;  // If the nested SEI messages are picture buffering SEI messages, picture timing SEI messages or sub-picture timing SEI messages, nesting_ols_flag shall be equal to 1, by default case
   if (scalableNestingSEI->m_snOlsFlag)
@@ -417,13 +417,13 @@ void SEIEncoder::initSEIScalableNesting(SEIScalableNesting *scalableNestingSEI,
     {
       if (i == 0)
       {
-        CHECK (scalableNestingSEI->m_snOlsIdx[i] < 0, "OLS indexes must be  equal to or greater than 0");
+        CHECK_VTM(scalableNestingSEI->m_snOlsIdx[i] < 0, "OLS indexes must be  equal to or greater than 0");
         // no "-1" operation for the first index although the name implies one
         scalableNestingSEI->m_snOlsIdxDeltaMinus1[i] = scalableNestingSEI->m_snOlsIdx[i];
       }
       else
       {
-        CHECK (scalableNestingSEI->m_snOlsIdx[i] <= scalableNestingSEI->m_snOlsIdx[i - 1], "OLS indexes must be in ascending order");
+        CHECK_VTM(scalableNestingSEI->m_snOlsIdx[i] <= scalableNestingSEI->m_snOlsIdx[i - 1], "OLS indexes must be in ascending order");
         scalableNestingSEI->m_snOlsIdxDeltaMinus1[i] = scalableNestingSEI->m_snOlsIdx[i] - scalableNestingSEI->m_snOlsIdx[i - 1] - 1;
       }
     }
@@ -443,7 +443,7 @@ void SEIEncoder::initSEIScalableNesting(SEIScalableNesting *scalableNestingSEI,
     scalableNestingSEI->m_snNumSubpics = (uint32_t) subpictureIDs.size();
     scalableNestingSEI->m_snSubpicId   = subpictureIDs;
     scalableNestingSEI->m_snSubpicIdLen = max(1, ceilLog2((*std::max_element(subpictureIDs.begin(), subpictureIDs.end())) + 1));
-    CHECK ( scalableNestingSEI->m_snSubpicIdLen > 15, "Subpicture ID too large. Length must be <= 15 bits");
+    CHECK_VTM( scalableNestingSEI->m_snSubpicIdLen > 15, "Subpicture ID too large. Length must be <= 15 bits");
   }
   scalableNestingSEI->m_nestedSEIs.clear();
   for (SEIMessages::iterator it = nestedSEIs.begin(); it != nestedSEIs.end(); it++)
@@ -456,8 +456,8 @@ void SEIEncoder::initSEIScalableNesting(SEIScalableNesting *scalableNestingSEI,
 //! calculate hashes for entire reconstructed picture
 void SEIEncoder::initDecodedPictureHashSEI(SEIDecodedPictureHash *decodedPictureHashSEI, PelUnitBuf& pic, std::string &rHashString, const BitDepths &bitDepths)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(decodedPictureHashSEI!=NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(decodedPictureHashSEI!=NULL), "Unspecified error");
 
   decodedPictureHashSEI->method = m_pcCfg->getDecodedPictureHashSEIType();
   switch (m_pcCfg->getDecodedPictureHashSEIType())
@@ -486,8 +486,8 @@ void SEIEncoder::initDecodedPictureHashSEI(SEIDecodedPictureHash *decodedPicture
 
 void SEIEncoder::initSEIDependentRAPIndication(SEIDependentRAPIndication *seiDependentRAPIndication)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(seiDependentRAPIndication!=NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(seiDependentRAPIndication!=NULL), "Unspecified error");
 }
 
 
@@ -562,16 +562,16 @@ static void readTokenValueAndValidate(T            &returnedValue, /// value ret
 #if U0033_ALTERNATIVE_TRANSFER_CHARACTERISTICS_SEI
 void SEIEncoder::initSEIAlternativeTransferCharacteristics(SEIAlternativeTransferCharacteristics *seiAltTransCharacteristics)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(seiAltTransCharacteristics!=NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(seiAltTransCharacteristics!=NULL), "Unspecified error");
   //  Set SEI message parameters read from command line options
   seiAltTransCharacteristics->m_preferredTransferCharacteristics = m_pcCfg->getSEIPreferredTransferCharacteristics();
 }
 #endif
 void SEIEncoder::initSEIFilmGrainCharacteristics(SEIFilmGrainCharacteristics *seiFilmGrain)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(seiFilmGrain != NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(seiFilmGrain != NULL), "Unspecified error");
   //  Set SEI message parameters read from command line options
   seiFilmGrain->m_filmGrainCharacteristicsCancelFlag      = m_pcCfg->getFilmGrainCharactersticsSEICancelFlag();
   seiFilmGrain->m_filmGrainCharacteristicsPersistenceFlag = m_pcCfg->getFilmGrainCharactersticsSEIPersistenceFlag();
@@ -587,8 +587,8 @@ void SEIEncoder::initSEIFilmGrainCharacteristics(SEIFilmGrainCharacteristics *se
 
 void SEIEncoder::initSEIMasteringDisplayColourVolume(SEIMasteringDisplayColourVolume *seiMDCV)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(seiMDCV != NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(seiMDCV != NULL), "Unspecified error");
   //  Set SEI message parameters read from command line options
   for (int j = 0; j <= 1; j++)
   {
@@ -604,8 +604,8 @@ void SEIEncoder::initSEIMasteringDisplayColourVolume(SEIMasteringDisplayColourVo
 
 void SEIEncoder::initSEIContentLightLevel(SEIContentLightLevelInfo *seiCLL)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(seiCLL != NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(seiCLL != NULL), "Unspecified error");
   //  Set SEI message parameters read from command line options
   seiCLL->m_maxContentLightLevel    = m_pcCfg->getCLLSEIMaxContentLightLevel();
   seiCLL->m_maxPicAverageLightLevel = m_pcCfg->getCLLSEIMaxPicAvgLightLevel();
@@ -613,8 +613,8 @@ void SEIEncoder::initSEIContentLightLevel(SEIContentLightLevelInfo *seiCLL)
 
 void SEIEncoder::initSEIAmbientViewingEnvironment(SEIAmbientViewingEnvironment *seiAmbViewEnvironment)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(seiAmbViewEnvironment != NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(seiAmbViewEnvironment != NULL), "Unspecified error");
   //  Set SEI message parameters read from command line options
   seiAmbViewEnvironment->m_ambientIlluminance = m_pcCfg->getAmbientViewingEnvironmentSEIIlluminance();
   seiAmbViewEnvironment->m_ambientLightX      = m_pcCfg->getAmbientViewingEnvironmentSEIAmbientLightX();
diff --git a/source/Lib/EncoderLib/SEIwrite.cpp b/source/Lib/EncoderLib/SEIwrite.cpp
index 042d25a..c1fa998 100644
--- a/source/Lib/EncoderLib/SEIwrite.cpp
+++ b/source/Lib/EncoderLib/SEIwrite.cpp
@@ -51,7 +51,7 @@ void SEIWriter::xWriteSEIpayloadData(OutputBitstream &bs, const SEI& sei, HRD &h
     break;
   case SEI::DECODING_UNIT_INFO:
     bp = hrd.getBufferingPeriodSEI();
-    CHECK (bp == nullptr, "Buffering Period need to be initialized in HRD to allow writing of Decoding Unit Information SEI");
+    CHECK_VTM(bp == nullptr, "Buffering Period need to be initialized in HRD to allow writing of Decoding Unit Information SEI");
     xWriteSEIDecodingUnitInfo(*static_cast<const SEIDecodingUnitInfo*>(& sei), *bp, temporalId);
     break;
   case SEI::SCALABLE_NESTING:
@@ -67,7 +67,7 @@ void SEIWriter::xWriteSEIpayloadData(OutputBitstream &bs, const SEI& sei, HRD &h
   case SEI::PICTURE_TIMING:
     {
       bp = hrd.getBufferingPeriodSEI();
-      CHECK (bp == nullptr, "Buffering Period need to be initialized in HRD to allow writing of Picture Timing SEI");
+      CHECK_VTM(bp == nullptr, "Buffering Period need to be initialized in HRD to allow writing of Picture Timing SEI");
       xWriteSEIPictureTiming(*static_cast<const SEIPictureTiming*>(&sei), *bp, temporalId);
     }
     break;
@@ -162,7 +162,7 @@ void SEIWriter::writeSEImessages(OutputBitstream& bs, const SEIMessages &seiList
     g_HLSTraceEnable = traceEnable;
 #endif
     uint32_t payload_data_num_bits = bs_count.getNumberOfWrittenBits();
-    CHECK(0 != payload_data_num_bits % 8, "Invalid number of payload data bits");
+    CHECK_VTM(0 != payload_data_num_bits % 8, "Invalid number of payload data bits");
 
     setBitstream(&bs);
     uint32_t payloadType = (*sei)->payloadType();
@@ -265,19 +265,19 @@ void SEIWriter::xWriteSEIBufferingPeriod(const SEIBufferingPeriod& sei)
 {
   WRITE_FLAG( sei.m_bpNalCpbParamsPresentFlag, "bp_nal_hrd_parameters_present_flag");
   WRITE_FLAG( sei.m_bpVclCpbParamsPresentFlag, "bp_vcl_hrd_parameters_present_flag");
-  CHECK(!sei.m_bpNalCpbParamsPresentFlag && !sei.m_bpVclCpbParamsPresentFlag, "bp_nal_hrd_parameters_present_flag and/or bp_vcl_hrd_parameters_present_flag must be true");
-  CHECK (sei.m_initialCpbRemovalDelayLength < 1, "sei.m_initialCpbRemovalDelayLength must be > 0");
+  CHECK_VTM(!sei.m_bpNalCpbParamsPresentFlag && !sei.m_bpVclCpbParamsPresentFlag, "bp_nal_hrd_parameters_present_flag and/or bp_vcl_hrd_parameters_present_flag must be true");
+  CHECK_VTM(sei.m_initialCpbRemovalDelayLength < 1, "sei.m_initialCpbRemovalDelayLength must be > 0");
   WRITE_CODE( sei.m_initialCpbRemovalDelayLength - 1, 5, "initial_cpb_removal_delay_length_minus1" );
-  CHECK (sei.m_cpbRemovalDelayLength < 1, "sei.m_cpbRemovalDelayLength must be > 0");
+  CHECK_VTM(sei.m_cpbRemovalDelayLength < 1, "sei.m_cpbRemovalDelayLength must be > 0");
   WRITE_CODE( sei.m_cpbRemovalDelayLength - 1,        5, "cpb_removal_delay_length_minus1" );
-  CHECK (sei.m_dpbOutputDelayLength < 1, "sei.m_dpbOutputDelayLength must be > 0");
+  CHECK_VTM(sei.m_dpbOutputDelayLength < 1, "sei.m_dpbOutputDelayLength must be > 0");
   WRITE_CODE( sei.m_dpbOutputDelayLength - 1,         5, "dpb_output_delay_length_minus1" );
   WRITE_FLAG( sei.m_bpDecodingUnitHrdParamsPresentFlag, "bp_decoding_unit_hrd_params_present_flag"  );
   if( sei.m_bpDecodingUnitHrdParamsPresentFlag )
   {
-    CHECK (sei.m_duCpbRemovalDelayIncrementLength < 1, "sei.m_duCpbRemovalDelayIncrementLength must be > 0");
+    CHECK_VTM(sei.m_duCpbRemovalDelayIncrementLength < 1, "sei.m_duCpbRemovalDelayIncrementLength must be > 0");
     WRITE_CODE( sei.m_duCpbRemovalDelayIncrementLength - 1, 5, "du_cpb_removal_delay_increment_length_minus1" );
-    CHECK (sei.m_dpbOutputDelayDuLength < 1, "sei.m_dpbOutputDelayDuLength must be > 0");
+    CHECK_VTM(sei.m_dpbOutputDelayDuLength < 1, "sei.m_dpbOutputDelayDuLength must be > 0");
     WRITE_CODE( sei.m_dpbOutputDelayDuLength - 1, 5, "dpb_output_delay_du_length_minus1" );
     WRITE_FLAG( sei.m_decodingUnitCpbParamsInPicTimingSeiFlag, "decoding_unit_cpb_params_in_pic_timing_sei_flag" );
     WRITE_FLAG(sei.m_decodingUnitDpbDuParamsInPicTimingSeiFlag, "decoding_unit_dpb_du_params_in_pic_timing_sei_flag");
@@ -290,10 +290,10 @@ void SEIWriter::xWriteSEIBufferingPeriod(const SEIBufferingPeriod& sei)
     WRITE_CODE( sei.m_maxInitialRemovalDelayForConcatenation, sei.m_initialCpbRemovalDelayLength, "max_initial_removal_delay_for_concatenation" );
   }
 
-  CHECK (sei.m_auCpbRemovalDelayDelta < 1, "sei.m_auCpbRemovalDelayDelta must be > 0");
+  CHECK_VTM(sei.m_auCpbRemovalDelayDelta < 1, "sei.m_auCpbRemovalDelayDelta must be > 0");
   WRITE_CODE( sei.m_auCpbRemovalDelayDelta - 1, sei.m_cpbRemovalDelayLength, "au_cpb_removal_delay_delta_minus1" );
 
-  CHECK(sei.m_bpMaxSubLayers < 1, "bp_max_sub_layers_minus1 must be > 0");
+  CHECK_VTM(sei.m_bpMaxSubLayers < 1, "bp_max_sub_layers_minus1 must be > 0");
   WRITE_CODE(sei.m_bpMaxSubLayers - 1, 3, "bp_max_sub_layers_minus1");
   if (sei.m_bpMaxSubLayers - 1 > 0)
   {
@@ -302,14 +302,14 @@ void SEIWriter::xWriteSEIBufferingPeriod(const SEIBufferingPeriod& sei)
 
   if (sei.m_cpbRemovalDelayDeltasPresentFlag)
   {
-    CHECK (sei.m_numCpbRemovalDelayDeltas < 1, "m_numCpbRemovalDelayDeltas must be > 0");
+    CHECK_VTM(sei.m_numCpbRemovalDelayDeltas < 1, "m_numCpbRemovalDelayDeltas must be > 0");
     WRITE_UVLC( sei.m_numCpbRemovalDelayDeltas - 1, "num_cpb_removal_delay_deltas_minus1" );
     for( int i = 0; i < sei.m_numCpbRemovalDelayDeltas; i ++ )
     {
       WRITE_CODE( sei.m_cpbRemovalDelayDelta[i],        sei.m_cpbRemovalDelayLength, "cpb_removal_delay_delta[i]" );
     }
   }
-  CHECK (sei.m_bpCpbCnt < 1, "sei.m_bpCpbCnt must be > 0");
+  CHECK_VTM(sei.m_bpCpbCnt < 1, "sei.m_bpCpbCnt must be > 0");
   WRITE_UVLC( sei.m_bpCpbCnt - 1, "bp_cpb_cnt_minus1");
   if (sei.m_bpMaxSubLayers - 1 > 0)
   {
@@ -484,7 +484,7 @@ void SEIWriter::xWriteSEIDependentRAPIndication(const SEIDependentRAPIndication&
 
 void SEIWriter::xWriteSEIScalableNesting(OutputBitstream& bs, const SEIScalableNesting& sei)
 {
-  CHECK (sei.m_nestedSEIs.size()<1, "There must be at lease one SEI message nested in the scalable nesting SEI.")
+  CHECK_VTM(sei.m_nestedSEIs.size()<1, "There must be at lease one SEI message nested in the scalable nesting SEI.")
 
   WRITE_FLAG(sei.m_snOlsFlag, "sn_ols_flag");
   WRITE_FLAG(sei.m_snSubpicFlag, "sn_subpic_flag");
@@ -511,7 +511,7 @@ void SEIWriter::xWriteSEIScalableNesting(OutputBitstream& bs, const SEIScalableN
   if (sei.m_snSubpicFlag)
   {
     WRITE_UVLC( sei.m_snNumSubpics - 1, "sn_num_subpics_minus1");
-    CHECK(sei.m_snSubpicIdLen < 1, "sn_subpic_id_len_minus1 must be >= 0");
+    CHECK_VTM(sei.m_snSubpicIdLen < 1, "sn_subpic_id_len_minus1 must be >= 0");
     WRITE_UVLC( sei.m_snSubpicIdLen - 1, "sn_subpic_id_len_minus1");
     for (uint32_t i = 0; i < sei.m_snNumSubpics; i++)
     {
@@ -742,11 +742,11 @@ void SEIWriter::xWriteSEIGeneralizedCubemapProjection(const SEIGeneralizedCubema
 
 void SEIWriter::xWriteSEISubpictureLevelInfo(const SEISubpicureLevelInfo &sei)
 {
-  CHECK(sei.m_numRefLevels < 1, "SEISubpicureLevelInfo: numRefLevels must be greater than zero");
-  CHECK(sei.m_numRefLevels != (int)sei.m_refLevelIdc.size(), "SEISubpicureLevelInfo: numRefLevels must be equal to the number of levels");
+  CHECK_VTM(sei.m_numRefLevels < 1, "SEISubpicureLevelInfo: numRefLevels must be greater than zero");
+  CHECK_VTM(sei.m_numRefLevels != (int)sei.m_refLevelIdc.size(), "SEISubpicureLevelInfo: numRefLevels must be equal to the number of levels");
   if (sei.m_explicitFractionPresentFlag)
   {
-    CHECK(sei.m_numRefLevels != (int)sei.m_refLevelFraction.size(), "SEISubpicureLevelInfo: numRefLevels must be equal to the number of fractions");
+    CHECK_VTM(sei.m_numRefLevels != (int)sei.m_refLevelFraction.size(), "SEISubpicureLevelInfo: numRefLevels must be equal to the number of fractions");
   }
   WRITE_CODE( (uint32_t)sei.m_numRefLevels - 1, 3,                            "sli_num_ref_levels_minus1");
   WRITE_FLAG(           sei.m_cbrConstraintFlag,                              "sli_cbr_constraint_flag");
@@ -770,7 +770,7 @@ void SEIWriter::xWriteSEISubpictureLevelInfo(const SEISubpicureLevelInfo &sei)
       WRITE_CODE((uint32_t)sei.m_refLevelIdc[i][k], 8, "sli_ref_level_idc[i][k]");
       if (sei.m_explicitFractionPresentFlag)
       {
-        CHECK(sei.m_numSubpics != (int)sei.m_refLevelFraction[i].size(), "SEISubpicureLevelInfo: number of fractions differs from number of subpictures");
+        CHECK_VTM(sei.m_numSubpics != (int)sei.m_refLevelFraction[i].size(), "SEISubpicureLevelInfo: number of fractions differs from number of subpictures");
         for (int j = 0; j < sei.m_numSubpics; j++)
         {
           WRITE_CODE((uint32_t)sei.m_refLevelFraction[i][j][k], 8, "sli_ref_level_fraction_minus1[i][j][k]");
diff --git a/source/Lib/EncoderLib/VLCWriter.cpp b/source/Lib/EncoderLib/VLCWriter.cpp
index 639cb51..3c602d2 100644
--- a/source/Lib/EncoderLib/VLCWriter.cpp
+++ b/source/Lib/EncoderLib/VLCWriter.cpp
@@ -124,7 +124,7 @@ void VLCWriter::xWriteSCode    ( int code, uint32_t length )
 
 void VLCWriter::xWriteCode     ( uint32_t uiCode, uint32_t uiLength )
 {
-  CHECK( uiLength == 0, "Code of length '0' not supported" );
+  CHECK_VTM( uiLength == 0, "Code of length '0' not supported" );
   m_pcBitIf->write( uiCode, uiLength );
 }
 
@@ -133,7 +133,7 @@ void VLCWriter::xWriteUvlc     ( uint32_t uiCode )
   uint32_t uiLength = 1;
   uint32_t uiTemp = ++uiCode;
 
-  CHECK( !uiTemp, "Integer overflow" );
+  CHECK_VTM( !uiTemp, "Integer overflow" );
 
   while( 1 != uiTemp )
   {
@@ -165,7 +165,7 @@ void VLCWriter::xWriteRbspTrailingBits()
     WRITE_FLAG( 0, "rbsp_alignment_zero_bit");
     cnt++;
   }
-  CHECK(cnt>=8, "More than '8' alignment bytes read");
+  CHECK_VTM(cnt>=8, "More than '8' alignment bytes read");
 }
 
 void AUDWriter::codeAUD(OutputBitstream& bs, const bool audIrapOrGdrAuFlag, const int pictureType)
@@ -174,7 +174,7 @@ void AUDWriter::codeAUD(OutputBitstream& bs, const bool audIrapOrGdrAuFlag, cons
   xTraceAccessUnitDelimiter();
 #endif
 
-  CHECK(pictureType >= 3, "Invalid picture type");
+  CHECK_VTM(pictureType >= 3, "Invalid picture type");
   setBitstream(&bs);
   WRITE_FLAG(audIrapOrGdrAuFlag, "aud_irap_or_gdr_au_flag");
   WRITE_CODE(pictureType, 3, "pic_type");
@@ -216,7 +216,7 @@ void HLSWriter::xCodeRefPicList( const ReferencePictureList* rpl, bool isLongTer
 
       if( rpl->isInterLayerRefPic( ii ) )
       {
-        CHECK( rpl->getInterLayerRefPicIdx( ii ) < 0, "Wrong inter-layer reference index" );
+        CHECK_VTM( rpl->getInterLayerRefPicIdx( ii ) < 0, "Wrong inter-layer reference index" );
         WRITE_UVLC( rpl->getInterLayerRefPicIdx( ii ), "ilrp_idx[ listIdx ][ rplsIdx ][ i ]" );
       }
     }
@@ -243,7 +243,7 @@ void HLSWriter::xCodeRefPicList( const ReferencePictureList* rpl, bool isLongTer
       unsigned int absDeltaValue = (deltaValue < 0) ? 0 - deltaValue : deltaValue;
       if (isForbiddenZeroDeltaPoc || ii == 0)
       {
-        CHECK(!absDeltaValue, "Zero delta POC is not used without WP or is the 0-th entry");
+        CHECK_VTM(!absDeltaValue, "Zero delta POC is not used without WP or is the 0-th entry");
         WRITE_UVLC( absDeltaValue - 1, "abs_delta_poc_st[ listIdx ][ rplsIdx ][ i ]" );
       }
       else
@@ -299,15 +299,15 @@ void HLSWriter::codePPS( const PPS* pcPPS )
   WRITE_FLAG( pcPPS->getSubPicIdMappingInPpsFlag() ? 1 : 0, "pps_subpic_id_mapping_present_flag" );
   if( pcPPS->getSubPicIdMappingInPpsFlag() )
   {
-    CHECK(pcPPS->getNumSubPics() < 1, "PPS: NumSubPics cannot be less than 1");
+    CHECK_VTM(pcPPS->getNumSubPics() < 1, "PPS: NumSubPics cannot be less than 1");
     if( !pcPPS->getNoPicPartitionFlag() )
     {
       WRITE_UVLC(pcPPS->getNumSubPics() - 1, "pps_num_subpics_minus1");
     }
-    CHECK(pcPPS->getSubPicIdLen() < 1, "PPS: SubPicIdLen cannot be less than 1");
+    CHECK_VTM(pcPPS->getSubPicIdLen() < 1, "PPS: SubPicIdLen cannot be less than 1");
     WRITE_UVLC( pcPPS->getSubPicIdLen() - 1, "pps_subpic_id_len_minus1" );
 
-    CHECK((1 << pcPPS->getSubPicIdLen()) < pcPPS->getNumSubPics(), "pps_subpic_id_len exceeds valid range");
+    CHECK_VTM((1 << pcPPS->getSubPicIdLen()) < pcPPS->getNumSubPics(), "pps_subpic_id_len exceeds valid range");
     for( int picIdx = 0; picIdx < pcPPS->getNumSubPics( ); picIdx++ )
     {
       WRITE_CODE( pcPPS->getSubPicId(picIdx), pcPPS->getSubPicIdLen( ), "pps_subpic_id[i]" );
@@ -389,7 +389,7 @@ void HLSWriter::codePPS( const PPS* pcPPS )
             expSliceHeightSum += pcPPS->getSliceHeightInCtu(i + j);
           }
 
-          CHECK( expSliceHeightSum > pcPPS->getTileRowHeight(pcPPS->getSliceTileIdx(i) / pcPPS->getNumTileColumns()), "The sum of expressed slice heights is larger than the height of the tile containing the slices.");
+          CHECK_VTM( expSliceHeightSum > pcPPS->getTileRowHeight(pcPPS->getSliceTileIdx(i) / pcPPS->getNumTileColumns()), "The sum of expressed slice heights is larger than the height of the tile containing the slices.");
           i += (pcPPS->getNumSlicesInTile(i) - 1);
         }
 
@@ -569,8 +569,8 @@ void HLSWriter::codeAlfAps( APS* pcAPS )
     if (paramCcAlf.newCcAlfFilter[ccIdx])
     {
       const int filterCount = paramCcAlf.ccAlfFilterCount[ccIdx];
-      CHECK(filterCount > MAX_NUM_CC_ALF_FILTERS, "CC ALF Filter count is too large");
-      CHECK(filterCount == 0, "CC ALF Filter count is too small");
+      CHECK_VTM(filterCount > MAX_NUM_CC_ALF_FILTERS, "CC ALF Filter count is too large");
+      CHECK_VTM(filterCount == 0, "CC ALF Filter count is too small");
 
       if (MAX_NUM_CC_ALF_FILTERS > 1)
       {
@@ -774,7 +774,7 @@ void HLSWriter::dpb_parameters(int maxSubLayersMinus1, bool subLayerInfoFlag, co
 {
   for (uint32_t i = (subLayerInfoFlag ? 0 : maxSubLayersMinus1); i <= maxSubLayersMinus1; i++)
   {
-    CHECK(pcSPS->getMaxDecPicBuffering(i) < 1, "MaxDecPicBuffering must be greater than 0");
+    CHECK_VTM(pcSPS->getMaxDecPicBuffering(i) < 1, "MaxDecPicBuffering must be greater than 0");
     WRITE_UVLC(pcSPS->getMaxDecPicBuffering(i) - 1, "dpb_max_dec_pic_buffering_minus1[i]");
     WRITE_UVLC(pcSPS->getMaxNumReorderPics(i), "dpb_max_num_reorder_pics[i]");
     WRITE_UVLC(pcSPS->getMaxLatencyIncreasePlus1(i), "dpb_max_latency_increase_plus1[i]");
@@ -788,7 +788,7 @@ void HLSWriter::codeSPS( const SPS* pcSPS )
 #endif
   WRITE_CODE(pcSPS->getSPSId(), 4, "sps_seq_parameter_set_id");
   WRITE_CODE( pcSPS->getVPSId(), 4, "sps_video_parameter_set_id" );
-  CHECK(pcSPS->getMaxTLayers() == 0, "Maximum number of temporal sub-layers is '0'");
+  CHECK_VTM(pcSPS->getMaxTLayers() == 0, "Maximum number of temporal sub-layers is '0'");
 
   WRITE_CODE(pcSPS->getMaxTLayers() - 1, 3, "sps_max_sub_layers_minus1");
   WRITE_CODE(int(pcSPS->getChromaFormatIdc()), 2, "sps_chroma_format_idc");
@@ -797,7 +797,7 @@ void HLSWriter::codeSPS( const SPS* pcSPS )
 
   if( !pcSPS->getVPSId() )
   {
-    CHECK( !pcSPS->getPtlDpbHrdParamsPresentFlag(), "When sps_video_parameter_set_id is equal to 0, the value of sps_ptl_dpb_hrd_params_present_flag shall be equal to 1" );
+    CHECK_VTM( !pcSPS->getPtlDpbHrdParamsPresentFlag(), "When sps_video_parameter_set_id is equal to 0, the value of sps_ptl_dpb_hrd_params_present_flag shall be equal to 1" );
   }
 
   if (pcSPS->getPtlDpbHrdParamsPresentFlag())
@@ -813,7 +813,7 @@ void HLSWriter::codeSPS( const SPS* pcSPS )
   {
     WRITE_FLAG(pcSPS->getResChangeInClvsEnabledFlag(), "sps_res_change_in_clvs_allowed_flag");
   }
-  CHECK(!pcSPS->getRprEnabledFlag() && pcSPS->getResChangeInClvsEnabledFlag(), "When sps_ref_pic_resampling_enabled_flag is equal to 0, sps_res_change_in_clvs_allowed_flag shall be equal to 0");
+  CHECK_VTM(!pcSPS->getRprEnabledFlag() && pcSPS->getResChangeInClvsEnabledFlag(), "When sps_ref_pic_resampling_enabled_flag is equal to 0, sps_res_change_in_clvs_allowed_flag shall be equal to 0");
 
   WRITE_UVLC( pcSPS->getMaxPicWidthInLumaSamples(), "sps_pic_width_max_in_luma_samples" );
   WRITE_UVLC( pcSPS->getMaxPicHeightInLumaSamples(), "sps_pic_height_max_in_luma_samples" );
@@ -832,7 +832,7 @@ void HLSWriter::codeSPS( const SPS* pcSPS )
 
   if (pcSPS->getSubPicInfoPresentFlag())
   {
-    CHECK(pcSPS->getNumSubPics() < 1, "SPS: NumSubPics cannot be less than 1");
+    CHECK_VTM(pcSPS->getNumSubPics() < 1, "SPS: NumSubPics cannot be less than 1");
     WRITE_UVLC(pcSPS->getNumSubPics() - 1, "sps_num_subpics_minus1");
     if( pcSPS->getNumSubPics() > 1 )
     {
@@ -869,7 +869,7 @@ void HLSWriter::codeSPS( const SPS* pcSPS )
       }
     }
 
-    CHECK(pcSPS->getSubPicIdLen() < 1, "SPS: SubPicIdLen cannot be less than 1");
+    CHECK_VTM(pcSPS->getSubPicIdLen() < 1, "SPS: SubPicIdLen cannot be less than 1");
     WRITE_UVLC(pcSPS->getSubPicIdLen() - 1, "sps_subpic_id_len_minus1");
     WRITE_FLAG(pcSPS->getSubPicIdMappingExplicitlySignalledFlag(), "sps_subpic_id_mapping_explicitly_signalled_flag");
     if (pcSPS->getSubPicIdMappingExplicitlySignalledFlag())
@@ -888,7 +888,7 @@ void HLSWriter::codeSPS( const SPS* pcSPS )
   const Profile::Name profile = pcSPS->getProfileTierLevel()->getProfileIdc();
   if (profile != Profile::NONE)
   {
-    CHECK(pcSPS->getBitDepth(CHANNEL_TYPE_LUMA) > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "sps_bitdepth_minus8 exceeds range supported by signalled profile");
+    CHECK_VTM(pcSPS->getBitDepth(CHANNEL_TYPE_LUMA) > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "sps_bitdepth_minus8 exceeds range supported by signalled profile");
   }
   WRITE_UVLC(pcSPS->getBitDepth(CHANNEL_TYPE_LUMA) - 8, "sps_bitdepth_minus8");
   WRITE_FLAG( pcSPS->getEntropyCodingSyncEnabledFlag() ? 1 : 0, "sps_entropy_coding_sync_enabled_flag" );
@@ -916,7 +916,7 @@ void HLSWriter::codeSPS( const SPS* pcSPS )
     }
     dpb_parameters(pcSPS->getMaxTLayers() - 1, pcSPS->getSubLayerDpbParamsFlag(), pcSPS);
   }
-  CHECK( pcSPS->getMaxCUWidth() != pcSPS->getMaxCUHeight(),                          "Rectangular CTUs not supported" );
+  CHECK_VTM( pcSPS->getMaxCUWidth() != pcSPS->getMaxCUHeight(),                          "Rectangular CTUs not supported" );
   WRITE_UVLC(pcSPS->getLog2MinCodingBlockSize() - 2, "sps_log2_min_luma_coding_block_size_minus2");
   WRITE_FLAG(pcSPS->getSplitConsOverrideEnabledFlag(), "sps_partition_constraints_override_enabled_flag");
   WRITE_UVLC(floorLog2(pcSPS->getMinQTSize(I_SLICE)) - pcSPS->getLog2MinCodingBlockSize(), "sps_log2_diff_min_qt_min_cb_intra_slice_luma");
@@ -958,7 +958,7 @@ void HLSWriter::codeSPS( const SPS* pcSPS )
   }
   else
   {
-    CHECK(pcSPS->getBDPCMEnabledFlag(), "BDPCM cannot be used when transform skip is disabled");
+    CHECK_VTM(pcSPS->getBDPCMEnabledFlag(), "BDPCM cannot be used when transform skip is disabled");
   }
   WRITE_FLAG(pcSPS->getUseMTS() ? 1 : 0, "sps_mts_enabled_flag");
   if (pcSPS->getUseMTS())
@@ -974,7 +974,7 @@ void HLSWriter::codeSPS( const SPS* pcSPS )
     const ChromaQpMappingTable& chromaQpMappingTable = pcSPS->getChromaQpMappingTable();
     WRITE_FLAG(chromaQpMappingTable.getSameCQPTableForAllChromaFlag(), "sps_same_qp_table_for_chroma_flag");
     int numQpTables = chromaQpMappingTable.getSameCQPTableForAllChromaFlag() ? 1 : (pcSPS->getJointCbCrEnabledFlag() ? 3 : 2);
-    CHECK(numQpTables != chromaQpMappingTable.getNumQpTables(), " numQpTables does not match at encoder side ");
+    CHECK_VTM(numQpTables != chromaQpMappingTable.getNumQpTables(), " numQpTables does not match at encoder side ");
     for (int i = 0; i < numQpTables; i++)
     {
       WRITE_SVLC(chromaQpMappingTable.getQpTableStartMinus26(i), "sps_qp_table_starts_minus26");
@@ -1084,9 +1084,9 @@ void HLSWriter::codeSPS( const SPS* pcSPS )
     WRITE_FLAG(pcSPS->getUseGeo() ? 1 : 0, "sps_gpm_enabled_flag");
     if (pcSPS->getUseGeo())
     {
-      CHECK(pcSPS->getMaxNumMergeCand() < pcSPS->getMaxNumGeoCand(),
+      CHECK_VTM(pcSPS->getMaxNumMergeCand() < pcSPS->getMaxNumGeoCand(),
             "The number of GPM candidates must not be greater than the number of merge candidates");
-      CHECK(2 > pcSPS->getMaxNumGeoCand(),
+      CHECK_VTM(2 > pcSPS->getMaxNumGeoCand(),
             "The number of GPM candidates must not be smaller than 2");
       if (pcSPS->getMaxNumMergeCand() >= 3)
       {
@@ -1112,10 +1112,10 @@ void HLSWriter::codeSPS( const SPS* pcSPS )
   }
   else
   {
-    CHECK(pcSPS->getHorCollocatedChromaFlag() != 1, "Invalid value for horizontal collocated chroma flag");
-    CHECK(pcSPS->getVerCollocatedChromaFlag() != 1, "Invalid value for vertical collocated chroma flag");
+    CHECK_VTM(pcSPS->getHorCollocatedChromaFlag() != 1, "Invalid value for horizontal collocated chroma flag");
+    CHECK_VTM(pcSPS->getVerCollocatedChromaFlag() != 1, "Invalid value for vertical collocated chroma flag");
   }
-  CHECK(pcSPS->getMaxNumMergeCand() > MRG_MAX_NUM_CANDS, "More merge candidates signalled than supported");
+  CHECK_VTM(pcSPS->getMaxNumMergeCand() > MRG_MAX_NUM_CANDS, "More merge candidates signalled than supported");
   WRITE_FLAG(pcSPS->getPLTMode() ? 1 : 0,                                                    "sps_palette_enabled_flag" );
   if (pcSPS->getChromaFormatIdc() == CHROMA_444 && pcSPS->getLog2MaxTbSize() != 6)
   {
@@ -1128,7 +1128,7 @@ void HLSWriter::codeSPS( const SPS* pcSPS )
   WRITE_FLAG(pcSPS->getIBCFlag() ? 1 : 0,                                                      "sps_ibc_enabled_flag");
   if (pcSPS->getIBCFlag())
   {
-    CHECK(pcSPS->getMaxNumIBCMergeCand() > IBC_MRG_MAX_NUM_CANDS, "More IBC merge candidates signalled than supported");
+    CHECK_VTM(pcSPS->getMaxNumIBCMergeCand() > IBC_MRG_MAX_NUM_CANDS, "More IBC merge candidates signalled than supported");
     WRITE_UVLC(IBC_MRG_MAX_NUM_CANDS - pcSPS->getMaxNumIBCMergeCand(), "sps_six_minus_max_num_ibc_merge_cand");
   }
 #if LUMA_ADAPTIVE_DEBLOCKING_FILTER_QP_OFFSET
@@ -1175,30 +1175,30 @@ void HLSWriter::codeSPS( const SPS* pcSPS )
       WRITE_UVLC( pcSPS->getNumVerVirtualBoundaries(), "sps_num_ver_virtual_boundaries");
       if (pcSPS->getMaxPicWidthInLumaSamples() <= 8)
       {
-        CHECK(pcSPS->getNumVerVirtualBoundaries() != 0, "SPS: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
+        CHECK_VTM(pcSPS->getNumVerVirtualBoundaries() != 0, "SPS: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
       }
       else
       {
-        CHECK(pcSPS->getNumVerVirtualBoundaries() > 3, "SPS: The number of vertical virtual boundaries shall be in the range of 0 to 3");
+        CHECK_VTM(pcSPS->getNumVerVirtualBoundaries() > 3, "SPS: The number of vertical virtual boundaries shall be in the range of 0 to 3");
       }
       for( unsigned i = 0; i < pcSPS->getNumVerVirtualBoundaries(); i++ )
       {
         WRITE_UVLC((pcSPS->getVirtualBoundariesPosX(i)>>3) - 1, "sps_virtual_boundary_pos_x_minus1[i]");
-        CHECK(((pcSPS->getVirtualBoundariesPosX(i)>>3) - 1) > (((pcSPS->getMaxPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_width_max_in_luma_samples / 8 ) - 2, inclusive.");
+        CHECK_VTM(((pcSPS->getVirtualBoundariesPosX(i)>>3) - 1) > (((pcSPS->getMaxPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_width_max_in_luma_samples / 8 ) - 2, inclusive.");
       }
       WRITE_UVLC(pcSPS->getNumHorVirtualBoundaries(), "sps_num_hor_virtual_boundaries");
       if (pcSPS->getMaxPicHeightInLumaSamples() <= 8)
       {
-        CHECK(pcSPS->getNumHorVirtualBoundaries() != 0, "SPS: When picture height is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
+        CHECK_VTM(pcSPS->getNumHorVirtualBoundaries() != 0, "SPS: When picture height is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
       }
       else
       {
-        CHECK(pcSPS->getNumHorVirtualBoundaries() > 3, "SPS: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
+        CHECK_VTM(pcSPS->getNumHorVirtualBoundaries() > 3, "SPS: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
       }
       for( unsigned i = 0; i < pcSPS->getNumHorVirtualBoundaries(); i++ )
       {
         WRITE_UVLC((pcSPS->getVirtualBoundariesPosY(i)>>3) - 1, "sps_virtual_boundary_pos_y_minus1[i]");
-        CHECK(((pcSPS->getVirtualBoundariesPosY(i)>>3) - 1) > (((pcSPS->getMaxPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_height_max_in_luma_samples / 8 ) - 2, inclusive.");
+        CHECK_VTM(((pcSPS->getVirtualBoundariesPosY(i)>>3) - 1) > (((pcSPS->getMaxPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_height_max_in_luma_samples / 8 ) - 2, inclusive.");
       }
     }
   }
@@ -1233,7 +1233,7 @@ void HLSWriter::codeSPS( const SPS* pcSPS )
     g_HLSTraceEnable = traceEnable;
 #endif
     unsigned vui_payload_data_num_bits = bs_count.getNumberOfWrittenBits();
-    CHECK( vui_payload_data_num_bits % 8 != 0, "Invalid number of VUI payload data bits" );
+    CHECK_VTM( vui_payload_data_num_bits % 8 != 0, "Invalid number of VUI payload data bits" );
     setBitstream(bs);
     WRITE_UVLC((vui_payload_data_num_bits >> 3) - 1, "sps_vui_payload_size_minus1");
     while (!isByteAligned())
@@ -1295,7 +1295,7 @@ void HLSWriter::codeSPS( const SPS* pcSPS )
           break;
         }
         default:
-          CHECK(sps_extension_flags[i]!=false, "Unknown PPS extension signalled"); // Should never get here with an active SPS extension flag.
+          CHECK_VTM(sps_extension_flags[i]!=false, "Unknown PPS extension signalled"); // Should never get here with an active SPS extension flag.
           break;
         }
       }
@@ -1310,7 +1310,7 @@ void HLSWriter::codeDCI(const DCI* dci)
 #endif
   WRITE_CODE(0, 4, "dci_reserved_zero_4bits");
   uint32_t numPTLs = (uint32_t)dci->getNumPTLs();
-  CHECK( (numPTLs < 1) || ( numPTLs > 15), "dci_num_plts_minus1 shall be in the range of 0 - 14");
+  CHECK_VTM( (numPTLs < 1) || ( numPTLs > 15), "dci_num_plts_minus1 shall be in the range of 0 - 14");
 
   WRITE_CODE(numPTLs - 1, 4, "dci_num_ptls_minus1");
 
@@ -1383,7 +1383,7 @@ void HLSWriter::codeVPS(const VPS* pcVPS)
         }
       }
     }
-    CHECK(pcVPS->getNumPtls() - 1 >= pcVPS->getTotalNumOLSs(), "vps_num_ptls_minus1 shall be less than TotalNumOlss");
+    CHECK_VTM(pcVPS->getNumPtls() - 1 >= pcVPS->getTotalNumOLSs(), "vps_num_ptls_minus1 shall be less than TotalNumOlss");
     WRITE_CODE(pcVPS->getNumPtls() - 1, 8, "vps_num_ptls_minus1");
   }
 
@@ -1398,7 +1398,7 @@ void HLSWriter::codeVPS(const VPS* pcVPS)
     }
     else 
     {
-      CHECK(pcVPS->getPtlMaxTemporalId(i) != pcVPS->getMaxSubLayers() - 1, "When vps_default_ptl_dpb_hrd_max_tid_flag is equal to 1, the value of vps_ptl_max_tid[ i ] is inferred to be equal to vps_max_sublayers_minus1");
+      CHECK_VTM(pcVPS->getPtlMaxTemporalId(i) != pcVPS->getMaxSubLayers() - 1, "When vps_default_ptl_dpb_hrd_max_tid_flag is equal to 1, the value of vps_ptl_max_tid[ i ] is inferred to be equal to vps_max_sublayers_minus1");
     }
   }
   int cnt = 0;
@@ -1407,7 +1407,7 @@ void HLSWriter::codeVPS(const VPS* pcVPS)
     WRITE_FLAG( 0, "vps_ptl_reserved_zero_bit");
     cnt++;
   }
-  CHECK(cnt>=8, "More than '8' alignment bytes written");
+  CHECK_VTM(cnt>=8, "More than '8' alignment bytes written");
   for (int i = 0; i < pcVPS->getNumPtls(); i++)
   {
     codeProfileTierLevel(&pcVPS->getProfileTierLevel(i), pcVPS->getPtPresentFlag(i), pcVPS->getPtlMaxTemporalId(i) - 1);
@@ -1435,12 +1435,12 @@ void HLSWriter::codeVPS(const VPS* pcVPS)
       }
       else
       {
-        CHECK(pcVPS->m_dpbMaxTemporalId[i] != pcVPS->getMaxSubLayers() - 1, "When vps_default_ptl_dpb_hrd_max_tid_flag is equal to 1, the value of vps_dpb_max_tid[ i ] is inferred to be equal to vps_max_sublayers_minus1");
+        CHECK_VTM(pcVPS->m_dpbMaxTemporalId[i] != pcVPS->getMaxSubLayers() - 1, "When vps_default_ptl_dpb_hrd_max_tid_flag is equal to 1, the value of vps_dpb_max_tid[ i ] is inferred to be equal to vps_max_sublayers_minus1");
       }
 
       for( int j = ( pcVPS->m_sublayerDpbParamsPresentFlag ? 0 : pcVPS->m_dpbMaxTemporalId[i] ); j <= pcVPS->m_dpbMaxTemporalId[i]; j++ )
       {
-        CHECK(pcVPS->m_dpbParameters[i].m_maxDecPicBuffering[j] < 1, "MaxDecPicBuffering must be greater than 0");
+        CHECK_VTM(pcVPS->m_dpbParameters[i].m_maxDecPicBuffering[j] < 1, "MaxDecPicBuffering must be greater than 0");
         WRITE_UVLC(pcVPS->m_dpbParameters[i].m_maxDecPicBuffering[j] - 1, "dpb_max_dec_pic_buffering_minus1[i]");
         WRITE_UVLC( pcVPS->m_dpbParameters[i].m_maxNumReorderPics[j], "dpb_max_num_reorder_pics[i]" );
         WRITE_UVLC( pcVPS->m_dpbParameters[i].m_maxLatencyIncreasePlus1[j], "dpb_max_latency_increase_plus1[i]" );
@@ -1457,7 +1457,7 @@ void HLSWriter::codeVPS(const VPS* pcVPS)
         const Profile::Name profile = pcVPS->getProfileTierLevel(pcVPS->getOlsPtlIdx(i)).getProfileIdc();
         if (profile != Profile::NONE)
         {
-          CHECK(pcVPS->m_olsDpbBitDepthMinus8[i] + 8 > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "vps_ols_dpb_bitdepth_minus8[ i ] exceeds range supported by signalled profile");
+          CHECK_VTM(pcVPS->m_olsDpbBitDepthMinus8[i] + 8 > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "vps_ols_dpb_bitdepth_minus8[ i ] exceeds range supported by signalled profile");
         }
         WRITE_UVLC( pcVPS->m_olsDpbBitDepthMinus8[i], "vps_ols_dpb_bitdepth_minus8[i]");
         if( (pcVPS->m_numDpbParams > 1) && (pcVPS->m_numDpbParams != pcVPS->m_numMultiLayeredOlss) )
@@ -1487,7 +1487,7 @@ void HLSWriter::codeVPS(const VPS* pcVPS)
       }
       else 
       {
-        CHECK(pcVPS->getHrdMaxTid(i) != pcVPS->getMaxSubLayers() - 1, "When vps_default_ptl_dpb_hrd_max_tid_flag is equal to 1, the value of vps_hrd_max_tid[ i ] is inferred to be equal to vps_max_sublayers_minus1");
+        CHECK_VTM(pcVPS->getHrdMaxTid(i) != pcVPS->getMaxSubLayers() - 1, "When vps_default_ptl_dpb_hrd_max_tid_flag is equal to 1, the value of vps_hrd_max_tid[ i ] is inferred to be equal to vps_max_sublayers_minus1");
       }
       uint32_t firstSublayer = pcVPS->getVPSSublayerCpbParamsPresentFlag() ? 0 : pcVPS->getHrdMaxTid(i);
       codeOlsHrdParameters(pcVPS->getGeneralHrdParameters(), pcVPS->getOlsHrdParameters(i),firstSublayer, pcVPS->getHrdMaxTid(i));
@@ -1535,9 +1535,9 @@ WRITE_FLAG(picHeader->getGdrOrIrapPicFlag(), "ph_gdr_or_irap_pic_flag");
   // parameter sets
   WRITE_UVLC(picHeader->getPPSId(), "ph_pic_parameter_set_id");
   pps = slice->getPPS();
-  CHECK(pps == 0, "Invalid PPS");
+  CHECK_VTM(pps == 0, "Invalid PPS");
   sps = slice->getSPS();
-  CHECK(sps == 0, "Invalid SPS");
+  CHECK_VTM(sps == 0, "Invalid SPS");
   int pocBits = slice->getSPS()->getBitsForPOC();
   int pocMask = (1 << pocBits) - 1;
   WRITE_CODE(slice->getPOC() & pocMask, pocBits, "ph_pic_order_cnt_lsb");
@@ -1670,30 +1670,30 @@ WRITE_FLAG(picHeader->getGdrOrIrapPicFlag(), "ph_gdr_or_irap_pic_flag");
       WRITE_UVLC(picHeader->getNumVerVirtualBoundaries(), "ph_num_ver_virtual_boundaries");
       if (pps->getPicWidthInLumaSamples() <= 8)
       {
-        CHECK(picHeader->getNumVerVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
+        CHECK_VTM(picHeader->getNumVerVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
       }
       else
       {
-        CHECK(picHeader->getNumVerVirtualBoundaries() > 3, "PH: The number of vertical virtual boundaries shall be in the range of 0 to 3");
+        CHECK_VTM(picHeader->getNumVerVirtualBoundaries() > 3, "PH: The number of vertical virtual boundaries shall be in the range of 0 to 3");
       }
       for( unsigned i = 0; i < picHeader->getNumVerVirtualBoundaries(); i++ )
       {
         WRITE_UVLC((picHeader->getVirtualBoundariesPosX(i) >> 3) - 1, "ph_virtual_boundary_pos_x_minus1[i]");
-        CHECK(((picHeader->getVirtualBoundariesPosX(i)>>3) - 1) > (((pps->getPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_width_in_luma_samples / 8 ) - 2, inclusive.");
+        CHECK_VTM(((picHeader->getVirtualBoundariesPosX(i)>>3) - 1) > (((pps->getPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_width_in_luma_samples / 8 ) - 2, inclusive.");
       }
       WRITE_UVLC(picHeader->getNumHorVirtualBoundaries(), "ph_num_hor_virtual_boundaries");
       if (pps->getPicHeightInLumaSamples() <= 8)
       {
-        CHECK(picHeader->getNumHorVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
+        CHECK_VTM(picHeader->getNumHorVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
       }
       else
       {
-        CHECK(picHeader->getNumHorVirtualBoundaries() > 3, "PH: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
+        CHECK_VTM(picHeader->getNumHorVirtualBoundaries() > 3, "PH: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
       }
       for( unsigned i = 0; i < picHeader->getNumHorVirtualBoundaries(); i++ )
       {
         WRITE_UVLC((picHeader->getVirtualBoundariesPosY(i)>>3) - 1, "ph_virtual_boundary_pos_y_minus1[i]");
-        CHECK(((picHeader->getVirtualBoundariesPosY(i)>>3) - 1) > (((pps->getPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_height_in_luma_samples / 8 ) - 2, inclusive.");
+        CHECK_VTM(((picHeader->getVirtualBoundariesPosY(i)>>3) - 1) > (((pps->getPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_height_in_luma_samples / 8 ) - 2, inclusive.");
       }
     }
     else
@@ -1742,13 +1742,13 @@ WRITE_FLAG(picHeader->getGdrOrIrapPicFlag(), "ph_gdr_or_irap_pic_flag");
       }
       else if(sps->getNumRPL(listIdx) == 0)
       {
-        CHECK(picHeader->getRPLIdx(listIdx) != -1, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
+        CHECK_VTM(picHeader->getRPLIdx(listIdx) != -1, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
       }
       else if(listIdx == 1)
       {
         auto rplsSpsFlag0 = picHeader->getRPLIdx(0) != -1 ? 1 : 0;
         auto rplsSpsFlag1 = picHeader->getRPLIdx(1) != -1 ? 1 : 0;
-        CHECK(rplsSpsFlag1 != rplsSpsFlag0, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
+        CHECK_VTM(rplsSpsFlag1 != rplsSpsFlag0, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
       }
 
       if(picHeader->getRPLIdx(listIdx) != -1)
@@ -1761,11 +1761,11 @@ WRITE_FLAG(picHeader->getGdrOrIrapPicFlag(), "ph_gdr_or_irap_pic_flag");
         }
         else if(sps->getNumRPL(listIdx) == 1)
         {
-          CHECK(picHeader->getRPLIdx(listIdx) != 0, "RPL1Idx is not signalled but it is not equal to 0");
+          CHECK_VTM(picHeader->getRPLIdx(listIdx) != 0, "RPL1Idx is not signalled but it is not equal to 0");
         }
         else
         {
-          CHECK(picHeader->getRPL1idx() != picHeader->getRPL0idx(), "RPL1Idx is not signalled but it is not the same as RPL0Idx");
+          CHECK_VTM(picHeader->getRPL1idx() != picHeader->getRPL0idx(), "RPL1Idx is not signalled but it is not the same as RPL0Idx");
         }
       }
       // explicit RPL in picture header
@@ -2152,7 +2152,7 @@ void HLSWriter::codeSliceHeader         ( Slice* pcSlice, PicHeader *picHeader )
   }
   if (!picHeader->getPicIntraSliceAllowedFlag())
   {
-    CHECK(pcSlice->getSliceType() == I_SLICE, "when ph_intra_slice_allowed_flag = 0, no I_Slice is allowed");
+    CHECK_VTM(pcSlice->getSliceType() == I_SLICE, "when ph_intra_slice_allowed_flag = 0, no I_Slice is allowed");
   }
 
   if (pcSlice->getSPS()->getALFEnabledFlag() && !pcSlice->getPPS()->getAlfInfoInPhFlag())
@@ -2260,13 +2260,13 @@ void HLSWriter::codeSliceHeader         ( Slice* pcSlice, PicHeader *picHeader )
       }
       else if (pcSlice->getSPS()->getNumRPL1() == 0)
       {
-        CHECK(pcSlice->getRPL1idx() != -1, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
+        CHECK_VTM(pcSlice->getRPL1idx() != -1, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
       }
       else
       {
         auto rplsSpsFlag0 = pcSlice->getRPL0idx() != -1 ? 1 : 0;
         auto rplsSpsFlag1 = pcSlice->getRPL1idx() != -1 ? 1 : 0;
-        CHECK(rplsSpsFlag1 != rplsSpsFlag0, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
+        CHECK_VTM(rplsSpsFlag1 != rplsSpsFlag0, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
       }
 
       if (pcSlice->getRPL1idx() != -1)
@@ -2282,11 +2282,11 @@ void HLSWriter::codeSliceHeader         ( Slice* pcSlice, PicHeader *picHeader )
         }
         else if (pcSlice->getSPS()->getNumRPL1() == 1)
         {
-          CHECK(pcSlice->getRPL1idx() != 0, "RPL1Idx is not signalled but it is not equal to 0");
+          CHECK_VTM(pcSlice->getRPL1idx() != 0, "RPL1Idx is not signalled but it is not equal to 0");
         }
         else
         {
-          CHECK(pcSlice->getRPL1idx() != pcSlice->getRPL0idx(), "RPL1Idx is not signalled but it is not the same as RPL0Idx");
+          CHECK_VTM(pcSlice->getRPL1idx() != pcSlice->getRPL0idx(), "RPL1Idx is not signalled but it is not the same as RPL0Idx");
         }
       }
       else
@@ -2413,7 +2413,7 @@ void HLSWriter::codeSliceHeader         ( Slice* pcSlice, PicHeader *picHeader )
           WRITE_SVLC( pcSlice->getSliceChromaQpDelta(JOINT_CbCr), "sh_joint_cbcr_qp_offset");
         }
       }
-      CHECK(numberValidComponents < COMPONENT_Cr+1, "Too many valid components");
+      CHECK_VTM(numberValidComponents < COMPONENT_Cr+1, "Too many valid components");
     }
 
     if (pcSlice->getPPS()->getCuChromaQpOffsetListEnabledFlag())
@@ -2690,7 +2690,7 @@ void  HLSWriter::codeTilesWPPEntryPoint( Slice* pSlice )
   while (maxOffset >= (1u << (offsetLenMinus1 + 1)))
   {
     offsetLenMinus1++;
-    CHECK(offsetLenMinus1 + 1 >= 32, "Invalid offset length minus 1");
+    CHECK_VTM(offsetLenMinus1 + 1 >= 32, "Invalid offset length minus 1");
   }
 
   if (pSlice->getNumberOfSubstreamSizes()>0)
@@ -2737,7 +2737,7 @@ void HLSWriter::xCodePredWeightTable( Slice* pcSlice )
 
           if( bChroma )
           {
-            CHECK(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
+            CHECK_VTM(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
                   "Chroma blocks of different size not supported");
             iDeltaDenom = (wp[COMPONENT_Cb].log2WeightDenom - wp[COMPONENT_Y].log2WeightDenom);
             WRITE_SVLC( iDeltaDenom, "delta_chroma_log2_weight_denom" );
@@ -2752,7 +2752,7 @@ void HLSWriter::xCodePredWeightTable( Slice* pcSlice )
         for ( int iRefIdx=0 ; iRefIdx<pcSlice->getNumRefIdx(eRefPicList) ; iRefIdx++ )
         {
           wp = pcSlice->getWpScaling(eRefPicList, iRefIdx);
-          CHECK(wp[COMPONENT_Cb].presentFlag != wp[COMPONENT_Cr].presentFlag,
+          CHECK_VTM(wp[COMPONENT_Cb].presentFlag != wp[COMPONENT_Cr].presentFlag,
                 "Inconsistent settings for chroma channels");
           WRITE_FLAG(wp[COMPONENT_Cb].presentFlag,
                      iNumRef == 0 ? "chroma_weight_l0_flag[i]" : "chroma_weight_l1_flag[i]");
@@ -2776,7 +2776,7 @@ void HLSWriter::xCodePredWeightTable( Slice* pcSlice )
           {
             for ( int j = COMPONENT_Cb ; j < numberValidComponents ; j++ )
             {
-              CHECK(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
+              CHECK_VTM(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
                     "Chroma blocks of different size not supported");
               int iDeltaWeight = (wp[j].codedWeight - (1 << wp[COMPONENT_Cb].log2WeightDenom));
               WRITE_SVLC( iDeltaWeight, iNumRef==0?"delta_chroma_weight_l0[i]":"delta_chroma_weight_l1[i]" );
@@ -2790,7 +2790,7 @@ void HLSWriter::xCodePredWeightTable( Slice* pcSlice )
         }
       }
     }
-    CHECK(uiTotalSignalledWeightFlags>24, "Too many signalled weight flags");
+    CHECK_VTM(uiTotalSignalledWeightFlags>24, "Too many signalled weight flags");
   }
 }
 
@@ -2820,7 +2820,7 @@ void HLSWriter::xCodePredWeightTable(PicHeader *picHeader, const SPS *sps)
 
         if (chroma)
         {
-          CHECK(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
+          CHECK_VTM(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
                 "Chroma blocks of different size not supported");
           deltaDenom = (wp[COMPONENT_Cb].log2WeightDenom - wp[COMPONENT_Y].log2WeightDenom);
           WRITE_SVLC(deltaDenom, "delta_chroma_log2_weight_denom");
@@ -2835,7 +2835,7 @@ void HLSWriter::xCodePredWeightTable(PicHeader *picHeader, const SPS *sps)
       for (int refIdx = 0; refIdx < numLxWeights; refIdx++)
       {
         wp = picHeader->getWpScaling(refPicList, refIdx);
-        CHECK(wp[COMPONENT_Cb].presentFlag != wp[COMPONENT_Cr].presentFlag,
+        CHECK_VTM(wp[COMPONENT_Cb].presentFlag != wp[COMPONENT_Cr].presentFlag,
               "Inconsistent settings for chroma channels");
         WRITE_FLAG(wp[COMPONENT_Cb].presentFlag, numRef == 0 ? "chroma_weight_l0_flag[i]" : "chroma_weight_l1_flag[i]");
         totalSignalledWeightFlags += 2 * wp[COMPONENT_Cb].presentFlag;
@@ -2858,7 +2858,7 @@ void HLSWriter::xCodePredWeightTable(PicHeader *picHeader, const SPS *sps)
         {
           for (int j = COMPONENT_Cb; j < numberValidComponents; j++)
           {
-            CHECK(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
+            CHECK_VTM(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
                   "Chroma blocks of different size not supported");
             int deltaWeight = (wp[j].codedWeight - (1 << wp[COMPONENT_Cb].log2WeightDenom));
             WRITE_SVLC(deltaWeight, numRef == 0 ? "delta_chroma_weight_l0[i]" : "delta_chroma_weight_l1[i]");
@@ -2881,7 +2881,7 @@ void HLSWriter::xCodePredWeightTable(PicHeader *picHeader, const SPS *sps)
       moreSyntaxToBeParsed = (numLxWeights == 0) ? false : true;
     }
   }
-  CHECK(totalSignalledWeightFlags > 24, "Too many signalled weight flags");
+  CHECK_VTM(totalSignalledWeightFlags > 24, "Too many signalled weight flags");
 }
 
 /** code quantization matrix
diff --git a/source/Lib/EncoderLib/WeightPredAnalysis.cpp b/source/Lib/EncoderLib/WeightPredAnalysis.cpp
index 6db6870..d89e90b 100644
--- a/source/Lib/EncoderLib/WeightPredAnalysis.cpp
+++ b/source/Lib/EncoderLib/WeightPredAnalysis.cpp
@@ -108,7 +108,7 @@ void xScaleHistogram(const std::vector<int> &histogramInput,
                      const int               offset,
                      const bool              bHighPrecision)
 {
-  CHECK(&histogramInput == &histogramOutput, "Input and output histogram are the same");
+  CHECK_VTM(&histogramInput == &histogramOutput, "Input and output histogram are the same");
   const int numElements=int(histogramInput.size());
   histogramOutput.clear();
   histogramOutput.resize(numElements);
@@ -133,7 +133,7 @@ Distortion xCalcHistCumulDistortion(const std::vector<int>& histogram0,
   const std::vector<int>& histogram1)
 {
   Distortion distortion = 0;
-  CHECK(histogram0.size() != histogram1.size(), "Different histogram sizes");
+  CHECK_VTM(histogram0.size() != histogram1.size(), "Different histogram sizes");
   const int numElements = int(histogram0.size());
 
   int64_t  cumul = 0;
@@ -408,7 +408,7 @@ bool WeightPredAnalysis::xUpdatingWPParameters(Slice *const slice, const int log
   const bool bUseHighPrecisionWeighting = slice->getSPS()->getSpsRangeExtension().getHighPrecisionOffsetsEnabledFlag();
   const int numPredDir                  = slice->isInterP() ? 1 : 2;
 
-  CHECK(numPredDir > int(NUM_REF_PIC_LIST_01), "Invalid reference picture list");
+  CHECK_VTM(numPredDir > int(NUM_REF_PIC_LIST_01), "Invalid reference picture list");
 
   for ( int refList = 0; refList < numPredDir; refList++ )
   {
@@ -486,7 +486,7 @@ bool WeightPredAnalysis::xSelectWPHistExtClip(Slice *const slice, const int log2
   const int               numPredDir       = slice->isInterP() ? 1 : 2;
   const bool              useHighPrecision = slice->getSPS()->getSpsRangeExtension().getHighPrecisionOffsetsEnabledFlag();
 
-  CHECK(numPredDir > int(NUM_REF_PIC_LIST_01), "Invalid reference picture list");
+  CHECK_VTM(numPredDir > int(NUM_REF_PIC_LIST_01), "Invalid reference picture list");
 
   for ( int refList = 0; refList < numPredDir; refList++ )
   {
@@ -649,7 +649,7 @@ bool WeightPredAnalysis::xSelectWP(Slice *const slice, const int log2Denom)
   const int               numPredDir                          = slice->isInterP() ? 1 : 2;
   const bool              useHighPrecisionPredictionWeighting = slice->getSPS()->getSpsRangeExtension().getHighPrecisionOffsetsEnabledFlag();
 
-  CHECK(numPredDir > int(NUM_REF_PIC_LIST_01), "Invalid reference picture list");
+  CHECK_VTM(numPredDir > int(NUM_REF_PIC_LIST_01), "Invalid reference picture list");
 
   for ( int refList = 0; refList < numPredDir; refList++ )
   {
diff --git a/source/Lib/Utilities/VideoIOYuv.cpp b/source/Lib/Utilities/VideoIOYuv.cpp
index 9eec0c1..260aefb 100644
--- a/source/Lib/Utilities/VideoIOYuv.cpp
+++ b/source/Lib/Utilities/VideoIOYuv.cpp
@@ -472,7 +472,7 @@ static bool writePlane( uint32_t orgWidth, uint32_t orgHeight, ostream& fd, cons
   const uint32_t height_file = height444 >> csy_file;
   const bool     writePYUV   = (packedYUVOutputMode > 0) && (fileBitDepth == 10 || fileBitDepth == 12) && ((width_file & (1 + (fileBitDepth & 3))) == 0);
 
-  CHECK( csx_file != csx_src, "Not supported" );
+  CHECK_VTM( csx_file != csx_src, "Not supported" );
   const uint32_t stride_file = writePYUV ? ( orgWidth * fileBitDepth ) >> ( csx_file + 3 ) : ( orgWidth * ( is16bit ? 2 : 1 ) ) >> csx_file;
 
   std::vector<uint8_t> bufVec(stride_file);
@@ -1142,7 +1142,7 @@ bool VideoIOYuv::write( const CPelUnitBuf& picTop, const CPelUnitBuf& picBottom,
   const CPelUnitBuf& picBottomO  = nonZeroBitDepthShift ? picBottomZ : picBottomC;
 
   bool retval = true;
-  CHECK( picTopO.chromaFormat != picBottomO.chromaFormat, "Incompatible formats of bottom and top fields" );
+  CHECK_VTM( picTopO.chromaFormat != picBottomO.chromaFormat, "Incompatible formats of bottom and top fields" );
 
   const ChromaFormat dstChrFormat = picTopO.chromaFormat;
   for (uint32_t comp = 0; retval && comp < ::getNumberValidComponents(dstChrFormat); comp++)
@@ -1155,9 +1155,9 @@ bool VideoIOYuv::write( const CPelUnitBuf& picTop, const CPelUnitBuf& picBottom,
     const uint32_t    width444   = areaTopY.width  - (confLeft + confRight);
     const uint32_t    height444  = areaTopY.height - (confTop + confBottom);
 
-    CHECK(areaTop.width  != areaBottom.width , "Incompatible formats");
-    CHECK(areaTop.height != areaBottom.height, "Incompatible formats");
-    CHECK(areaTop.stride != areaBottom.stride, "Incompatible formats");
+    CHECK_VTM(areaTop.width  != areaBottom.width , "Incompatible formats");
+    CHECK_VTM(areaTop.height != areaBottom.height, "Incompatible formats");
+    CHECK_VTM(areaTop.stride != areaBottom.stride, "Incompatible formats");
 
     if ((width444 == 0) || (height444 == 0))
     {
@@ -1196,7 +1196,7 @@ void VideoIOYuv::ColourSpaceConvert(const CPelUnitBuf &src, PelUnitBuf &dest, co
       if (format!=CHROMA_444)
       {
         // only 444 is handled.
-        CHECK( format != CHROMA_444, "Chroma format other than 444 not supported" );
+        CHECK_VTM( format != CHROMA_444, "Chroma format other than 444 not supported" );
       }
 
       {
@@ -1220,7 +1220,7 @@ void VideoIOYuv::ColourSpaceConvert(const CPelUnitBuf &src, PelUnitBuf &dest, co
         if (format!=CHROMA_444)
         {
           // only 444 is handled.
-          CHECK(format!=CHROMA_444, "Chroma format other than 444 not supported");
+          CHECK_VTM(format!=CHROMA_444, "Chroma format other than 444 not supported");
         }
 
         // channel re-mapping
