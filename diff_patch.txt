Only in ../VVCSoftware_10: bin
Only in ../VVCSoftware_10: build
diff -rwu ../vtm10_original/VVCSoftware_VTM/cfg/encoder_intra_vtm.cfg ../VVCSoftware_10/cfg/encoder_intra_vtm.cfg
--- ../vtm10_original/VVCSoftware_VTM/cfg/encoder_intra_vtm.cfg	2022-09-16 14:27:06.092533236 +0200
+++ ../VVCSoftware_10/cfg/encoder_intra_vtm.cfg	2022-09-14 14:33:17.257811082 +0200
@@ -1,3 +1,7 @@
+#======== Extra Settings ===============
+PredictPartition              : 1
+# WritePartition                : 1
+# ReadPartition                 : 1
 #======== File I/O =====================
 BitstreamFile                 : str.bin
 ReconFile                     : rec.yuv
diff -rwu ../vtm10_original/VVCSoftware_VTM/cfg/encoder_randomaccess_vtm.cfg ../VVCSoftware_10/cfg/encoder_randomaccess_vtm.cfg
--- ../vtm10_original/VVCSoftware_VTM/cfg/encoder_randomaccess_vtm.cfg	2022-09-16 14:27:06.092533236 +0200
+++ ../VVCSoftware_10/cfg/encoder_randomaccess_vtm.cfg	2022-05-20 14:24:32.885421754 +0200
@@ -1,6 +1,9 @@
 #======== File I/O =====================
 BitstreamFile                 : str.bin
-ReconFile                     : rec.yuv
+# ReconFile                     : rec.yuv
+# WritePartition                : 1
+# PredictPartition                : 1
+PredictPartitionInter           : 1
 
 #======== Profile ================
 Profile                       : auto
Only in ../VVCSoftware_10: cmake-build-debug
diff -rwu ../vtm10_original/VVCSoftware_VTM/CMakeLists.txt ../VVCSoftware_10/CMakeLists.txt
--- ../vtm10_original/VVCSoftware_VTM/CMakeLists.txt	2022-09-16 14:27:06.092533236 +0200
+++ ../VVCSoftware_10/CMakeLists.txt	2022-09-16 14:23:57.126678483 +0200
@@ -1,6 +1,10 @@
 # minimum required cmake version
 cmake_minimum_required( VERSION 3.5 FATAL_ERROR )
 
+include_directories(LGBM_DIRECTORY_HERE/LightGBM/include)
+link_directories(LGBM_DIRECTORY_HERE/LightGBM)
+link_libraries(_lightgbm)
+
 # project name
 if( EXTENSION_360_VIDEO )
   project( NextSoftware360 )
@@ -37,7 +41,7 @@
 endif()
 
 # set c++11
-set( CMAKE_CXX_STANDARD 11 )
+set( CMAKE_CXX_STANDARD 14 )
 set( CMAKE_CXX_STANDARD_REQUIRED ON )
 
 # compile everything position independent (even static libraries)
@@ -75,6 +79,9 @@
 # for gcc 8.2:
 bb_enable_warnings( gcc warnings-as-errors -Wno-sign-compare -Wno-class-memaccess)
 
+# Added by Souhaiel
+bb_enable_warnings( gcc -Wno-unknown-pragmas )
+
 if( XCODE )
   bb_enable_warnings( clang warnings-as-errors
                             -Wno-deprecated-declarations
@@ -93,6 +100,7 @@
 endif()
 #bb_enable_warnings( clang warnings-as-errors )
 
+
 # enable warnings
 bb_enable_warnings( msvc warnings-as-errors "/wd4996" )
 
Only in ../VVCSoftware_10/.git: COMMIT_EDITMSG
diff -rwu ../vtm10_original/VVCSoftware_VTM/.git/config ../VVCSoftware_10/.git/config
--- ../vtm10_original/VVCSoftware_VTM/.git/config	2022-09-16 14:26:03.361244379 +0200
+++ ../VVCSoftware_10/.git/config	2022-06-07 09:50:16.902072137 +0200
@@ -4,7 +4,7 @@
 	bare = false
 	logallrefupdates = true
 [remote "origin"]
-	url = https://vcgit.hhi.fraunhofer.de/jvet/VVCSoftware_VTM.git
+	url = ssh://git@gitlab.insa-rennes.fr:16022/Souhaiel.Belhadj-Dit-Mdalsi/vtm10_inter.git
 	fetch = +refs/heads/*:refs/remotes/origin/*
 [branch "master"]
 	remote = origin
diff -rwu ../vtm10_original/VVCSoftware_VTM/.git/FETCH_HEAD ../VVCSoftware_10/.git/FETCH_HEAD
--- ../vtm10_original/VVCSoftware_VTM/.git/FETCH_HEAD	2022-09-16 14:27:24.352326397 +0200
+++ ../VVCSoftware_10/.git/FETCH_HEAD	2022-06-14 15:57:37.609016276 +0200
@@ -1 +1 @@
-ee9643e94c40da1fc211617606423401a61c52a2	not-for-merge	branch 'master' of https://vcgit.hhi.fraunhofer.de/jvet/VVCSoftware_VTM
+ad03791de6f141162dd1b26b7553fb172d1a0d94		branch 'master' of ssh://gitlab.insa-rennes.fr:16022/Souhaiel.Belhadj-Dit-Mdalsi/vtm10_inter
diff -rwu ../vtm10_original/VVCSoftware_VTM/.git/HEAD ../VVCSoftware_10/.git/HEAD
--- ../vtm10_original/VVCSoftware_VTM/.git/HEAD	2022-09-16 14:27:06.160532464 +0200
+++ ../VVCSoftware_10/.git/HEAD	2022-06-07 09:42:50.534095199 +0200
@@ -1 +1 @@
-7abf654d22a0b6a9b8f7d210a7f30c4e7fa99757
+ref: refs/heads/master
Binary files ../vtm10_original/VVCSoftware_VTM/.git/index and ../VVCSoftware_10/.git/index differ
diff -rwu ../vtm10_original/VVCSoftware_VTM/.git/logs/HEAD ../VVCSoftware_10/.git/logs/HEAD
--- ../vtm10_original/VVCSoftware_VTM/.git/logs/HEAD	2022-09-16 14:27:06.160532464 +0200
+++ ../VVCSoftware_10/.git/logs/HEAD	2022-09-14 14:34:54.617183002 +0200
@@ -1,2 +1,5 @@
-0000000000000000000000000000000000000000 ee9643e94c40da1fc211617606423401a61c52a2 Belhadj Dit Mdalsi Souhaiel <souhaiel.belhadj-dit-mdalsi@insa-rennes.fr> 1663331163 +0200	clone: from https://vcgit.hhi.fraunhofer.de/jvet/VVCSoftware_VTM.git
-ee9643e94c40da1fc211617606423401a61c52a2 7abf654d22a0b6a9b8f7d210a7f30c4e7fa99757 Belhadj Dit Mdalsi Souhaiel <souhaiel.belhadj-dit-mdalsi@insa-rennes.fr> 1663331226 +0200	checkout: moving from master to 7abf654d22a0b6a9b8f7d210a7f30c4e7fa99757
+0000000000000000000000000000000000000000 d124e83212250321e7f71f8deded59d88bf277fb Belhadj Dit Mdalsi Souhaiel <souhaiel.belhadj-dit-mdalsi@insa-rennes.fr> 1654588189 +0200	commit (initial): first commit
+d124e83212250321e7f71f8deded59d88bf277fb ad03791de6f141162dd1b26b7553fb172d1a0d94 Belhadj Dit Mdalsi Souhaiel <souhaiel.belhadj-dit-mdalsi@insa-rennes.fr> 1654691197 +0200	commit: using sou model
+ad03791de6f141162dd1b26b7553fb172d1a0d94 cffb1b9b87eb2f88d4af4386e0cbf57807527d92 Belhadj Dit Mdalsi Souhaiel <souhaiel.belhadj-dit-mdalsi@insa-rennes.fr> 1661938219 +0200	commit: intra model unfiltered
+cffb1b9b87eb2f88d4af4386e0cbf57807527d92 dd369795cd0e36e5434a6d2e3b451b929eff1063 Belhadj Dit Mdalsi Souhaiel <souhaiel.belhadj-dit-mdalsi@insa-rennes.fr> 1662630702 +0200	commit: intra model filtered test
+dd369795cd0e36e5434a6d2e3b451b929eff1063 3031b3c794057d76b1b2367c1bcd288a58aacde2 Belhadj Dit Mdalsi Souhaiel <souhaiel.belhadj-dit-mdalsi@insa-rennes.fr> 1663158894 +0200	commit: intra model slide
diff -rwu ../vtm10_original/VVCSoftware_VTM/.git/logs/refs/heads/master ../VVCSoftware_10/.git/logs/refs/heads/master
--- ../vtm10_original/VVCSoftware_VTM/.git/logs/refs/heads/master	2022-09-16 14:26:03.361244379 +0200
+++ ../VVCSoftware_10/.git/logs/refs/heads/master	2022-09-14 14:34:54.617183002 +0200
@@ -1 +1,5 @@
-0000000000000000000000000000000000000000 ee9643e94c40da1fc211617606423401a61c52a2 Belhadj Dit Mdalsi Souhaiel <souhaiel.belhadj-dit-mdalsi@insa-rennes.fr> 1663331163 +0200	clone: from https://vcgit.hhi.fraunhofer.de/jvet/VVCSoftware_VTM.git
+0000000000000000000000000000000000000000 d124e83212250321e7f71f8deded59d88bf277fb Belhadj Dit Mdalsi Souhaiel <souhaiel.belhadj-dit-mdalsi@insa-rennes.fr> 1654588189 +0200	commit (initial): first commit
+d124e83212250321e7f71f8deded59d88bf277fb ad03791de6f141162dd1b26b7553fb172d1a0d94 Belhadj Dit Mdalsi Souhaiel <souhaiel.belhadj-dit-mdalsi@insa-rennes.fr> 1654691197 +0200	commit: using sou model
+ad03791de6f141162dd1b26b7553fb172d1a0d94 cffb1b9b87eb2f88d4af4386e0cbf57807527d92 Belhadj Dit Mdalsi Souhaiel <souhaiel.belhadj-dit-mdalsi@insa-rennes.fr> 1661938219 +0200	commit: intra model unfiltered
+cffb1b9b87eb2f88d4af4386e0cbf57807527d92 dd369795cd0e36e5434a6d2e3b451b929eff1063 Belhadj Dit Mdalsi Souhaiel <souhaiel.belhadj-dit-mdalsi@insa-rennes.fr> 1662630702 +0200	commit: intra model filtered test
+dd369795cd0e36e5434a6d2e3b451b929eff1063 3031b3c794057d76b1b2367c1bcd288a58aacde2 Belhadj Dit Mdalsi Souhaiel <souhaiel.belhadj-dit-mdalsi@insa-rennes.fr> 1663158894 +0200	commit: intra model slide
Only in ../vtm10_original/VVCSoftware_VTM/.git/logs/refs/remotes/origin: HEAD
Only in ../VVCSoftware_10/.git/logs/refs/remotes/origin: master
Only in ../VVCSoftware_10/.git/objects: 00
Only in ../VVCSoftware_10/.git/objects: 01
Only in ../VVCSoftware_10/.git/objects: 02
Only in ../VVCSoftware_10/.git/objects: 03
Only in ../VVCSoftware_10/.git/objects: 04
Only in ../VVCSoftware_10/.git/objects: 05
Only in ../VVCSoftware_10/.git/objects: 06
Only in ../VVCSoftware_10/.git/objects: 07
Only in ../VVCSoftware_10/.git/objects: 08
Only in ../VVCSoftware_10/.git/objects: 09
Only in ../VVCSoftware_10/.git/objects: 0a
Only in ../VVCSoftware_10/.git/objects: 0b
Only in ../VVCSoftware_10/.git/objects: 0c
Only in ../VVCSoftware_10/.git/objects: 0d
Only in ../VVCSoftware_10/.git/objects: 0e
Only in ../VVCSoftware_10/.git/objects: 0f
Only in ../VVCSoftware_10/.git/objects: 10
Only in ../VVCSoftware_10/.git/objects: 11
Only in ../VVCSoftware_10/.git/objects: 12
Only in ../VVCSoftware_10/.git/objects: 13
Only in ../VVCSoftware_10/.git/objects: 14
Only in ../VVCSoftware_10/.git/objects: 15
Only in ../VVCSoftware_10/.git/objects: 16
Only in ../VVCSoftware_10/.git/objects: 17
Only in ../VVCSoftware_10/.git/objects: 18
Only in ../VVCSoftware_10/.git/objects: 19
Only in ../VVCSoftware_10/.git/objects: 1a
Only in ../VVCSoftware_10/.git/objects: 1b
Only in ../VVCSoftware_10/.git/objects: 1c
Only in ../VVCSoftware_10/.git/objects: 1d
Only in ../VVCSoftware_10/.git/objects: 1e
Only in ../VVCSoftware_10/.git/objects: 1f
Only in ../VVCSoftware_10/.git/objects: 20
Only in ../VVCSoftware_10/.git/objects: 21
Only in ../VVCSoftware_10/.git/objects: 22
Only in ../VVCSoftware_10/.git/objects: 23
Only in ../VVCSoftware_10/.git/objects: 24
Only in ../VVCSoftware_10/.git/objects: 25
Only in ../VVCSoftware_10/.git/objects: 26
Only in ../VVCSoftware_10/.git/objects: 27
Only in ../VVCSoftware_10/.git/objects: 28
Only in ../VVCSoftware_10/.git/objects: 29
Only in ../VVCSoftware_10/.git/objects: 2a
Only in ../VVCSoftware_10/.git/objects: 2b
Only in ../VVCSoftware_10/.git/objects: 2c
Only in ../VVCSoftware_10/.git/objects: 2d
Only in ../VVCSoftware_10/.git/objects: 2f
Only in ../VVCSoftware_10/.git/objects: 30
Only in ../VVCSoftware_10/.git/objects: 31
Only in ../VVCSoftware_10/.git/objects: 32
Only in ../VVCSoftware_10/.git/objects: 33
Only in ../VVCSoftware_10/.git/objects: 34
Only in ../VVCSoftware_10/.git/objects: 35
Only in ../VVCSoftware_10/.git/objects: 36
Only in ../VVCSoftware_10/.git/objects: 37
Only in ../VVCSoftware_10/.git/objects: 38
Only in ../VVCSoftware_10/.git/objects: 39
Only in ../VVCSoftware_10/.git/objects: 3a
Only in ../VVCSoftware_10/.git/objects: 3b
Only in ../VVCSoftware_10/.git/objects: 3c
Only in ../VVCSoftware_10/.git/objects: 3d
Only in ../VVCSoftware_10/.git/objects: 3e
Only in ../VVCSoftware_10/.git/objects: 3f
Only in ../VVCSoftware_10/.git/objects: 40
Only in ../VVCSoftware_10/.git/objects: 41
Only in ../VVCSoftware_10/.git/objects: 42
Only in ../VVCSoftware_10/.git/objects: 43
Only in ../VVCSoftware_10/.git/objects: 44
Only in ../VVCSoftware_10/.git/objects: 45
Only in ../VVCSoftware_10/.git/objects: 46
Only in ../VVCSoftware_10/.git/objects: 47
Only in ../VVCSoftware_10/.git/objects: 48
Only in ../VVCSoftware_10/.git/objects: 49
Only in ../VVCSoftware_10/.git/objects: 4a
Only in ../VVCSoftware_10/.git/objects: 4b
Only in ../VVCSoftware_10/.git/objects: 4c
Only in ../VVCSoftware_10/.git/objects: 4d
Only in ../VVCSoftware_10/.git/objects: 4e
Only in ../VVCSoftware_10/.git/objects: 4f
Only in ../VVCSoftware_10/.git/objects: 50
Only in ../VVCSoftware_10/.git/objects: 51
Only in ../VVCSoftware_10/.git/objects: 52
Only in ../VVCSoftware_10/.git/objects: 54
Only in ../VVCSoftware_10/.git/objects: 55
Only in ../VVCSoftware_10/.git/objects: 56
Only in ../VVCSoftware_10/.git/objects: 57
Only in ../VVCSoftware_10/.git/objects: 58
Only in ../VVCSoftware_10/.git/objects: 59
Only in ../VVCSoftware_10/.git/objects: 5a
Only in ../VVCSoftware_10/.git/objects: 5b
Only in ../VVCSoftware_10/.git/objects: 5c
Only in ../VVCSoftware_10/.git/objects: 5d
Only in ../VVCSoftware_10/.git/objects: 5e
Only in ../VVCSoftware_10/.git/objects: 5f
Only in ../VVCSoftware_10/.git/objects: 60
Only in ../VVCSoftware_10/.git/objects: 61
Only in ../VVCSoftware_10/.git/objects: 62
Only in ../VVCSoftware_10/.git/objects: 63
Only in ../VVCSoftware_10/.git/objects: 64
Only in ../VVCSoftware_10/.git/objects: 65
Only in ../VVCSoftware_10/.git/objects: 66
Only in ../VVCSoftware_10/.git/objects: 67
Only in ../VVCSoftware_10/.git/objects: 68
Only in ../VVCSoftware_10/.git/objects: 69
Only in ../VVCSoftware_10/.git/objects: 6a
Only in ../VVCSoftware_10/.git/objects: 6b
Only in ../VVCSoftware_10/.git/objects: 6c
Only in ../VVCSoftware_10/.git/objects: 6d
Only in ../VVCSoftware_10/.git/objects: 6e
Only in ../VVCSoftware_10/.git/objects: 6f
Only in ../VVCSoftware_10/.git/objects: 70
Only in ../VVCSoftware_10/.git/objects: 71
Only in ../VVCSoftware_10/.git/objects: 72
Only in ../VVCSoftware_10/.git/objects: 73
Only in ../VVCSoftware_10/.git/objects: 74
Only in ../VVCSoftware_10/.git/objects: 75
Only in ../VVCSoftware_10/.git/objects: 76
Only in ../VVCSoftware_10/.git/objects: 77
Only in ../VVCSoftware_10/.git/objects: 78
Only in ../VVCSoftware_10/.git/objects: 79
Only in ../VVCSoftware_10/.git/objects: 7a
Only in ../VVCSoftware_10/.git/objects: 7b
Only in ../VVCSoftware_10/.git/objects: 7c
Only in ../VVCSoftware_10/.git/objects: 7d
Only in ../VVCSoftware_10/.git/objects: 7e
Only in ../VVCSoftware_10/.git/objects: 7f
Only in ../VVCSoftware_10/.git/objects: 80
Only in ../VVCSoftware_10/.git/objects: 81
Only in ../VVCSoftware_10/.git/objects: 82
Only in ../VVCSoftware_10/.git/objects: 83
Only in ../VVCSoftware_10/.git/objects: 84
Only in ../VVCSoftware_10/.git/objects: 85
Only in ../VVCSoftware_10/.git/objects: 86
Only in ../VVCSoftware_10/.git/objects: 87
Only in ../VVCSoftware_10/.git/objects: 88
Only in ../VVCSoftware_10/.git/objects: 89
Only in ../VVCSoftware_10/.git/objects: 8a
Only in ../VVCSoftware_10/.git/objects: 8b
Only in ../VVCSoftware_10/.git/objects: 8c
Only in ../VVCSoftware_10/.git/objects: 8d
Only in ../VVCSoftware_10/.git/objects: 8e
Only in ../VVCSoftware_10/.git/objects: 8f
Only in ../VVCSoftware_10/.git/objects: 90
Only in ../VVCSoftware_10/.git/objects: 91
Only in ../VVCSoftware_10/.git/objects: 93
Only in ../VVCSoftware_10/.git/objects: 94
Only in ../VVCSoftware_10/.git/objects: 95
Only in ../VVCSoftware_10/.git/objects: 96
Only in ../VVCSoftware_10/.git/objects: 97
Only in ../VVCSoftware_10/.git/objects: 99
Only in ../VVCSoftware_10/.git/objects: 9a
Only in ../VVCSoftware_10/.git/objects: 9b
Only in ../VVCSoftware_10/.git/objects: 9c
Only in ../VVCSoftware_10/.git/objects: 9d
Only in ../VVCSoftware_10/.git/objects: 9e
Only in ../VVCSoftware_10/.git/objects: 9f
Only in ../VVCSoftware_10/.git/objects: a0
Only in ../VVCSoftware_10/.git/objects: a1
Only in ../VVCSoftware_10/.git/objects: a2
Only in ../VVCSoftware_10/.git/objects: a3
Only in ../VVCSoftware_10/.git/objects: a4
Only in ../VVCSoftware_10/.git/objects: a5
Only in ../VVCSoftware_10/.git/objects: a6
Only in ../VVCSoftware_10/.git/objects: a7
Only in ../VVCSoftware_10/.git/objects: a8
Only in ../VVCSoftware_10/.git/objects: a9
Only in ../VVCSoftware_10/.git/objects: aa
Only in ../VVCSoftware_10/.git/objects: ab
Only in ../VVCSoftware_10/.git/objects: ac
Only in ../VVCSoftware_10/.git/objects: ad
Only in ../VVCSoftware_10/.git/objects: ae
Only in ../VVCSoftware_10/.git/objects: af
Only in ../VVCSoftware_10/.git/objects: b0
Only in ../VVCSoftware_10/.git/objects: b2
Only in ../VVCSoftware_10/.git/objects: b3
Only in ../VVCSoftware_10/.git/objects: b4
Only in ../VVCSoftware_10/.git/objects: b5
Only in ../VVCSoftware_10/.git/objects: b6
Only in ../VVCSoftware_10/.git/objects: b7
Only in ../VVCSoftware_10/.git/objects: b8
Only in ../VVCSoftware_10/.git/objects: b9
Only in ../VVCSoftware_10/.git/objects: ba
Only in ../VVCSoftware_10/.git/objects: bb
Only in ../VVCSoftware_10/.git/objects: bc
Only in ../VVCSoftware_10/.git/objects: bd
Only in ../VVCSoftware_10/.git/objects: be
Only in ../VVCSoftware_10/.git/objects: bf
Only in ../VVCSoftware_10/.git/objects: c0
Only in ../VVCSoftware_10/.git/objects: c1
Only in ../VVCSoftware_10/.git/objects: c2
Only in ../VVCSoftware_10/.git/objects: c3
Only in ../VVCSoftware_10/.git/objects: c4
Only in ../VVCSoftware_10/.git/objects: c5
Only in ../VVCSoftware_10/.git/objects: c6
Only in ../VVCSoftware_10/.git/objects: c7
Only in ../VVCSoftware_10/.git/objects: c8
Only in ../VVCSoftware_10/.git/objects: c9
Only in ../VVCSoftware_10/.git/objects: ca
Only in ../VVCSoftware_10/.git/objects: cb
Only in ../VVCSoftware_10/.git/objects: cc
Only in ../VVCSoftware_10/.git/objects: cd
Only in ../VVCSoftware_10/.git/objects: ce
Only in ../VVCSoftware_10/.git/objects: cf
Only in ../VVCSoftware_10/.git/objects: d0
Only in ../VVCSoftware_10/.git/objects: d1
Only in ../VVCSoftware_10/.git/objects: d2
Only in ../VVCSoftware_10/.git/objects: d3
Only in ../VVCSoftware_10/.git/objects: d4
Only in ../VVCSoftware_10/.git/objects: d5
Only in ../VVCSoftware_10/.git/objects: d6
Only in ../VVCSoftware_10/.git/objects: d7
Only in ../VVCSoftware_10/.git/objects: d8
Only in ../VVCSoftware_10/.git/objects: d9
Only in ../VVCSoftware_10/.git/objects: da
Only in ../VVCSoftware_10/.git/objects: db
Only in ../VVCSoftware_10/.git/objects: dc
Only in ../VVCSoftware_10/.git/objects: dd
Only in ../VVCSoftware_10/.git/objects: de
Only in ../VVCSoftware_10/.git/objects: df
Only in ../VVCSoftware_10/.git/objects: e0
Only in ../VVCSoftware_10/.git/objects: e1
Only in ../VVCSoftware_10/.git/objects: e2
Only in ../VVCSoftware_10/.git/objects: e3
Only in ../VVCSoftware_10/.git/objects: e4
Only in ../VVCSoftware_10/.git/objects: e5
Only in ../VVCSoftware_10/.git/objects: e6
Only in ../VVCSoftware_10/.git/objects: e7
Only in ../VVCSoftware_10/.git/objects: e8
Only in ../VVCSoftware_10/.git/objects: e9
Only in ../VVCSoftware_10/.git/objects: ea
Only in ../VVCSoftware_10/.git/objects: eb
Only in ../VVCSoftware_10/.git/objects: ec
Only in ../VVCSoftware_10/.git/objects: ed
Only in ../VVCSoftware_10/.git/objects: ee
Only in ../VVCSoftware_10/.git/objects: ef
Only in ../VVCSoftware_10/.git/objects: f0
Only in ../VVCSoftware_10/.git/objects: f1
Only in ../VVCSoftware_10/.git/objects: f2
Only in ../VVCSoftware_10/.git/objects: f3
Only in ../VVCSoftware_10/.git/objects: f4
Only in ../VVCSoftware_10/.git/objects: f5
Only in ../VVCSoftware_10/.git/objects: f6
Only in ../VVCSoftware_10/.git/objects: f7
Only in ../VVCSoftware_10/.git/objects: f8
Only in ../VVCSoftware_10/.git/objects: f9
Only in ../VVCSoftware_10/.git/objects: fa
Only in ../VVCSoftware_10/.git/objects: fb
Only in ../VVCSoftware_10/.git/objects: fc
Only in ../VVCSoftware_10/.git/objects: fd
Only in ../VVCSoftware_10/.git/objects: fe
Only in ../VVCSoftware_10/.git/objects: ff
Only in ../vtm10_original/VVCSoftware_VTM/.git/objects/pack: pack-b63e4a73a5afdd56119bcc3152999f173afe85f1.idx
Only in ../vtm10_original/VVCSoftware_VTM/.git/objects/pack: pack-b63e4a73a5afdd56119bcc3152999f173afe85f1.pack
Only in ../VVCSoftware_10/.git: ORIG_HEAD
Only in ../vtm10_original/VVCSoftware_VTM/.git: packed-refs
diff -rwu ../vtm10_original/VVCSoftware_VTM/.git/refs/heads/master ../VVCSoftware_10/.git/refs/heads/master
--- ../vtm10_original/VVCSoftware_VTM/.git/refs/heads/master	2022-09-16 14:26:03.361244379 +0200
+++ ../VVCSoftware_10/.git/refs/heads/master	2022-09-14 14:34:54.617183002 +0200
@@ -1 +1 @@
-ee9643e94c40da1fc211617606423401a61c52a2
+3031b3c794057d76b1b2367c1bcd288a58aacde2
Only in ../vtm10_original/VVCSoftware_VTM/.git/refs/remotes/origin: HEAD
Only in ../VVCSoftware_10/.git/refs/remotes/origin: master
Only in ../VVCSoftware_10: .idea
Only in ../VVCSoftware_10: .ipynb_checkpoints
Only in ../VVCSoftware_10: lib
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp ../VVCSoftware_10/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp	2022-09-16 14:27:06.116532963 +0200
+++ ../VVCSoftware_10/source/App/BitstreamExtractorApp/BitstreamExtractorApp.cpp	2022-05-13 17:45:28.488153594 +0200
@@ -123,9 +123,9 @@
 bool BitstreamExtractorApp::xCheckSliceSubpicture(Slice &slice, int targetSubPicId)
 {
   PPS *pps = m_parameterSetManager.getPPS(m_picHeader.getPPSId());
-  CHECK(nullptr == pps, "referenced PPS not found");
+  CHECK_VTM(nullptr == pps, "referenced PPS not found");
   SPS *sps = m_parameterSetManager.getSPS(pps->getSPSId());
-  CHECK(nullptr == sps, "referenced SPS not found");
+  CHECK_VTM(nullptr == sps, "referenced SPS not found");
 
   if (sps->getSubPicInfoPresentFlag())
   {
@@ -319,7 +319,7 @@
     }
   }
   numTileCols=(int)tileColBd.size() - 1;
-  CHECK (numTileCols < 1, "After extraction there should be at least one tile horizonally.");
+  CHECK_VTM(numTileCols < 1, "After extraction there should be at least one tile horizonally.");
   tileColWidth.resize(numTileCols);
   for (int i=0; i<numTileCols; i++)
   {
@@ -424,7 +424,7 @@
 {
   // create a new NAL unit for output
   OutputNALUnit naluOut (NAL_UNIT_VPS, layerId, temporalId);
-  CHECK( naluOut.m_temporalId, "The value of TemporalId of VPS NAL units shall be equal to 0" );
+  CHECK_VTM( naluOut.m_temporalId, "The value of TemporalId of VPS NAL units shall be equal to 0" );
 
   // write the VPS to the newly created NAL unit buffer
   m_hlSyntaxWriter.setBitstream( &naluOut.m_Bitstream );
@@ -438,7 +438,7 @@
 {
   // create a new NAL unit for output
   OutputNALUnit naluOut (NAL_UNIT_SPS, layerId, temporalId);
-  CHECK( naluOut.m_temporalId, "The value of TemporalId of SPS NAL units shall be equal to 0" );
+  CHECK_VTM( naluOut.m_temporalId, "The value of TemporalId of SPS NAL units shall be equal to 0" );
 
   // write the SPS to the newly created NAL unit buffer
   m_hlSyntaxWriter.setBitstream( &naluOut.m_Bitstream );
@@ -483,8 +483,8 @@
   SEIMessages scalableNestingSEIs = getSeisByType(SEIs, SEI::SCALABLE_NESTING);
   if (scalableNestingSEIs.size())
   {
-    CHECK ( scalableNestingSEIs.size() > 1, "There shall be only one Scalable Nesting SEI in one NAL unit" );
-    CHECK ( scalableNestingSEIs.size() != SEIs.size(), "Scalable Nesting SEI shall not be in the same NAL unit as other SEIs" );
+    CHECK_VTM( scalableNestingSEIs.size() > 1, "There shall be only one Scalable Nesting SEI in one NAL unit" );
+    CHECK_VTM( scalableNestingSEIs.size() != SEIs.size(), "Scalable Nesting SEI shall not be in the same NAL unit as other SEIs" );
     // check, if the scalable nesting SEI applies to the target subpicture
     SEIScalableNesting *sei = (SEIScalableNesting*) scalableNestingSEIs.front();
 
@@ -638,7 +638,7 @@
         // if there is no VPS nal unit, there shall be one OLS and one layer.
         if (m_vpsId == 0)
         {
-          CHECK(m_targetOlsIdx != 0, "only one OLS and one layer exist, but target olsIdx is not equal to zero");
+          CHECK_VTM(m_targetOlsIdx != 0, "only one OLS and one layer exist, but target olsIdx is not equal to zero");
         }
         // Remove NAL units with nal_unit_type not equal to any of VPS_NUT, DPS_NUT, and EOB_NUT and with nuh_layer_id not included in the list LayerIdInOls[targetOlsIdx].
         NalUnitType t = nalu.m_nalUnitType;
@@ -650,8 +650,8 @@
           vps->deriveOutputLayerSets();
         }
         uint32_t numOlss = vps->getTotalNumOLSs();
-        CHECK(m_targetOlsIdx <0  || m_targetOlsIdx >= numOlss, "target Ols shall be in the range of OLSs specified by the VPS");
-        CHECK(m_maxTemporalLayer < -1 || m_maxTemporalLayer > vps->getPtlMaxTemporalId(vps->getOlsPtlIdx(m_targetOlsIdx)), "MaxTemporalLayer shall either be equal -1 (for diabled) or in the range of 0 to vps_ptl_max_tid[ vps_ols_ptl_idx[ targetOlsIdx ] ], inclusive");
+        CHECK_VTM(m_targetOlsIdx <0  || m_targetOlsIdx >= numOlss, "target Ols shall be in the range of OLSs specified by the VPS");
+        CHECK_VTM(m_maxTemporalLayer < -1 || m_maxTemporalLayer > vps->getPtlMaxTemporalId(vps->getOlsPtlIdx(m_targetOlsIdx)), "MaxTemporalLayer shall either be equal -1 (for diabled) or in the range of 0 to vps_ptl_max_tid[ vps_ols_ptl_idx[ targetOlsIdx ] ], inclusive");
         std::vector<int> layerIdInOls = vps->getLayerIdsInOls(m_targetOlsIdx);
         bool isIncludedInTargetOls = std::find(layerIdInOls.begin(), layerIdInOls.end(), nalu.m_nuhLayerId) != layerIdInOls.end();
         writeInpuNalUnitToStream &= (isSpecialNalTypes || isIncludedInTargetOls);
@@ -681,8 +681,8 @@
         }
         if (m_subPicIdx >= 0 && isMultiSubpicLayer[nalu.m_nuhLayerId])
         {
-          CHECK(m_subPicIdx >= sps->getNumSubPics(), "Target subpicture not found");
-          CHECK(!sps->getSubPicTreatedAsPicFlag(m_subPicIdx), "sps_subpic_treated_as_pic_flag[subpicIdxTarget] should be equal to 1 for subpicture extraction");
+          CHECK_VTM(m_subPicIdx >= sps->getNumSubPics(), "Target subpicture not found");
+          CHECK_VTM(!sps->getSubPicTreatedAsPicFlag(m_subPicIdx), "sps_subpic_treated_as_pic_flag[subpicIdxTarget] should be equal to 1 for subpicture extraction");
           xSetSPSUpdated(sps->getSPSId());
           writeInpuNalUnitToStream = false;
         }
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/App/DecoderApp/DecApp.cpp ../VVCSoftware_10/source/App/DecoderApp/DecApp.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/App/DecoderApp/DecApp.cpp	2022-09-16 14:27:06.116532963 +0200
+++ ../VVCSoftware_10/source/App/DecoderApp/DecApp.cpp	2022-05-13 17:45:28.388154726 +0200
@@ -197,10 +197,10 @@
         // parse NAL unit syntax if within target decoding layer
         if( ( m_iMaxTemporalLayer < 0 || nalu.m_temporalId <= m_iMaxTemporalLayer ) && xIsNaluWithinTargetDecLayerIdSet( &nalu ) )
         {
-          CHECK(nalu.m_temporalId > m_iMaxTemporalLayer, "bitstream shall not include any NAL unit with TemporalId greater than HighestTid");
+          CHECK_VTM(nalu.m_temporalId > m_iMaxTemporalLayer, "bitstream shall not include any NAL unit with TemporalId greater than HighestTid");
           if (m_targetDecLayerIdSet.size())
           {
-            CHECK(std::find(m_targetDecLayerIdSet.begin(), m_targetDecLayerIdSet.end(), nalu.m_nuhLayerId) == m_targetDecLayerIdSet.end(), "bitstream shall not contain any other layers than included in the OLS with OlsIdx");
+            CHECK_VTM(std::find(m_targetDecLayerIdSet.begin(), m_targetDecLayerIdSet.end(), nalu.m_nuhLayerId) == m_targetDecLayerIdSet.end(), "bitstream shall not contain any other layers than included in the OLS with OlsIdx");
           }
           if (bPicSkipped)
           {
@@ -237,7 +237,7 @@
       // within the current PU, only EOS and EOB are allowed to be sent after an EOS nal unit
       if(isEosPresentInPu)
       {
-        CHECK(nalu.m_nalUnitType != NAL_UNIT_EOS && nalu.m_nalUnitType != NAL_UNIT_EOB, "When an EOS NAL unit is present in a PU, it shall be the last NAL unit among all NAL units within the PU other than other EOS NAL units or an EOB NAL unit");
+        CHECK_VTM(nalu.m_nalUnitType != NAL_UNIT_EOS && nalu.m_nalUnitType != NAL_UNIT_EOB, "When an EOS NAL unit is present in a PU, it shall be the last NAL unit among all NAL units within the PU other than other EOS NAL units or an EOB NAL unit");
       }
     }
 
@@ -354,7 +354,7 @@
   }
   // May need to check again one more time as in case one the bitstream has only one picture, the first check may miss it
   setOutputPicturePresentInStream();
-  CHECK(!outputPicturePresentInBitstream, "It is required that there shall be at least one picture with PictureOutputFlag equal to 1 in the bitstream")
+  CHECK_VTM(!outputPicturePresentInBitstream, "It is required that there shall be at least one picture with PictureOutputFlag equal to 1 in the bitstream")
 
   xFlushOutput( pcListPic );
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/App/EncoderApp/EncAppCfg.cpp ../VVCSoftware_10/source/App/EncoderApp/EncAppCfg.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/App/EncoderApp/EncAppCfg.cpp	2022-09-16 14:27:06.120532918 +0200
+++ ../VVCSoftware_10/source/App/EncoderApp/EncAppCfg.cpp	2022-05-13 17:45:28.172157173 +0200
@@ -698,6 +698,14 @@
   ("InputPathPrefix,-ipp",                            inputPathPrefix,                             string(""), "pathname to prepend to input filename")
   ("BitstreamFile,b",                                 m_bitstreamFileName,                         string(""), "Bitstream output file name")
   ("ReconFile,o",                                     m_reconFileName,                             string(""), "Reconstructed YUV output file name")
+
+  //altissie added
+  ("WritePartition,wp",                               m_writePartition,                                 false, "Write partition decision into dat file")
+  ("ReadPartition,rp",                                m_readPartition,                                  false, "Read partition decision of dat file")
+  ("DatFolder,-df",                                   m_datFolder,                                 string(""), "Folder for dat file (partition file)")
+  ("PredictPartition,pp",                             m_predictPartition,                               false, "Predict partition decision with cnn+ml in intra coding")
+  ("PredictPartitionInter,ppi",                       m_predictPartitionInter,                          false, "Predict partition decision with cnn+ml in inter coding")
+
   ("SourceWidth,-wdt",                                m_iSourceWidth,                                       0, "Source picture width")
   ("SourceHeight,-hgt",                               m_iSourceHeight,                                      0, "Source picture height")
   ("InputBitDepth",                                   m_inputBitDepth[CHANNEL_TYPE_LUMA],                   8, "Bit-depth of input file")
@@ -1595,26 +1603,26 @@
   }
   if ( m_subPicInfoPresentFlag )
   {
-    CHECK( m_numSubPics > MAX_NUM_SUB_PICS || m_numSubPics < 1, "Number of subpicture must be within 1 to 2^16" )
+    CHECK_VTM( m_numSubPics > MAX_NUM_SUB_PICS || m_numSubPics < 1, "Number of subpicture must be within 1 to 2^16" )
     if (!m_subPicSameSizeFlag)
     {
-      CHECK(cfg_subPicCtuTopLeftX.values.size() != m_numSubPics, "Number of SubPicCtuTopLeftX values must be equal to NumSubPics");
-      CHECK(cfg_subPicCtuTopLeftY.values.size() != m_numSubPics, "Number of SubPicCtuTopLeftY values must be equal to NumSubPics");
-      CHECK(cfg_subPicWidth.values.size() != m_numSubPics, "Number of SubPicWidth values must be equal to NumSubPics");
-      CHECK(cfg_subPicHeight.values.size() != m_numSubPics, "Number of SubPicHeight values must be equal to NumSubPics");
+      CHECK_VTM(cfg_subPicCtuTopLeftX.values.size() != m_numSubPics, "Number of SubPicCtuTopLeftX values must be equal to NumSubPics");
+      CHECK_VTM(cfg_subPicCtuTopLeftY.values.size() != m_numSubPics, "Number of SubPicCtuTopLeftY values must be equal to NumSubPics");
+      CHECK_VTM(cfg_subPicWidth.values.size() != m_numSubPics, "Number of SubPicWidth values must be equal to NumSubPics");
+      CHECK_VTM(cfg_subPicHeight.values.size() != m_numSubPics, "Number of SubPicHeight values must be equal to NumSubPics");
     }
     else
     {
-      CHECK(cfg_subPicCtuTopLeftX.values.size() != 0, "Number of SubPicCtuTopLeftX values must be equal to 0");
-      CHECK(cfg_subPicCtuTopLeftY.values.size() != 0, "Number of SubPicCtuTopLeftY values must be equal to 0");
-      CHECK(cfg_subPicWidth.values.size() != 1, "Number of SubPicWidth values must be equal to 1");
-      CHECK(cfg_subPicHeight.values.size() != 1, "Number of SubPicHeight values must be equal to 1");
+      CHECK_VTM(cfg_subPicCtuTopLeftX.values.size() != 0, "Number of SubPicCtuTopLeftX values must be equal to 0");
+      CHECK_VTM(cfg_subPicCtuTopLeftY.values.size() != 0, "Number of SubPicCtuTopLeftY values must be equal to 0");
+      CHECK_VTM(cfg_subPicWidth.values.size() != 1, "Number of SubPicWidth values must be equal to 1");
+      CHECK_VTM(cfg_subPicHeight.values.size() != 1, "Number of SubPicHeight values must be equal to 1");
     }
-    CHECK( cfg_subPicTreatedAsPicFlag.values.size() != m_numSubPics, "Number of SubPicTreatedAsPicFlag values must be equal to NumSubPics");
-    CHECK( cfg_loopFilterAcrossSubpicEnabledFlag.values.size() != m_numSubPics, "Number of LoopFilterAcrossSubpicEnabledFlag values must be equal to NumSubPics");
+    CHECK_VTM( cfg_subPicTreatedAsPicFlag.values.size() != m_numSubPics, "Number of SubPicTreatedAsPicFlag values must be equal to NumSubPics");
+    CHECK_VTM( cfg_loopFilterAcrossSubpicEnabledFlag.values.size() != m_numSubPics, "Number of LoopFilterAcrossSubpicEnabledFlag values must be equal to NumSubPics");
     if (m_subPicIdMappingExplicitlySignalledFlag)
     {
-      CHECK( cfg_subPicId.values.size() != m_numSubPics, "Number of SubPicId values must be equal to NumSubPics");
+      CHECK_VTM( cfg_subPicId.values.size() != m_numSubPics, "Number of SubPicId values must be equal to NumSubPics");
     }
     m_subPicCtuTopLeftX                 = cfg_subPicCtuTopLeftX.values;
     m_subPicCtuTopLeftY                 = cfg_subPicCtuTopLeftY.values;
@@ -1635,16 +1643,16 @@
     {
       for (int i = 0; i < m_numSubPics; i++)
       {
-        CHECK(m_subPicCtuTopLeftX[i] + m_subPicWidth[i] > tmpWidthVal, "Subpicture must not exceed picture boundary");
-        CHECK(m_subPicCtuTopLeftY[i] + m_subPicHeight[i] > tmpHeightVal, "Subpicture must not exceed picture boundary");
+        CHECK_VTM(m_subPicCtuTopLeftX[i] + m_subPicWidth[i] > tmpWidthVal, "Subpicture must not exceed picture boundary");
+        CHECK_VTM(m_subPicCtuTopLeftY[i] + m_subPicHeight[i] > tmpHeightVal, "Subpicture must not exceed picture boundary");
       }
     }
     else
     {
       uint32_t numSubpicCols = tmpWidthVal / m_subPicWidth[0];
-      CHECK(tmpWidthVal % m_subPicWidth[0] != 0, "sps_subpic_width_minus1[0] is invalid.");
-      CHECK(tmpHeightVal % m_subPicHeight[0] != 0, "sps_subpic_height_minus1[0] is invalid.");
-      CHECK(numSubpicCols * (tmpHeightVal / m_subPicHeight[0]) != m_numSubPics, "when sps_subpic_same_size_flag is equal to, sps_num_subpics_minus1 is invalid");
+      CHECK_VTM(tmpWidthVal % m_subPicWidth[0] != 0, "sps_subpic_width_minus1[0] is invalid.");
+      CHECK_VTM(tmpHeightVal % m_subPicHeight[0] != 0, "sps_subpic_height_minus1[0] is invalid.");
+      CHECK_VTM(numSubpicCols * (tmpHeightVal / m_subPicHeight[0]) != m_numSubPics, "when sps_subpic_same_size_flag is equal to, sps_num_subpics_minus1 is invalid");
     }
     // automatically determine subpicture ID lenght in case it is not specified
     if (m_subPicIdLen == 0)
@@ -1662,26 +1670,26 @@
       }
     }
 
-    CHECK( m_subPicIdLen > 16, "SubPicIdLen must not exceed 16 bits" );
-    CHECK(m_resChangeInClvsEnabled, "resolution change in CLVS and subpictures cannot be enabled together");
+    CHECK_VTM( m_subPicIdLen > 16, "SubPicIdLen must not exceed 16 bits" );
+    CHECK_VTM(m_resChangeInClvsEnabled, "resolution change in CLVS and subpictures cannot be enabled together");
   }
 
   if (m_virtualBoundariesPresentFlag)
   {
     if (m_iSourceWidth <= 8)
-      CHECK(m_numVerVirtualBoundaries != 0, "The number of vertical virtual boundaries shall be 0 when the picture width is less than or equal to 8");
+      CHECK_VTM(m_numVerVirtualBoundaries != 0, "The number of vertical virtual boundaries shall be 0 when the picture width is less than or equal to 8");
 
     if (m_iSourceHeight <= 8)
-      CHECK(m_numHorVirtualBoundaries != 0, "The number of horizontal virtual boundaries shall be 0 when the picture height is less than or equal to 8");
+      CHECK_VTM(m_numHorVirtualBoundaries != 0, "The number of horizontal virtual boundaries shall be 0 when the picture height is less than or equal to 8");
   }
 
   if (m_cfgSubpictureLevelInfoSEI.m_enabled)
   {
-    CHECK (m_numSubPics != m_cfgSubpictureLevelInfoSEI.m_numSubpictures, "NumSubPics must be equal to SEISubpicLevelInfoNumSubpics" );
-    CHECK (m_cfgSubpictureLevelInfoSEI.m_sliMaxSublayers != m_maxSublayers, "SEISubpicLevelInfoMaxSublayers must be equal to vps_max_sublayers");
+    CHECK_VTM(m_numSubPics != m_cfgSubpictureLevelInfoSEI.m_numSubpictures, "NumSubPics must be equal to SEISubpicLevelInfoNumSubpics" );
+    CHECK_VTM(m_cfgSubpictureLevelInfoSEI.m_sliMaxSublayers != m_maxSublayers, "SEISubpicLevelInfoMaxSublayers must be equal to vps_max_sublayers");
     if (m_cfgSubpictureLevelInfoSEI.m_sliSublayerInfoPresentFlag)
     {
-      CHECK(cfg_sliRefLevels.values.size() < m_maxSublayers, "when sliSublayerInfoPresentFlag = 1, the number of reference levels must be greater than or equal to sublayers");
+      CHECK_VTM(cfg_sliRefLevels.values.size() < m_maxSublayers, "when sliSublayerInfoPresentFlag = 1, the number of reference levels must be greater than or equal to sublayers");
     }
     if (m_cfgSubpictureLevelInfoSEI.m_explicitFraction)
     {
@@ -1689,23 +1697,23 @@
       m_cfgSubpictureLevelInfoSEI.m_refLevels = cfg_sliRefLevels.values;
       if (m_cfgSubpictureLevelInfoSEI.m_sliSublayerInfoPresentFlag)
       {
-        CHECK((int)cfg_sliRefLevels.values.size() / m_maxSublayers * m_cfgSubpictureLevelInfoSEI.m_numSubpictures * m_cfgSubpictureLevelInfoSEI.m_sliMaxSublayers != cfg_sliFractions.values.size(),
+        CHECK_VTM((int)cfg_sliRefLevels.values.size() / m_maxSublayers * m_cfgSubpictureLevelInfoSEI.m_numSubpictures * m_cfgSubpictureLevelInfoSEI.m_sliMaxSublayers != cfg_sliFractions.values.size(),
           "when sliSublayerInfoPresentFlag = 1, the number  of subpicture level fractions must be equal to the numer of subpictures times the number of reference levels times the number of sublayers");
       }
       else
       {
-        CHECK((int)cfg_sliRefLevels.values.size() * m_cfgSubpictureLevelInfoSEI.m_numSubpictures != cfg_sliFractions.values.size(), "when sliSublayerInfoPresentFlag = 0, the number  of subpicture level fractions must be equal to the numer of subpictures times the number of reference levels");
+        CHECK_VTM((int)cfg_sliRefLevels.values.size() * m_cfgSubpictureLevelInfoSEI.m_numSubpictures != cfg_sliFractions.values.size(), "when sliSublayerInfoPresentFlag = 0, the number  of subpicture level fractions must be equal to the numer of subpictures times the number of reference levels");
       }
     }
     m_cfgSubpictureLevelInfoSEI.m_nonSubpicLayersFraction = cfg_sliNonSubpicLayersFractions.values;
     if (m_cfgSubpictureLevelInfoSEI.m_sliSublayerInfoPresentFlag)
     {
-      CHECK((int)cfg_sliNonSubpicLayersFractions.values.size() != ( cfg_sliRefLevels.values.size() * m_cfgSubpictureLevelInfoSEI.m_numSubpictures ),
+      CHECK_VTM((int)cfg_sliNonSubpicLayersFractions.values.size() != ( cfg_sliRefLevels.values.size() * m_cfgSubpictureLevelInfoSEI.m_numSubpictures ),
         "when sliSublayerInfoPresentFlag = 1, the number  of non-subpicture level fractions must be equal to the numer of reference levels times the number of sublayers");
     }
     else
     {
-      CHECK((int)cfg_sliNonSubpicLayersFractions.values.size() != ( cfg_sliRefLevels.values.size() ),
+      CHECK_VTM((int)cfg_sliNonSubpicLayersFractions.values.size() != ( cfg_sliRefLevels.values.size() ),
         "when sliSublayerInfoPresentFlag = 0, the number  of non-subpicture level fractions must be equal to the numer of reference levels");
     }
   }
@@ -1821,13 +1829,13 @@
   m_ext360.processOptions(ext360CfgContext);
 #endif
 
-  CHECK( !( tmpWeightedPredictionMethod >= 0 && tmpWeightedPredictionMethod <= WP_PER_PICTURE_WITH_HISTOGRAM_AND_PER_COMPONENT_AND_CLIPPING_AND_EXTENSION ), "Error in cfg" );
+  CHECK_VTM( !( tmpWeightedPredictionMethod >= 0 && tmpWeightedPredictionMethod <= WP_PER_PICTURE_WITH_HISTOGRAM_AND_PER_COMPONENT_AND_CLIPPING_AND_EXTENSION ), "Error in cfg" );
   m_weightedPredictionMethod = WeightedPredictionMethod(tmpWeightedPredictionMethod);
 
-  CHECK( tmpFastInterSearchMode<0 || tmpFastInterSearchMode>FASTINTERSEARCH_MODE3, "Error in cfg" );
+  CHECK_VTM( tmpFastInterSearchMode<0 || tmpFastInterSearchMode>FASTINTERSEARCH_MODE3, "Error in cfg" );
   m_fastInterSearchMode = FastInterSearchMode(tmpFastInterSearchMode);
 
-  CHECK( tmpMotionEstimationSearchMethod < 0 || tmpMotionEstimationSearchMethod >= MESEARCH_NUMBER_OF_METHODS, "Error in cfg" );
+  CHECK_VTM( tmpMotionEstimationSearchMethod < 0 || tmpMotionEstimationSearchMethod >= MESEARCH_NUMBER_OF_METHODS, "Error in cfg" );
   m_motionEstimationSearchMethod=MESearchMethod(tmpMotionEstimationSearchMethod);
 
   if (extendedProfile == ExtendedProfileName::AUTO)
@@ -1865,7 +1873,7 @@
       if (m_profile != Profile::NONE)
       {
         const ProfileFeatures *features = ProfileFeatures::getProfileFeatures(m_profile);
-        CHECK(features->profile != m_profile, "Profile not found");
+        CHECK_VTM(features->profile != m_profile, "Profile not found");
         m_bitDepthConstraint = features->maxBitDepth;
       }
       else // m_profile == Profile::NONE
@@ -1873,11 +1881,11 @@
         m_bitDepthConstraint = 16; // max value - unconstrained.
       }
     }
-    CHECK(m_bitDepthConstraint < m_internalBitDepth[CHANNEL_TYPE_LUMA], "MaxBitDepthConstraint setting does not allow the specified luma bit depth to be coded.");
-    CHECK(m_bitDepthConstraint < m_internalBitDepth[CHANNEL_TYPE_CHROMA], "MaxBitDepthConstraint setting does not allow the specified chroma bit depth to be coded.");
-    CHECK(m_chromaFormatConstraint < m_chromaFormatIDC, "MaxChromaFormatConstraint setting does not allow the specified chroma format to be coded.");
-    CHECK(m_chromaFormatConstraint >= NUM_CHROMA_FORMAT, "Bad value given for MaxChromaFormatConstraint setting.")
-    CHECK(m_bitDepthConstraint < 8 || m_bitDepthConstraint>16, "MaxBitDepthConstraint setting must be in the range 8 to 16 (inclusive)");
+    CHECK_VTM(m_bitDepthConstraint < m_internalBitDepth[CHANNEL_TYPE_LUMA], "MaxBitDepthConstraint setting does not allow the specified luma bit depth to be coded.");
+    CHECK_VTM(m_bitDepthConstraint < m_internalBitDepth[CHANNEL_TYPE_CHROMA], "MaxBitDepthConstraint setting does not allow the specified chroma bit depth to be coded.");
+    CHECK_VTM(m_chromaFormatConstraint < m_chromaFormatIDC, "MaxChromaFormatConstraint setting does not allow the specified chroma format to be coded.");
+    CHECK_VTM(m_chromaFormatConstraint >= NUM_CHROMA_FORMAT, "Bad value given for MaxChromaFormatConstraint setting.")
+    CHECK_VTM(m_bitDepthConstraint < 8 || m_bitDepthConstraint>16, "MaxBitDepthConstraint setting must be in the range 8 to 16 (inclusive)");
   }
 
 
@@ -1886,7 +1894,7 @@
 
   // Picture width and height must be multiples of 8 and minCuSize
   const int minResolutionMultiple = std::max(8, 1 << m_log2MinCuSize);
-  CHECK(((m_iSourceWidth% minResolutionMultiple) || (m_iSourceHeight % minResolutionMultiple)) && m_conformanceWindowMode != 1, "Picture width or height is not a multiple of 8 or minCuSize, please use ConformanceMode 1!");
+  CHECK_VTM(((m_iSourceWidth% minResolutionMultiple) || (m_iSourceHeight % minResolutionMultiple)) && m_conformanceWindowMode != 1, "Picture width or height is not a multiple of 8 or minCuSize, please use ConformanceMode 1!");
   switch (m_conformanceWindowMode)
   {
   case 0:
@@ -1953,13 +1961,13 @@
   {
     for(int i = 0; i < m_numSubPics; i++)
     {
-      CHECK( (m_subPicCtuTopLeftX[i] * m_uiCTUSize) >= (m_iSourceWidth - m_confWinRight * SPS::getWinUnitX(m_chromaFormatIDC)),
+      CHECK_VTM( (m_subPicCtuTopLeftX[i] * m_uiCTUSize) >= (m_iSourceWidth - m_confWinRight * SPS::getWinUnitX(m_chromaFormatIDC)),
           "No subpicture can be located completely outside of the conformance cropping window");
-      CHECK( ((m_subPicCtuTopLeftX[i] + m_subPicWidth[i]) * m_uiCTUSize) <= (m_confWinLeft * SPS::getWinUnitX(m_chromaFormatIDC)),
+      CHECK_VTM( ((m_subPicCtuTopLeftX[i] + m_subPicWidth[i]) * m_uiCTUSize) <= (m_confWinLeft * SPS::getWinUnitX(m_chromaFormatIDC)),
 	  "No subpicture can be located completely outside of the conformance cropping window" );
-      CHECK( (m_subPicCtuTopLeftY[i] * m_uiCTUSize) >= (m_iSourceHeight  - m_confWinBottom * SPS::getWinUnitY(m_chromaFormatIDC)),
+      CHECK_VTM( (m_subPicCtuTopLeftY[i] * m_uiCTUSize) >= (m_iSourceHeight  - m_confWinBottom * SPS::getWinUnitY(m_chromaFormatIDC)),
           "No subpicture can be located completely outside of the conformance cropping window");
-      CHECK( ((m_subPicCtuTopLeftY[i] + m_subPicHeight[i]) * m_uiCTUSize) <= (m_confWinTop * SPS::getWinUnitY(m_chromaFormatIDC)),
+      CHECK_VTM( ((m_subPicCtuTopLeftY[i] + m_subPicHeight[i]) * m_uiCTUSize) <= (m_confWinTop * SPS::getWinUnitY(m_chromaFormatIDC)),
           "No subpicture can be located completely outside of the conformance cropping window");
     }
   }
@@ -2024,13 +2032,13 @@
 
 
 #if SHARP_LUMA_DELTA_QP
-  CHECK( lumaLevelToDeltaQPMode >= LUMALVL_TO_DQP_NUM_MODES, "Error in cfg" );
+  CHECK_VTM( lumaLevelToDeltaQPMode >= LUMALVL_TO_DQP_NUM_MODES, "Error in cfg" );
 
   m_lumaLevelToDeltaQPMapping.mode=LumaLevelToDQPMode(lumaLevelToDeltaQPMode);
 
   if (m_lumaLevelToDeltaQPMapping.mode)
   {
-    CHECK(  cfg_lumaLeveltoDQPMappingLuma.values.size() != cfg_lumaLeveltoDQPMappingQP.values.size(), "Error in cfg" );
+    CHECK_VTM(  cfg_lumaLeveltoDQPMappingLuma.values.size() != cfg_lumaLeveltoDQPMappingQP.values.size(), "Error in cfg" );
     m_lumaLevelToDeltaQPMapping.mapping.resize(cfg_lumaLeveltoDQPMappingLuma.values.size());
     for(uint32_t i=0; i<cfg_lumaLeveltoDQPMappingLuma.values.size(); i++)
     {
@@ -2039,9 +2047,9 @@
   }
 #endif
 
-  CHECK(cfg_qpInValCb.values.size() != cfg_qpOutValCb.values.size(), "Chroma QP table for Cb is incomplete.");
-  CHECK(cfg_qpInValCr.values.size() != cfg_qpOutValCr.values.size(), "Chroma QP table for Cr is incomplete.");
-  CHECK(cfg_qpInValCbCr.values.size() != cfg_qpOutValCbCr.values.size(), "Chroma QP table for CbCr is incomplete.");
+  CHECK_VTM(cfg_qpInValCb.values.size() != cfg_qpOutValCb.values.size(), "Chroma QP table for Cb is incomplete.");
+  CHECK_VTM(cfg_qpInValCr.values.size() != cfg_qpOutValCr.values.size(), "Chroma QP table for Cr is incomplete.");
+  CHECK_VTM(cfg_qpInValCbCr.values.size() != cfg_qpOutValCbCr.values.size(), "Chroma QP table for CbCr is incomplete.");
   if (m_useIdentityTableForNon420Chroma && m_chromaFormatIDC != CHROMA_420)
   {
     m_chromaQpMappingTableParams.m_sameCQPTableForAllChromaFlag = true;
@@ -2076,12 +2084,12 @@
   m_chromaQpMappingTableParams.m_deltaQpOutVal[0].resize(cfg_qpOutValCb.values.size());
   m_chromaQpMappingTableParams.m_numPtsInCQPTableMinus1[0] = (int) cfg_qpOutValCb.values.size() - 2;
   m_chromaQpMappingTableParams.m_qpTableStartMinus26[0]    = -26 + cfg_qpInValCb.values[0];
-  CHECK(m_chromaQpMappingTableParams.m_qpTableStartMinus26[0] < -26 - qpBdOffsetC || m_chromaQpMappingTableParams.m_qpTableStartMinus26[0] > 36, "qpTableStartMinus26[0] is out of valid range of -26 -qpBdOffsetC to 36, inclusive.")
-  CHECK(cfg_qpInValCb.values[0] != cfg_qpOutValCb.values[0], "First qpInValCb value should be equal to first qpOutValCb value");
+  CHECK_VTM(m_chromaQpMappingTableParams.m_qpTableStartMinus26[0] < -26 - qpBdOffsetC || m_chromaQpMappingTableParams.m_qpTableStartMinus26[0] > 36, "qpTableStartMinus26[0] is out of valid range of -26 -qpBdOffsetC to 36, inclusive.")
+  CHECK_VTM(cfg_qpInValCb.values[0] != cfg_qpOutValCb.values[0], "First qpInValCb value should be equal to first qpOutValCb value");
   for (int i = 0; i < cfg_qpInValCb.values.size() - 1; i++)
   {
-    CHECK(cfg_qpInValCb.values[i] < -qpBdOffsetC || cfg_qpInValCb.values[i] > MAX_QP, "Some entries cfg_qpInValCb are out of valid range of -qpBdOffsetC to 63, inclusive.");
-    CHECK(cfg_qpOutValCb.values[i] < -qpBdOffsetC || cfg_qpOutValCb.values[i] > MAX_QP, "Some entries cfg_qpOutValCb are out of valid range of -qpBdOffsetC to 63, inclusive.");
+    CHECK_VTM(cfg_qpInValCb.values[i] < -qpBdOffsetC || cfg_qpInValCb.values[i] > MAX_QP, "Some entries cfg_qpInValCb are out of valid range of -qpBdOffsetC to 63, inclusive.");
+    CHECK_VTM(cfg_qpOutValCb.values[i] < -qpBdOffsetC || cfg_qpOutValCb.values[i] > MAX_QP, "Some entries cfg_qpOutValCb are out of valid range of -qpBdOffsetC to 63, inclusive.");
     m_chromaQpMappingTableParams.m_deltaQpInValMinus1[0][i] = cfg_qpInValCb.values[i + 1] - cfg_qpInValCb.values[i] - 1;
     m_chromaQpMappingTableParams.m_deltaQpOutVal[0][i] = cfg_qpOutValCb.values[i + 1] - cfg_qpOutValCb.values[i];
   }
@@ -2091,12 +2099,12 @@
     m_chromaQpMappingTableParams.m_deltaQpOutVal[1].resize(cfg_qpOutValCr.values.size());
     m_chromaQpMappingTableParams.m_numPtsInCQPTableMinus1[1] = (int) cfg_qpOutValCr.values.size() - 2;
     m_chromaQpMappingTableParams.m_qpTableStartMinus26[1]    = -26 + cfg_qpInValCr.values[0];
-    CHECK(m_chromaQpMappingTableParams.m_qpTableStartMinus26[1] < -26 - qpBdOffsetC || m_chromaQpMappingTableParams.m_qpTableStartMinus26[1] > 36, "qpTableStartMinus26[1] is out of valid range of -26 -qpBdOffsetC to 36, inclusive.")
-    CHECK(cfg_qpInValCr.values[0] != cfg_qpOutValCr.values[0], "First qpInValCr value should be equal to first qpOutValCr value");
+    CHECK_VTM(m_chromaQpMappingTableParams.m_qpTableStartMinus26[1] < -26 - qpBdOffsetC || m_chromaQpMappingTableParams.m_qpTableStartMinus26[1] > 36, "qpTableStartMinus26[1] is out of valid range of -26 -qpBdOffsetC to 36, inclusive.")
+    CHECK_VTM(cfg_qpInValCr.values[0] != cfg_qpOutValCr.values[0], "First qpInValCr value should be equal to first qpOutValCr value");
     for (int i = 0; i < cfg_qpInValCr.values.size() - 1; i++)
     {
-      CHECK(cfg_qpInValCr.values[i] < -qpBdOffsetC || cfg_qpInValCr.values[i] > MAX_QP, "Some entries cfg_qpInValCr are out of valid range of -qpBdOffsetC to 63, inclusive.");
-      CHECK(cfg_qpOutValCr.values[i] < -qpBdOffsetC || cfg_qpOutValCr.values[i] > MAX_QP, "Some entries cfg_qpOutValCr are out of valid range of -qpBdOffsetC to 63, inclusive.");
+      CHECK_VTM(cfg_qpInValCr.values[i] < -qpBdOffsetC || cfg_qpInValCr.values[i] > MAX_QP, "Some entries cfg_qpInValCr are out of valid range of -qpBdOffsetC to 63, inclusive.");
+      CHECK_VTM(cfg_qpOutValCr.values[i] < -qpBdOffsetC || cfg_qpOutValCr.values[i] > MAX_QP, "Some entries cfg_qpOutValCr are out of valid range of -qpBdOffsetC to 63, inclusive.");
       m_chromaQpMappingTableParams.m_deltaQpInValMinus1[1][i] = cfg_qpInValCr.values[i + 1] - cfg_qpInValCr.values[i] - 1;
       m_chromaQpMappingTableParams.m_deltaQpOutVal[1][i] = cfg_qpOutValCr.values[i + 1] - cfg_qpOutValCr.values[i];
     }
@@ -2104,12 +2112,12 @@
     m_chromaQpMappingTableParams.m_deltaQpOutVal[2].resize(cfg_qpOutValCbCr.values.size());
     m_chromaQpMappingTableParams.m_numPtsInCQPTableMinus1[2] = (int) cfg_qpOutValCbCr.values.size() - 2;
     m_chromaQpMappingTableParams.m_qpTableStartMinus26[2]    = -26 + cfg_qpInValCbCr.values[0];
-    CHECK(m_chromaQpMappingTableParams.m_qpTableStartMinus26[2] < -26 - qpBdOffsetC || m_chromaQpMappingTableParams.m_qpTableStartMinus26[2] > 36, "qpTableStartMinus26[2] is out of valid range of -26 -qpBdOffsetC to 36, inclusive.")
-    CHECK(cfg_qpInValCbCr.values[0] != cfg_qpInValCbCr.values[0], "First qpInValCbCr value should be equal to first qpOutValCbCr value");
+    CHECK_VTM(m_chromaQpMappingTableParams.m_qpTableStartMinus26[2] < -26 - qpBdOffsetC || m_chromaQpMappingTableParams.m_qpTableStartMinus26[2] > 36, "qpTableStartMinus26[2] is out of valid range of -26 -qpBdOffsetC to 36, inclusive.")
+    CHECK_VTM(cfg_qpInValCbCr.values[0] != cfg_qpInValCbCr.values[0], "First qpInValCbCr value should be equal to first qpOutValCbCr value");
     for (int i = 0; i < cfg_qpInValCbCr.values.size() - 1; i++)
     {
-      CHECK(cfg_qpInValCbCr.values[i] < -qpBdOffsetC || cfg_qpInValCbCr.values[i] > MAX_QP, "Some entries cfg_qpInValCbCr are out of valid range of -qpBdOffsetC to 63, inclusive.");
-      CHECK(cfg_qpOutValCbCr.values[i] < -qpBdOffsetC || cfg_qpOutValCbCr.values[i] > MAX_QP, "Some entries cfg_qpOutValCbCr are out of valid range of -qpBdOffsetC to 63, inclusive.");
+      CHECK_VTM(cfg_qpInValCbCr.values[i] < -qpBdOffsetC || cfg_qpInValCbCr.values[i] > MAX_QP, "Some entries cfg_qpInValCbCr are out of valid range of -qpBdOffsetC to 63, inclusive.");
+      CHECK_VTM(cfg_qpOutValCbCr.values[i] < -qpBdOffsetC || cfg_qpOutValCbCr.values[i] > MAX_QP, "Some entries cfg_qpOutValCbCr are out of valid range of -qpBdOffsetC to 63, inclusive.");
       m_chromaQpMappingTableParams.m_deltaQpInValMinus1[2][i] = cfg_qpInValCbCr.values[i + 1] - cfg_qpInValCbCr.values[i] - 1;
       m_chromaQpMappingTableParams.m_deltaQpOutVal[2][i] = cfg_qpInValCbCr.values[i + 1] - cfg_qpInValCbCr.values[i];
     }
@@ -2118,8 +2126,8 @@
 #if LUMA_ADAPTIVE_DEBLOCKING_FILTER_QP_OFFSET
   if ( m_LadfEnabed )
   {
-    CHECK( m_LadfNumIntervals != cfg_LadfQpOffset.values.size(), "size of LadfQpOffset must be equal to LadfNumIntervals");
-    CHECK( m_LadfNumIntervals - 1 != cfg_LadfIntervalLowerBound.values.size(), "size of LadfIntervalLowerBound must be equal to LadfNumIntervals - 1");
+    CHECK_VTM( m_LadfNumIntervals != cfg_LadfQpOffset.values.size(), "size of LadfQpOffset must be equal to LadfNumIntervals");
+    CHECK_VTM( m_LadfNumIntervals - 1 != cfg_LadfIntervalLowerBound.values.size(), "size of LadfIntervalLowerBound must be equal to LadfNumIntervals - 1");
     m_LadfQpOffset = cfg_LadfQpOffset.values;
     m_LadfIntervalLowerBound[0] = 0;
     for (int k = 1; k < m_LadfNumIntervals; k++)
@@ -2156,14 +2164,14 @@
 
   if( m_virtualBoundariesEnabledFlag )
   {
-    CHECK( m_subPicInfoPresentFlag && m_virtualBoundariesPresentFlag != 1, "When subpicture signalling is present, the signalling of virtual boundaries, if present, shall be in the SPS" );
+    CHECK_VTM( m_subPicInfoPresentFlag && m_virtualBoundariesPresentFlag != 1, "When subpicture signalling is present, the signalling of virtual boundaries, if present, shall be in the SPS" );
 
     if( m_virtualBoundariesPresentFlag )
     {
-      CHECK( m_numVerVirtualBoundaries > 3, "Number of vertical virtual boundaries must be comprised between 0 and 3 included" );
-      CHECK( m_numHorVirtualBoundaries > 3, "Number of horizontal virtual boundaries must be comprised between 0 and 3 included" );
-      CHECK( m_numVerVirtualBoundaries != cfg_virtualBoundariesPosX.values.size(), "Size of VirtualBoundariesPosX must be equal to NumVerVirtualBoundaries");
-      CHECK( m_numHorVirtualBoundaries != cfg_virtualBoundariesPosY.values.size(), "Size of VirtualBoundariesPosY must be equal to NumHorVirtualBoundaries");
+      CHECK_VTM( m_numVerVirtualBoundaries > 3, "Number of vertical virtual boundaries must be comprised between 0 and 3 included" );
+      CHECK_VTM( m_numHorVirtualBoundaries > 3, "Number of horizontal virtual boundaries must be comprised between 0 and 3 included" );
+      CHECK_VTM( m_numVerVirtualBoundaries != cfg_virtualBoundariesPosX.values.size(), "Size of VirtualBoundariesPosX must be equal to NumVerVirtualBoundaries");
+      CHECK_VTM( m_numHorVirtualBoundaries != cfg_virtualBoundariesPosY.values.size(), "Size of VirtualBoundariesPosY must be equal to NumHorVirtualBoundaries");
       m_virtualBoundariesPosX = cfg_virtualBoundariesPosX.values;
       if (m_numVerVirtualBoundaries > 1)
       {
@@ -2171,11 +2179,11 @@
       }
       for (unsigned i = 0; i < m_numVerVirtualBoundaries; i++)
       {
-        CHECK( m_virtualBoundariesPosX[i] == 0 || m_virtualBoundariesPosX[i] >= m_iSourceWidth, "The vertical virtual boundary must be within the picture" );
-        CHECK( m_virtualBoundariesPosX[i] % 8, "The vertical virtual boundary must be a multiple of 8 luma samples" );
+        CHECK_VTM( m_virtualBoundariesPosX[i] == 0 || m_virtualBoundariesPosX[i] >= m_iSourceWidth, "The vertical virtual boundary must be within the picture" );
+        CHECK_VTM( m_virtualBoundariesPosX[i] % 8, "The vertical virtual boundary must be a multiple of 8 luma samples" );
         if (i > 0)
         {
-          CHECK( m_virtualBoundariesPosX[i] - m_virtualBoundariesPosX[i-1] < m_uiCTUSize, "The distance between any two vertical virtual boundaries shall be greater than or equal to the CTU size" );
+          CHECK_VTM( m_virtualBoundariesPosX[i] - m_virtualBoundariesPosX[i-1] < m_uiCTUSize, "The distance between any two vertical virtual boundaries shall be greater than or equal to the CTU size" );
         }
       }
       m_virtualBoundariesPosY = cfg_virtualBoundariesPosY.values;
@@ -2185,11 +2193,11 @@
       }
       for (unsigned i = 0; i < m_numHorVirtualBoundaries; i++)
       {
-        CHECK( m_virtualBoundariesPosY[i] == 0 || m_virtualBoundariesPosY[i] >= m_iSourceHeight, "The horizontal virtual boundary must be within the picture" );
-        CHECK( m_virtualBoundariesPosY[i] % 8, "The horizontal virtual boundary must be a multiple of 8 luma samples" );
+        CHECK_VTM( m_virtualBoundariesPosY[i] == 0 || m_virtualBoundariesPosY[i] >= m_iSourceHeight, "The horizontal virtual boundary must be within the picture" );
+        CHECK_VTM( m_virtualBoundariesPosY[i] % 8, "The horizontal virtual boundary must be a multiple of 8 luma samples" );
         if (i > 0)
         {
-          CHECK( m_virtualBoundariesPosY[i] - m_virtualBoundariesPosY[i-1] < m_uiCTUSize, "The distance between any two horizontal virtual boundaries shall be greater than or equal to the CTU size" );
+          CHECK_VTM( m_virtualBoundariesPosY[i] - m_virtualBoundariesPosY[i-1] < m_uiCTUSize, "The distance between any two horizontal virtual boundaries shall be greater than or equal to the CTU size" );
         }
       }
     }
@@ -2197,7 +2205,7 @@
 
   if ( m_alf )
   {
-    CHECK( m_maxNumAlfAlternativesChroma < 1 || m_maxNumAlfAlternativesChroma > MAX_NUM_ALF_ALTERNATIVES_CHROMA, std::string("The maximum number of ALF Chroma filter alternatives must be in the range (1-") + std::to_string(MAX_NUM_ALF_ALTERNATIVES_CHROMA) + std::string (", inclusive)") );
+    CHECK_VTM( m_maxNumAlfAlternativesChroma < 1 || m_maxNumAlfAlternativesChroma > MAX_NUM_ALF_ALTERNATIVES_CHROMA, std::string("The maximum number of ALF Chroma filter alternatives must be in the range (1-") + std::to_string(MAX_NUM_ALF_ALTERNATIVES_CHROMA) + std::string (", inclusive)") );
   }
 
   // reading external dQP description from file
@@ -2234,7 +2242,7 @@
   }
   if ( m_omniViewportSEIEnabled && !m_omniViewportSEICancelFlag )
   {
-    CHECK (!( m_omniViewportSEICntMinus1 >= 0 && m_omniViewportSEICntMinus1 < 16 ), "SEIOmniViewportCntMinus1 must be in the range of 0 to 16");
+    CHECK_VTM(!( m_omniViewportSEICntMinus1 >= 0 && m_omniViewportSEICntMinus1 < 16 ), "SEIOmniViewportCntMinus1 must be in the range of 0 to 16");
     m_omniViewportSEIAzimuthCentre.resize  (m_omniViewportSEICntMinus1+1);
     m_omniViewportSEIElevationCentre.resize(m_omniViewportSEICntMinus1+1);
     m_omniViewportSEITiltCentre.resize     (m_omniViewportSEICntMinus1+1);
@@ -2252,17 +2260,17 @@
 
   if(!m_rwpSEIRwpCancelFlag && m_rwpSEIEnabled)
   {
-    CHECK (!( m_rwpSEINumPackedRegions > 0 && m_rwpSEINumPackedRegions <= std::numeric_limits<uint8_t>::max() ), "SEIRwpNumPackedRegions must be in the range of 1 to 255");
-    CHECK (!(cfg_rwpSEIRwpTransformType.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIRwpTransformType values be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIRwpGuardBandFlag.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIRwpGuardBandFlag values must be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIProjRegionWidth.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIProjRegionWidth values must be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIProjRegionHeight.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIProjRegionHeight values must be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIRwpSEIProjRegionTop.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIRwpSEIProjRegionTop values must be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIProjRegionLeft.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIProjRegionLeft values must be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIPackedRegionWidth.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIPackedRegionWidth values must be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIPackedRegionHeight.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIPackedRegionHeight values must be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIPackedRegionTop.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIPackedRegionTop values must be equal to SEIRwpNumPackedRegions");
-    CHECK (!(cfg_rwpSEIPackedRegionLeft.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIPackedRegionLeft values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!( m_rwpSEINumPackedRegions > 0 && m_rwpSEINumPackedRegions <= std::numeric_limits<uint8_t>::max() ), "SEIRwpNumPackedRegions must be in the range of 1 to 255");
+    CHECK_VTM(!(cfg_rwpSEIRwpTransformType.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIRwpTransformType values be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIRwpGuardBandFlag.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIRwpGuardBandFlag values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIProjRegionWidth.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIProjRegionWidth values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIProjRegionHeight.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIProjRegionHeight values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIRwpSEIProjRegionTop.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIRwpSEIProjRegionTop values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIProjRegionLeft.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIProjRegionLeft values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIPackedRegionWidth.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIPackedRegionWidth values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIPackedRegionHeight.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIPackedRegionHeight values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIPackedRegionTop.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIPackedRegionTop values must be equal to SEIRwpNumPackedRegions");
+    CHECK_VTM(!(cfg_rwpSEIPackedRegionLeft.values.size() == m_rwpSEINumPackedRegions), "Number of must SEIPackedRegionLeft values must be equal to SEIRwpNumPackedRegions");
 
     m_rwpSEIRwpTransformType.resize(m_rwpSEINumPackedRegions);
     m_rwpSEIRwpGuardBandFlag.resize(m_rwpSEINumPackedRegions);
@@ -2283,7 +2291,7 @@
     for( int i=0; i < m_rwpSEINumPackedRegions; i++ )
     {
       m_rwpSEIRwpTransformType[i]                     = cfg_rwpSEIRwpTransformType.values[i];
-      CHECK (!( m_rwpSEIRwpTransformType[i] >= 0 && m_rwpSEIRwpTransformType[i] <= 7 ), "SEIRwpTransformType must be in the range of 0 to 7");
+      CHECK_VTM(!( m_rwpSEIRwpTransformType[i] >= 0 && m_rwpSEIRwpTransformType[i] <= 7 ), "SEIRwpTransformType must be in the range of 0 to 7");
       m_rwpSEIRwpGuardBandFlag[i]                     = cfg_rwpSEIRwpGuardBandFlag.values[i];
       m_rwpSEIProjRegionWidth[i]                      = cfg_rwpSEIProjRegionWidth.values[i];
       m_rwpSEIProjRegionHeight[i]                     = cfg_rwpSEIProjRegionHeight.values[i];
@@ -2299,7 +2307,7 @@
         m_rwpSEIRwpRightGuardBandWidth[i]             =  cfg_rwpSEIRwpRightGuardBandWidth.values[i];
         m_rwpSEIRwpTopGuardBandHeight[i]              =  cfg_rwpSEIRwpTopGuardBandHeight.values[i];
         m_rwpSEIRwpBottomGuardBandHeight[i]           =  cfg_rwpSEIRwpBottomGuardBandHeight.values[i];
-        CHECK (! ( m_rwpSEIRwpLeftGuardBandWidth[i] > 0 || m_rwpSEIRwpRightGuardBandWidth[i] > 0 || m_rwpSEIRwpTopGuardBandHeight[i] >0 || m_rwpSEIRwpBottomGuardBandHeight[i] >0 ), "At least one of the RWP guard band parameters mut be greater than zero");
+        CHECK_VTM(! ( m_rwpSEIRwpLeftGuardBandWidth[i] > 0 || m_rwpSEIRwpRightGuardBandWidth[i] > 0 || m_rwpSEIRwpTopGuardBandHeight[i] >0 || m_rwpSEIRwpBottomGuardBandHeight[i] >0 ), "At least one of the RWP guard band parameters mut be greater than zero");
         m_rwpSEIRwpGuardBandNotUsedForPredFlag[i]     =  cfg_rwpSEIRwpGuardBandNotUsedForPredFlag.values[i];
         for( int j=0; j < 4; j++ )
         {
@@ -2312,16 +2320,16 @@
   if (m_gcmpSEIEnabled && !m_gcmpSEICancelFlag)
   {
     int numFace = m_gcmpSEIPackingType == 4 || m_gcmpSEIPackingType == 5 ? 5 : 6;
-    CHECK (!(cfg_gcmpSEIFaceIndex.values.size()                  == numFace), "Number of SEIGcmpFaceIndex must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
-    CHECK (!(cfg_gcmpSEIFaceRotation.values.size()               == numFace), "Number of SEIGcmpFaceRotation must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
+    CHECK_VTM(!(cfg_gcmpSEIFaceIndex.values.size()                  == numFace), "Number of SEIGcmpFaceIndex must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
+    CHECK_VTM(!(cfg_gcmpSEIFaceRotation.values.size()               == numFace), "Number of SEIGcmpFaceRotation must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
     m_gcmpSEIFaceIndex.resize(numFace);
     m_gcmpSEIFaceRotation.resize(numFace);
     if (m_gcmpSEIMappingFunctionType == 2)
     {
-      CHECK (!(cfg_gcmpSEIFunctionCoeffU.values.size()           == numFace), "Number of SEIGcmpFunctionCoeffU must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
-      CHECK (!(cfg_gcmpSEIFunctionUAffectedByVFlag.values.size() == numFace), "Number of SEIGcmpFunctionUAffectedByVFlag must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
-      CHECK (!(cfg_gcmpSEIFunctionCoeffV.values.size()           == numFace), "Number of SEIGcmpFunctionCoeffV must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
-      CHECK (!(cfg_gcmpSEIFunctionVAffectedByUFlag.values.size() == numFace), "Number of SEIGcmpFunctionVAffectedByUFlag must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
+      CHECK_VTM(!(cfg_gcmpSEIFunctionCoeffU.values.size()           == numFace), "Number of SEIGcmpFunctionCoeffU must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
+      CHECK_VTM(!(cfg_gcmpSEIFunctionUAffectedByVFlag.values.size() == numFace), "Number of SEIGcmpFunctionUAffectedByVFlag must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
+      CHECK_VTM(!(cfg_gcmpSEIFunctionCoeffV.values.size()           == numFace), "Number of SEIGcmpFunctionCoeffV must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
+      CHECK_VTM(!(cfg_gcmpSEIFunctionVAffectedByUFlag.values.size() == numFace), "Number of SEIGcmpFunctionVAffectedByUFlag must be equal to 5 when SEIGcmpPackingType is equal to 4 or 5, otherwise, it must be equal to 6");
       m_gcmpSEIFunctionCoeffU.resize(numFace);
       m_gcmpSEIFunctionUAffectedByVFlag.resize(numFace);
       m_gcmpSEIFunctionCoeffV.resize(numFace);
@@ -2647,7 +2655,7 @@
   if (m_profile != Profile::NONE)
   {
     const ProfileFeatures *features = ProfileFeatures::getProfileFeatures(m_profile);
-    CHECK(features->profile != m_profile, "Profile not found");
+    CHECK_VTM(features->profile != m_profile, "Profile not found");
     xConfirmPara(m_level == Level::LEVEL15_5 && !features->canUseLevel15p5, "Profile does not support level 15.5");
   }
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/App/EncoderApp/EncAppCfg.h ../VVCSoftware_10/source/App/EncoderApp/EncAppCfg.h
--- ../vtm10_original/VVCSoftware_VTM/source/App/EncoderApp/EncAppCfg.h	2022-09-16 14:27:06.120532918 +0200
+++ ../VVCSoftware_10/source/App/EncoderApp/EncAppCfg.h	2022-05-13 17:45:28.256156222 +0200
@@ -86,6 +86,13 @@
   std::string m_bitstreamFileName;                            ///< output bitstream file
   std::string m_reconFileName;                                ///< output reconstruction file
 
+  // altissie added
+  bool      m_writePartition;                                 ///< write the perfect partition
+  bool      m_readPartition;                                  ///< read the partition saved in dat file. Reinject the best partition
+  bool      m_predictPartition;                               ///< predict the partition with cnn+ml model in intra
+  bool      m_predictPartitionInter;                               ///< predict the partition with cnn+ml model in inter
+  std::string m_datFolder;                                   ///< dat folder to save and load partition
+
   // Lambda modifiers
   double    m_adLambdaModifier[ MAX_TLAYER ];                 ///< Lambda modifier array for each temporal layer
   std::vector<double> m_adIntraLambdaModifier;                ///< Lambda modifier for Intra pictures, one for each temporal layer. If size>temporalLayer, then use [temporalLayer], else if size>0, use [size()-1], else use m_adLambdaModifier.
@@ -773,6 +780,17 @@
   void  destroy   ();                                         ///< destroy option handling class
   bool  parseCfg  ( int argc, char* argv[] );                ///< parse configuration file to fill member variables
 
+  //altissie added
+  unsigned int getM_uiCTUSize() const {return m_uiCTUSize;};
+  const bool is_writePartition() const {return m_writePartition;};
+  const bool is_readPartition() const {return m_readPartition;};
+  const bool is_predictPartition() const {return m_predictPartition;};
+  const bool is_predictPartitionInter() const {return m_predictPartitionInter;};
+  const std::string &get_filenameInput() const {return m_inputFileName;};
+  const std::string &get_datFolder() const {return m_datFolder;};
+  const unsigned int get_qp() const {return m_iQP;};
+  int get_sourceWidth() const {return m_iSourceWidth;};
+  int get_sourceHeight() const {return m_iSourceHeight;};
 };// END CLASS DEFINITION EncAppCfg
 
 //! \}
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/App/EncoderApp/EncApp.cpp ../VVCSoftware_10/source/App/EncoderApp/EncApp.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/App/EncoderApp/EncApp.cpp	2022-09-16 14:27:06.120532918 +0200
+++ ../VVCSoftware_10/source/App/EncoderApp/EncApp.cpp	2022-05-13 17:45:28.276155995 +0200
@@ -182,7 +182,7 @@
       }
     }
   }
-  CHECK( m_numPtlsInVps == 0, "There has to be at least one PTL structure in the VPS." );
+  CHECK_VTM( m_numPtlsInVps == 0, "There has to be at least one PTL structure in the VPS." );
   vps.setNumPtls                                                 ( m_numPtlsInVps );
   vps.setPtPresentFlag                                           (0, 1);
   for (int i = 0; i < vps.getNumPtls(); i++)
@@ -203,7 +203,7 @@
   ptls[0].setTierFlag                                            ( m_levelTier );
   ptls[0].setFrameOnlyConstraintFlag                             ( m_frameOnlyConstraintFlag);
   ptls[0].setMultiLayerEnabledFlag                               ( m_multiLayerEnabledFlag);
-  CHECK((m_profile == Profile::MAIN_10 || m_profile == Profile::MAIN_10_444
+  CHECK_VTM((m_profile == Profile::MAIN_10 || m_profile == Profile::MAIN_10_444
          || m_profile == Profile::MAIN_10_STILL_PICTURE || m_profile == Profile::MAIN_10_444_STILL_PICTURE)
           && m_multiLayerEnabledFlag,
         "ptl_multilayer_enabled_flag shall be equal to 0 for non-multilayer profiles");
@@ -259,16 +259,16 @@
     m_cEncLib.setPicHeaderInSliceHeaderConstraintFlag(m_picHeaderInSliceHeaderConstraintFlag);
     m_cEncLib.setOneSlicePerPicConstraintFlag(m_oneSlicePerPicConstraintFlag);
     m_cEncLib.setNoIdrRplConstraintFlag(m_noIdrRplConstraintFlag);
-    CHECK(m_noIdrRplConstraintFlag&& m_idrRefParamList, "IDR RPL shall be deactivated when gci_no_idr_rpl_constraint_flag equal to 1");
+    CHECK_VTM(m_noIdrRplConstraintFlag&& m_idrRefParamList, "IDR RPL shall be deactivated when gci_no_idr_rpl_constraint_flag equal to 1");
 
     m_cEncLib.setNoRectSliceConstraintFlag(m_noRectSliceConstraintFlag);
-    CHECK(m_noRectSliceConstraintFlag && !m_rasterSliceFlag, "Rectangular slice shall be deactivated when gci_no_rectangular_slice_constraint_flag equal to 1");
+    CHECK_VTM(m_noRectSliceConstraintFlag && !m_rasterSliceFlag, "Rectangular slice shall be deactivated when gci_no_rectangular_slice_constraint_flag equal to 1");
 
     m_cEncLib.setOneSlicePerSubpicConstraintFlag(m_oneSlicePerSubpicConstraintFlag);
-    CHECK(m_oneSlicePerSubpicConstraintFlag && !m_singleSlicePerSubPicFlag, "Each picture shall consist of one and only one rectangular slice when gci_one_slice_per_subpic_constraint_flag equal to 1");
+    CHECK_VTM(m_oneSlicePerSubpicConstraintFlag && !m_singleSlicePerSubPicFlag, "Each picture shall consist of one and only one rectangular slice when gci_one_slice_per_subpic_constraint_flag equal to 1");
 
     m_cEncLib.setNoSubpicInfoConstraintFlag(m_noSubpicInfoConstraintFlag);
-    CHECK(m_noSubpicInfoConstraintFlag&& m_subPicInfoPresentFlag, "Subpicture information shall not present when gci_no_subpic_info_constraint_flag equal to 1");
+    CHECK_VTM(m_noSubpicInfoConstraintFlag&& m_subPicInfoPresentFlag, "Subpicture information shall not present when gci_no_subpic_info_constraint_flag equal to 1");
     m_cEncLib.setOnePictureOnlyConstraintFlag(m_onePictureOnlyConstraintFlag);
     m_cEncLib.setIntraOnlyConstraintFlag(m_intraOnlyConstraintFlag);
     m_cEncLib.setNoIdrConstraintFlag(m_noIdrConstraintFlag);
@@ -277,160 +277,160 @@
     m_cEncLib.setNoCuQpDeltaConstraintFlag(m_noCuQpDeltaConstraintFlag);
 
     m_cEncLib.setNoTrailConstraintFlag(m_noTrailConstraintFlag);
-    CHECK(m_noTrailConstraintFlag && m_iIntraPeriod != 1, "TRAIL shall be deactivated when m_noTrailConstraintFlag is equal to 1");
+    CHECK_VTM(m_noTrailConstraintFlag && m_iIntraPeriod != 1, "TRAIL shall be deactivated when m_noTrailConstraintFlag is equal to 1");
 
     m_cEncLib.setNoStsaConstraintFlag(m_noStsaConstraintFlag);
-    CHECK(m_noStsaConstraintFlag && (m_iIntraPeriod != 1 || xHasNonZeroTemporalID()), "STSA shall be deactivated when m_noStsaConstraintFlag is equal to 1");
+    CHECK_VTM(m_noStsaConstraintFlag && (m_iIntraPeriod != 1 || xHasNonZeroTemporalID()), "STSA shall be deactivated when m_noStsaConstraintFlag is equal to 1");
 
     m_cEncLib.setNoRaslConstraintFlag(m_noRaslConstraintFlag);
-    CHECK(m_noRaslConstraintFlag && (m_iIntraPeriod != 1 || xHasLeadingPicture()), "RASL shall be deactivated when m_noRaslConstraintFlag is equal to 1");
+    CHECK_VTM(m_noRaslConstraintFlag && (m_iIntraPeriod != 1 || xHasLeadingPicture()), "RASL shall be deactivated when m_noRaslConstraintFlag is equal to 1");
 
     m_cEncLib.setNoRadlConstraintFlag(m_noRadlConstraintFlag);
-    CHECK(m_noRadlConstraintFlag && (m_iIntraPeriod != 1 || xHasLeadingPicture()), "RADL shall be deactivated when m_noRadlConstraintFlag is equal to 1");
+    CHECK_VTM(m_noRadlConstraintFlag && (m_iIntraPeriod != 1 || xHasLeadingPicture()), "RADL shall be deactivated when m_noRadlConstraintFlag is equal to 1");
 
     m_cEncLib.setNoCraConstraintFlag(m_noCraConstraintFlag);
-    CHECK(m_noCraConstraintFlag && (m_iDecodingRefreshType == 1), "CRA shall be deactivated when m_noCraConstraintFlag is equal to 1");
+    CHECK_VTM(m_noCraConstraintFlag && (m_iDecodingRefreshType == 1), "CRA shall be deactivated when m_noCraConstraintFlag is equal to 1");
 
     m_cEncLib.setNoRprConstraintFlag(m_noRprConstraintFlag);
-    CHECK(m_noRprConstraintFlag && m_rprEnabledFlag, "Reference picture resampling shall be deactivated when m_noRprConstraintFlag is equal to 1");
+    CHECK_VTM(m_noRprConstraintFlag && m_rprEnabledFlag, "Reference picture resampling shall be deactivated when m_noRprConstraintFlag is equal to 1");
 
     m_cEncLib.setNoResChangeInClvsConstraintFlag(m_noResChangeInClvsConstraintFlag);
-    CHECK(m_noResChangeInClvsConstraintFlag && m_resChangeInClvsEnabled, "Resolution change in CLVS shall be deactivated when m_noResChangeInClvsConstraintFlag is equal to 1");
+    CHECK_VTM(m_noResChangeInClvsConstraintFlag && m_resChangeInClvsEnabled, "Resolution change in CLVS shall be deactivated when m_noResChangeInClvsConstraintFlag is equal to 1");
 
     m_cEncLib.setMaxBitDepthConstraintIdc(m_maxBitDepthConstraintIdc);
-    CHECK(m_internalBitDepth[CHANNEL_TYPE_LUMA] > m_maxBitDepthConstraintIdc, "Internal bit depth shall be less than or equal to m_maxBitDepthConstraintIdc");
+    CHECK_VTM(m_internalBitDepth[CHANNEL_TYPE_LUMA] > m_maxBitDepthConstraintIdc, "Internal bit depth shall be less than or equal to m_maxBitDepthConstraintIdc");
 
     m_cEncLib.setMaxChromaFormatConstraintIdc(m_maxChromaFormatConstraintIdc);
-    CHECK(m_chromaFormatIDC > m_maxChromaFormatConstraintIdc, "Chroma format Idc shall be less than or equal to m_maxBitDepthConstraintIdc");
+    CHECK_VTM(m_chromaFormatIDC > m_maxChromaFormatConstraintIdc, "Chroma format Idc shall be less than or equal to m_maxBitDepthConstraintIdc");
 
     m_cEncLib.setNoMttConstraintFlag(m_noMttConstraintFlag);
-    CHECK(m_noMttConstraintFlag && (m_uiMaxMTTHierarchyDepth || m_uiMaxMTTHierarchyDepthI || m_uiMaxMTTHierarchyDepthIChroma), "Mtt shall be deactivated when m_bNoMttConstraintFlag is equal to 1");
+    CHECK_VTM(m_noMttConstraintFlag && (m_uiMaxMTTHierarchyDepth || m_uiMaxMTTHierarchyDepthI || m_uiMaxMTTHierarchyDepthIChroma), "Mtt shall be deactivated when m_bNoMttConstraintFlag is equal to 1");
 
     m_cEncLib.setNoQtbttDualTreeIntraConstraintFlag(m_noQtbttDualTreeIntraConstraintFlag);
-    CHECK(m_noQtbttDualTreeIntraConstraintFlag && m_dualTree, "Dual tree shall be deactivated when m_bNoQtbttDualTreeIntraConstraintFlag is equal to 1");
+    CHECK_VTM(m_noQtbttDualTreeIntraConstraintFlag && m_dualTree, "Dual tree shall be deactivated when m_bNoQtbttDualTreeIntraConstraintFlag is equal to 1");
 
     m_cEncLib.setMaxLog2CtuSizeConstraintIdc(m_maxLog2CtuSizeConstraintIdc);
-    CHECK( m_uiCTUSize > (1<<(m_maxLog2CtuSizeConstraintIdc)), "CTUSize shall be less than or equal to 1 << m_maxLog2CtuSize");
+    CHECK_VTM( m_uiCTUSize > (1<<(m_maxLog2CtuSizeConstraintIdc)), "CTUSize shall be less than or equal to 1 << m_maxLog2CtuSize");
 
     m_cEncLib.setNoPartitionConstraintsOverrideConstraintFlag(m_noPartitionConstraintsOverrideConstraintFlag);
-    CHECK(m_noPartitionConstraintsOverrideConstraintFlag && m_SplitConsOverrideEnabledFlag, "Partition override shall be deactivated when m_noPartitionConstraintsOverrideConstraintFlag is equal to 1");
+    CHECK_VTM(m_noPartitionConstraintsOverrideConstraintFlag && m_SplitConsOverrideEnabledFlag, "Partition override shall be deactivated when m_noPartitionConstraintsOverrideConstraintFlag is equal to 1");
 
     m_cEncLib.setNoSaoConstraintFlag(m_noSaoConstraintFlag);
-    CHECK(m_noSaoConstraintFlag && m_bUseSAO, "SAO shall be deactivated when m_bNoSaoConstraintFlag is equal to 1");
+    CHECK_VTM(m_noSaoConstraintFlag && m_bUseSAO, "SAO shall be deactivated when m_bNoSaoConstraintFlag is equal to 1");
 
     m_cEncLib.setNoAlfConstraintFlag(m_noAlfConstraintFlag);
-    CHECK(m_noAlfConstraintFlag && m_alf, "ALF shall be deactivated when m_bNoAlfConstraintFlag is equal to 1");
+    CHECK_VTM(m_noAlfConstraintFlag && m_alf, "ALF shall be deactivated when m_bNoAlfConstraintFlag is equal to 1");
 
     m_cEncLib.setNoCCAlfConstraintFlag(m_noCCAlfConstraintFlag);
-    CHECK(m_noCCAlfConstraintFlag && m_ccalf, "CCALF shall be deactivated when m_noCCAlfConstraintFlag is equal to 1");
+    CHECK_VTM(m_noCCAlfConstraintFlag && m_ccalf, "CCALF shall be deactivated when m_noCCAlfConstraintFlag is equal to 1");
 
     m_cEncLib.setNoWeightedPredictionConstraintFlag(m_noWeightedPredictionConstraintFlag);
-    CHECK(m_noWeightedPredictionConstraintFlag && (m_useWeightedPred || m_useWeightedBiPred), "Weighted Prediction shall be deactivated when m_bNoWeightedPredictionConstraintFlag is equal to 1");
+    CHECK_VTM(m_noWeightedPredictionConstraintFlag && (m_useWeightedPred || m_useWeightedBiPred), "Weighted Prediction shall be deactivated when m_bNoWeightedPredictionConstraintFlag is equal to 1");
 
     m_cEncLib.setNoRefWraparoundConstraintFlag(m_noRefWraparoundConstraintFlag);
-    CHECK(m_noRefWraparoundConstraintFlag && m_wrapAround, "Wrap around shall be deactivated when m_bNoRefWraparoundConstraintFlag is equal to 1");
+    CHECK_VTM(m_noRefWraparoundConstraintFlag && m_wrapAround, "Wrap around shall be deactivated when m_bNoRefWraparoundConstraintFlag is equal to 1");
 
     m_cEncLib.setNoTemporalMvpConstraintFlag(m_noTemporalMvpConstraintFlag);
-    CHECK(m_noTemporalMvpConstraintFlag && m_TMVPModeId, "Temporal MVP shall be deactivated when m_bNoTemporalMvpConstraintFlag is equal to 1");
+    CHECK_VTM(m_noTemporalMvpConstraintFlag && m_TMVPModeId, "Temporal MVP shall be deactivated when m_bNoTemporalMvpConstraintFlag is equal to 1");
 
     m_cEncLib.setNoSbtmvpConstraintFlag(m_noSbtmvpConstraintFlag);
-    CHECK(m_noSbtmvpConstraintFlag && m_sbTmvpEnableFlag,
+    CHECK_VTM(m_noSbtmvpConstraintFlag && m_sbTmvpEnableFlag,
           "SbTMVP shall be deactivated when m_bNoSbtmvpConstraintFlag is equal to 1");
 
     m_cEncLib.setNoAmvrConstraintFlag(m_noAmvrConstraintFlag);
-    CHECK(m_noAmvrConstraintFlag && (m_ImvMode != IMV_OFF || m_AffineAmvr), "AMVR shall be deactivated when m_bNoAmvrConstraintFlag is equal to 1");
+    CHECK_VTM(m_noAmvrConstraintFlag && (m_ImvMode != IMV_OFF || m_AffineAmvr), "AMVR shall be deactivated when m_bNoAmvrConstraintFlag is equal to 1");
 
     m_cEncLib.setNoBdofConstraintFlag(m_noBdofConstraintFlag);
-    CHECK(m_noBdofConstraintFlag && m_BIO, "BIO shall be deactivated when m_bNoBdofConstraintFlag is equal to 1");
+    CHECK_VTM(m_noBdofConstraintFlag && m_BIO, "BIO shall be deactivated when m_bNoBdofConstraintFlag is equal to 1");
 
     m_cEncLib.setNoDmvrConstraintFlag(m_noDmvrConstraintFlag);
-    CHECK(m_noDmvrConstraintFlag && m_DMVR, "DMVR shall be deactivated when m_noDmvrConstraintFlag is equal to 1");
+    CHECK_VTM(m_noDmvrConstraintFlag && m_DMVR, "DMVR shall be deactivated when m_noDmvrConstraintFlag is equal to 1");
 
     m_cEncLib.setNoCclmConstraintFlag(m_noCclmConstraintFlag);
-    CHECK(m_noCclmConstraintFlag && m_LMChroma, "CCLM shall be deactivated when m_bNoCclmConstraintFlag is equal to 1");
+    CHECK_VTM(m_noCclmConstraintFlag && m_LMChroma, "CCLM shall be deactivated when m_bNoCclmConstraintFlag is equal to 1");
 
     m_cEncLib.setNoMtsConstraintFlag(m_noMtsConstraintFlag);
-    CHECK(m_noMtsConstraintFlag && (m_MTS || m_MTSImplicit), "MTS shall be deactivated when m_bNoMtsConstraintFlag is equal to 1");
+    CHECK_VTM(m_noMtsConstraintFlag && (m_MTS || m_MTSImplicit), "MTS shall be deactivated when m_bNoMtsConstraintFlag is equal to 1");
 
     m_cEncLib.setNoSbtConstraintFlag(m_noSbtConstraintFlag);
-    CHECK(m_noSbtConstraintFlag && m_SBT, "SBT shall be deactivated when mm_noSbtConstraintFlag_nonPackedConstraintFlag is equal to 1");
+    CHECK_VTM(m_noSbtConstraintFlag && m_SBT, "SBT shall be deactivated when mm_noSbtConstraintFlag_nonPackedConstraintFlag is equal to 1");
 
     m_cEncLib.setNoAffineMotionConstraintFlag(m_noAffineMotionConstraintFlag);
-    CHECK(m_noAffineMotionConstraintFlag && m_Affine, "Affine shall be deactivated when m_bNoAffineMotionConstraintFlag is equal to 1");
+    CHECK_VTM(m_noAffineMotionConstraintFlag && m_Affine, "Affine shall be deactivated when m_bNoAffineMotionConstraintFlag is equal to 1");
 
     m_cEncLib.setNoBcwConstraintFlag(m_noBcwConstraintFlag);
-    CHECK(m_noBcwConstraintFlag && m_bcw, "BCW shall be deactivated when m_bNoBcwConstraintFlag is equal to 1");
+    CHECK_VTM(m_noBcwConstraintFlag && m_bcw, "BCW shall be deactivated when m_bNoBcwConstraintFlag is equal to 1");
 
     m_cEncLib.setNoIbcConstraintFlag(m_noIbcConstraintFlag);
-    CHECK(m_noIbcConstraintFlag && m_IBCMode, "IBC shall be deactivated when m_noIbcConstraintFlag is equal to 1");
+    CHECK_VTM(m_noIbcConstraintFlag && m_IBCMode, "IBC shall be deactivated when m_noIbcConstraintFlag is equal to 1");
 
     m_cEncLib.setNoCiipConstraintFlag(m_noCiipConstraintFlag);
-    CHECK(m_noCiipConstraintFlag && m_ciip, "CIIP shall be deactivated when m_bNoCiipConstraintFlag is equal to 1");
+    CHECK_VTM(m_noCiipConstraintFlag && m_ciip, "CIIP shall be deactivated when m_bNoCiipConstraintFlag is equal to 1");
 
     m_cEncLib.setNoGeoConstraintFlag(m_noGeoConstraintFlag);
-    CHECK(m_noGeoConstraintFlag && m_Geo, "GEO shall be deactivated when m_noGeoConstraintFlag is equal to 1");
+    CHECK_VTM(m_noGeoConstraintFlag && m_Geo, "GEO shall be deactivated when m_noGeoConstraintFlag is equal to 1");
 
     m_cEncLib.setNoLadfConstraintFlag(m_noLadfConstraintFlag);
-    CHECK(m_noLadfConstraintFlag && m_LadfEnabed, "LADF shall be deactivated when m_bNoLadfConstraintFlag is equal to 1");
+    CHECK_VTM(m_noLadfConstraintFlag && m_LadfEnabed, "LADF shall be deactivated when m_bNoLadfConstraintFlag is equal to 1");
 
     m_cEncLib.setNoTransformSkipConstraintFlag(m_noTransformSkipConstraintFlag);
-    CHECK(m_noTransformSkipConstraintFlag && m_useTransformSkip, "Transform skip shall be deactivated when m_noTransformSkipConstraintFlag is equal to 1");
+    CHECK_VTM(m_noTransformSkipConstraintFlag && m_useTransformSkip, "Transform skip shall be deactivated when m_noTransformSkipConstraintFlag is equal to 1");
 
     m_cEncLib.setNoLumaTransformSize64ConstraintFlag(m_noLumaTransformSize64ConstraintFlag);
-    CHECK(m_noLumaTransformSize64ConstraintFlag && m_log2MaxTbSize > 5, "Max transform size shall be less than 64 when m_noLumaTransformSize64ConstraintFlag is equal to 1");
+    CHECK_VTM(m_noLumaTransformSize64ConstraintFlag && m_log2MaxTbSize > 5, "Max transform size shall be less than 64 when m_noLumaTransformSize64ConstraintFlag is equal to 1");
 
     m_cEncLib.setNoBDPCMConstraintFlag(m_noBDPCMConstraintFlag);
-    CHECK(m_noBDPCMConstraintFlag && m_useBDPCM, "BDPCM shall be deactivated when m_noBDPCMConstraintFlag is equal to 1");
+    CHECK_VTM(m_noBDPCMConstraintFlag && m_useBDPCM, "BDPCM shall be deactivated when m_noBDPCMConstraintFlag is equal to 1");
 
     m_cEncLib.setNoJointCbCrConstraintFlag(m_noJointCbCrConstraintFlag);
-    CHECK(m_noJointCbCrConstraintFlag && m_JointCbCrMode, "JCCR shall be deactivated when m_noJointCbCrConstraintFlag is equal to 1");
+    CHECK_VTM(m_noJointCbCrConstraintFlag && m_JointCbCrMode, "JCCR shall be deactivated when m_noJointCbCrConstraintFlag is equal to 1");
 
     m_cEncLib.setNoDepQuantConstraintFlag(m_noDepQuantConstraintFlag);
-    CHECK(m_noDepQuantConstraintFlag && m_depQuantEnabledFlag, "DQ shall be deactivated when m_bNoDepQuantConstraintFlag is equal to 1");
+    CHECK_VTM(m_noDepQuantConstraintFlag && m_depQuantEnabledFlag, "DQ shall be deactivated when m_bNoDepQuantConstraintFlag is equal to 1");
 
     m_cEncLib.setNoSignDataHidingConstraintFlag(m_noSignDataHidingConstraintFlag);
-    CHECK(m_noSignDataHidingConstraintFlag && m_signDataHidingEnabledFlag, "SDH shall be deactivated when m_bNoSignDataHidingConstraintFlag is equal to 1");
+    CHECK_VTM(m_noSignDataHidingConstraintFlag && m_signDataHidingEnabledFlag, "SDH shall be deactivated when m_bNoSignDataHidingConstraintFlag is equal to 1");
 
     m_cEncLib.setNoApsConstraintFlag(m_noApsConstraintFlag);
-    CHECK(m_noApsConstraintFlag && (m_lmcsEnabled || (m_useScalingListId != SCALING_LIST_OFF)), "LMCS and explict scaling list shall be deactivated when m_noApsConstraintFlag is equal to 1");
+    CHECK_VTM(m_noApsConstraintFlag && (m_lmcsEnabled || (m_useScalingListId != SCALING_LIST_OFF)), "LMCS and explict scaling list shall be deactivated when m_noApsConstraintFlag is equal to 1");
 
     m_cEncLib.setNoMrlConstraintFlag(m_noMrlConstraintFlag);
-    CHECK(m_noMrlConstraintFlag && m_MRL, "MRL shall be deactivated when m_noMrlConstraintFlag is equal to 1");
+    CHECK_VTM(m_noMrlConstraintFlag && m_MRL, "MRL shall be deactivated when m_noMrlConstraintFlag is equal to 1");
 
     m_cEncLib.setNoIspConstraintFlag(m_noIspConstraintFlag);
-    CHECK(m_noIspConstraintFlag && m_ISP, "ISP shall be deactivated when m_noIspConstraintFlag is equal to 1");
+    CHECK_VTM(m_noIspConstraintFlag && m_ISP, "ISP shall be deactivated when m_noIspConstraintFlag is equal to 1");
 
     m_cEncLib.setNoMipConstraintFlag(m_noMipConstraintFlag);
-    CHECK(m_noMipConstraintFlag && m_MIP, "MIP shall be deactivated when m_noMipConstraintFlag is equal to 1");
+    CHECK_VTM(m_noMipConstraintFlag && m_MIP, "MIP shall be deactivated when m_noMipConstraintFlag is equal to 1");
 
     m_cEncLib.setNoLfnstConstraintFlag(m_noLfnstConstraintFlag);
-    CHECK(m_noLfnstConstraintFlag && m_LFNST, "LFNST shall be deactivated when m_noLfnstConstraintFlag is equal to 1");
+    CHECK_VTM(m_noLfnstConstraintFlag && m_LFNST, "LFNST shall be deactivated when m_noLfnstConstraintFlag is equal to 1");
 
     m_cEncLib.setNoMmvdConstraintFlag(m_noMmvdConstraintFlag);
-    CHECK(m_noMmvdConstraintFlag && m_MMVD, "MMVD shall be deactivated when m_noMmvdConstraintFlag is equal to 1");
+    CHECK_VTM(m_noMmvdConstraintFlag && m_MMVD, "MMVD shall be deactivated when m_noMmvdConstraintFlag is equal to 1");
 
     m_cEncLib.setNoSmvdConstraintFlag(m_noSmvdConstraintFlag);
-    CHECK(m_noSmvdConstraintFlag && m_SMVD, "SMVD shall be deactivated when m_noSmvdConstraintFlag is equal to 1");
+    CHECK_VTM(m_noSmvdConstraintFlag && m_SMVD, "SMVD shall be deactivated when m_noSmvdConstraintFlag is equal to 1");
 
     m_cEncLib.setNoProfConstraintFlag(m_noProfConstraintFlag);
-    CHECK(m_noProfConstraintFlag && m_PROF, "PROF shall be deactivated when m_noProfConstraintFlag is equal to 1");
+    CHECK_VTM(m_noProfConstraintFlag && m_PROF, "PROF shall be deactivated when m_noProfConstraintFlag is equal to 1");
 
     m_cEncLib.setNoPaletteConstraintFlag(m_noPaletteConstraintFlag);
-    CHECK(m_noPaletteConstraintFlag && m_PLTMode, "Palette shall be deactivated when m_noPaletteConstraintFlag is equal to 1");
+    CHECK_VTM(m_noPaletteConstraintFlag && m_PLTMode, "Palette shall be deactivated when m_noPaletteConstraintFlag is equal to 1");
 
     m_cEncLib.setNoActConstraintFlag(m_noActConstraintFlag);
-    CHECK(m_noActConstraintFlag && m_useColorTrans, "ACT shall be deactivated when m_noActConstraintFlag is equal to 1");
+    CHECK_VTM(m_noActConstraintFlag && m_useColorTrans, "ACT shall be deactivated when m_noActConstraintFlag is equal to 1");
 
     m_cEncLib.setNoLmcsConstraintFlag(m_noLmcsConstraintFlag);
-    CHECK(m_noLmcsConstraintFlag && m_lmcsEnabled, "LMCS shall be deactivated when m_noLmcsConstraintFlag is equal to 1");
+    CHECK_VTM(m_noLmcsConstraintFlag && m_lmcsEnabled, "LMCS shall be deactivated when m_noLmcsConstraintFlag is equal to 1");
 
     m_cEncLib.setNoExplicitScaleListConstraintFlag(m_noExplicitScaleListConstraintFlag);
-    CHECK(m_noExplicitScaleListConstraintFlag && m_useScalingListId != SCALING_LIST_OFF, "Explicit scaling list shall be deactivated when m_noExplicitScaleListConstraintFlag is equal to 1");
+    CHECK_VTM(m_noExplicitScaleListConstraintFlag && m_useScalingListId != SCALING_LIST_OFF, "Explicit scaling list shall be deactivated when m_noExplicitScaleListConstraintFlag is equal to 1");
 
     m_cEncLib.setNoVirtualBoundaryConstraintFlag(m_noVirtualBoundaryConstraintFlag);
-    CHECK(m_noVirtualBoundaryConstraintFlag && m_virtualBoundariesEnabledFlag, "Virtuall boundaries shall be deactivated when m_noVirtualBoundaryConstraintFlag is equal to 1");
+    CHECK_VTM(m_noVirtualBoundaryConstraintFlag && m_virtualBoundariesEnabledFlag, "Virtuall boundaries shall be deactivated when m_noVirtualBoundaryConstraintFlag is equal to 1");
     m_cEncLib.setNoChromaQpOffsetConstraintFlag(m_noChromaQpOffsetConstraintFlag);
-    CHECK(m_noChromaQpOffsetConstraintFlag && m_cuChromaQpOffsetSubdiv, "Chroma Qp offset shall be 0 when m_noChromaQpOffsetConstraintFlag is equal to 1");
+    CHECK_VTM(m_noChromaQpOffsetConstraintFlag && m_cuChromaQpOffsetSubdiv, "Chroma Qp offset shall be 0 when m_noChromaQpOffsetConstraintFlag is equal to 1");
   }
   else
   {
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/App/EncoderApp/encmain.cpp ../VVCSoftware_10/source/App/EncoderApp/encmain.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/App/EncoderApp/encmain.cpp	2022-09-16 14:27:06.120532918 +0200
+++ ../VVCSoftware_10/source/App/EncoderApp/encmain.cpp	2022-09-16 14:23:08.759229214 +0200
@@ -43,6 +43,8 @@
 #include "EncoderLib/EncLibCommon.h"
 #include "EncApp.h"
 #include "Utilities/program_options_lite.h"
+#include <EncoderLib/PartitionManager.h>
+#include <EncoderLib/PartitionPrediction.h>
 
 //! \ingroup EncoderApp
 //! \{
@@ -51,6 +53,21 @@
 static const uint32_t settingHelpWidth = 84;
 static const uint32_t settingValueWidth = 3;
 // --------------------------------------------------------------------------------------------------------------------- //
+// Extern pointer to store and load the partition + current parameter
+PartitionManager * store_partition;
+PartitionManager * load_partition;
+PartitionParam * param_partition;
+PartitionPrediction * predict_partition;
+PartitionPrediction * predict_partitionInter;
+
+//fdeep::model *model = static_cast<fdeep::model *>(malloc(sizeof(fdeep::model)));
+//std::unique_ptr<fdeep::model> model;
+
+string folder_model = "MODEL_DIRECTORY_HERE/cnn_model/" ;
+
+
+
+float time_cnn = 0;
 
 //macro value printing function
 
@@ -213,9 +230,9 @@
         if (vps->getDirectRefLayerFlag(i, j))
         {
           int refLayerChromaFormatIdcInVPS = pcEncApp[j]->getChromaFormatIDC();
-          CHECK(curLayerChromaFormatIdc != refLayerChromaFormatIdcInVPS, "The chroma formats of the current layer and the reference layer are different");
+          CHECK_VTM(curLayerChromaFormatIdc != refLayerChromaFormatIdcInVPS, "The chroma formats of the current layer and the reference layer are different");
           int refLayerBitDepthInVPS = pcEncApp[j]->getBitDepth();
-          CHECK(curLayerBitDepth != refLayerBitDepthInVPS, "The bit-depth of the current layer and the reference layer are different");
+          CHECK_VTM(curLayerBitDepth != refLayerBitDepthInVPS, "The bit-depth of the current layer and the reference layer are different");
         }
       }
     }
@@ -225,6 +242,66 @@
   printMacroSettings();
 #endif
 
+  // Get partition param from config file
+  param_partition = new PartitionParam(pcEncApp.at(0)->getM_uiCTUSize(), 6*3/*Because I decided to use 6*3 bits to encode MTT in dat file*/, pcEncApp.at(0)->is_writePartition(), pcEncApp.at(0)->is_readPartition(), pcEncApp.at(0)->is_predictPartition(), pcEncApp.at(0)->is_predictPartitionInter());
+
+  if(param_partition->is_writePartition()){
+      //Get name of the input video to create dat file to save partition
+      std::size_t posEnd = pcEncApp.at(0)->get_filenameInput().find_last_of("/");
+      string filenameFeatures = pcEncApp.at(0)->get_filenameInput().substr(posEnd+1);
+      std::size_t pos = filenameFeatures.find(".yuv");
+      filenameFeatures = filenameFeatures.substr(0,pos);
+      filenameFeatures += "_partition_" + to_string(pcEncApp.at(0)->get_qp()) + ".dat";
+      filenameFeatures = pcEncApp.at(0)->get_datFolder() + "/" + filenameFeatures;
+      // Create pointer to store partition
+      store_partition = new PartitionManager(param_partition, (u_int16_t) pcEncApp.at(0)->get_sourceWidth(),
+                                             (u_int16_t) pcEncApp.at(0)->get_sourceHeight(), filenameFeatures, !param_partition->is_writePartition());
+      store_partition->store_params();
+  }
+
+  if(param_partition->is_readPartition()){
+      //Get name of the input video to create dat file to save partition
+      std::size_t posEnd = pcEncApp.at(0)->get_filenameInput().find_last_of("/");
+      string filenameFeatures = pcEncApp.at(0)->get_filenameInput().substr(posEnd+1);
+      std::size_t pos = filenameFeatures.find(".yuv");
+      filenameFeatures = filenameFeatures.substr(0,pos);
+      filenameFeatures += "_partition_" + to_string(pcEncApp.at(0)->get_qp()) + ".dat";
+      filenameFeatures = pcEncApp.at(0)->get_datFolder() + "/" + filenameFeatures;
+      // Create pointer to load partition
+      load_partition = new PartitionManager(param_partition, (u_int16_t) pcEncApp.at(0)->get_sourceWidth(),
+                                            (u_int16_t) pcEncApp.at(0)->get_sourceHeight(), filenameFeatures, param_partition->is_readPartition());
+      load_partition->load_params();
+  }
+
+  // load the model if we predict intra partition
+  if(param_partition->is_predictPartition() ){
+    clock_t start = clock();
+    //*model = fdeep::load_model(folder_model+"my_model_tech_db_filtered2020-05-13_15-05-43_0.094_0.094.json");
+
+//    predict_partition = new PartitionPrediction(folder_model+"intra/alex_cnn.json", pcEncApp.at(0)->get_qp(), true);
+//    predict_partition = new PartitionPrediction(folder_model+"intra/my_model_tech_0.065_0.66.json", pcEncApp.at(0)->get_qp(), true);
+//    predict_partition = new PartitionPrediction(folder_model+"intra/my_model_tech_db_filtered2020-05-13_15-05-43_0.094_0.094.json", pcEncApp.at(0)->get_qp(), true);
+    predict_partition = new PartitionPrediction(folder_model+"intra/technicolor_slide.json", pcEncApp.at(0)->get_qp(), true);
+
+    predict_partition->initializeModels("intra");
+
+    time_cnn += ((double) clock() - start) / CLOCKS_PER_SEC;
+  }
+
+  // load the model if we predict inter partition
+  if(param_partition->is_predictPartitionInter() ){
+    clock_t start = clock();
+    // *model = fdeep::load_model(folder_model+"my_model_tech_db_filtered2020-05-13_15-05-43_0.094_0.094.json");
+
+//    predict_partitionInter = new PartitionPrediction(folder_model+"inter/20220228_145317_benchmark_mobileNetV2_filteredData.json", pcEncApp.at(0)->get_qp(), false);
+    predict_partitionInter = new PartitionPrediction(folder_model+"cnn/inter/my_model_inter_3dim_mobilenetv2_batch256_100epoch_dbfilteredaugmented_gooddim_2021-04-19_15-31-43_0.04_0.044.json", pcEncApp.at(0)->get_qp(), false);
+
+    predict_partitionInter->initializeModels("inter");
+
+    time_cnn += ((double) clock() - start) / CLOCKS_PER_SEC;
+  }
+
+
   // starting time
   auto startTime  = std::chrono::steady_clock::now();
   std::time_t startTime2 = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
@@ -337,6 +414,17 @@
          encTime / 1000.0);
 #endif
 
+  if(param_partition->is_predictPartition() || param_partition->is_predictPartitionInter()){
+    std::cout<<"Time in the CNN + utilization of result: "<<time_cnn<<std::endl;
+  }
+
+  // Delete pointer
+  delete param_partition;
+  delete store_partition;
+  delete load_partition;
+  delete predict_partition;
+  delete predict_partitionInter;
+
   return 0;
 }
 
Only in ../VVCSoftware_10/source/App/EncoderApp: .ipynb_checkpoints
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/App/Parcat/parcat.cpp ../VVCSoftware_10/source/App/Parcat/parcat.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/App/Parcat/parcat.cpp	2022-09-16 14:27:06.120532918 +0200
+++ ../VVCSoftware_10/source/App/Parcat/parcat.cpp	2022-05-13 17:45:28.368154954 +0200
@@ -81,9 +81,9 @@
   // parameter sets
   READ_UVLC(uiCode, "ph_pic_parameter_set_id");
   pps = parameterSetManager->getPPS(uiCode);
-  CHECK(pps == 0, "Invalid PPS");
+  CHECK_VTM(pps == 0, "Invalid PPS");
   sps = parameterSetManager->getSPS(pps->getSPSId());
-  CHECK(sps == 0, "Invalid SPS");
+  CHECK_VTM(sps == 0, "Invalid SPS");
   return;
 }
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/App/StreamMergeApp/StreamMergeApp.cpp ../VVCSoftware_10/source/App/StreamMergeApp/StreamMergeApp.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/App/StreamMergeApp/StreamMergeApp.cpp	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/App/StreamMergeApp/StreamMergeApp.cpp	2022-05-13 17:45:28.440154138 +0200
@@ -126,7 +126,7 @@
 #if RExt__DECODER_DEBUG_BIT_STATISTICS
     statBits.bits += 8; statBits.count++;
 #endif
-    CHECK(zero_byte != 0, "Zero byte not '0'");
+    CHECK_VTM(zero_byte != 0, "Zero byte not '0'");
     stats.m_numZeroByteBytes++;
   }
 
@@ -192,7 +192,7 @@
 #if RExt__DECODER_DEBUG_BIT_STATISTICS
     statBits.bits += 8; statBits.count++;
 #endif
-    CHECK(trailing_zero_8bits != 0, "Trailing zero bits not '0'");
+    CHECK_VTM(trailing_zero_8bits != 0, "Trailing zero bits not '0'");
     stats.m_numTrailingZero8BitsBytes++;
   }
 }
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/App/StreamMergeApp/StreamMergeApp.h ../VVCSoftware_10/source/App/StreamMergeApp/StreamMergeApp.h
--- ../vtm10_original/VVCSoftware_VTM/source/App/StreamMergeApp/StreamMergeApp.h	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/App/StreamMergeApp/StreamMergeApp.h	2022-05-13 17:45:28.424154319 +0200
@@ -111,7 +111,7 @@
   */
   bool eofBeforeNBytes(uint32_t n, std::istream& m_Input)
   {
-    CHECK(n > 4, "Unsupported look-ahead value");
+    CHECK_VTM(n > 4, "Unsupported look-ahead value");
     if (m_numFutureBytes >= n)
     {
       return false;
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/App/SubpicMergeApp/SubpicMergeApp.cpp ../VVCSoftware_10/source/App/SubpicMergeApp/SubpicMergeApp.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/App/SubpicMergeApp/SubpicMergeApp.cpp	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/App/SubpicMergeApp/SubpicMergeApp.cpp	2022-05-13 17:45:28.296155769 +0200
@@ -321,7 +321,7 @@
   slice.setSPS(psManager.getSPS(picHeader.getSPSId()));
 
   InputBitstream &inBs = nalu.getBitstream();
-  CHECK(inBs.getNumBitsLeft() & 7, "Slicedata must be byte aligned");
+  CHECK_VTM(inBs.getNumBitsLeft() & 7, "Slicedata must be byte aligned");
   int numDataBytes = inBs.getNumBitsLeft() / 8;
   for (int i = 0; i < numDataBytes; i++ )
   {
@@ -482,7 +482,7 @@
   {
     for (auto spsId : subpic.spsIds)
     {
-      CHECK(subpic.psManager.getSPS(spsId)->getSubPicInfoPresentFlag(), "Input streams containing subpictures not supported")
+      CHECK_VTM(subpic.psManager.getSPS(spsId)->getSubPicInfoPresentFlag(), "Input streams containing subpictures not supported")
     }
   }
 
@@ -504,10 +504,10 @@
     int subPicId = 0;
     for (auto &subpic : *m_subpics)
     {
-      CHECK(subpic.topLeftCornerX % sps.getCTUSize(), "Subpicture top-left X is not multiple of CTU size");
-      CHECK(subpic.topLeftCornerY % sps.getCTUSize(), "Subpicture top-left Y is not multiple of CTU size");
-      CHECK(subpic.width % sps.getCTUSize(), "Subpicture width is not multiple of CTU size");
-      CHECK(subpic.height % sps.getCTUSize(), "Subpicture height is not multiple of CTU size");
+      CHECK_VTM(subpic.topLeftCornerX % sps.getCTUSize(), "Subpicture top-left X is not multiple of CTU size");
+      CHECK_VTM(subpic.topLeftCornerY % sps.getCTUSize(), "Subpicture top-left Y is not multiple of CTU size");
+      CHECK_VTM(subpic.width % sps.getCTUSize(), "Subpicture width is not multiple of CTU size");
+      CHECK_VTM(subpic.height % sps.getCTUSize(), "Subpicture height is not multiple of CTU size");
       sps.setSubPicCtuTopLeftX(subPicId, (uint32_t)(subpic.topLeftCornerX / sps.getCTUSize()));
       sps.setSubPicCtuTopLeftY(subPicId, (uint32_t)(subpic.topLeftCornerY / sps.getCTUSize()));
       sps.setSubPicWidth(subPicId, (uint32_t)(subpic.width / sps.getCTUSize()));
@@ -588,7 +588,7 @@
   {
     for (auto ppsId : subpic.ppsIds)
     {
-      CHECK(subpic.psManager.getPPS(ppsId)->getScalingWindow().getWindowEnabledFlag(), "Scaling window in input streams not supported")
+      CHECK_VTM(subpic.psManager.getPPS(ppsId)->getScalingWindow().getWindowEnabledFlag(), "Scaling window in input streams not supported")
     }
   }
 
@@ -647,14 +647,14 @@
       {
         tileY += tileHeights[tileIdxY];
       }
-      CHECK(tileIdxY == tileHeights.size(), "Could not find subpicture to tile border match");
+      CHECK_VTM(tileIdxY == tileHeights.size(), "Could not find subpicture to tile border match");
 
       unsigned int tileIdxX = 0;
       for (unsigned int tileX = 0; tileX != subpic.topLeftCornerX && tileIdxX < tileWidths.size(); tileIdxX++)
       {
         tileX += tileWidths[tileIdxX];
       }
-      CHECK(tileIdxX == tileWidths.size(), "Could not find subpicture to tile border match")
+      CHECK_VTM(tileIdxX == tileWidths.size(), "Could not find subpicture to tile border match")
 
       const PPS &subpicPPS = *subpic.slices[0].getPPS();
 
@@ -703,8 +703,8 @@
       // Update slice headers to use new SPSes and PPSes
       int ppsId = slice.getPPS()->getPPSId();
       int spsId = slice.getSPS()->getSPSId();
-      CHECK(!psManager.getSPS(spsId), "Invaldi SPS");
-      CHECK(!psManager.getSPS(ppsId), "Invaldi PPS");
+      CHECK_VTM(!psManager.getSPS(spsId), "Invaldi SPS");
+      CHECK_VTM(!psManager.getSPS(ppsId), "Invaldi PPS");
       slice.setSPS(psManager.getSPS(spsId));
       slice.setPPS(psManager.getPPS(ppsId));
 
@@ -776,7 +776,7 @@
     prevNaluType = subpic.slices[0].getNalUnitType();
   }
 
-  CHECK(IRAPFound && nonIRAPNonTrailingFound, "IRAP subpictures can only be mixed with trailing subpictures");
+  CHECK_VTM(IRAPFound && nonIRAPNonTrailingFound, "IRAP subpictures can only be mixed with trailing subpictures");
 
   return mixedNaluTypesFlag;
 }
@@ -809,7 +809,7 @@
     }
   }
 
-  CHECK(subpicToReturn == NULL, "Could not find non-IRAP subpicture when mixed NALU types in enabled");
+  CHECK_VTM(subpicToReturn == NULL, "Could not find non-IRAP subpicture when mixed NALU types in enabled");
 
   if (IRAPFound)
   {
@@ -924,7 +924,7 @@
   }
 
   bool isMixedNaluPic = getMixedNalPicFlag();
-  CHECK(!mixedNaluFlag && isMixedNaluPic, "Mixed NALU types is disabled but picture contains mixed NALU types");
+  CHECK_VTM(!mixedNaluFlag && isMixedNaluPic, "Mixed NALU types is disabled but picture contains mixed NALU types");
 
   Subpicture &subpicForPicHeader = selectSubpicForPicHeader(isMixedNaluPic);
   bool writePicHeader = true;
@@ -990,7 +990,7 @@
       else
       {
         int jointCbCrSignFlagCurr = subpic.picHeader.getJointCbCrSignFlag() ? 1 : 0;
-        CHECK(jointCbCrSignFlag != jointCbCrSignFlagCurr, "ph_joint_cbcr_sign_flag must have indentical value in all input subpictures");
+        CHECK_VTM(jointCbCrSignFlag != jointCbCrSignFlagCurr, "ph_joint_cbcr_sign_flag must have indentical value in all input subpictures");
       }
     }
   }
@@ -1012,7 +1012,7 @@
               if (APSIdType == APSIdType2)
               {
                 bool sameContent = nal.getBitstream().getFifo() == nal2.getBitstream().getFifo();
-                CHECK(!sameContent, "Two APS with the same ID and the same type must have identical content");
+                CHECK_VTM(!sameContent, "Two APS with the same ID and the same type must have identical content");
               }
             }
           }
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/AdaptiveLoopFilter.cpp ../VVCSoftware_10/source/Lib/CommonLib/AdaptiveLoopFilter.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/AdaptiveLoopFilter.cpp	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/AdaptiveLoopFilter.cpp	2022-05-13 17:45:29.364143673 +0200
@@ -631,7 +631,7 @@
     {
       int apsIdx = cs.slice->getTileGroupApsIdLuma()[i];
       curAPS = aps[apsIdx];
-      CHECK(curAPS == NULL, "invalid APS");
+      CHECK_VTM(curAPS == NULL, "invalid APS");
       alfParamTmp = curAPS->getAlfAPSParam();
       reconstructCoeff(alfParamTmp, CHANNEL_TYPE_LUMA, isRdo, true);
       memcpy(m_coeffApsLuma[i], m_coeffFinal, sizeof(m_coeffFinal));
@@ -686,7 +686,7 @@
     {
       int filterIdx = alfParam.filterCoeffDeltaIdx[classIdx];
 
-      CHECK(!(filterIdx >= 0 && filterIdx < alfParam.numLumaFilters), "Bad coeff delta idx in ALF");
+      CHECK_VTM(!(filterIdx >= 0 && filterIdx < alfParam.numLumaFilters), "Bad coeff delta idx in ALF");
       for (int coeffIdx = 0; coeffIdx < numCoeffMinus1; ++coeffIdx)
       {
         m_coeffFinal[classIdx * MAX_NUM_ALF_LUMA_COEFF + coeffIdx] = coeff[filterIdx * MAX_NUM_ALF_LUMA_COEFF + coeffIdx];
@@ -696,7 +696,7 @@
       for( int coeffIdx = 0; coeffIdx < numCoeffMinus1; ++coeffIdx )
       {
         int clipIdx = alfParam.nonLinearFlag[channel] ? clipp[filterIdx * MAX_NUM_ALF_LUMA_COEFF + coeffIdx] : 0;
-        CHECK(!(clipIdx >= 0 && clipIdx < MaxAlfNumClippingValues), "Bad clip idx in ALF");
+        CHECK_VTM(!(clipIdx >= 0 && clipIdx < MaxAlfNumClippingValues), "Bad clip idx in ALF");
         m_clippFinal[classIdx * MAX_NUM_ALF_LUMA_COEFF + coeffIdx] = isRdo ? clipIdx : m_alfClippingValues[channel][clipIdx];
       }
       m_clippFinal[classIdx* MAX_NUM_ALF_LUMA_COEFF + numCoeffMinus1] =
@@ -849,7 +849,7 @@
                                                  const CPelBuf &srcLuma, const Area &blkDst, const Area &blk,
                                                  const int shift, const int vbCTUHeight, int vbPos)
 {
-  CHECK((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
+  CHECK_VTM((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
 
   static const int th[16] = { 0, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4 };
   const int stride = srcLuma.stride;
@@ -1062,12 +1062,12 @@
                                    const short *filterSet, const Pel *fClipSet, const ClpRng &clpRng,
                                    CodingStructure &cs, const int vbCTUHeight, int vbPos)
 {
-  CHECK((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
+  CHECK_VTM((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
 
   const bool bChroma = isChroma( compId );
   if( bChroma )
   {
-    CHECK( filtType != 0, "Chroma needs to have filtType == 0" );
+    CHECK_VTM( filtType != 0, "Chroma needs to have filtType == 0" );
   }
 
   const CPelBuf srcLuma = recSrc.get( compId );
@@ -1097,10 +1097,10 @@
   const int clsSizeY = 4;
   const int clsSizeX = 4;
 
-  CHECK( startHeight % clsSizeY, "Wrong startHeight in filtering" );
-  CHECK( startWidth % clsSizeX, "Wrong startWidth in filtering" );
-  CHECK( ( endHeight - startHeight ) % clsSizeY, "Wrong endHeight in filtering" );
-  CHECK( ( endWidth - startWidth ) % clsSizeX, "Wrong endWidth in filtering" );
+  CHECK_VTM( startHeight % clsSizeY, "Wrong startHeight in filtering" );
+  CHECK_VTM( startWidth % clsSizeX, "Wrong startWidth in filtering" );
+  CHECK_VTM( ( endHeight - startHeight ) % clsSizeY, "Wrong endHeight in filtering" );
+  CHECK_VTM( ( endWidth - startWidth ) % clsSizeX, "Wrong endWidth in filtering" );
 
   AlfClassifier *pClass = nullptr;
 
@@ -1293,9 +1293,9 @@
                                         const Area &blkSrc, const ComponentID compId, const int16_t *filterCoeff,
                                         const ClpRngs &clpRngs, CodingStructure &cs, int vbCTUHeight, int vbPos)
 {
-  CHECK(1 << floorLog2(vbCTUHeight) != vbCTUHeight, "Not a power of 2");
+  CHECK_VTM(1 << floorLog2(vbCTUHeight) != vbCTUHeight, "Not a power of 2");
 
-  CHECK(!isChroma(compId), "Must be chroma");
+  CHECK_VTM(!isChroma(compId), "Must be chroma");
 
   const SPS*     sps           = cs.slice->getSPS();
   ChromaFormat nChromaFormat   = sps->getChromaFormatIdc();
@@ -1308,10 +1308,10 @@
   const int scaleX             = getComponentScaleX(compId, nChromaFormat);
   const int scaleY             = getComponentScaleY(compId, nChromaFormat);
 
-  CHECK( startHeight % clsSizeY, "Wrong startHeight in filtering" );
-  CHECK( startWidth % clsSizeX, "Wrong startWidth in filtering" );
-  CHECK( ( endHeight - startHeight ) % clsSizeY, "Wrong endHeight in filtering" );
-  CHECK( ( endWidth - startWidth ) % clsSizeX, "Wrong endWidth in filtering" );
+  CHECK_VTM( startHeight % clsSizeY, "Wrong startHeight in filtering" );
+  CHECK_VTM( startWidth % clsSizeX, "Wrong startWidth in filtering" );
+  CHECK_VTM( ( endHeight - startHeight ) % clsSizeY, "Wrong endHeight in filtering" );
+  CHECK_VTM( ( endWidth - startWidth ) % clsSizeX, "Wrong endWidth in filtering" );
 
   CPelBuf     srcBuf     = recSrc.get(COMPONENT_Y);
   const int   lumaStride = srcBuf.stride;
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/AlfParameters.h ../VVCSoftware_10/source/Lib/CommonLib/AlfParameters.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/AlfParameters.h	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/AlfParameters.h	2022-05-13 17:45:29.112146527 +0200
@@ -112,7 +112,7 @@
     else
     {
       filterType = ALF_NUM_OF_FILTER_TYPES;
-      CHECK( 0, "Wrong ALF filter shape" );
+      CHECK_VTM( 0, "Wrong ALF filter shape" );
     }
   }
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/BitStream.cpp ../VVCSoftware_10/source/Lib/CommonLib/BitStream.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/BitStream.cpp	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/BitStream.cpp	2022-05-13 17:45:29.364143673 +0200
@@ -109,8 +109,8 @@
 
 void OutputBitstream::write   ( uint32_t uiBits, uint32_t uiNumberOfBits )
 {
-  CHECK( uiNumberOfBits > 32, "Number of bits is exceeds '32'" );
-  CHECK( uiNumberOfBits != 32 && (uiBits & (~0 << uiNumberOfBits)) != 0, "Unsupported parameters" );
+  CHECK_VTM( uiNumberOfBits > 32, "Number of bits is exceeds '32'" );
+  CHECK_VTM( uiNumberOfBits != 32 && (uiBits & (~0 << uiNumberOfBits)) != 0, "Unsupported parameters" );
 
   /* any modulo 8 remainder of num_total_bits cannot be written this time,
    * and will be held until next time. */
@@ -253,7 +253,7 @@
 
 void InputBitstream::read (uint32_t uiNumberOfBits, uint32_t& ruiBits)
 {
-  CHECK( uiNumberOfBits > 32, "Too many bits read" );
+  CHECK_VTM( uiNumberOfBits > 32, "Too many bits read" );
 
   m_numBitsRead += uiNumberOfBits;
 
@@ -290,7 +290,7 @@
    */
   uint32_t aligned_word = 0;
   uint32_t num_bytes_to_load = (uiNumberOfBits - 1) >> 3;
-  CHECK(m_fifo_idx + num_bytes_to_load >= m_fifo.size(), "Exceeded FIFO size");
+  CHECK_VTM(m_fifo_idx + num_bytes_to_load >= m_fifo.size(), "Exceeded FIFO size");
 
   switch (num_bytes_to_load)
   {
@@ -319,7 +319,7 @@
  */
 void OutputBitstream::insertAt(const OutputBitstream& src, uint32_t pos)
 {
-  CHECK(0 != src.getNumberOfWrittenBits() % 8, "Number of written bits is not a multiple of 8");
+  CHECK_VTM(0 != src.getNumberOfWrittenBits() % 8, "Number of written bits is not a multiple of 8");
 
   vector<uint8_t>::iterator at = m_fifo.begin() + pos;
   m_fifo.insert(at, src.m_fifo.begin(), src.m_fifo.end());
@@ -396,14 +396,14 @@
 {
   uint32_t code = 0;
   read( 1, code );
-  CHECK(code != 1, "Code is not '1'");
+  CHECK_VTM(code != 1, "Code is not '1'");
 
   uint32_t numBits = getNumBitsUntilByteAligned();
   if(numBits)
   {
-    CHECK(numBits > getNumBitsLeft(), "More bits available than left");
+    CHECK_VTM(numBits > getNumBitsLeft(), "More bits available than left");
     read( numBits, code );
-    CHECK(code != 0, "Code not '0'");
+    CHECK_VTM(code != 0, "Code not '0'");
   }
   return numBits+1;
 }
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/BitStream.h ../VVCSoftware_10/source/Lib/CommonLib/BitStream.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/BitStream.h	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/BitStream.h	2022-05-13 17:45:29.384143446 +0200
@@ -171,7 +171,7 @@
   void        read            ( uint32_t uiNumberOfBits, uint32_t& ruiBits );
   void        readByte        ( uint32_t &ruiBits )
   {
-    CHECK( m_fifo_idx >= m_fifo.size(), "FIFO exceeded" );
+    CHECK_VTM( m_fifo_idx >= m_fifo.size(), "FIFO exceeded" );
     ruiBits = m_fifo[m_fifo_idx++];
 #if ENABLE_TRACING
     m_numBitsRead += 8;
@@ -180,7 +180,7 @@
 
   void        peekPreviousByte( uint32_t &byte )
   {
-    CHECK( m_fifo_idx == 0, "FIFO empty" );
+    CHECK_VTM( m_fifo_idx == 0, "FIFO empty" );
     byte = m_fifo[m_fifo_idx - 1];
   }
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Buffer.cpp ../VVCSoftware_10/source/Lib/CommonLib/Buffer.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Buffer.cpp	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/Buffer.cpp	2022-05-13 17:45:29.312144262 +0200
@@ -684,7 +684,7 @@
 
 void PelStorage::create( const ChromaFormat &_chromaFormat, const Area& _area, const unsigned _maxCUSize, const unsigned _margin, const unsigned _alignment, const bool _scaleChromaMargin )
 {
-  CHECK( !bufs.empty(), "Trying to re-create an already initialized buffer" );
+  CHECK_VTM( !bufs.empty(), "Trying to re-create an already initialized buffer" );
 
   chromaFormat = _chromaFormat;
 
@@ -715,11 +715,11 @@
     if( _alignment )
     {
       // make sure buffer lines are align
-      CHECK( _alignment != MEMORY_ALIGN_DEF_SIZE, "Unsupported alignment" );
+      CHECK_VTM( _alignment != MEMORY_ALIGN_DEF_SIZE, "Unsupported alignment" );
       totalWidth = ( ( totalWidth + _alignment - 1 ) / _alignment ) * _alignment;
     }
     uint32_t area = totalWidth * totalHeight;
-    CHECK( !area, "Trying to create a buffer with zero area" );
+    CHECK_VTM( !area, "Trying to create a buffer with zero area" );
 
     m_origin[i] = ( Pel* ) xMalloc( Pel, area );
     Pel* topLeft = m_origin[i] + totalWidth * ymargin + xmargin;
@@ -749,9 +749,9 @@
   for( uint32_t i = 0; i < numCh; i++ )
   {
     // check this otherwise it would turn out to get very weird
-    CHECK( chromaFormat                   != other.chromaFormat                  , "Incompatible formats" );
-    CHECK( get( ComponentID( i ) )        != other.get( ComponentID( i ) )       , "Incompatible formats" );
-    CHECK( get( ComponentID( i ) ).stride != other.get( ComponentID( i ) ).stride, "Incompatible formats" );
+    CHECK_VTM( chromaFormat                   != other.chromaFormat                  , "Incompatible formats" );
+    CHECK_VTM( get( ComponentID( i ) )        != other.get( ComponentID( i ) )       , "Incompatible formats" );
+    CHECK_VTM( get( ComponentID( i ) ).stride != other.get( ComponentID( i ) ).stride, "Incompatible formats" );
 
     std::swap( bufs[i].buf,    other.bufs[i].buf );
     std::swap( bufs[i].stride, other.bufs[i].stride );
@@ -827,9 +827,9 @@
   int r, g, b;
   int y0, cg, co;
 
-  CHECK(bufs[COMPONENT_Y].stride != bufs[COMPONENT_Cb].stride || bufs[COMPONENT_Y].stride != bufs[COMPONENT_Cr].stride, "unequal stride for 444 content");
-  CHECK(other.bufs[COMPONENT_Y].stride != other.bufs[COMPONENT_Cb].stride || other.bufs[COMPONENT_Y].stride != other.bufs[COMPONENT_Cr].stride, "unequal stride for 444 content");
-  CHECK(bufs[COMPONENT_Y].width != other.bufs[COMPONENT_Y].width || bufs[COMPONENT_Y].height != other.bufs[COMPONENT_Y].height, "unequal block size")
+  CHECK_VTM(bufs[COMPONENT_Y].stride != bufs[COMPONENT_Cb].stride || bufs[COMPONENT_Y].stride != bufs[COMPONENT_Cr].stride, "unequal stride for 444 content");
+  CHECK_VTM(other.bufs[COMPONENT_Y].stride != other.bufs[COMPONENT_Cb].stride || other.bufs[COMPONENT_Y].stride != other.bufs[COMPONENT_Cr].stride, "unequal stride for 444 content");
+  CHECK_VTM(bufs[COMPONENT_Y].width != other.bufs[COMPONENT_Y].width || bufs[COMPONENT_Y].height != other.bufs[COMPONENT_Y].height, "unequal block size")
 
     if (forward)
     {
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Buffer.h ../VVCSoftware_10/source/Lib/CommonLib/Buffer.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Buffer.h	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/Buffer.h	2022-05-13 17:45:29.328144080 +0200
@@ -317,8 +317,8 @@
   static_assert( std::is_trivially_copyable<T>::value, "Type T is not trivially_copyable" );
 #endif
 
-  CHECK( width  != other.width,  "Incompatible size" );
-  CHECK( height != other.height, "Incompatible size" );
+  CHECK_VTM( width  != other.width,  "Incompatible size" );
+  CHECK_VTM( height != other.height, "Incompatible size" );
 
   if( buf == other.buf )
   {
@@ -349,8 +349,8 @@
 template<typename T>
 void AreaBuf<T>::subtract( const AreaBuf<const T> &other )
 {
-  CHECK( width  != other.width,  "Incompatible size" );
-  CHECK( height != other.height, "Incompatible size" );
+  CHECK_VTM( width  != other.width,  "Incompatible size" );
+  CHECK_VTM( height != other.height, "Incompatible size" );
 
         T* dest =       buf;
   const T* subs = other.buf;
@@ -434,7 +434,7 @@
     else if(!(width & 3))
       g_pelBufOP.removeWeightHighFreq4(dst, dstStride, src, srcStride, width, height, 16, bcwWeight);
     else
-      CHECK(true, "Not supported");
+      CHECK_VTM(true, "Not supported");
   }
   else
   {
@@ -483,7 +483,7 @@
     else if (!(width & 3))
       g_pelBufOP.removeHighFreq4(dst, dstStride, src, srcStride, width, height);
     else
-      CHECK(true, "Not supported");
+      CHECK_VTM(true, "Not supported");
   }
   else
   {
@@ -536,7 +536,7 @@
   int w = width;
   int s = stride;
 
-  CHECK((w + 2 * marginX) > s, "Size of buffer too small to extend");
+  CHECK_VTM((w + 2 * marginX) > s, "Size of buffer too small to extend");
   // do left and right margins
   for (int y = 0; y < h; y++)
   {
@@ -573,7 +573,7 @@
   int h = height;
   int w = width;
 
-  CHECK( w  > s, "Size of buffer too small to extend" );
+  CHECK_VTM( w  > s, "Size of buffer too small to extend" );
 
   // top-left margin
   if ( dir == 1 )
@@ -612,7 +612,7 @@
   int w = width;
   int s = stride;
 
-  CHECK( ( w + 2 * margin ) > s, "Size of buffer too small to extend" );
+  CHECK_VTM( ( w + 2 * margin ) > s, "Size of buffer too small to extend" );
   // do left and right margins
   for( int y = 0; y < h; y++ )
   {
@@ -646,8 +646,8 @@
 {
   int64_t acc = 0;
 
-  CHECK( width  != other.width,  "Incompatible size" );
-  CHECK( height != other.height, "Incompatible size" );
+  CHECK_VTM( width  != other.width,  "Incompatible size" );
+  CHECK_VTM( height != other.height, "Incompatible size" );
 
   const T* src1 =       buf;
   const T* src2 = other.buf;
@@ -687,7 +687,7 @@
 template<typename T>
 void AreaBuf<T>::transposedFrom( const AreaBuf<const T> &other )
 {
-  CHECK( width * height != other.width * other.height, "Incompatible size" );
+  CHECK_VTM( width * height != other.width * other.height, "Incompatible size" );
 
         T* dst  =       buf;
   const T* src  = other.buf;
@@ -802,9 +802,9 @@
 template<typename T>
 void UnitBuf<T>::copyFrom(const UnitBuf<const T> &other, const bool lumaOnly, const bool chromaOnly )
 {
-  CHECK( chromaFormat != other.chromaFormat, "Incompatible formats" );
+  CHECK_VTM( chromaFormat != other.chromaFormat, "Incompatible formats" );
 
-  CHECK( lumaOnly && chromaOnly, "Not allowed to have both lumaOnly and chromaOnly selected" );
+  CHECK_VTM( lumaOnly && chromaOnly, "Not allowed to have both lumaOnly and chromaOnly selected" );
   const size_t compStart = chromaOnly ? 1 : 0;
   const size_t compEnd   = lumaOnly ? 1 : (unsigned) bufs.size();
   for( size_t i = compStart; i < compEnd; i++ )
@@ -818,7 +818,7 @@
 template<typename T>
 void UnitBuf<T>::subtract( const UnitBuf<const T> &other )
 {
-  CHECK( chromaFormat != other.chromaFormat, "Incompatible formats" );
+  CHECK_VTM( chromaFormat != other.chromaFormat, "Incompatible formats" );
 
   for( unsigned i = 0; i < bufs.size(); i++ )
   {
@@ -829,9 +829,9 @@
 template<typename T>
 void UnitBuf<T>::copyClip(const UnitBuf<const T> &src, const ClpRngs &clpRngs, const bool lumaOnly, const bool chromaOnly )
 {
-  CHECK( chromaFormat != src.chromaFormat, "Incompatible formats" );
+  CHECK_VTM( chromaFormat != src.chromaFormat, "Incompatible formats" );
 
-  CHECK( lumaOnly && chromaOnly, "Not allowed to have both lumaOnly and chromaOnly selected" );
+  CHECK_VTM( lumaOnly && chromaOnly, "Not allowed to have both lumaOnly and chromaOnly selected" );
   const size_t compStart = chromaOnly ? 1 : 0;
   const size_t compEnd   = lumaOnly ? 1 : bufs.size();
   for( size_t i = compStart; i < compEnd; i++ )
@@ -844,7 +844,7 @@
 template<typename T>
 void UnitBuf<T>::roundToOutputBitdepth(const UnitBuf<const T> &src, const ClpRngs& clpRngs)
 {
-  CHECK(chromaFormat != src.chromaFormat, "Incompatible formats");
+  CHECK_VTM(chromaFormat != src.chromaFormat, "Incompatible formats");
 
   for (unsigned i = 0; i < bufs.size(); i++)
   {
@@ -855,8 +855,8 @@
 template<typename T>
 void UnitBuf<T>::reconstruct(const UnitBuf<const T> &pred, const UnitBuf<const T> &resi, const ClpRngs& clpRngs)
 {
-  CHECK( chromaFormat != pred.chromaFormat, "Incompatible formats" );
-  CHECK( chromaFormat != resi.chromaFormat, "Incompatible formats" );
+  CHECK_VTM( chromaFormat != pred.chromaFormat, "Incompatible formats" );
+  CHECK_VTM( chromaFormat != resi.chromaFormat, "Incompatible formats" );
 
   for( unsigned i = 0; i < bufs.size(); i++ )
   {
@@ -870,7 +870,7 @@
   const size_t istart = chromaOnly ? 1 : 0;
   const size_t iend = lumaOnly ? 1 : bufs.size();
 
-  CHECK(lumaOnly && chromaOnly, "should not happen");
+  CHECK_VTM(lumaOnly && chromaOnly, "should not happen");
 
   for(size_t i = istart; i < iend; i++)
   {
@@ -884,7 +884,7 @@
   const size_t istart = chromaOnly ? 1 : 0;
   const size_t iend   = lumaOnly   ? 1 : bufs.size();
 
-  CHECK( lumaOnly && chromaOnly, "should not happen" );
+  CHECK_VTM( lumaOnly && chromaOnly, "should not happen" );
 
   for( size_t i = istart; i < iend; i++)
   {
@@ -1024,7 +1024,7 @@
 
   void create( const Size& size )
   {
-    CHECK( m_memory, "Trying to re-create an already initialized buffer" );
+    CHECK_VTM( m_memory, "Trying to re-create an already initialized buffer" );
     m_memory = new Pel [ size.area() ];
     *static_cast<PelBuf*>(this) = PelBuf( m_memory, size );
   }
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/CodingStatistics.h ../VVCSoftware_10/source/Lib/CommonLib/CodingStatistics.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/CodingStatistics.h	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/CodingStatistics.h	2022-05-13 17:45:29.088146799 +0200
@@ -219,7 +219,7 @@
     "TOOL_LFNST",
     "TOOL_TOTAL"
   };
-  CHECK( STATS__NUM_STATS != sizeof( statNames ) / sizeof( char* ) || name >= STATS__NUM_STATS, "stats out of range" );
+  CHECK_VTM( STATS__NUM_STATS != sizeof( statNames ) / sizeof( char* ) || name >= STATS__NUM_STATS, "stats out of range" );
   return statNames[name];
 }
 
@@ -281,7 +281,7 @@
 
   static const char *GetSubClassString( const uint32_t subClass )
   {
-    CHECK( subClass >= CODING_STATS_NUM_SUBCLASSES, "Subclass does not exist" );
+    CHECK_VTM( subClass >= CODING_STATS_NUM_SUBCLASSES, "Subclass does not exist" );
     static const char *strings[1 + MAX_NUM_COMPONENT + MAX_NUM_CHANNEL_TYPE] = { "-", "Y", "Cb", "Cr", "Luma", "Chroma" };
     return strings[subClass / CODING_STATS_NUM_SIZES];
   }
@@ -807,7 +807,7 @@
 
   static int getNumOnes( int bins )
   {
-    CHECK( bins < 0, "Bins should not be nagative" );
+    CHECK_VTM( bins < 0, "Bins should not be nagative" );
 
     int count = 0;
     while( bins )
@@ -820,7 +820,7 @@
 
   static void IncrementStatisticEP( const CodingStatisticsClassType &stat, const int numBits, const int value )
   {
-    CHECK( stat.type == STATS__CABAC_BITS__INVALID, "Should never be used." );
+    CHECK_VTM( stat.type == STATS__CABAC_BITS__INVALID, "Should never be used." );
     SStat &s = GetStatisticEP( stat );
     s.bits  += numBits;
 #if EPBINCOUNT_FIX
@@ -857,7 +857,7 @@
 
   static void IncrementStatisticTool( const CodingStatisticsClassType &stat )
   {
-    CHECK( stat.type < STATS__TOOL_TOTAL_FRAME || stat.type >= STATS__TOOL_TOTAL, "Should never be used." );
+    CHECK_VTM( stat.type < STATS__TOOL_TOTAL_FRAME || stat.type >= STATS__TOOL_TOTAL, "Should never be used." );
     StatTool &s = GetStatisticTool( stat );
     s.count++;
 
@@ -871,7 +871,7 @@
 
   static void UpdateCABACStat( const CodingStatisticsClassType &stat, uint32_t uiRangeBefore, uint32_t uiRangeAfter, int val )
   {
-    CHECK( stat.type == STATS__CABAC_BITS__INVALID, "Should never be used." );
+    CHECK_VTM( stat.type == STATS__CABAC_BITS__INVALID, "Should never be used." );
     CodingStatistics &inst = GetSingletonInstance();
     // doing rangeBefore*p(x)=rangeAfter
     // p(x)=rangeAfter/rangeBefore
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/CodingStructure.cpp ../VVCSoftware_10/source/Lib/CommonLib/CodingStructure.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/CodingStructure.cpp	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/CodingStructure.cpp	2022-05-13 17:45:29.048147251 +0200
@@ -270,7 +270,7 @@
 {
   const ChannelType effChType = CHANNEL_TYPE_LUMA;
   const CompArea &_blk = area.blocks[effChType];
-  CHECK( !_blk.contains( pos ), "must contain the pos" );
+  CHECK_VTM( !_blk.contains( pos ), "must contain the pos" );
 
   const unsigned idx = m_cuIdx[effChType][rsAddr( pos, _blk.pos(), _blk.width, unitScale[effChType] )];
 
@@ -293,8 +293,8 @@
     //keep this check, which is helpful to identify bugs
     if( treeType == TREE_C && effChType == CHANNEL_TYPE_LUMA )
     {
-      CHECK( parent == nullptr, "parent shall be valid; consider using function getLumaCU()" );
-      CHECK( parent->treeType != TREE_D, "wrong parent treeType " );
+      CHECK_VTM( parent == nullptr, "parent shall be valid; consider using function getLumaCU()" );
+      CHECK_VTM( parent->treeType != TREE_D, "wrong parent treeType " );
     }
     if (parent)
     {
@@ -328,8 +328,8 @@
   {
     if( treeType == TREE_C && effChType == CHANNEL_TYPE_LUMA )
     {
-      CHECK( parent == nullptr, "parent shall be valid; consider using function getLumaCU()" );
-      CHECK( parent->treeType != TREE_D, "wrong parent treeType" );
+      CHECK_VTM( parent == nullptr, "parent shall be valid; consider using function getLumaCU()" );
+      CHECK_VTM( parent->treeType != TREE_D, "wrong parent treeType" );
     }
     if (parent)
     {
@@ -453,8 +453,8 @@
             while( !tus[idx - 1 + extraIdx]->blocks[getFirstComponentOfChannel( effChType )].contains( pos ) )
             {
               extraIdx++;
-              CHECK( tus[idx - 1 + extraIdx]->cu->treeType == TREE_C, "tu searched by position points to a chroma tree CU" );
-              CHECK( extraIdx > 3, "extraIdx > 3" );
+              CHECK_VTM( tus[idx - 1 + extraIdx]->cu->treeType == TREE_C, "tu searched by position points to a chroma tree CU" );
+              CHECK_VTM( extraIdx > 3, "extraIdx > 3" );
             }
           }
         }
@@ -508,8 +508,8 @@
             while ( !tus[idx - 1 + extraIdx]->blocks[getFirstComponentOfChannel( effChType )].contains(pos) )
             {
               extraIdx++;
-              CHECK( tus[idx - 1 + extraIdx]->cu->treeType == TREE_C, "tu searched by position points to a chroma tree CU" );
-              CHECK( extraIdx > 3, "extraIdx > 3" );
+              CHECK_VTM( tus[idx - 1 + extraIdx]->cu->treeType == TREE_C, "tu searched by position points to a chroma tree CU" );
+              CHECK_VTM( extraIdx > 3, "extraIdx > 3" );
             }
           }
         }
@@ -576,7 +576,7 @@
     const Area scaledSelf  = scale.scale( _selfBlk );
     const Area scaledBlk   = scale.scale(     _blk );
     unsigned *idxPtr       = m_cuIdx[i] + rsAddr( scaledBlk.pos(), scaledSelf.pos(), scaledSelf.width );
-    CHECK( *idxPtr, "Overwriting a pre-existing value, should be '0'!" );
+    CHECK_VTM( *idxPtr, "Overwriting a pre-existing value, should be '0'!" );
     AreaBuf<uint32_t>( idxPtr, scaledSelf.width, scaledBlk.size() ).fill( idx );
   }
 
@@ -636,7 +636,7 @@
     const Area scaledSelf  = scale.scale( _selfBlk );
     const Area scaledBlk   = scale.scale(     _blk );
     unsigned *idxPtr       = m_puIdx[i] + rsAddr( scaledBlk.pos(), scaledSelf.pos(), scaledSelf.width );
-    CHECK( *idxPtr, "Overwriting a pre-existing value, should be '0'!" );
+    CHECK_VTM( *idxPtr, "Overwriting a pre-existing value, should be '0'!" );
     AreaBuf<uint32_t>( idxPtr, scaledSelf.width, scaledBlk.size() ).fill( idx );
   }
 
@@ -721,7 +721,7 @@
         const Area scaledSelf = scale.scale(_selfBlk);
         const Area scaledBlk = isIspTu ? scale.scale(tu->cu->blocks[i]) : scale.scale(_blk);
         unsigned *idxPtr = m_tuIdx[i] + rsAddr(scaledBlk.pos(), scaledSelf.pos(), scaledSelf.width);
-        CHECK(*idxPtr, "Overwriting a pre-existing value, should be '0'!");
+        CHECK_VTM(*idxPtr, "Overwriting a pre-existing value, should be '0'!");
         AreaBuf<uint32_t>(idxPtr, scaledSelf.width, scaledBlk.size()).fill(idx);
       }
     }
@@ -1035,7 +1035,7 @@
     ComponentID comID = jointPLT ? (ComponentID)compBegin : ((i > 0) ? COMPONENT_Cb : COMPONENT_Y);
     prevPLT.curPLTSize[comID] = curPLTSize[comID] + stuffPLTsize[comID];
     memcpy(prevPLT.curPLT[i], stuffedPLT[i], prevPLT.curPLTSize[comID] * sizeof(Pel));
-    CHECK(prevPLT.curPLTSize[comID] > maxPredPltSize, " Maximum palette predictor size exceed limit");
+    CHECK_VTM(prevPLT.curPLTSize[comID] > maxPredPltSize, " Maximum palette predictor size exceed limit");
   }
 }
 
@@ -1064,7 +1064,7 @@
 
 void CodingStructure::rebindPicBufs()
 {
-  CHECK( parent, "rebindPicBufs can only be used for the top level CodingStructure" );
+  CHECK_VTM( parent, "rebindPicBufs can only be used for the top level CodingStructure" );
 
   if (!picture->M_BUFS(0, PIC_RECONSTRUCTION).bufs.empty())
   {
@@ -1154,7 +1154,7 @@
 
 void CodingStructure::initSubStructure( CodingStructure& subStruct, const ChannelType _chType, const UnitArea &subArea, const bool &isTuEnc )
 {
-  CHECK( this == &subStruct, "Trying to init self as sub-structure" );
+  CHECK_VTM( this == &subStruct, "Trying to init self as sub-structure" );
 
   subStruct.useDbCost = false;
   subStruct.costDbOffset = 0;
@@ -1603,7 +1603,7 @@
 
   PelStorage* buf = type == PIC_PREDICTION ? &m_pred : ( type == PIC_RESIDUAL ? &m_resi : ( type == PIC_RECONSTRUCTION ? &m_reco : ( type == PIC_ORG_RESI ? &m_orgr : nullptr ) ) );
 
-  CHECK( !buf, "Unknown buffer requested" );
+  CHECK_VTM( !buf, "Unknown buffer requested" );
 
   CHECKD( !area.blocks[compID].contains( blk ), "Buffer not contained in self requested" );
 
@@ -1637,7 +1637,7 @@
 
   const PelStorage* buf = type == PIC_PREDICTION ? &m_pred : ( type == PIC_RESIDUAL ? &m_resi : ( type == PIC_RECONSTRUCTION ? &m_reco : ( type == PIC_ORG_RESI ? &m_orgr : nullptr ) ) );
 
-  CHECK( !buf, "Unknown buffer requested" );
+  CHECK_VTM( !buf, "Unknown buffer requested" );
 
   CHECKD( !area.blocks[compID].contains( blk ), "Buffer not contained in self requested" );
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/CommonDef.h ../VVCSoftware_10/source/Lib/CommonLib/CommonDef.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/CommonDef.h	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/CommonDef.h	2022-05-13 17:45:29.068147025 +0200
@@ -512,7 +512,7 @@
 
 template <typename T> inline void Check3( T minVal, T maxVal, T a)
 {
-  CHECK( ( a > maxVal ) || ( a < minVal ), "ERROR: Range check " << minVal << " >= " << a << " <= " << maxVal << " failed" );
+  CHECK_VTM( ( a > maxVal ) || ( a < minVal ), "ERROR: Range check " << minVal << " >= " << a << " <= " << maxVal << " failed" );
 }  ///< general min/max clip
 
 extern MsgLevel g_verbosity;
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/ContextModelling.cpp ../VVCSoftware_10/source/Lib/CommonLib/ContextModelling.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/ContextModelling.cpp	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/ContextModelling.cpp	2022-05-13 17:45:29.212145394 +0200
@@ -348,7 +348,7 @@
 
 void MergeCtx::setMergeInfo( PredictionUnit& pu, int candIdx )
 {
-  CHECK( candIdx >= numValidMergeCand, "Merge candidate does not exist" );
+  CHECK_VTM( candIdx >= numValidMergeCand, "Merge candidate does not exist" );
   pu.regularMergeFlag        = !(pu.ciipFlag || pu.cu->geoFlag);
   pu.mergeFlag               = true;
   pu.mmvdMergeFlag = false;
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Contexts.cpp ../VVCSoftware_10/source/Lib/CommonLib/Contexts.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Contexts.cpp	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/Contexts.cpp	2022-05-13 17:45:29.292144488 +0200
@@ -153,7 +153,7 @@
 
 const std::vector<uint8_t>& ContextSetCfg::getInitTable( unsigned initId )
 {
-  CHECK( initId >= (unsigned)sm_InitTables.size(),
+  CHECK_VTM( initId >= (unsigned)sm_InitTables.size(),
          "Invalid initId (" << initId << "), only " << sm_InitTables.size() << " tables defined." );
   return sm_InitTables[initId];
 }
@@ -168,7 +168,7 @@
   {
     const std::initializer_list<uint8_t>& initSet   = *setIter;
     std::vector<uint8_t>&           initTable = sm_InitTables[setId];
-    CHECK( initSet.size() != numValues,
+    CHECK_VTM( initSet.size() != numValues,
            "Number of init values do not match for all sets (" << initSet.size() << " != " << numValues << ")." );
     initTable.resize( startIdx + numValues );
     std::size_t elemId = startIdx;
@@ -912,10 +912,10 @@
 void CtxStore<BinProbModel>::init( int qp, int initId )
 {
   const std::vector<uint8_t>& initTable = ContextSetCfg::getInitTable( initId );
-  CHECK( m_CtxBuffer.size() != initTable.size(),
+  CHECK_VTM( m_CtxBuffer.size() != initTable.size(),
         "Size of init table (" << initTable.size() << ") does not match size of context buffer (" << m_CtxBuffer.size() << ")." );
   const std::vector<uint8_t> &rateInitTable = ContextSetCfg::getInitTable(NUMBER_OF_SLICE_TYPES);
-  CHECK(m_CtxBuffer.size() != rateInitTable.size(),
+  CHECK_VTM(m_CtxBuffer.size() != rateInitTable.size(),
         "Size of rate init table (" << rateInitTable.size() << ") does not match size of context buffer ("
                                     << m_CtxBuffer.size() << ").");
   int clippedQP = Clip3( 0, MAX_QP, qp );
@@ -929,7 +929,7 @@
 template <class BinProbModel>
 void CtxStore<BinProbModel>::setWinSizes( const std::vector<uint8_t>& log2WindowSizes )
 {
-  CHECK( m_CtxBuffer.size() != log2WindowSizes.size(),
+  CHECK_VTM( m_CtxBuffer.size() != log2WindowSizes.size(),
         "Size of window size table (" << log2WindowSizes.size() << ") does not match size of context buffer (" << m_CtxBuffer.size() << ")." );
   for( std::size_t k = 0; k < m_CtxBuffer.size(); k++ )
   {
@@ -940,7 +940,7 @@
 template <class BinProbModel>
 void CtxStore<BinProbModel>::loadPStates( const std::vector<uint16_t>& probStates )
 {
-  CHECK( m_CtxBuffer.size() != probStates.size(),
+  CHECK_VTM( m_CtxBuffer.size() != probStates.size(),
         "Size of prob states table (" << probStates.size() << ") does not match size of context buffer (" << m_CtxBuffer.size() << ")." );
   for( std::size_t k = 0; k < m_CtxBuffer.size(); k++ )
   {
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Contexts.h ../VVCSoftware_10/source/Lib/CommonLib/Contexts.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Contexts.h	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/Contexts.h	2022-05-13 17:45:29.140146210 +0200
@@ -115,7 +115,7 @@
     int rate0 = 2 + ((log2WindowSize >> 2) & 3);
     int rate1 = 3 + rate0 + (log2WindowSize & 3);
     m_rate    = 16 * rate0 + rate1;
-    CHECK(rate1 > 9, "Second window size is too large!");
+    CHECK_VTM(rate1 > 9, "Second window size is too large!");
   }
   void estFracBitsUpdate(unsigned bin, uint64_t &b)
   {
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/DepQuant.cpp ../VVCSoftware_10/source/Lib/CommonLib/DepQuant.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/DepQuant.cpp	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/DepQuant.cpp	2022-05-13 17:45:28.964148203 +0200
@@ -285,7 +285,7 @@
           const int  begSbb = scanId - ( scanId & (groupSize-1) ); // first pos in current subblock
           for( int k = 0; k < nbOut.num; k++ )
           {
-            CHECK(begSbb > nbOut.outPos[k], "Position must be past sub block begin");
+            CHECK_VTM(begSbb > nbOut.outPos[k], "Position must be past sub block begin");
             nbOut.outPos[k] -= begSbb;
           }
           nbOut.maxDist -= scanId;
@@ -1174,7 +1174,7 @@
       const State* prvState = 0;
       if( decision.prevId  >= 4 )
       {
-        CHECK( decision.absLevel != 0, "cannot happen" );
+        CHECK_VTM( decision.absLevel != 0, "cannot happen" );
         prvState    = skipStates + ( decision.prevId - 4 );
         m_numSigSbb = 0;
         ::memset( m_absLevelsAndCtxInit, 0, 16*sizeof(uint8_t) );
@@ -1558,7 +1558,7 @@
 DepQuant::DepQuant( const Quant* other, bool enc ) : QuantRDOQ( other )
 {
   const DepQuant* dq = dynamic_cast<const DepQuant*>( other );
-  CHECK( other && !dq, "The DepQuant cast must be successfull!" );
+  CHECK_VTM( other && !dq, "The DepQuant cast must be successfull!" );
   p = new DQIntern::DepQuant();
   if( enc )
   {
@@ -1584,7 +1584,7 @@
     const int         width           = rect.width;
     const int         height          = rect.height;
     uint32_t          scalingListType = getScalingListType(tu.cu->predMode, compID);
-    CHECK(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
+    CHECK_VTM(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
     const uint32_t    log2TrWidth     = floorLog2(width);
     const uint32_t    log2TrHeight    = floorLog2(height);
 
@@ -1612,7 +1612,7 @@
     const int         width           = rect.width;
     const int         height          = rect.height;
     uint32_t          scalingListType = getScalingListType(tu.cu->predMode, compID);
-    CHECK(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
+    CHECK_VTM(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
     const uint32_t    log2TrWidth  = floorLog2(width);
     const uint32_t    log2TrHeight = floorLog2(height);
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Hash.cpp ../VVCSoftware_10/source/Lib/CommonLib/Hash.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Hash.cpp	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/Hash.cpp	2022-05-13 17:45:29.348143854 +0200
@@ -339,7 +339,7 @@
   uint32_t* srcHash[2] = { picHash[0], picHash[1] };
 
   int addValue = m_blockSizeToIndex[width][height];
-  CHECK(addValue < 0, "Wrong")
+  CHECK_VTM(addValue < 0, "Wrong")
   addValue <<= m_CRCBits;
   int crcMask = 1 << m_CRCBits;
   crcMask -= 1;
@@ -536,7 +536,7 @@
 {
   int addValue = m_blockSizeToIndex[width][height];
 
-  CHECK(addValue < 0, "Wrong")
+  CHECK_VTM(addValue < 0, "Wrong")
   addValue <<= m_CRCBits;
   int crcMask = 1 << m_CRCBits;
   crcMask -= 1;
@@ -623,7 +623,7 @@
 
   if (width != height)//currently support 1:2 or 2:1 block size
   {
-    CHECK(width != (height << 1) && (width << 1) != height, "Wrong")
+    CHECK_VTM(width != (height << 1) && (width << 1) != height, "Wrong")
     bool isHorizontal = width == (height << 1) ? true : false;
     length = 2 * sizeof(uint32_t);
     srcIdx = 1 - srcIdx;
@@ -641,7 +641,7 @@
     }
     else
     {
-      CHECK(srcSubBlockInWidth != 1, "Wrong")
+      CHECK_VTM(srcSubBlockInWidth != 1, "Wrong")
       toHash[0] = hashValueBuffer[0][srcIdx][0];
       toHash[1] = hashValueBuffer[0][srcIdx][srcSubBlockInWidth];
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/HRD.h ../VVCSoftware_10/source/Lib/CommonLib/HRD.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/HRD.h	2022-09-16 14:27:06.128532827 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/HRD.h	2022-05-13 17:45:29.352143808 +0200
@@ -178,7 +178,7 @@
 
 inline void checkBPSyntaxElementLength(const SEIBufferingPeriod* bp1, const SEIBufferingPeriod* bp2)
 {
-  CHECK(bp1->m_initialCpbRemovalDelayLength != bp2->m_initialCpbRemovalDelayLength ||
+  CHECK_VTM(bp1->m_initialCpbRemovalDelayLength != bp2->m_initialCpbRemovalDelayLength ||
         bp1->m_cpbRemovalDelayLength != bp2->m_cpbRemovalDelayLength ||
         bp1->m_dpbOutputDelayLength != bp2->m_dpbOutputDelayLength ||
         bp1->m_duCpbRemovalDelayIncrementLength != bp2->m_duCpbRemovalDelayIncrementLength ||
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/IbcHashMap.cpp ../VVCSoftware_10/source/Lib/CommonLib/IbcHashMap.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/IbcHashMap.cpp	2022-09-16 14:27:06.132532782 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/IbcHashMap.cpp	2022-05-13 17:45:29.084146843 +0200
@@ -316,7 +316,7 @@
       }
       else
       {
-        CHECK(topLeft != *refBlockPos, "4x4 target block should not have offset!");
+        CHECK_VTM(topLeft != *refBlockPos, "4x4 target block should not have offset!");
         if (abs(topLeft.x - lumaArea.x) > searchRange4SmallBlk || abs(topLeft.y - lumaArea.y) > searchRange4SmallBlk || !cs.isDecomp(bottomRight, CHANNEL_TYPE_LUMA))
         {
           continue;
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/InterpolationFilter.cpp ../VVCSoftware_10/source/Lib/CommonLib/InterpolationFilter.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/InterpolationFilter.cpp	2022-09-16 14:27:06.132532782 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/InterpolationFilter.cpp	2022-05-13 17:45:29.280144624 +0200
@@ -573,7 +573,7 @@
   int shift    = IF_FILTER_PREC;
   // with the current settings (IF_INTERNAL_PREC = 14 and IF_FILTER_PREC = 6), though headroom can be
   // negative for bit depths greater than 14, shift will remain non-negative for bit depths of 8->20
-  CHECK(shift < 0, "Negative shift");
+  CHECK_VTM(shift < 0, "Negative shift");
 
   if ( isLast )
   {
@@ -744,7 +744,7 @@
   }
   else if( isLuma( compID ) )
   {
-    CHECK( frac < 0 || frac >= LUMA_INTERPOLATION_FILTER_SUB_SAMPLE_POSITIONS, "Invalid fraction" );
+    CHECK_VTM( frac < 0 || frac >= LUMA_INTERPOLATION_FILTER_SUB_SAMPLE_POSITIONS, "Invalid fraction" );
     if( nFilterIdx == 1 )
     {
       filterHor<NTAPS_BILINEAR>( clpRng, src, srcStride, dst, dstStride, width, height, isLast, m_bilinearFilterPrec4[frac], biMCForDMVR );
@@ -785,7 +785,7 @@
   else
   {
     const uint32_t csx = getComponentScaleX( compID, fmt );
-    CHECK( frac < 0 || csx >= 2 || ( frac << ( 1 - csx ) ) >= CHROMA_INTERPOLATION_FILTER_SUB_SAMPLE_POSITIONS, "Invalid fraction" );
+    CHECK_VTM( frac < 0 || csx >= 2 || ( frac << ( 1 - csx ) ) >= CHROMA_INTERPOLATION_FILTER_SUB_SAMPLE_POSITIONS, "Invalid fraction" );
     if( nFilterIdx == 3 )
     {
       filterHor<NTAPS_CHROMA>( clpRng, src, srcStride, dst, dstStride, width, height, isLast, m_chromaFilterRPR1[frac << ( 1 - csx )], biMCForDMVR );
@@ -826,7 +826,7 @@
   }
   else if( isLuma( compID ) )
   {
-    CHECK( frac < 0 || frac >= LUMA_INTERPOLATION_FILTER_SUB_SAMPLE_POSITIONS, "Invalid fraction" );
+    CHECK_VTM( frac < 0 || frac >= LUMA_INTERPOLATION_FILTER_SUB_SAMPLE_POSITIONS, "Invalid fraction" );
     if( nFilterIdx == 1 )
     {
       filterVer<NTAPS_BILINEAR>( clpRng, src, srcStride, dst, dstStride, width, height, isFirst, isLast, m_bilinearFilterPrec4[frac], biMCForDMVR );
@@ -867,7 +867,7 @@
   else
   {
     const uint32_t csy = getComponentScaleY( compID, fmt );
-    CHECK( frac < 0 || csy >= 2 || ( frac << ( 1 - csy ) ) >= CHROMA_INTERPOLATION_FILTER_SUB_SAMPLE_POSITIONS, "Invalid fraction" );
+    CHECK_VTM( frac < 0 || csy >= 2 || ( frac << ( 1 - csy ) ) >= CHROMA_INTERPOLATION_FILTER_SUB_SAMPLE_POSITIONS, "Invalid fraction" );
     if( nFilterIdx == 3 )
     {
       filterVer<NTAPS_CHROMA>( clpRng, src, srcStride, dst, dstStride, width, height, isFirst, isLast, m_chromaFilterRPR1[frac << ( 1 - csy )], biMCForDMVR );
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/InterPrediction.cpp ../VVCSoftware_10/source/Lib/CommonLib/InterPrediction.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/InterPrediction.cpp	2022-09-16 14:27:06.132532782 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/InterPrediction.cpp	2022-05-13 17:45:28.960148248 +0200
@@ -456,14 +456,14 @@
   int iRefIdx = pu.refIdx[eRefPicList];
   Mv mv[3];
   bool isIBC = false;
-  CHECK( !CU::isIBC( *pu.cu ) && pu.lwidth() == 4 && pu.lheight() == 4, "invalid 4x4 inter blocks" );
+  CHECK_VTM( !CU::isIBC( *pu.cu ) && pu.lwidth() == 4 && pu.lheight() == 4, "invalid 4x4 inter blocks" );
   if (CU::isIBC(*pu.cu))
   {
     isIBC = true;
   }
   if( pu.cu->affine )
   {
-    CHECK( iRefIdx < 0, "iRefIdx incorrect." );
+    CHECK_VTM( iRefIdx < 0, "iRefIdx incorrect." );
 
     mv[0] = pu.mvAffi[eRefPicList][0];
     mv[1] = pu.mvAffi[eRefPicList][1];
@@ -498,7 +498,7 @@
     }
     if ( pu.cu->affine )
     {
-      CHECK( bioApplied, "BIO is not allowed with affine" );
+      CHECK_VTM( bioApplied, "BIO is not allowed with affine" );
       m_iRefListIdx = eRefPicList;
       bool genChromaMv = (!luma && chroma && compID == COMPONENT_Cb);
       xPredAffineBlk( compID, pu, pu.cu->slice->getRefPic( eRefPicList, iRefIdx )->unscaledPic, mv, pcYuvPred, bi, pu.cu->slice->clpRng( compID ), genChromaMv, pu.cu->slice->getScalingRatio( eRefPicList, iRefIdx ));
@@ -522,7 +522,7 @@
 {
   const PPS   &pps   = *pu.cs->pps;
   const Slice &slice = *pu.cs->slice;
-  CHECK( !pu.cu->affine && pu.refIdx[0] >= 0 && pu.refIdx[1] >= 0 && ( pu.lwidth() + pu.lheight() == 12 ), "invalid 4x8/8x4 bi-predicted blocks" );
+  CHECK_VTM( !pu.cu->affine && pu.refIdx[0] >= 0 && pu.refIdx[1] >= 0 && ( pu.lwidth() + pu.lheight() == 12 ), "invalid 4x8/8x4 bi-predicted blocks" );
 
   int refIdx0 = pu.refIdx[REF_PIC_LIST_0];
   int refIdx1 = pu.refIdx[REF_PIC_LIST_1];
@@ -590,9 +590,9 @@
 
     RefPicList eRefPicList = (refList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
 
-    CHECK(CU::isIBC(*pu.cu) && eRefPicList != REF_PIC_LIST_0, "Invalid interdir for ibc mode");
-    CHECK(CU::isIBC(*pu.cu) && pu.refIdx[refList] != MAX_NUM_REF, "Invalid reference index for ibc mode");
-    CHECK((CU::isInter(*pu.cu) && pu.refIdx[refList] >= slice.getNumRefIdx(eRefPicList)), "Invalid reference index");
+    CHECK_VTM(CU::isIBC(*pu.cu) && eRefPicList != REF_PIC_LIST_0, "Invalid interdir for ibc mode");
+    CHECK_VTM(CU::isIBC(*pu.cu) && pu.refIdx[refList] != MAX_NUM_REF, "Invalid reference index for ibc mode");
+    CHECK_VTM((CU::isInter(*pu.cu) && pu.refIdx[refList] >= slice.getNumRefIdx(eRefPicList)), "Invalid reference index");
     m_iRefListIdx = refList;
 
     PelUnitBuf pcMbBuf = ( pu.chromaFormat == CHROMA_400 ?
@@ -693,8 +693,8 @@
 
   if( !isIBC && xPredInterBlkRPR( scalingRatio, *pu.cs->pps, CompArea( compID, chFmt, pu.blocks[compID], Size( dstPic.bufs[compID].width, dstPic.bufs[compID].height ) ), refPic, mv, dstPic.bufs[compID].buf, dstPic.bufs[compID].stride, bi, wrapRef, clpRng, 0, useAltHpelIf ) )
   {
-    CHECK( bilinearMC, "DMVR should be disabled with RPR" );
-    CHECK( bioApplied, "BDOF should be disabled with RPR" );
+    CHECK_VTM( bilinearMC, "DMVR should be disabled with RPR" );
+    CHECK_VTM( bioApplied, "BDOF should be disabled with RPR" );
   }
   else
   {
@@ -887,8 +887,8 @@
   int blockWidth = AFFINE_MIN_BLOCK_SIZE;
   int blockHeight = AFFINE_MIN_BLOCK_SIZE;
 
-  CHECK(blockWidth  > (width >> iScaleX ), "Sub Block width  > Block width");
-  CHECK(blockHeight > (height >> iScaleY), "Sub Block height > Block height");
+  CHECK_VTM(blockWidth  > (width >> iScaleX ), "Sub Block width  > Block width");
+  CHECK_VTM(blockHeight > (height >> iScaleY), "Sub Block height > Block height");
   const int MVBUFFER_SIZE = MAX_CU_SIZE / MIN_PU_SIZE;
 
   const int cxWidth  = width  >> iScaleX;
@@ -1004,12 +1004,12 @@
 
   if (genChromaMv && pu.chromaFormat != CHROMA_444)
   {
-    CHECK(compID == COMPONENT_Y, "Chroma only subblock MV calculation should not apply to Luma");
+    CHECK_VTM(compID == COMPONENT_Y, "Chroma only subblock MV calculation should not apply to Luma");
     int lumaBlockWidth  = AFFINE_MIN_BLOCK_SIZE;
     int lumaBlockHeight = AFFINE_MIN_BLOCK_SIZE;
 
-    CHECK(lumaBlockWidth > (width >> scaleXLuma), "Sub Block width  > Block width");
-    CHECK(lumaBlockHeight > (height >> scaleYLuma), "Sub Block height > Block height");
+    CHECK_VTM(lumaBlockWidth > (width >> scaleXLuma), "Sub Block width  > Block width");
+    CHECK_VTM(lumaBlockHeight > (height >> scaleYLuma), "Sub Block height > Block height");
 
     const int cxWidthLuma  = width >> scaleXLuma;
     const int cxHeightLuma = height >> scaleYLuma;
@@ -1128,7 +1128,7 @@
 
       if( xPredInterBlkRPR( scalingRatio, *pu.cs->pps, CompArea( compID, chFmt, pu.blocks[compID].offset( w, h ), Size( blockWidth, blockHeight ) ), refPic, Mv( iMvScaleTmpHor, iMvScaleTmpVer ), dstBuf.buf + w + h * dstBuf.stride, dstBuf.stride, bi, wrapRef, clpRng, 2 ) )
       {
-        CHECK( enablePROF, "PROF should be disabled with RPR" );
+        CHECK_VTM( enablePROF, "PROF should be disabled with RPR" );
       }
       else
       {
@@ -1355,7 +1355,7 @@
 
 void InterPrediction::xWeightedAverage(const PredictionUnit& pu, const CPelUnitBuf& pcYuvSrc0, const CPelUnitBuf& pcYuvSrc1, PelUnitBuf& pcYuvDst, const BitDepths& clipBitDepths, const ClpRngs& clpRngs, const bool& bioApplied, bool lumaOnly, bool chromaOnly, PelUnitBuf* yuvDstTmp /*= NULL*/)
 {
-  CHECK( (chromaOnly && lumaOnly), "should not happen" );
+  CHECK_VTM( (chromaOnly && lumaOnly), "should not happen" );
 
   const int iRefIdx0 = pu.refIdx[0];
   const int iRefIdx1 = pu.refIdx[1];
@@ -1364,7 +1364,7 @@
   {
     if( pu.cu->BcwIdx != BCW_DEFAULT && (yuvDstTmp || !pu.ciipFlag) )
     {
-      CHECK(bioApplied, "Bcw is disallowed with BIO");
+      CHECK_VTM(bioApplied, "Bcw is disallowed with BIO");
       pcYuvDst.addWeightedAvg(pcYuvSrc0, pcYuvSrc1, clpRngs, pu.cu->BcwIdx, chromaOnly, lumaOnly);
       if (yuvDstTmp)
         yuvDstTmp->addAvg(pcYuvSrc0, pcYuvSrc1, clpRngs, chromaOnly, lumaOnly);
@@ -1456,13 +1456,13 @@
   // Note: there appears to be an interaction with weighted prediction that
   // makes the code follow different paths if chroma is on or off (in the encoder).
   // Therefore for 4:0:0, "chroma" is not changed to false.
-  CHECK(predBufWOBIO && pu.ciipFlag, "the case should not happen!");
+  CHECK_VTM(predBufWOBIO && pu.ciipFlag, "the case should not happen!");
 
   if (!pu.cs->pcv->isEncoder)
   {
     if (CU::isIBC(*pu.cu))
     {
-      CHECK(!luma, "IBC only for Chroma is not allowed.");
+      CHECK_VTM(!luma, "IBC only for Chroma is not allowed.");
       xIntraBlockCopy(pu, predBuf, COMPONENT_Y);
       if (chroma && isChromaEnabled(pu.chromaFormat))
       {
@@ -1485,7 +1485,7 @@
 
   if( eRefPicList != REF_PIC_LIST_X )
   {
-    CHECK(predBufWOBIO != NULL, "the case should not happen!");
+    CHECK_VTM(predBufWOBIO != NULL, "the case should not happen!");
     if ((CU::isIBC(*pu.cu) == false) && ((sliceType == P_SLICE && pps.getUseWP()) || (sliceType == B_SLICE && pps.getWPBiPred())))
     {
       xPredInterUni(pu, eRefPicList, predBuf, true, false, luma, chroma);
@@ -1499,7 +1499,7 @@
   }
   else
   {
-    CHECK( !pu.cu->affine && pu.refIdx[0] >= 0 && pu.refIdx[1] >= 0 && ( pu.lwidth() + pu.lheight() == 12 ), "invalid 4x8/8x4 bi-predicted blocks" );
+    CHECK_VTM( !pu.cu->affine && pu.refIdx[0] >= 0 && pu.refIdx[1] >= 0 && ( pu.lwidth() + pu.lheight() == 12 ), "invalid 4x8/8x4 bi-predicted blocks" );
     int refIdx0 = pu.refIdx[REF_PIC_LIST_0];
     int refIdx1 = pu.refIdx[REF_PIC_LIST_1];
 
@@ -1563,7 +1563,7 @@
     {
       if (pu.mergeType != MRG_TYPE_DEFAULT_N && pu.mergeType != MRG_TYPE_IBC)
       {
-        CHECK(predBufWOBIO != NULL, "the case should not happen!");
+        CHECK_VTM(predBufWOBIO != NULL, "the case should not happen!");
         xSubPuMC(pu, predBuf, eRefPicList, luma, chroma);
       }
       else if (xCheckIdenticalMotion(pu))
@@ -1898,7 +1898,7 @@
         deltaIntMvX    = (cMv.getHor() >> mvshiftTempHor) - (startMv.getHor() >> mvshiftTempHor);
         deltaIntMvY    = (cMv.getVer() >> mvshiftTempVer) - (startMv.getVer() >> mvshiftTempVer);
 
-        CHECK((abs(deltaIntMvX) > DMVR_NUM_ITERATION) || (abs(deltaIntMvY) > DMVR_NUM_ITERATION), "not expected DMVR movement");
+        CHECK_VTM((abs(deltaIntMvX) > DMVR_NUM_ITERATION) || (abs(deltaIntMvY) > DMVR_NUM_ITERATION), "not expected DMVR movement");
 
         offset = (DMVR_NUM_ITERATION + leftPixelExtra) * (pcPadTemp.bufs[compID].stride + 1);
         offset += (deltaIntMvY)* pcPadTemp.bufs[compID].stride;
@@ -2429,7 +2429,7 @@
     int refHeight = ((((int32_t)y0Int + (height-1) * stepY) + offY ) >> posShift) - ((((int32_t)y0Int + 0 * stepY) + offY ) >> posShift) + 1;
     refHeight = std::max<int>( 1, refHeight );
 
-    CHECK( MAX_CU_SIZE * MAX_SCALING_RATIO + 16 < refHeight + vFilterSize - 1 + extSize, "Buffer is not large enough, increase MAX_SCALING_RATIO" );
+    CHECK_VTM( MAX_CU_SIZE * MAX_SCALING_RATIO + 16 < refHeight + vFilterSize - 1 + extSize, "Buffer is not large enough, increase MAX_SCALING_RATIO" );
 
     Pel buffer[( MAX_CU_SIZE + 16 ) * ( MAX_CU_SIZE * MAX_SCALING_RATIO + 16 )];
     int tmpStride = width;
@@ -2442,7 +2442,7 @@
       xInt = std::min( std::max( -(NTAPS_LUMA / 2), xInt ), ( refPicWidth >> ::getComponentScaleX( compID, chFmt ) ) + (NTAPS_LUMA / 2) );
       int xFrac = ( ( posX + offX ) >> ( posShift - shiftHor ) ) & ( ( 1 << shiftHor ) - 1 );
 
-      CHECK( xInt0 > xInt, "Wrong horizontal starting point" );
+      CHECK_VTM( xInt0 > xInt, "Wrong horizontal starting point" );
 
       Position offset = Position( xInt, yInt0 );
       refBuf = refPic->getRecoBuf( CompArea( compID, chFmt, offset, Size( 1, refHeight ) ), wrapRef );
@@ -2458,7 +2458,7 @@
       yInt = std::min( std::max( -(NTAPS_LUMA / 2), yInt ), ( refPicHeight >> ::getComponentScaleY( compID, chFmt ) ) + (NTAPS_LUMA / 2) );
       int yFrac = ( ( posY + offY ) >> ( posShift - shiftVer ) ) & ( ( 1 << shiftVer ) - 1 );
 
-      CHECK( yInt0 > yInt, "Wrong vertical starting point" );
+      CHECK_VTM( yInt0 > yInt, "Wrong vertical starting point" );
 
       Pel* tempBuf = buffer + ( yInt - yInt0 ) * tmpStride;
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/IntraPrediction.cpp ../VVCSoftware_10/source/Lib/CommonLib/IntraPrediction.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/IntraPrediction.cpp	2022-09-16 14:27:06.132532782 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/IntraPrediction.cpp	2022-05-13 17:45:29.148146119 +0200
@@ -151,7 +151,7 @@
 //NOTE: Bit-Limit - 25-bit source
 Pel IntraPrediction::xGetPredValDc( const CPelBuf &pSrc, const Size &dstSize )
 {
-  CHECK( dstSize.width == 0 || dstSize.height == 0, "Empty area provided" );
+  CHECK_VTM( dstSize.width == 0 || dstSize.height == 0, "Empty area provided" );
 
   int idx, sum = 0;
   Pel dcVal;
@@ -218,12 +218,12 @@
   const ChannelType    channelType  = toChannelType( compID );
   const int            iWidth       = piPred.width;
   const int            iHeight      = piPred.height;
-  CHECK(iWidth == 2, "Width of 2 is not supported");
-  CHECK(PU::isMIP(pu, toChannelType(compId)), "We should not get here for MIP.");
+  CHECK_VTM(iWidth == 2, "Width of 2 is not supported");
+  CHECK_VTM(PU::isMIP(pu, toChannelType(compId)), "We should not get here for MIP.");
   const uint32_t       uiDirMode    = isLuma( compId ) && pu.cu->bdpcmMode ? BDPCM_IDX : !isLuma(compId) && pu.cu->bdpcmModeChroma ? BDPCM_IDX : PU::getFinalIntraMode(pu, channelType);
 
-  CHECK( floorLog2(iWidth) < 2 && pu.cs->pcv->noChroma2x2, "Size not allowed" );
-  CHECK( floorLog2(iWidth) > 7, "Size not allowed" );
+  CHECK_VTM( floorLog2(iWidth) < 2 && pu.cs->pcv->noChroma2x2, "Size not allowed" );
+  CHECK_VTM( floorLog2(iWidth) > 7, "Size not allowed" );
 
   const int srcStride  = m_refBufferStride[compID];
   const int srcHStride = 2;
@@ -243,7 +243,7 @@
   {
     PelBuf dstBuf = piPred;
     const int scale = ((floorLog2(iWidth) - 2 + floorLog2(iHeight) - 2 + 2) >> 2);
-    CHECK(scale < 0 || scale > 31, "PDPC: scale < 0 || scale > 31");
+    CHECK_VTM(scale < 0 || scale > 31, "PDPC: scale < 0 || scale > 31");
 
     if (uiDirMode == PLANAR_IDX || uiDirMode == DC_IDX)
     {
@@ -301,13 +301,13 @@
   const uint32_t offset = 1 << (log2W + log2H);
 
   // Get left and above reference column and row
-  CHECK(width > MAX_CU_SIZE, "width greater than limit");
+  CHECK_VTM(width > MAX_CU_SIZE, "width greater than limit");
   for( int k = 0; k < width + 1; k++ )
   {
     topRow[k] = pSrc.at( k + 1, 0 );
   }
 
-  CHECK(height > MAX_CU_SIZE, "height greater than limit");
+  CHECK_VTM(height > MAX_CU_SIZE, "height greater than limit");
   for( int k = 0; k < height + 1; k++ )
   {
     leftColumn[k] = pSrc.at(k + 1, 1);
@@ -429,7 +429,7 @@
     {
       const int diff = std::min<int>( abs( predMode - HOR_IDX ), abs( predMode - VER_IDX ) );
       const int log2Size = ((floorLog2(puSize.width) + floorLog2(puSize.height)) >> 1);
-      CHECK( log2Size >= MAX_INTRA_FILTER_DEPTHS, "Size not supported" );
+      CHECK_VTM( log2Size >= MAX_INTRA_FILTER_DEPTHS, "Size not supported" );
       filterFlag = (diff > m_aucIntraFilter[log2Size]);
     }
 
@@ -437,7 +437,7 @@
     if (filterFlag)
     {
       const bool isRefFilter       =  isIntegerSlope(absAng);
-      CHECK( puSize.width * puSize.height <= 32, "DCT-IF interpolation filter is always used for 4x4, 4x8, and 8x4 luma CB" );
+      CHECK_VTM( puSize.width * puSize.height <= 32, "DCT-IF interpolation filter is always used for 4x4, 4x8, and 8x4 luma CB" );
       m_ipaParam.refFilterFlag     =  isRefFilter;
       m_ipaParam.interpolationFlag = !isRefFilter;
     }
@@ -651,7 +651,7 @@
   const int strideP = pDst.stride;
   const int strideS = pSrc.stride;
 
-  CHECK( !( dirMode == 1 || dirMode == 2 ), "Incorrect BDPCM mode parameter." );
+  CHECK_VTM( !( dirMode == 1 || dirMode == 2 ), "Incorrect BDPCM mode parameter." );
 
   Pel* pred = &pDst.buf[0];
   if( dirMode == 1 )
@@ -683,7 +683,7 @@
 void IntraPrediction::geneWeightedPred(const ComponentID compId, PelBuf &pred, const PredictionUnit &pu, Pel *srcBuf)
 {
   const int            width = pred.width;
-  CHECK(width == 2, "Width of 2 is not supported");
+  CHECK_VTM(width == 2, "Width of 2 is not supported");
   const int            height = pred.height;
   const int            srcStride = width;
   const int            dstStride = pred.stride;
@@ -779,7 +779,7 @@
 
 void IntraPrediction::initIntraPatternChType(const CodingUnit &cu, const CompArea &area, const bool forceRefFilterFlag)
 {
-  CHECK(area.width == 2, "Width of 2 is not supported");
+  CHECK_VTM(area.width == 2, "Width of 2 is not supported");
   const CodingStructure& cs   = *cu.cs;
 
   if (!forceRefFilterFlag)
@@ -946,7 +946,7 @@
   const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
   const int  numLeftBelowUnits  = totalLeftUnits - numLeftUnits;
 
-  CHECK( numAboveUnits <= 0 || numLeftUnits <= 0 || numAboveRightUnits <= 0 || numLeftBelowUnits <= 0, "Size not supported" );
+  CHECK_VTM( numAboveUnits <= 0 || numLeftUnits <= 0 || numAboveRightUnits <= 0 || numLeftBelowUnits <= 0, "Size not supported" );
 
   // ----- Step 1: analyze neighborhood -----
   const Position posLT          = area;
@@ -1343,8 +1343,8 @@
   //assert 420 chroma subsampling
   CompArea lumaArea = CompArea( COMPONENT_Y, pu.chromaFormat, chromaArea.lumaPos(), recalcSize( pu.chromaFormat, CHANNEL_TYPE_CHROMA, CHANNEL_TYPE_LUMA, chromaArea.size() ) );//needed for correct pos/size (4x4 Tus)
 
-  CHECK(lumaArea.width == chromaArea.width && CHROMA_444 != pu.chromaFormat, "");
-  CHECK(lumaArea.height == chromaArea.height && CHROMA_444 != pu.chromaFormat && CHROMA_422 != pu.chromaFormat, "");
+  CHECK_VTM(lumaArea.width == chromaArea.width && CHROMA_444 != pu.chromaFormat, "");
+  CHECK_VTM(lumaArea.height == chromaArea.height && CHROMA_444 != pu.chromaFormat && CHROMA_422 != pu.chromaFormat, "");
 
   const SizeType uiCWidth = chromaArea.width;
   const SizeType uiCHeight = chromaArea.height;
@@ -1563,7 +1563,7 @@
       }
       else
       {
-        CHECK(pu.chromaFormat != CHROMA_420, "Chroma format must be 4:2:0 for vertical filtering");
+        CHECK_VTM(pu.chromaFormat != CHROMA_420, "Chroma format must be 4:2:0 for vertical filtering");
         const bool leftPadding = i == 0 && !leftIsAvailable;
 
         int s = 4;
@@ -1585,7 +1585,7 @@
                                               const CompArea &chromaArea,
                                               int &a, int &b, int &iShift)
 {
-  CHECK(compID == COMPONENT_Y, "");
+  CHECK_VTM(compID == COMPONENT_Y, "");
 
   const SizeType cWidth  = chromaArea.width;
   const SizeType cHeight = chromaArea.height;
@@ -1811,10 +1811,10 @@
 
 void IntraPrediction::initIntraMip( const PredictionUnit &pu, const CompArea &area )
 {
-  CHECK( area.width > MIP_MAX_WIDTH || area.height > MIP_MAX_HEIGHT, "Error: block size not supported for MIP" );
+  CHECK_VTM( area.width > MIP_MAX_WIDTH || area.height > MIP_MAX_HEIGHT, "Error: block size not supported for MIP" );
 
   // prepare input (boundary) data for prediction
-  CHECK( m_ipaParam.refFilterFlag, "ERROR: unfiltered refs expected for MIP" );
+  CHECK_VTM( m_ipaParam.refFilterFlag, "ERROR: unfiltered refs expected for MIP" );
   Pel       *ptrSrc     = getPredictorPtr(area.compID);
   const int  srcStride  = m_refBufferStride[area.compID];
   const int  srcHStride = 2;
@@ -1825,8 +1825,8 @@
 
 void IntraPrediction::predIntraMip( const ComponentID compId, PelBuf &piPred, const PredictionUnit &pu )
 {
-  CHECK( piPred.width > MIP_MAX_WIDTH || piPred.height > MIP_MAX_HEIGHT, "Error: block size not supported for MIP" );
-  CHECK( piPred.width != (1 << floorLog2(piPred.width)) || piPred.height != (1 << floorLog2(piPred.height)), "Error: expecting blocks of size 2^M x 2^N" );
+  CHECK_VTM( piPred.width > MIP_MAX_WIDTH || piPred.height > MIP_MAX_HEIGHT, "Error: block size not supported for MIP" );
+  CHECK_VTM( piPred.width != (1 << floorLog2(piPred.width)) || piPred.height != (1 << floorLog2(piPred.height)), "Error: expecting blocks of size 2^M x 2^N" );
 
   // generate mode-specific prediction
   uint32_t modeIdx       = MAX_NUM_MIP_MODE;
@@ -1840,15 +1840,15 @@
   {
     const PredictionUnit &coLocatedLumaPU = PU::getCoLocatedLumaPU(pu);
 
-    CHECK(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "Error: MIP is only supported for chroma with DM_CHROMA.");
-    CHECK(!coLocatedLumaPU.cu->mipFlag, "Error: Co-located luma CU should use MIP.");
+    CHECK_VTM(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "Error: MIP is only supported for chroma with DM_CHROMA.");
+    CHECK_VTM(!coLocatedLumaPU.cu->mipFlag, "Error: Co-located luma CU should use MIP.");
 
     modeIdx       = coLocatedLumaPU.intraDir[CHANNEL_TYPE_LUMA];
     transposeFlag = coLocatedLumaPU.mipTransposedFlag;
   }
   const int bitDepth = pu.cu->slice->getSPS()->getBitDepth(toChannelType(compId));
 
-  CHECK(modeIdx >= getNumModesMip(piPred), "Error: Wrong MIP mode index");
+  CHECK_VTM(modeIdx >= getNumModesMip(piPred), "Error: Wrong MIP mode index");
 
   static_vector<int, MIP_MAX_WIDTH* MIP_MAX_HEIGHT> predMip( piPred.width * piPred.height );
   m_matrixIntraPred.predBlock(predMip.data(), modeIdx, transposeFlag, bitDepth, compId);
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/LoopFilter.cpp ../VVCSoftware_10/source/Lib/CommonLib/LoopFilter.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/LoopFilter.cpp	2022-09-16 14:27:06.132532782 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/LoopFilter.cpp	2022-05-13 17:45:29.280144624 +0200
@@ -886,8 +886,8 @@
 
 
   // pcSlice->isInterP()
-  CHECK(CU::isInter(cuP) && 0 > miP.refIdx[0], "Invalid reference picture list index");
-  CHECK(CU::isInter(cuP) && 0 > miQ.refIdx[0], "Invalid reference picture list index");
+  CHECK_VTM(CU::isInter(cuP) && 0 > miP.refIdx[0], "Invalid reference picture list index");
+  CHECK_VTM(CU::isInter(cuP) && 0 > miQ.refIdx[0], "Invalid reference picture list index");
   const Picture *piRefP0 = (CU::isIBC(cuP) ? sliceP.getPic() : sliceP.getRefPic(REF_PIC_LIST_0, miP.refIdx[0]));
   const Picture *piRefQ0 = (CU::isIBC(cuQ) ? sliceQ.getPic() : sliceQ.getRefPic(REF_PIC_LIST_0, miQ.refIdx[0]));
   if (piRefP0 != piRefQ0)
@@ -1276,12 +1276,12 @@
 
       if (edgeDir == EDGE_VER)
       {
-        CHECK(!isAvailableLeft(cu, cuP, !pps.getLoopFilterAcrossSlicesEnabledFlag(), !pps.getLoopFilterAcrossTilesEnabledFlag(),
+        CHECK_VTM(!isAvailableLeft(cu, cuP, !pps.getLoopFilterAcrossSlicesEnabledFlag(), !pps.getLoopFilterAcrossTilesEnabledFlag(),
           !( pps.getSubPicFromCU(cu).getloopFilterAcrossEnabledFlag() && pps.getSubPicFromCU(cuP).getloopFilterAcrossEnabledFlag())), "Neighbour not available");
       }
       else  // (iDir == EDGE_HOR)
       {
-        CHECK(!isAvailableAbove(cu, cuP, !pps.getLoopFilterAcrossSlicesEnabledFlag(), !pps.getLoopFilterAcrossTilesEnabledFlag(),
+        CHECK_VTM(!isAvailableAbove(cu, cuP, !pps.getLoopFilterAcrossSlicesEnabledFlag(), !pps.getLoopFilterAcrossTilesEnabledFlag(),
           !( pps.getSubPicFromCU(cu).getloopFilterAcrossEnabledFlag() && pps.getSubPicFromCU(cuP).getloopFilterAcrossEnabledFlag())), "Neighbour not available");
       }
 
@@ -1432,7 +1432,7 @@
 
 inline void LoopFilter::xFilteringPandQ(Pel* src, int offset, int numberPSide, int numberQSide, int tc) const
 {
-  CHECK(numberPSide <= 3 && numberQSide <= 3, "Short filtering in long filtering function");
+  CHECK_VTM(numberPSide <= 3 && numberQSide <= 3, "Short filtering in long filtering function");
   Pel* srcP = src-offset;
   Pel* srcQ = src;
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/MatrixIntraPrediction.cpp ../VVCSoftware_10/source/Lib/CommonLib/MatrixIntraPrediction.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/MatrixIntraPrediction.cpp	2022-09-16 14:27:06.132532782 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/MatrixIntraPrediction.cpp	2022-05-13 17:45:29.288144533 +0200
@@ -120,7 +120,7 @@
 void MatrixIntraPrediction::predBlock(int *const result, const int modeIdx, const bool transpose, const int bitDepth,
                                       const ComponentID compId)
 {
-  CHECK(m_component != compId, "Boundary has not been prepared for this component.");
+  CHECK_VTM(m_component != compId, "Boundary has not been prepared for this component.");
 
   const bool needUpsampling = ( m_upsmpFactorHor > 1 ) || ( m_upsmpFactorVer > 1 );
 
@@ -293,7 +293,7 @@
   int sum = 0;
   for( int i = 0; i < inputSize; i++ ) { sum += input[i]; }
   const int offset = (1 << (MIP_SHIFT_MATRIX - 1)) - MIP_OFFSET_MATRIX * sum;
-  CHECK( inputSize != 4 * (inputSize >> 2), "Error, input size not divisible by four" );
+  CHECK_VTM( inputSize != 4 * (inputSize >> 2), "Error, input size not divisible by four" );
 
   const uint8_t *weight = matrix;
   const int   inputOffset = transpose ? m_inputOffsetTransp : m_inputOffset;
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/MotionInfo.h ../VVCSoftware_10/source/Lib/CommonLib/MotionInfo.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/MotionInfo.h	2022-09-16 14:27:06.132532782 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/MotionInfo.h	2022-05-13 17:45:29.296144443 +0200
@@ -79,21 +79,21 @@
 
   void setMvField( Mv const & cMv, const int iRefIdx )
   {
-    CHECK( iRefIdx == -1 && cMv != Mv(0,0), "Must not happen." );
+    CHECK_VTM( iRefIdx == -1 && cMv != Mv(0,0), "Must not happen." );
     mv     = cMv;
     refIdx = iRefIdx;
   }
 
   bool operator==( const MvField& other ) const
   {
-    CHECK( refIdx == -1 && mv != Mv(0,0), "Error in operator== of MvField." );
-    CHECK( other.refIdx == -1 && other.mv != Mv(0,0), "Error in operator== of MvField." );
+    CHECK_VTM( refIdx == -1 && mv != Mv(0,0), "Error in operator== of MvField." );
+    CHECK_VTM( other.refIdx == -1 && other.mv != Mv(0,0), "Error in operator== of MvField." );
     return refIdx == other.refIdx && mv == other.mv;
   }
   bool operator!=( const MvField& other ) const
   {
-    CHECK( refIdx == -1 && mv != Mv(0,0), "Error in operator!= of MvField." );
-    CHECK( other.refIdx == -1 && other.mv != Mv(0,0), "Error in operator!= of MvField." );
+    CHECK_VTM( refIdx == -1 && mv != Mv(0,0), "Error in operator!= of MvField." );
+    CHECK_VTM( other.refIdx == -1 && other.mv != Mv(0,0), "Error in operator!= of MvField." );
     return refIdx != other.refIdx || mv != other.mv;
   }
 };
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/ParameterSetManager.h ../VVCSoftware_10/source/Lib/CommonLib/ParameterSetManager.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/ParameterSetManager.h	2022-09-16 14:27:06.132532782 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/ParameterSetManager.h	2022-05-13 17:45:29.196145575 +0200
@@ -71,7 +71,7 @@
 
   T *allocatePS(const int psId)
   {
-    CHECK( psId >= m_maxId, "Invalid PS id" );
+    CHECK_VTM( psId >= m_maxId, "Invalid PS id" );
     if ( m_paramsetMap.find(psId) == m_paramsetMap.end() )
     {
       m_paramsetMap[psId].bChanged = true;
@@ -88,7 +88,7 @@
   }
   void storePS( int psId, T *ps )
   {
-    CHECK( psId >= m_maxId, "Invalid PS id" );
+    CHECK_VTM( psId >= m_maxId, "Invalid PS id" );
     if( m_paramsetMap.find( psId ) != m_paramsetMap.end() )
     {
       delete m_paramsetMap[psId].parameterSet;
@@ -98,7 +98,7 @@
   }
   void storePS(int psId, T *ps, const std::vector<uint8_t> *pNaluData)
   {
-    CHECK( psId >= m_maxId, "Invalid PS id" );
+    CHECK_VTM( psId >= m_maxId, "Invalid PS id" );
     if ( m_paramsetMap.find(psId) != m_paramsetMap.end() )
     {
       MapData<T> &mapData=m_paramsetMap[psId];
@@ -144,25 +144,25 @@
 
     if( std::find( accessUnitApsNals.begin(), accessUnitApsNals.end(), apsId ) != accessUnitApsNals.end() )
     {
-      CHECK( m_paramsetMap.find( apsId ) == m_paramsetMap.end(), "APS does not exist" );
+      CHECK_VTM( m_paramsetMap.find( apsId ) == m_paramsetMap.end(), "APS does not exist" );
       APS* existedAPS = m_paramsetMap[apsId].parameterSet;
       bool sameNalUnitType = aps->getHasPrefixNalUnitType() == existedAPS->getHasPrefixNalUnitType();
       bool samePU = aps->getLayerId() == existedAPS->getLayerId();
       if( aps->getAPSType() == LMCS_APS )
       {
-        CHECK( samePU && sameNalUnitType && aps->getReshaperAPSInfo() != existedAPS->getReshaperAPSInfo(), "All APS NAL units with a particular value of nal_unit_type, a particular value of aps_adaptation_parameter_set_id, and a particular value of aps_params_type within a PU shall have the same content" );
+        CHECK_VTM( samePU && sameNalUnitType && aps->getReshaperAPSInfo() != existedAPS->getReshaperAPSInfo(), "All APS NAL units with a particular value of nal_unit_type, a particular value of aps_adaptation_parameter_set_id, and a particular value of aps_params_type within a PU shall have the same content" );
       }
       else if( aps->getAPSType() == ALF_APS )
       {
-        CHECK( samePU && sameNalUnitType && aps->getAlfAPSParam() != existedAPS->getAlfAPSParam(), "All APS NAL units with a particular value of nal_unit_type, a particular value of aps_adaptation_parameter_set_id, and a particular value of aps_params_type within a PU shall have the same content" );
+        CHECK_VTM( samePU && sameNalUnitType && aps->getAlfAPSParam() != existedAPS->getAlfAPSParam(), "All APS NAL units with a particular value of nal_unit_type, a particular value of aps_adaptation_parameter_set_id, and a particular value of aps_params_type within a PU shall have the same content" );
       }
       else if( aps->getAPSType() == SCALING_LIST_APS )
       {
-        CHECK( samePU && sameNalUnitType && aps->getScalingList() != existedAPS->getScalingList(), "All APS NAL units with a particular value of nal_unit_type, a particular value of aps_adaptation_parameter_set_id, and a particular value of aps_params_type within a PU shall have the same content" );
+        CHECK_VTM( samePU && sameNalUnitType && aps->getScalingList() != existedAPS->getScalingList(), "All APS NAL units with a particular value of nal_unit_type, a particular value of aps_adaptation_parameter_set_id, and a particular value of aps_params_type within a PU shall have the same content" );
       }
       else
       {
-        CHECK( true, "Wrong APS type" );
+        CHECK_VTM( true, "Wrong APS type" );
       }
     }
     else
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Picture.cpp ../VVCSoftware_10/source/Lib/CommonLib/Picture.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Picture.cpp	2022-09-16 14:27:06.132532782 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/Picture.cpp	2022-05-13 17:45:29.092146753 +0200
@@ -428,16 +428,16 @@
   if (mixedLossyLossless)
   {
     m_lossylosslessSliceArray.assign(numSlices, false); // initialize to all slices are lossless 
-    CHECK(numElementsinsliceLosslessIndexArray == 0 , "sliceLosslessArray is empty, must need to configure for mixed lossy/lossless");
+    CHECK_VTM(numElementsinsliceLosslessIndexArray == 0 , "sliceLosslessArray is empty, must need to configure for mixed lossy/lossless");
 
     // mixed lossy/lossless slices, set only lossless slices;
     for (uint16_t i = 0; i < numElementsinsliceLosslessIndexArray; i++)
     {
-        CHECK(sliceLosslessIndexArray[i] >= numSlices || sliceLosslessIndexArray[i] < 0, "index of lossless slice is out of slice index bound");
+      CHECK_VTM(sliceLosslessIndexArray[i] >= numSlices || sliceLosslessIndexArray[i] < 0, "index of lossless slice is out of slice index bound");
         m_lossylosslessSliceArray[sliceLosslessIndexArray[i]] = true;
     }
   } 
-  CHECK(m_lossylosslessSliceArray.size() < numSlices, "sliceLosslessArray size is less than number of slices");
+  CHECK_VTM(m_lossylosslessSliceArray.size() < numSlices, "sliceLosslessArray size is less than number of slices");
 }
 
 Slice *Picture::swapSliceObject(Slice * p, uint32_t i)
@@ -744,7 +744,7 @@
   int *buf = new int[orgHeight * scaledWidth];
   int maxVal = ( 1 << bitDepth ) - 1;
 
-  CHECK( bitDepth > 17, "Overflow may happen!" );
+  CHECK_VTM( bitDepth > 17, "Overflow may happen!" );
 
   for( int i = 0; i < scaledWidth; i++ )
   {
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Quant.cpp ../VVCSoftware_10/source/Lib/CommonLib/Quant.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Quant.cpp	2022-09-16 14:27:06.132532782 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/Quant.cpp	2022-05-13 17:45:29.132146300 +0200
@@ -387,8 +387,8 @@
     coef = tu.getCoeffs(compID).buf;
   }
   const TCoeff          *const piQCoef = coef;
-  CHECK(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
-  CHECK(uiWidth > m_uiMaxTrSize, "Unsupported transformation size");
+  CHECK_VTM(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
+  CHECK_VTM(uiWidth > m_uiMaxTrSize, "Unsupported transformation size");
 
   // Represents scaling through forward transform
   const bool bClipTransformShiftTo0 = tu.mtsIdx[compID] != MTS_SKIP && sps->getSpsRangeExtension().getExtendedPrecisionProcessingFlag();
@@ -972,7 +972,7 @@
 
     TCoeff deltaU[MAX_TB_SIZEY * MAX_TB_SIZEY];
     int scalingListType = getScalingListType(tu.cu->predMode, compID);
-    CHECK(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
+    CHECK_VTM(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
     const uint32_t uiLog2TrWidth = floorLog2(uiWidth);
     const uint32_t uiLog2TrHeight = floorLog2(uiHeight);
     int *piQuantCoeff = getQuantCoeff(scalingListType, cQP.rem(useTransformSkip), uiLog2TrWidth, uiLog2TrHeight);
@@ -1050,7 +1050,7 @@
   const int  maxLog2TrDynamicRange = sps.getMaxLog2TrDynamicRange(toChannelType(compID));
 
   int scalingListType = getScalingListType(tu.cu->predMode, compID);
-  CHECK(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
+  CHECK_VTM(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
 
   const uint32_t uiLog2TrWidth  = floorLog2(uiWidth);
   const uint32_t uiLog2TrHeight = floorLog2(uiHeight);
@@ -1116,7 +1116,7 @@
   const bool           useTransformSkip = (tu.mtsIdx[compID] == MTS_SKIP);
   const int            defaultQuantisationCoefficient = g_quantScales[0][cQP.rem(useTransformSkip)];
 
-  CHECK( scalingListType >= SCALING_LIST_NUM, "Invalid scaling list" );
+  CHECK_VTM( scalingListType >= SCALING_LIST_NUM, "Invalid scaling list" );
 
   const uint32_t uiLog2TrWidth      = floorLog2(uiWidth);
   const uint32_t uiLog2TrHeight     = floorLog2(uiHeight);
@@ -1175,7 +1175,7 @@
   const bool           isLfnstApplied = tu.cu->lfnstIdx > 0 && (tu.cu->isSepTree() ? true : isLuma(compID));
   const bool           disableSMForACT = tu.cs->slice->getSPS()->getScalingMatrixForAlternativeColourSpaceDisabledFlag() && (tu.cs->slice->getSPS()->getScalingMatrixDesignatedColourSpaceFlag() == tu.cu->colorTransform);
   const bool           enableScalingLists = getUseScalingList(uiWidth, uiHeight, true, isLfnstApplied, disableSMForLFNST, disableSMForACT);
-  CHECK(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
+  CHECK_VTM(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
 
   const bool isTransformSkip = (tu.mtsIdx[compID] == MTS_SKIP);
   const int rightShift = (IQUANT_SHIFT - ((isTransformSkip ? 0 : iTransformShift) + QP_per)) + (enableScalingLists ? LOG2_SCALING_LIST_NEUTRAL_VALUE : 0);
@@ -1265,12 +1265,12 @@
 
   if (forward)
   {
-    CHECK(m_pairCheck == 1, "lambda has been already adjusted");
+    CHECK_VTM(m_pairCheck == 1, "lambda has been already adjusted");
     m_pairCheck = 1;
   }
   else
   {
-    CHECK(m_pairCheck == 0, "lambda has not been adjusted");
+    CHECK_VTM(m_pairCheck == 0, "lambda has not been adjusted");
     m_pairCheck = 0;
   }
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/QuantRDOQ.cpp ../VVCSoftware_10/source/Lib/CommonLib/QuantRDOQ.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/QuantRDOQ.cpp	2022-09-16 14:27:06.132532782 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/QuantRDOQ.cpp	2022-05-13 17:45:29.028147478 +0200
@@ -81,7 +81,7 @@
 {
 
   const QuantRDOQ *rdoq = dynamic_cast<const QuantRDOQ*>( other );
-  CHECK( other && !rdoq, "The RDOQ cast must be successfull!" );
+  CHECK_VTM( other && !rdoq, "The RDOQ cast must be successfull!" );
   xInitScalingList( rdoq );
 }
 
@@ -601,11 +601,11 @@
   const uint32_t uiLog2BlockHeight                 = floorLog2(uiHeight);
   const uint32_t uiMaxNumCoeff                     = rect.area();
 
-  CHECK(compID >= MAX_NUM_TBLOCKS, "Invalid component ID");
+  CHECK_VTM(compID >= MAX_NUM_TBLOCKS, "Invalid component ID");
 
   int scalingListType = getScalingListType(tu.cu->predMode, compID);
 
-  CHECK(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
+  CHECK_VTM(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
 
   const TCoeff *plSrcCoeff = pSrc.buf;
         TCoeff *piDstCoeff = tu.getCoeffs(compID).buf;
@@ -1201,10 +1201,10 @@
         double   blockUncodedCost                   = 0;
   const uint32_t maxNumCoeff                        = rect.area();
 
-  CHECK( compID >= MAX_NUM_TBLOCKS, "Invalid component ID" );
+  CHECK_VTM( compID >= MAX_NUM_TBLOCKS, "Invalid component ID" );
 
   int scalingListType = getScalingListType( tu.cu->predMode, compID );
-  CHECK( scalingListType >= SCALING_LIST_NUM, "Invalid scaling list" );
+  CHECK_VTM( scalingListType >= SCALING_LIST_NUM, "Invalid scaling list" );
 
   const TCoeff *srcCoeff = coeffs.buf;
         TCoeff *dstCoeff = tu.getCoeffs( compID ).buf;
@@ -1423,10 +1423,10 @@
   double   blockUncodedCost = 0;
   const uint32_t maxNumCoeff = rect.area();
 
-  CHECK(compID >= MAX_NUM_TBLOCKS, "Invalid component ID");
+  CHECK_VTM(compID >= MAX_NUM_TBLOCKS, "Invalid component ID");
 
   int scalingListType = getScalingListType(tu.cu->predMode, compID);
-  CHECK(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
+  CHECK_VTM(scalingListType >= SCALING_LIST_NUM, "Invalid scaling list");
 
   const TCoeff *srcCoeff = coeffs.buf;
   TCoeff *dstCoeff = tu.getCoeffs(compID).buf;
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/RdCost.cpp ../VVCSoftware_10/source/Lib/CommonLib/RdCost.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/RdCost.cpp	2022-09-16 14:27:06.132532782 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/RdCost.cpp	2022-05-13 17:45:29.108146572 +0200
@@ -104,12 +104,12 @@
 
   if (forward)
   {
-    CHECK(m_pairCheck == 1, "lambda has been already adjusted");
+    CHECK_VTM(m_pairCheck == 1, "lambda has been already adjusted");
     m_pairCheck = 1;
   }
   else
   {
-    CHECK(m_pairCheck == 0, "lambda has not been adjusted");
+    CHECK_VTM(m_pairCheck == 0, "lambda has not been adjusted");
     m_pairCheck = 0;
   }
 
@@ -117,14 +117,14 @@
   m_DistScale = m_DistScaleStore[m_pairCheck][componentID];
   if (applyChromaScale)
   {
-    CHECK(m_pairCheck == 0 || componentID == COMPONENT_Y, "wrong lambda adjustment for CS");
+    CHECK_VTM(m_pairCheck == 0 || componentID == COMPONENT_Y, "wrong lambda adjustment for CS");
     double cResScale = (double)(1 << CSCALE_FP_PREC) / (double)(*resScaleInv);
     m_dLambda = m_dLambda / (cResScale*cResScale);
     m_DistScale = double(1 << SCALE_BITS) / m_dLambda;
   }
   if (m_pairCheck == 0)
   {
-    CHECK(m_DistScale != m_DistScaleUnadjusted, "lambda should be adjusted to the original value");
+    CHECK_VTM(m_DistScale != m_DistScaleUnadjusted, "lambda should be adjusted to the original value");
   }
 }
 
@@ -389,7 +389,7 @@
   rcDP.subShift = subShiftMode;
   rcDP.step       = step;
   rcDP.maximumDistortionForEarlyExit = std::numeric_limits<Distortion>::max();
-  CHECK( useHadamard || rcDP.useMR, "only used in xDMVRCost with these default parameters (so far...)" );
+  CHECK_VTM( useHadamard || rcDP.useMR, "only used in xDMVRCost with these default parameters (so far...)" );
   if ( bioApplied )
   {
     rcDP.distFunc = m_afpDistortFunc[ DF_SAD_INTERMEDIATE_BITDEPTH ];
@@ -473,7 +473,7 @@
 
 Distortion RdCost::xGetSAD_full( const DistParam& rcDtParam )
 {
-  CHECK( rcDtParam.applyWeight, "Cannot apply weight when using full-bit SAD!" );
+  CHECK_VTM( rcDtParam.applyWeight, "Cannot apply weight when using full-bit SAD!" );
   const Pel* piOrg = rcDtParam.org.buf;
   const Pel* piCur = rcDtParam.cur.buf;
   int  height      = rcDtParam.org.height;
@@ -1824,7 +1824,7 @@
 {
   if ( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 4, "Invalid size" );
+    CHECK_VTM( rcDtParam.org.width != 4, "Invalid size" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
 
@@ -1858,7 +1858,7 @@
 {
   if ( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 8, "Invalid size" );
+    CHECK_VTM( rcDtParam.org.width != 8, "Invalid size" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
 
@@ -1895,7 +1895,7 @@
 {
   if ( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 16, "Invalid size" );
+    CHECK_VTM( rcDtParam.org.width != 16, "Invalid size" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
 
@@ -1986,7 +1986,7 @@
 {
   if ( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 32, "Invalid size" );
+    CHECK_VTM( rcDtParam.org.width != 32, "Invalid size" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
 
@@ -2047,7 +2047,7 @@
 {
   if ( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 64, "Invalid size" );
+    CHECK_VTM( rcDtParam.org.width != 64, "Invalid size" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
 
@@ -2144,7 +2144,7 @@
 {
   Distortion satd = 0;
   TCoeff diff[4], m[4];
-  CHECK( iStep != 1, "Invalid step" );
+  CHECK_VTM( iStep != 1, "Invalid step" );
   diff[0] = piOrg[0             ] - piCur[0];
   diff[1] = piOrg[1             ] - piCur[1];
   diff[2] = piOrg[iStrideOrg    ] - piCur[0 + iStrideCur];
@@ -2172,7 +2172,7 @@
   Distortion satd = 0;
   TCoeff diff[16], m[16], d[16];
 
-  CHECK( iStep != 1, "Invalid step" );
+  CHECK_VTM( iStep != 1, "Invalid step" );
   for( k = 0; k < 16; k+=4 )
   {
     diff[k+0] = piOrg[0] - piCur[0];
@@ -2272,7 +2272,7 @@
   int k, i, j, jj;
   Distortion sad = 0;
   TCoeff diff[64], m1[8][8], m2[8][8], m3[8][8];
-  CHECK( iStep != 1, "Invalid step" );
+  CHECK_VTM( iStep != 1, "Invalid step" );
   for( k = 0; k < 64; k += 8 )
   {
     diff[k+0] = piOrg[0] - piCur[0];
@@ -3057,11 +3057,11 @@
 {
   Distortion distortionVal = 0;
   Intermediate_Int iTemp = org - cur;
-  CHECK( org<0, "");
+  CHECK_VTM( org<0, "");
 
   if (compIdx == COMPONENT_Y)
   {
-    CHECK(org != orgLuma, "");
+    CHECK_VTM(org != orgLuma, "");
   }
   // use luma to get weight
   double weight = 1.0;
@@ -3123,7 +3123,7 @@
 {
   if( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 2, "" );
+    CHECK_VTM( rcDtParam.org.width != 2, "" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam ); // ignore it for now
   }
 
@@ -3154,7 +3154,7 @@
 {
   if( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 4, "" );
+    CHECK_VTM( rcDtParam.org.width != 4, "" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam ); // ignore it for now
   }
 
@@ -3187,7 +3187,7 @@
 {
   if( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 8, "" );
+    CHECK_VTM( rcDtParam.org.width != 8, "" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
 
@@ -3224,7 +3224,7 @@
 {
   if( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 16, "" );
+    CHECK_VTM( rcDtParam.org.width != 16, "" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
         int  iRows = rcDtParam.org.height;
@@ -3314,7 +3314,7 @@
 {
   if( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 32, "" );
+    CHECK_VTM( rcDtParam.org.width != 32, "" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
         int  iRows = rcDtParam.org.height;
@@ -3374,7 +3374,7 @@
 {
   if( rcDtParam.applyWeight )
   {
-    CHECK( rcDtParam.org.width != 64, "" );
+    CHECK_VTM( rcDtParam.org.width != 64, "" );
     return RdCostWeightPrediction::xGetSSEw( rcDtParam );
   }
         int  iRows = rcDtParam.org.height;
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/RdCostWeightPrediction.cpp ../VVCSoftware_10/source/Lib/CommonLib/RdCostWeightPrediction.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/RdCostWeightPrediction.cpp	2022-09-16 14:27:06.132532782 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/RdCostWeightPrediction.cpp	2022-05-13 17:45:29.344143899 +0200
@@ -62,7 +62,7 @@
   const int             iStrideOrg = rcDtParam.org.stride;
   const ComponentID     compID     = rcDtParam.compID;
 
-  CHECK( compID >= MAX_NUM_COMPONENT, "Invalid component" );
+  CHECK_VTM( compID >= MAX_NUM_COMPONENT, "Invalid component" );
 
   const WPScalingParam &wpCur      = rcDtParam.wpCur[compID];
 
@@ -245,8 +245,8 @@
   const int             iStrideOrg = rcDtParam.org.stride;
   const ComponentID     compID     = rcDtParam.compID;
 
-  CHECK( rcDtParam.subShift != 0, "Subshift not supported" ); // NOTE: what is this protecting?
-  CHECK( compID >= MAX_NUM_COMPONENT, "Invalid channel" );
+  CHECK_VTM( rcDtParam.subShift != 0, "Subshift not supported" ); // NOTE: what is this protecting?
+  CHECK_VTM( compID >= MAX_NUM_COMPONENT, "Invalid channel" );
 
   const WPScalingParam &wpCur           = rcDtParam.wpCur[compID];
   const int             w0              = wpCur.w;
@@ -590,7 +590,7 @@
   const int         iStrideOrg = rcDtParam.org.stride;
   const int         iStep      = rcDtParam.step;
   const ComponentID compIdx    = rcDtParam.compID;
-  CHECK(compIdx>=MAX_NUM_COMPONENT, "Invalid component");
+  CHECK_VTM(compIdx>=MAX_NUM_COMPONENT, "Invalid component");
   const WPScalingParam &wpCur  = rcDtParam.wpCur[compIdx];
 
   Distortion uiSum = 0;
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Reshape.cpp ../VVCSoftware_10/source/Lib/CommonLib/Reshape.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Reshape.cpp	2022-09-16 14:27:06.132532782 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/Reshape.cpp	2022-05-13 17:45:29.212145394 +0200
@@ -188,7 +188,7 @@
     }
     else
     {
-      CHECK(pelnum != 0, "");
+      CHECK_VTM(pelnum != 0, "");
       lumaValue = valueDC;
     }
     chromaScale = calculateChromaAdj(lumaValue);
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/SampleAdaptiveOffset.cpp ../VVCSoftware_10/source/Lib/CommonLib/SampleAdaptiveOffset.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/SampleAdaptiveOffset.cpp	2022-09-16 14:27:06.132532782 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/SampleAdaptiveOffset.cpp	2022-05-13 17:45:28.984147976 +0200
@@ -165,7 +165,7 @@
     {
       dstOffsets[i] = codedOffset[i] *(1<<m_offsetStepLog2[compIdx]);
     }
-    CHECK(dstOffsets[SAO_CLASS_EO_PLAIN] != 0, "EO offset is not '0'"); //keep EO plain offset as zero
+    CHECK_VTM(dstOffsets[SAO_CLASS_EO_PLAIN] != 0, "EO offset is not '0'"); //keep EO plain offset as zero
   }
 
 }
@@ -250,7 +250,7 @@
     case SAO_MODE_MERGE:
       {
         SAOBlkParam* mergeTarget = mergeList[offsetParam.typeIdc];
-        CHECK(mergeTarget == NULL, "Merge target does not exist");
+        CHECK_VTM(mergeTarget == NULL, "Merge target does not exist");
 
         offsetParam = (*mergeTarget)[component];
       }
@@ -618,7 +618,7 @@
 void SampleAdaptiveOffset::SAOProcess( CodingStructure& cs, SAOBlkParam* saoBlkParams
                                       )
 {
-  CHECK(!saoBlkParams, "No parameters present");
+  CHECK_VTM(!saoBlkParams, "No parameters present");
 
   xReconstructBlkSAOParams(cs, saoBlkParams);
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Slice.cpp ../VVCSoftware_10/source/Lib/CommonLib/Slice.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Slice.cpp	2022-09-16 14:27:06.132532782 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/Slice.cpp	2022-05-13 17:45:29.320144171 +0200
@@ -444,7 +444,7 @@
   {
     if( m_RPL0.isInterLayerRefPic( ii ) )
     {
-      CHECK( m_RPL0.getInterLayerRefPicIdx( ii ) == NOT_VALID, "Wrong ILRP index" );
+      CHECK_VTM( m_RPL0.getInterLayerRefPicIdx( ii ) == NOT_VALID, "Wrong ILRP index" );
 
       int refLayerId = m_pcPic->cs->vps->getLayerId( m_pcPic->cs->vps->getDirectRefLayerIdx( layerIdx, m_RPL0.getInterLayerRefPicIdx( ii ) ) );
 
@@ -483,7 +483,7 @@
   {
     if( m_RPL1.isInterLayerRefPic( ii ) )
     {
-      CHECK( m_RPL1.getInterLayerRefPicIdx( ii ) == NOT_VALID, "Wrong ILRP index" );
+      CHECK_VTM( m_RPL1.getInterLayerRefPicIdx( ii ) == NOT_VALID, "Wrong ILRP index" );
 
       int refLayerId = m_pcPic->cs->vps->getLayerId( m_pcPic->cs->vps->getDirectRefLayerIdx( layerIdx, m_RPL1.getInterLayerRefPicIdx( ii ) ) );
 
@@ -564,7 +564,7 @@
     {
       if (!pRPL0->isRefPicLongterm(i))
       {
-        CHECK(getPOC() + pRPL0->getRefPicIdentifier(i) < pocCRA, "Invalid state");
+        CHECK_VTM(getPOC() + pRPL0->getRefPicIdentifier(i) < pocCRA, "Invalid state");
       }
       else if (!pRPL0->isInterLayerRefPic(i))
       {
@@ -577,8 +577,8 @@
         }
         const Picture *ltrp =
           xGetLongTermRefPic(rcListPic, ltrpPoc, pRPL0->getDeltaPocMSBPresentFlag(i), m_pcPic->layerId);
-        CHECK(ltrp == nullptr, "Long-term pic not found");
-        CHECK(ltrp->getPOC() < pocCRA, "Invalid state");
+        CHECK_VTM(ltrp == nullptr, "Long-term pic not found");
+        CHECK_VTM(ltrp->getPOC() < pocCRA, "Invalid state");
       }
     }
     numRefPic = pRPL1->getNumberOfShorttermPictures() + pRPL1->getNumberOfLongtermPictures();
@@ -586,7 +586,7 @@
     {
       if (!pRPL1->isRefPicLongterm(i))
       {
-        CHECK(getPOC() + pRPL1->getRefPicIdentifier(i) < pocCRA, "Invalid state");
+        CHECK_VTM(getPOC() + pRPL1->getRefPicIdentifier(i) < pocCRA, "Invalid state");
       }
       else if( !pRPL1->isInterLayerRefPic( i ) )
       {
@@ -599,8 +599,8 @@
         }
         const Picture *ltrp =
           xGetLongTermRefPic(rcListPic, ltrpPoc, pRPL1->getDeltaPocMSBPresentFlag(i), m_pcPic->layerId);
-        CHECK(ltrp == nullptr, "Long-term pic not found");
-        CHECK(ltrp->getPOC() < pocCRA, "Invalid state");
+        CHECK_VTM(ltrp == nullptr, "Long-term pic not found");
+        CHECK_VTM(ltrp->getPOC() < pocCRA, "Invalid state");
       }
     }
   }
@@ -653,14 +653,14 @@
 
         if( m_eNalUnitType == NAL_UNIT_CODED_SLICE_CRA || m_eNalUnitType == NAL_UNIT_CODED_SLICE_IDR_W_RADL || m_eNalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP )
         {
-          CHECK( refPicPOC < irapPOC || refPicDecodingOrderNumber < associatedIRAPDecodingOrderNumber, "When the current picture, with nuh_layer_id equal to a particular value layerId, "
+          CHECK_VTM( refPicPOC < irapPOC || refPicDecodingOrderNumber < associatedIRAPDecodingOrderNumber, "When the current picture, with nuh_layer_id equal to a particular value layerId, "
             "is an IRAP picture, there shall be no picture referred to by an entry in RefPicList[ 0 ] that precedes, in output order or decoding order, any preceding IRAP picture "
             "with nuh_layer_id equal to layerId in decoding order (when present)." );
         }
 
         if( irapPOC < getPOC() && !fieldSeqFlag )
         {
-          CHECK( refPicPOC < irapPOC || refPicDecodingOrderNumber < associatedIRAPDecodingOrderNumber, "When the current picture follows an IRAP picture having the same value "
+          CHECK_VTM( refPicPOC < irapPOC || refPicDecodingOrderNumber < associatedIRAPDecodingOrderNumber, "When the current picture follows an IRAP picture having the same value "
             "of nuh_layer_id and the leading pictures, if any, associated with that IRAP picture, in both decoding order and output order, there shall be no picture referred "
             "to by an entry in RefPicList[ 0 ] or RefPicList[ 1 ] that precedes that IRAP picture in output order or decoding order." );
         }
@@ -669,13 +669,13 @@
         const bool isGeneratedRefPic = pcRefPic->slices[0]->getPicHeader() ? false : true;
 
         const bool nonReferencePictureFlag = isGeneratedRefPic ? pcRefPic->slices[0]->getPicHeader()->getNonReferencePictureFlag() : pcRefPic->nonReferencePictureFlag;
-        CHECK( pcRefPic == m_pcPic || nonReferencePictureFlag, "The picture referred to by each entry in RefPicList[ 0 ] or RefPicList[ 1 ] shall not be the current picture and shall have ph_non_ref_pic_flag equal to 0" );
+        CHECK_VTM( pcRefPic == m_pcPic || nonReferencePictureFlag, "The picture referred to by each entry in RefPicList[ 0 ] or RefPicList[ 1 ] shall not be the current picture and shall have ph_non_ref_pic_flag equal to 0" );
 
         if( i < numActiveEntries[refPicList] )
         {
           if( irapPOC < getPOC() )
           {
-            CHECK( refPicPOC < irapPOC || refPicDecodingOrderNumber < associatedIRAPDecodingOrderNumber, "When the current picture follows an IRAP picture having the same value "
+            CHECK_VTM( refPicPOC < irapPOC || refPicDecodingOrderNumber < associatedIRAPDecodingOrderNumber, "When the current picture follows an IRAP picture having the same value "
               "of nuh_layer_id in both decoding order and output order, there shall be no picture referred to by an active entry in RefPicList[ 0 ] or RefPicList[ 1 ] that "
               "precedes that IRAP picture in output order or decoding order." );
           }
@@ -684,10 +684,10 @@
           // RefPicList[ 1 ] that is any of the following: A picture that precedes the associated IRAP picture in decoding order"
           if( m_eNalUnitType == NAL_UNIT_CODED_SLICE_RADL )
           {
-            CHECK( refPicDecodingOrderNumber < associatedIRAPDecodingOrderNumber, "RADL picture detected that violate the rule that no active entry in RefPicList[] shall precede the associated IRAP picture in decoding order" );
+            CHECK_VTM( refPicDecodingOrderNumber < associatedIRAPDecodingOrderNumber, "RADL picture detected that violate the rule that no active entry in RefPicList[] shall precede the associated IRAP picture in decoding order" );
           }
 
-          CHECK( pcRefPic->temporalId > m_pcPic->temporalId, "The picture referred to by each active entry in RefPicList[ 0 ] or RefPicList[ 1 ] shall be present in the DPB and shall have TemporalId less than or equal to that of the current picture." );
+          CHECK_VTM( pcRefPic->temporalId > m_pcPic->temporalId, "The picture referred to by each active entry in RefPicList[ 0 ] or RefPicList[ 1 ] shall be present in the DPB and shall have TemporalId less than or equal to that of the current picture." );
         }
       }
     }
@@ -706,12 +706,12 @@
 
     if( m_eNalUnitType == NAL_UNIT_CODED_SLICE_STSA && pcRefPic->layerId == m_pcPic->layerId )
     {
-      CHECK( pcRefPic->temporalId == m_uiTLayer, "When the current picture is an STSA picture and nuh_layer_id equal to that of the current picture, there shall be no active entry in the RPL that has TemporalId equal to that of the current picture" );
+      CHECK_VTM( pcRefPic->temporalId == m_uiTLayer, "When the current picture is an STSA picture and nuh_layer_id equal to that of the current picture, there shall be no active entry in the RPL that has TemporalId equal to that of the current picture" );
     }
 
     // Checking this: "When the current picture is a picture that follows, in decoding order, an STSA picture that has TemporalId equal to that of the current picture, there shall be no
     // picture that has TemporalId equal to that of the current picture included as an active entry in RefPicList[ 0 ] or RefPicList[ 1 ] that precedes the STSA picture in decoding order."
-    CHECK(pcRefPic->subLayerNonReferencePictureDueToSTSA, "The RPL of the current picture contains a picture that is not allowed in this temporal layer due to an earlier STSA picture");
+    CHECK_VTM(pcRefPic->subLayerNonReferencePictureDueToSTSA, "The RPL of the current picture contains a picture that is not allowed in this temporal layer due to an earlier STSA picture");
   }
 
   numOfActiveRef = getNumRefIdx(REF_PIC_LIST_1);
@@ -721,12 +721,12 @@
 
     if( m_eNalUnitType == NAL_UNIT_CODED_SLICE_STSA && pcRefPic->layerId == m_pcPic->layerId )
     {
-      CHECK( pcRefPic->temporalId == m_uiTLayer, "When the current picture is an STSA picture and nuh_layer_id equal to that of the current picture, there shall be no active entry in the RPL that has TemporalId equal to that of the current picture" );
+      CHECK_VTM( pcRefPic->temporalId == m_uiTLayer, "When the current picture is an STSA picture and nuh_layer_id equal to that of the current picture, there shall be no active entry in the RPL that has TemporalId equal to that of the current picture" );
     }
 
     // Checking this: "When the current picture is a picture that follows, in decoding order, an STSA picture that has TemporalId equal to that of the current picture, there shall be no
     // picture that has TemporalId equal to that of the current picture included as an active entry in RefPicList[ 0 ] or RefPicList[ 1 ] that precedes the STSA picture in decoding order."
-    CHECK(pcRefPic->subLayerNonReferencePictureDueToSTSA, "The active RPL part of the current picture contains a picture that is not allowed in this temporal layer due to an earlier STSA picture");
+    CHECK_VTM(pcRefPic->subLayerNonReferencePictureDueToSTSA, "The active RPL part of the current picture contains a picture that is not allowed in this temporal layer due to an earlier STSA picture");
   }
 
   // If the current picture is an STSA picture, make all reference pictures in the DPB with temporal
@@ -844,7 +844,7 @@
 
 void Slice::copySliceInfo(Slice *pSrc, bool cpyAlmostAll)
 {
-  CHECK(!pSrc, "Source is NULL");
+  CHECK_VTM(!pSrc, "Source is NULL");
 
   int i, j, k;
 
@@ -1031,7 +1031,7 @@
       if (nalUnitType < NAL_UNIT_CODED_SLICE_IDR_W_RADL ||
           nalUnitType > NAL_UNIT_CODED_SLICE_CRA)
       {
-        CHECK(nalUnitType != NAL_UNIT_CODED_SLICE_RASL &&
+        CHECK_VTM(nalUnitType != NAL_UNIT_CODED_SLICE_RASL &&
               nalUnitType != NAL_UNIT_CODED_SLICE_RADL, "Invalid NAL unit type");
       }
     }
@@ -1041,7 +1041,7 @@
   {
     if (pps.getMixedNaluTypesInPicFlag() == 0)
     {
-      CHECK(nalUnitType == NAL_UNIT_CODED_SLICE_RASL || nalUnitType == NAL_UNIT_CODED_SLICE_RADL, "When a picture is not a leading picture, it shall not be a RADL or RASL picture.");
+      CHECK_VTM(nalUnitType == NAL_UNIT_CODED_SLICE_RASL || nalUnitType == NAL_UNIT_CODED_SLICE_RADL, "When a picture is not a leading picture, it shall not be a RADL or RASL picture.");
     }
   }
 
@@ -1049,7 +1049,7 @@
   // an IDR picture.
   if (nalUnitType == NAL_UNIT_CODED_SLICE_RASL && !pps.getMixedNaluTypesInPicFlag())
   {
-    CHECK( this->getAssociatedIRAPType() == NAL_UNIT_CODED_SLICE_IDR_N_LP   ||
+    CHECK_VTM( this->getAssociatedIRAPType() == NAL_UNIT_CODED_SLICE_IDR_N_LP   ||
            this->getAssociatedIRAPType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL, "Invalid NAL unit type");
   }
 
@@ -1058,7 +1058,7 @@
   // with an IDR picture having nal_unit_type equal to IDR_N_LP.
   if (nalUnitType == NAL_UNIT_CODED_SLICE_RADL && !pps.getMixedNaluTypesInPicFlag())
   {
-    CHECK (this->getAssociatedIRAPType() == NAL_UNIT_CODED_SLICE_IDR_N_LP, "Invalid NAL unit type");
+    CHECK_VTM(this->getAssociatedIRAPType() == NAL_UNIT_CODED_SLICE_IDR_N_LP, "Invalid NAL unit type");
   }
 
   // loop through all pictures in the reference picture buffer
@@ -1081,7 +1081,7 @@
     {
       if ((nalUnitType == NAL_UNIT_CODED_SLICE_CRA || nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP || nalUnitType == NAL_UNIT_CODED_SLICE_IDR_W_RADL) && !pps.getMixedNaluTypesInPicFlag())
       {
-        CHECK(pcPic->poc >= this->getPOC(), "Any picture, with nuh_layer_id equal to a particular value layerId, that precedes an IRAP picture with nuh_layer_id "
+        CHECK_VTM(pcPic->poc >= this->getPOC(), "Any picture, with nuh_layer_id equal to a particular value layerId, that precedes an IRAP picture with nuh_layer_id "
               "equal to layerId in decoding order shall precede the IRAP picture in output order.");
       }
     }
@@ -1094,7 +1094,7 @@
         {
           if (this->getAssociatedIRAPPOC() != pcPic->poc)
           {
-            CHECK(pcPic->poc >= this->getPOC(), "Any picture, with nuh_layer_id equal to a particular value layerId, that precedes an IRAP picture with nuh_layer_id "
+            CHECK_VTM(pcPic->poc >= this->getPOC(), "Any picture, with nuh_layer_id equal to a particular value layerId, that precedes an IRAP picture with nuh_layer_id "
                   "equal to layerId in decoding order shall precede any RADL picture associated with the IRAP picture in output order.");
           }
         }
@@ -1106,7 +1106,7 @@
     {
       if (this->getPOC() == this->getPicHeader()->getRecoveryPocCnt() + this->getPrevGDRInSameLayerPOC())
       {
-        CHECK(pcPic->poc >= this->getPOC(), "Any picture, with nuh_layer_id equal to a particular value layerId, that precedes a recovery point picture with "
+        CHECK_VTM(pcPic->poc >= this->getPOC(), "Any picture, with nuh_layer_id equal to a particular value layerId, that precedes a recovery point picture with "
               "nuh_layer_id equal to layerId in decoding order shall precede the recovery point picture in output order.");
       }
     }
@@ -1122,7 +1122,7 @@
         {
           limitNonLP = 1;
         }
-        CHECK(pcPic->poc > this->getAssociatedIRAPPOC() && numNonLPFound > limitNonLP, "If sps_field_seq_flag is equal to 0 and the current picture, with nuh_layer_id "
+        CHECK_VTM(pcPic->poc > this->getAssociatedIRAPPOC() && numNonLPFound > limitNonLP, "If sps_field_seq_flag is equal to 0 and the current picture, with nuh_layer_id "
               "equal to a particular value layerId, is a leading picture associated with an IRAP picture, it shall precede, in decoding order, all non-leading "
               "pictures that are associated with the same IRAP picture.Otherwise, let picA and picB be the first and the last leading pictures, in decoding order, "
               "associated with an IRAP picture, respectively, there shall be at most one non-leading picture with nuh_layer_id equal to layerId preceding picA in "
@@ -1137,7 +1137,7 @@
       {
         if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL)
         {
-          CHECK(pcPic->poc <= this->getPOC(), "Any RASL picture associated with a CRA picture shall precede any RADL picture associated with the CRA picture in output order.");
+          CHECK_VTM(pcPic->poc <= this->getPOC(), "Any RASL picture associated with a CRA picture shall precede any RADL picture associated with the CRA picture in output order.");
         }
       }
     }
@@ -1154,7 +1154,7 @@
             pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR) &&
             pcPic->layerId == this->m_nuhLayerId)
         {
-          CHECK(this->getPOC() <= pcSlice->getPOC(), "Any RASL picture, with nuh_layer_id equal to a particular value layerId, associated with a CRA picture shall follow, "
+          CHECK_VTM(this->getPOC() <= pcSlice->getPOC(), "Any RASL picture, with nuh_layer_id equal to a particular value layerId, associated with a CRA picture shall follow, "
                "in output order, any IRAP or GDR picture with nuh_layer_id equal to layerId that precedes the CRA picture in decoding order.");
         }
       }
@@ -1168,7 +1168,7 @@
 
   if (getPPS()->getMixedNaluTypesInPicFlag() && getSliceType() != I_SLICE)
   {
-    CHECK(!getSPS()->getSubPicTreatedAsPicFlag(curSubpicIdx), "When pps_mixed_nalu_types_in_pic_flag is equal 1, the value of sps_subpic_treated_as_pic_flag shall be equal to 1 "
+    CHECK_VTM(!getSPS()->getSubPicTreatedAsPicFlag(curSubpicIdx), "When pps_mixed_nalu_types_in_pic_flag is equal 1, the value of sps_subpic_treated_as_pic_flag shall be equal to 1 "
           "for all the subpictures that are in the picture and contain at least one P or B slice");
   }
 
@@ -1183,20 +1183,20 @@
 
     if (prevIRAPSubpicPOC > getPOC() && (nalUnitType < NAL_UNIT_CODED_SLICE_IDR_W_RADL || nalUnitType > NAL_UNIT_CODED_SLICE_CRA))
     {
-      CHECK(nalUnitType != NAL_UNIT_CODED_SLICE_RASL && nalUnitType != NAL_UNIT_CODED_SLICE_RADL,
+      CHECK_VTM(nalUnitType != NAL_UNIT_CODED_SLICE_RASL && nalUnitType != NAL_UNIT_CODED_SLICE_RADL,
         "When a subpicture is a leading subpicture of an IRAP subpicture, it shall be a RADL or RASL subpicture");
     }
 
     if (prevIRAPSubpicPOC <= getPOC())
     {
-      CHECK(nalUnitType == NAL_UNIT_CODED_SLICE_RASL || nalUnitType == NAL_UNIT_CODED_SLICE_RADL,
+      CHECK_VTM(nalUnitType == NAL_UNIT_CODED_SLICE_RASL || nalUnitType == NAL_UNIT_CODED_SLICE_RADL,
         "When a subpicture is not a leading subpicture of an IRAP subpicture, it shall not be a RADL or RASL subpicture");
     }
 
-    CHECK(nalUnitType == NAL_UNIT_CODED_SLICE_RASL && (prevIRAPSubpicType == NAL_UNIT_CODED_SLICE_IDR_N_LP || prevIRAPSubpicType == NAL_UNIT_CODED_SLICE_IDR_W_RADL),
+    CHECK_VTM(nalUnitType == NAL_UNIT_CODED_SLICE_RASL && (prevIRAPSubpicType == NAL_UNIT_CODED_SLICE_IDR_N_LP || prevIRAPSubpicType == NAL_UNIT_CODED_SLICE_IDR_W_RADL),
       "No RASL subpictures shall be present in the bitstream that are associated with an IDR subpicture");
 
-    CHECK(nalUnitType == NAL_UNIT_CODED_SLICE_RADL && prevIRAPSubpicType == NAL_UNIT_CODED_SLICE_IDR_N_LP,
+    CHECK_VTM(nalUnitType == NAL_UNIT_CODED_SLICE_RADL && prevIRAPSubpicType == NAL_UNIT_CODED_SLICE_IDR_N_LP,
       "No RADL subpictures shall be present in the bitstream that are associated with an IDR subpicture having nal_unit_type equal to IDR_N_LP");
 
     //constraints related to current subpicture type and its preceding subpicture types
@@ -1232,7 +1232,7 @@
       if ((nalUnitType == NAL_UNIT_CODED_SLICE_CRA || nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP || nalUnitType == NAL_UNIT_CODED_SLICE_IDR_W_RADL) &&
         !this->getNoOutputOfPriorPicsFlag() && isBufPicOutput == 1 && bufPic->layerId == m_nuhLayerId)
       {
-        CHECK(bufPic->poc >= getPOC(), "Any subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal to a particular value subpicIdx, that "
+        CHECK_VTM(bufPic->poc >= getPOC(), "Any subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal to a particular value subpicIdx, that "
           "precedes, in decoding order, an IRAP subpicture with nuh_layer_id equal to layerId and subpicture index equal to subpicIdx shall precede, in output order, the "
           "IRAP subpicture");
       }
@@ -1240,7 +1240,7 @@
       if (nalUnitType == NAL_UNIT_CODED_SLICE_RADL && isBufPicOutput == 1 && bufPic->layerId == m_nuhLayerId &&
         prevIRAPSubpicPOC > bufSubpicPrevIRAPSubpicPOC && prevIRAPSubpicPOC != bufPic->poc)
       {
-        CHECK(bufPic->poc >= getPOC(), "Any subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal to a particular value subpicIdx, that "
+        CHECK_VTM(bufPic->poc >= getPOC(), "Any subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal to a particular value subpicIdx, that "
           "precedes, in decoding order, an IRAP subpicture with nuh_layer_id equal to layerId and subpicture index equal to subpicIdx shall precede, in output order, all "
           "its associated RADL subpictures");
       }
@@ -1248,7 +1248,7 @@
       if ((getPOC() == getPicHeader()->getRecoveryPocCnt() + prevGDRSubpicPOC) && !this->getNoOutputOfPriorPicsFlag() && isBufPicOutput == 1 &&
         bufPic->layerId == m_nuhLayerId && nalUnitType != NAL_UNIT_CODED_SLICE_GDR && getPicHeader()->getRecoveryPocCnt() != -1)
       {
-        CHECK(bufPic->poc >= getPOC(), "Any subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal to a particular value subpicIdx, that "
+        CHECK_VTM(bufPic->poc >= getPOC(), "Any subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal to a particular value subpicIdx, that "
           "precedes, in decoding order, a subpicture with nuh_layer_id equal to layerId and subpicture index equal to subpicIdx in a recovery point picture shall precede "
           "that subpicture in the recovery point picture in output order");
       }
@@ -1256,7 +1256,7 @@
       if (nalUnitType == NAL_UNIT_CODED_SLICE_RASL && prevIRAPSubpicType == NAL_UNIT_CODED_SLICE_CRA && bufSubpicType == NAL_UNIT_CODED_SLICE_RADL &&
         prevIRAPSubpicPOC == bufSubpicPrevIRAPSubpicPOC)
       {
-        CHECK(bufPic->poc <= getPOC(), "Any RASL subpicture associated with a CRA subpicture shall precede any RADL subpicture associated with the CRA subpicture in output order");
+        CHECK_VTM(bufPic->poc <= getPOC(), "Any RASL subpicture associated with a CRA subpicture shall precede any RADL subpicture associated with the CRA subpicture in output order");
       }
 
       if (nalUnitType == NAL_UNIT_CODED_SLICE_RASL && prevIRAPSubpicType == NAL_UNIT_CODED_SLICE_CRA && bufPic->layerId == m_nuhLayerId && bufPic->poc < prevIRAPSubpicPOC)
@@ -1264,7 +1264,7 @@
         if (bufSubpicType == NAL_UNIT_CODED_SLICE_IDR_N_LP || bufSubpicType == NAL_UNIT_CODED_SLICE_IDR_W_RADL ||
           bufSubpicType == NAL_UNIT_CODED_SLICE_CRA || bufSubpicType == NAL_UNIT_CODED_SLICE_GDR)
         {
-          CHECK(bufPic->poc >= getPOC(), "Any RASL subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal to a particular value subpicIdx, "
+          CHECK_VTM(bufPic->poc >= getPOC(), "Any RASL subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal to a particular value subpicIdx, "
             "associated with a CRA subpicture shall follow, in output order, any IRAP or GDR subpicture , with nuh_layer_id equal to layerId and subpicture index equal to "
             "subpicIdx, that precedes the CRA subpicture in decoding order");
         }
@@ -1276,7 +1276,7 @@
       {
         numNonLeadingPic++;
         int th = bufPic->cs->sps->getFieldSeqFlag() ? 1 : 0;
-        CHECK(bufPic->poc > prevIRAPSubpicPOC && numNonLeadingPic > th, "If sps_field_seq_flag is equal to 0 and the current subpicture, with nuh_layer_id equal to a particular value "
+        CHECK_VTM(bufPic->poc > prevIRAPSubpicPOC && numNonLeadingPic > th, "If sps_field_seq_flag is equal to 0 and the current subpicture, with nuh_layer_id equal to a particular value "
           "layerId and subpicture index equal to a particular value subpicIdx, is a leading subpicture associated with an IRAP subpicture, it shall precede, in decoding order, "
           "all non-leading subpictures that are associated with the same IRAP subpicture. Otherwise, let subpicA and subpicB be the first and the last leading subpictures, in "
           "decoding order, associated with an IRAP subpicture, respectively, there shall be at most one non-leading subpicture with nuh_layer_id equal to layerId and subpicture "
@@ -1330,7 +1330,7 @@
 
       if (nalUnitType == NAL_UNIT_CODED_SLICE_CRA || nalUnitType == NAL_UNIT_CODED_SLICE_IDR_W_RADL || nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP)
       {
-        CHECK(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture, with nuh_layer_id equal to a particular value "
+        CHECK_VTM(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture, with nuh_layer_id equal to a particular value "
               "layerId and subpicture index equal to a particular value subpicIdx, is an IRAP subpicture, there shall be no picture referred to by an entry in RefPicList[0] that "
               "precedes, in output order or decoding order,any preceding picture, in decoding order (when present), containing an IRAP subpicture with nuh_layer_id equal to "
               "layerId and subpicture index equal to subpicIdx");
@@ -1338,7 +1338,7 @@
 
       if (prevIRAPSubpicPOC < getPOC() && !getSPS()->getFieldSeqFlag())
       {
-        CHECK(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture follows an IRAP subpicture having the same value "
+        CHECK_VTM(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture follows an IRAP subpicture having the same value "
               "of nuh_layer_id and the same value of subpicture index in both decoding and output order, there shall be no picture referred to by an active entry in RefPicList[ 0 ] "
               "that precedes the picture containing that IRAP subpicture in output order or decoding order");
       }
@@ -1347,14 +1347,14 @@
       {
         if (prevIRAPSubpicPOC < getPOC())
         {
-          CHECK(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture follows an IRAP subpicture having the same value "
+          CHECK_VTM(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture follows an IRAP subpicture having the same value "
                 "of nuh_layer_id and the same value of subpicture index and the leading subpictures, if any, associated with that IRAP subpicture in both decoding and output order, "
                 "there shall be no picture referred to by an entry in RefPicList[ 0 ] that precedes the picture containing that IRAP subpicture in output order or decoding order");
         }
 
         if (nalUnitType == NAL_UNIT_CODED_SLICE_RADL)
         {
-          CHECK(refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal "
+          CHECK_VTM(refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal "
                 "to a particular value subpicIdx, is a RADL subpicture, there shall be no active entry in RefPicList[ 0 ] that is a picture that precedes the picture containing the"
                 "associated IRAP subpicture in decoding order");
 
@@ -1364,7 +1364,7 @@
             {
               if (pcRefPic->sliceSubpicIdx[i] == curSubpicIdx)
               {
-                CHECK(pcRefPic->slices[i]->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL, "When the current subpicture, with nuh_layer_id equal to a particular value layerId and "
+                CHECK_VTM(pcRefPic->slices[i]->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL, "When the current subpicture, with nuh_layer_id equal to a particular value layerId and "
                       "subpicture index equal to a particular value subpicIdx, is a RADL subpicture, there shall be no active entry in RefPicList[ 0 ] that is a picture with "
                       "nuh_layer_id equal to layerId containing a RASL subpicture with subpicture index equal to subpicIdx");
               }
@@ -1406,7 +1406,7 @@
 
       if (nalUnitType == NAL_UNIT_CODED_SLICE_CRA || nalUnitType == NAL_UNIT_CODED_SLICE_IDR_W_RADL || nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP)
       {
-        CHECK(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture, with nuh_layer_id equal to a particular value"
+        CHECK_VTM(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture, with nuh_layer_id equal to a particular value"
               "layerId and subpicture index equal to a particular value subpicIdx, is an IRAP subpicture, there shall be no picture referred to by an entry in RefPicList[1] that"
               "precedes, in output order or decoding order,any preceding picture, in decoding order (when present), containing an IRAP subpicture with nuh_layer_id equal to "
               "layerId and subpicture index equal to subpicIdx");
@@ -1414,7 +1414,7 @@
 
       if (prevIRAPSubpicPOC < getPOC() && !getSPS()->getFieldSeqFlag())
       {
-        CHECK(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture follows an IRAP subpicture having the same value "
+        CHECK_VTM(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture follows an IRAP subpicture having the same value "
               "of nuh_layer_id and the same value of subpicture index in both decoding and output order, there shall be no picture referred to by an active entry in RefPicList[ 1 ] "
               "that precedes the picture containing that IRAP subpicture in output order or decoding order");
       }
@@ -1422,14 +1422,14 @@
       {
         if (prevIRAPSubpicPOC < getPOC())
         {
-          CHECK(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture follows an IRAP subpicture having the same value "
+          CHECK_VTM(refPicPOC < prevIRAPSubpicPOC || refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture follows an IRAP subpicture having the same value "
                 "of nuh_layer_id and the same value of subpicture index and the leading subpictures, if any, associated with that IRAP subpicture in both decoding and output order, "
                 "there shall be no picture referred to by an entry in RefPicList[ 1 ] that precedes the picture containing that IRAP subpicture in output order or decoding order");
         }
 
         if (nalUnitType == NAL_UNIT_CODED_SLICE_RADL)
         {
-          CHECK(refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal "
+          CHECK_VTM(refPicDecodingOrderNumber < prevIRAPSubpicDecOrderNo, "When the current subpicture, with nuh_layer_id equal to a particular value layerId and subpicture index equal "
                 "to a particular value subpicIdx, is a RADL subpicture, there shall be no active entry in RefPicList[ 1 ] that is a picture that precedes the picture containing the"
                 "associated IRAP subpicture in decoding order");
 
@@ -1439,7 +1439,7 @@
             {
               if (pcRefPic->sliceSubpicIdx[i] == curSubpicIdx)
               {
-                CHECK(pcRefPic->slices[i]->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL, "When the current subpicture, with nuh_layer_id equal to a particular value layerId and "
+                CHECK_VTM(pcRefPic->slices[i]->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL, "When the current subpicture, with nuh_layer_id equal to a particular value layerId and "
                       "subpicture index equal to a particular value subpicIdx, is a RADL subpicture, there shall be no active entry in RefPicList[ 1 ] that is a picture with "
                       "nuh_layer_id equal to layerId containing a RASL subpicture with subpicture index equal to subpicIdx");
               }
@@ -1609,7 +1609,7 @@
       if( pRPL0->isInterLayerRefPic( i ) )
       {
         // Diagonal inter-layer prediction is not allowed
-        CHECK( pRPL0->getRefPicIdentifier( i ), "ILRP identifier should be 0" );
+        CHECK_VTM( pRPL0->getRefPicIdentifier( i ), "ILRP identifier should be 0" );
 
         if( pcPic->poc == m_iPOC )
         {
@@ -1654,7 +1654,7 @@
       if( pRPL1->isInterLayerRefPic( i ) )
       {
         // Diagonal inter-layer prediction is not allowed
-        CHECK( pRPL1->getRefPicIdentifier( i ), "ILRP identifier should be 0" );
+        CHECK_VTM( pRPL1->getRefPicIdentifier( i ), "ILRP identifier should be 0" );
 
         if( pcPic->poc == m_iPOC )
         {
@@ -1705,7 +1705,7 @@
     if (pcPic->referenced)
     {
       //check that pictures of higher temporal layers are not used
-      CHECK(pcPic->usedByCurr && !(pcPic->temporalId <= this->getTLayer()), "Invalid state");
+      CHECK_VTM(pcPic->usedByCurr && !(pcPic->temporalId <= this->getTLayer()), "Invalid state");
     }
   }
 }
@@ -1938,7 +1938,7 @@
     if( rpl->isInterLayerRefPic( i ) )
     {
       // Diagonal inter-layer prediction is not allowed
-      CHECK( rpl->getRefPicIdentifier( i ), "ILRP identifier should be 0" );
+      CHECK_VTM( rpl->getRefPicIdentifier( i ), "ILRP identifier should be 0" );
 
       if( poc == m_iPOC )
       {
@@ -2055,7 +2055,7 @@
 //! get tables for weighted prediction
 const WPScalingParam *Slice::getWpScaling(const RefPicList refPicList, const int refIdx) const
 {
-  CHECK(refPicList >= NUM_REF_PIC_LIST_01, "Invalid picture reference list");
+  CHECK_VTM(refPicList >= NUM_REF_PIC_LIST_01, "Invalid picture reference list");
   if (refIdx < 0)
   {
     return nullptr;
@@ -2068,7 +2068,7 @@
 
 WPScalingParam *Slice::getWpScaling(const RefPicList refPicList, const int refIdx)
 {
-  CHECK(refPicList >= NUM_REF_PIC_LIST_01, "Invalid picture reference list");
+  CHECK_VTM(refPicList >= NUM_REF_PIC_LIST_01, "Invalid picture reference list");
   if (refIdx < 0)
   {
     return nullptr;
@@ -2365,7 +2365,7 @@
   }
   for (int i = 0; i < m_maxLayers; i++)
   {
-    CHECK(layerUsedAsRefLayerFlag[i] == 0 && layerUsedAsOutputLayerFlag[i] == 0, "There shall be no layer that is neither an output layer nor a direct reference layer");
+    CHECK_VTM(layerUsedAsRefLayerFlag[i] == 0 && layerUsedAsOutputLayerFlag[i] == 0, "There shall be no layer that is neither an output layer nor a direct reference layer");
   }
 
   m_numLayersInOls[0] = 1;
@@ -2423,11 +2423,11 @@
     const int olsIdx = m_multiLayerOlsIdxToOlsIdx[multiLayerOlsIdx];
     const int olsTimingHrdIdx = getOlsTimingHrdIdx(multiLayerOlsIdx);
     const int olsPtlIdx = getOlsPtlIdx(olsIdx);
-    CHECK (getHrdMaxTid(olsTimingHrdIdx) < getPtlMaxTemporalId(olsPtlIdx), "The value of vps_hrd_max_tid[vps_ols_timing_hrd_idx[m]] shall be greater than or equal to "
+    CHECK_VTM(getHrdMaxTid(olsTimingHrdIdx) < getPtlMaxTemporalId(olsPtlIdx), "The value of vps_hrd_max_tid[vps_ols_timing_hrd_idx[m]] shall be greater than or equal to "
                                                                      "vps_ptl_max_tid[ vps_ols_ptl_idx[n]] for each m-th multi-layer OLS for m from 0 to "
                                                                      "NumMultiLayerOlss - 1, inclusive, and n being the OLS index of the m-th multi-layer OLS among all OLSs.");
     const int olsDpbParamsIdx = getOlsDpbParamsIdx(multiLayerOlsIdx);
-    CHECK (m_dpbMaxTemporalId[olsDpbParamsIdx] < getPtlMaxTemporalId(olsPtlIdx), "The value of vps_dpb_max_tid[vps_ols_dpb_params_idx[m]] shall be greater than or equal to "
+    CHECK_VTM(m_dpbMaxTemporalId[olsDpbParamsIdx] < getPtlMaxTemporalId(olsPtlIdx), "The value of vps_dpb_max_tid[vps_ols_dpb_params_idx[m]] shall be greater than or equal to "
                                                                      "vps_ptl_max_tid[ vps_ols_ptl_idx[n]] for each m-th multi-layer OLS for m from 0 to "
                                                                      "NumMultiLayerOlss - 1, inclusive, and n being the OLS index of the m-th multi-layer OLS among all OLSs.");
   }
@@ -2619,7 +2619,7 @@
 
 const WPScalingParam *PicHeader::getWpScaling(const RefPicList refPicList, const int refIdx) const
 {
-  CHECK(refPicList >= NUM_REF_PIC_LIST_01, "Invalid picture reference list");
+  CHECK_VTM(refPicList >= NUM_REF_PIC_LIST_01, "Invalid picture reference list");
   if (refIdx < 0)
   {
     return nullptr;
@@ -2632,7 +2632,7 @@
 
 WPScalingParam *PicHeader::getWpScaling(const RefPicList refPicList, const int refIdx)
 {
-  CHECK(refPicList >= NUM_REF_PIC_LIST_01, "Invalid picture reference list");
+  CHECK_VTM(refPicList >= NUM_REF_PIC_LIST_01, "Invalid picture reference list");
   if (refIdx < 0)
   {
     return nullptr;
@@ -2861,8 +2861,8 @@
 
     for (int j = 0; j <= getNumPtsInCQPTableMinus1(i); j++)
     {
-      CHECK(qpInVal[j]  < -qpBdOffsetC || qpInVal[j]  > MAX_QP, "qpInVal out of range");
-      CHECK(qpOutVal[j] < -qpBdOffsetC || qpOutVal[j] > MAX_QP, "qpOutVal out of range");
+      CHECK_VTM(qpInVal[j]  < -qpBdOffsetC || qpInVal[j]  > MAX_QP, "qpInVal out of range");
+      CHECK_VTM(qpOutVal[j] < -qpBdOffsetC || qpOutVal[j] > MAX_QP, "qpOutVal out of range");
     }
 
     m_chromaQpMappingTables[i][qpInVal[0]] = qpOutVal[0];
@@ -3052,7 +3052,7 @@
 
   for( colIdx = 0; colIdx < m_numExpTileCols; colIdx++ )
   {
-    CHECK(m_tileColWidth[colIdx] > remainingWidthInCtu,    "Tile column width exceeds picture width");
+    CHECK_VTM(m_tileColWidth[colIdx] > remainingWidthInCtu,    "Tile column width exceeds picture width");
     remainingWidthInCtu -= m_tileColWidth[colIdx];
   }
 
@@ -3060,7 +3060,7 @@
   uint32_t  uniformTileColWidth = m_tileColWidth[colIdx-1];
   while( remainingWidthInCtu > 0 )
   {
-    CHECK(colIdx >= MAX_TILE_COLS, "Number of tile columns exceeds valid range");
+    CHECK_VTM(colIdx >= MAX_TILE_COLS, "Number of tile columns exceeds valid range");
     uniformTileColWidth = std::min(remainingWidthInCtu, uniformTileColWidth);
     m_tileColWidth.push_back( uniformTileColWidth );
     remainingWidthInCtu -= uniformTileColWidth;
@@ -3073,7 +3073,7 @@
 
   for( rowIdx = 0; rowIdx < m_numExpTileRows; rowIdx++ )
   {
-    CHECK(m_tileRowHeight[rowIdx] > remainingHeightInCtu,     "Tile row height exceeds picture height");
+    CHECK_VTM(m_tileRowHeight[rowIdx] > remainingHeightInCtu,     "Tile row height exceeds picture height");
     remainingHeightInCtu -= m_tileRowHeight[rowIdx];
   }
 
@@ -3130,7 +3130,7 @@
  */
 void PPS::initRectSlices()
 {
-  CHECK(m_numSlicesInPic > MAX_SLICES, "Number of slices in picture exceeds valid range");
+  CHECK_VTM(m_numSlicesInPic > MAX_SLICES, "Number of slices in picture exceeds valid range");
   m_rectSlices.resize(m_numSlicesInPic);
 }
 
@@ -3169,11 +3169,11 @@
 
   if( getSingleSlicePerSubPicFlag() )
   {
-    CHECK (sps==nullptr, "RectSliceMap can only be initialized for slice_per_sub_pic_flag with a valid SPS");
+    CHECK_VTM(sps==nullptr, "RectSliceMap can only be initialized for slice_per_sub_pic_flag with a valid SPS");
     m_numSlicesInPic = sps->getNumSubPics();
 
     // allocate new memory for slice list
-    CHECK(m_numSlicesInPic > MAX_SLICES, "Number of slices in picture exceeds valid range");
+    CHECK_VTM(m_numSlicesInPic > MAX_SLICES, "Number of slices in picture exceeds valid range");
     m_sliceMap.resize( m_numSlicesInPic );
 
     if (sps->getNumSubPics() > 1)
@@ -3207,7 +3207,7 @@
 
       for( int i = 0; i < m_numSlicesInPic; i++ )
       {
-        CHECK(m_numSlicesInPic != sps->getNumSubPics(), "in single slice per subpic mode, number of slice and subpic shall be equal");
+        CHECK_VTM(m_numSlicesInPic != sps->getNumSubPics(), "in single slice per subpic mode, number of slice and subpic shall be equal");
         m_sliceMap[ i ].initSliceMap();
         if (subpicHeightLessThanOneTileFlag[i])
         {
@@ -3248,7 +3248,7 @@
   else
   {
     // allocate new memory for slice list
-    CHECK(m_numSlicesInPic > MAX_SLICES, "Number of slices in picture exceeds valid range");
+    CHECK_VTM(m_numSlicesInPic > MAX_SLICES, "Number of slices in picture exceeds valid range");
     m_sliceMap.resize( m_numSlicesInPic );
     // generate CTU maps for all rectangular slices in picture
     for( uint32_t i = 0; i < m_numSlicesInPic; i++ )
@@ -3299,7 +3299,7 @@
         }
 
         // infer slice height for last slice in tile
-        CHECK( ctuY >= getTileRowBd( tileY + 1 ), "Invalid rectangular slice signalling");
+        CHECK_VTM( ctuY >= getTileRowBd( tileY + 1 ), "Invalid rectangular slice signalling");
         m_rectSlices[ i ].setSliceHeightInCtu( getTileRowBd( tileY + 1 ) - ctuY );
         m_sliceMap[ i ].addCtusToSlice( getTileColumnBd(tileX), getTileColumnBd(tileX+1),
                                         ctuY, getTileRowBd( tileY + 1 ), m_picWidthInCtu);
@@ -3318,7 +3318,7 @@
   if (getSubPicIdMappingInPpsFlag())
   {
     // When signalled, the number of subpictures has to match in PPS and SPS
-    CHECK (getNumSubPics() != sps.getNumSubPics(), "pps_num_subpics_minus1 shall be equal to sps_num_subpics_minus1");
+    CHECK_VTM(getNumSubPics() != sps.getNumSubPics(), "pps_num_subpics_minus1 shall be equal to sps_num_subpics_minus1");
   }
   else
   {
@@ -3326,21 +3326,21 @@
     setNumSubPics(sps.getNumSubPics());
   }
 
-  CHECK(getNumSubPics() > MAX_NUM_SUB_PICS, "Number of sub-pictures in picture exceeds valid range");
+  CHECK_VTM(getNumSubPics() > MAX_NUM_SUB_PICS, "Number of sub-pictures in picture exceeds valid range");
   m_subPics.resize(getNumSubPics());
 
   // Check that no subpicture is specified outside of the conformance cropping window
   for(int i = 0; i < sps.getNumSubPics(); i++)
   {
-    CHECK( (sps.getSubPicCtuTopLeftX(i) * sps.getCTUSize()) >=
+    CHECK_VTM( (sps.getSubPicCtuTopLeftX(i) * sps.getCTUSize()) >=
           (sps.getMaxPicWidthInLumaSamples() - sps.getConformanceWindow().getWindowRightOffset() * SPS::getWinUnitX(sps.getChromaFormatIdc())),
           "No subpicture can be located completely outside of the conformance cropping window");
-    CHECK( ((sps.getSubPicCtuTopLeftX(i) + sps.getSubPicWidth(i)) * sps.getCTUSize()) <= (sps.getConformanceWindow().getWindowLeftOffset() * SPS::getWinUnitX(sps.getChromaFormatIdc())),
+    CHECK_VTM( ((sps.getSubPicCtuTopLeftX(i) + sps.getSubPicWidth(i)) * sps.getCTUSize()) <= (sps.getConformanceWindow().getWindowLeftOffset() * SPS::getWinUnitX(sps.getChromaFormatIdc())),
           "No subpicture can be located completely outside of the conformance cropping window" );
-    CHECK( (sps.getSubPicCtuTopLeftY(i) * sps.getCTUSize()) >=
+    CHECK_VTM( (sps.getSubPicCtuTopLeftY(i) * sps.getCTUSize()) >=
           (sps.getMaxPicHeightInLumaSamples()  - sps.getConformanceWindow().getWindowBottomOffset() * SPS::getWinUnitY(sps.getChromaFormatIdc())),
           "No subpicture can be located completely outside of the conformance cropping window");
-    CHECK( ((sps.getSubPicCtuTopLeftY(i) + sps.getSubPicHeight(i)) * sps.getCTUSize()) <= (sps.getConformanceWindow().getWindowTopOffset() * SPS::getWinUnitY(sps.getChromaFormatIdc())),
+    CHECK_VTM( ((sps.getSubPicCtuTopLeftY(i) + sps.getSubPicHeight(i)) * sps.getCTUSize()) <= (sps.getConformanceWindow().getWindowTopOffset() * SPS::getWinUnitY(sps.getChromaFormatIdc())),
           "No subpicture can be located completely outside of the conformance cropping window");
   }
 
@@ -3400,7 +3400,7 @@
 
     if (m_numSlicesInPic == 1)
     {
-      CHECK(getNumSubPics() != 1, "only one slice in picture, but number of subpic is not one");
+      CHECK_VTM(getNumSubPics() != 1, "only one slice in picture, but number of subpic is not one");
       m_subPics[i].addAllCtusInPicToSubPic(0, getPicWidthInCtu(), 0, getPicHeightInCtu(), getPicWidthInCtu());
       m_subPics[i].setNumSlicesInSubPic(1);
     }
@@ -3429,7 +3429,7 @@
           idxFirstSliceAfterSubpic = j;
         }
       }
-      CHECK( idxFirstSliceAfterSubpic < idxLastSliceInSubpic, "The signalling order of slices shall follow the coding order" );
+      CHECK_VTM( idxFirstSliceAfterSubpic < idxLastSliceInSubpic, "The signalling order of slices shall follow the coding order" );
       m_subPics[i].setNumSlicesInSubPic(numSlicesInSubPic);
     }
     m_subPics[i].setTreatedAsPicFlag(sps.getSubPicTreatedAsPicFlag(i));
@@ -3473,7 +3473,7 @@
   setNumSlicesInPic( (uint32_t) numTilesInSlice.size() );
 
   // allocate new memory for slice list
-  CHECK(m_numSlicesInPic > MAX_SLICES, "Number of slices in picture exceeds valid range");
+  CHECK_VTM(m_numSlicesInPic > MAX_SLICES, "Number of slices in picture exceeds valid range");
   m_sliceMap.resize( m_numSlicesInPic );
 
   for( uint32_t sliceIdx = 0; sliceIdx < numTilesInSlice.size(); sliceIdx++ )
@@ -3485,7 +3485,7 @@
     {
       uint32_t tileX = tileIdx % getNumTileColumns();
       uint32_t tileY = tileIdx / getNumTileColumns();
-      CHECK(tileY >= getNumTileRows(), "Number of tiles in slice exceeds the remaining number of tiles in picture");
+      CHECK_VTM(tileY >= getNumTileRows(), "Number of tiles in slice exceeds the remaining number of tiles in picture");
 
       m_sliceMap[sliceIdx].addCtusToSlice(getTileColumnBd(tileX), getTileColumnBd(tileX + 1),
                                           getTileRowBd(tileY), getTileRowBd(tileY + 1),
@@ -3511,13 +3511,13 @@
     sliceList = m_sliceMap[ i ].getCtuAddrList();
     ctuList.insert( ctuList.end(), sliceList.begin(), sliceList.end() );
   }
-  CHECK( ctuList.size() < picSizeInCtu, "Slice map contains too few CTUs");
-  CHECK( ctuList.size() > picSizeInCtu, "Slice map contains too many CTUs");
+  CHECK_VTM( ctuList.size() < picSizeInCtu, "Slice map contains too few CTUs");
+  CHECK_VTM( ctuList.size() > picSizeInCtu, "Slice map contains too many CTUs");
   std::sort( ctuList.begin(), ctuList.end() );
   for( i = 1; i < ctuList.size(); i++ )
   {
-    CHECK( ctuList[i] > ctuList[i-1]+1, "CTU missing in slice map");
-    CHECK( ctuList[i] == ctuList[i-1],  "CTU duplicated in slice map");
+    CHECK_VTM( ctuList[i] > ctuList[i-1]+1, "CTU missing in slice map");
+    CHECK_VTM( ctuList[i] == ctuList[i-1],  "CTU duplicated in slice map");
   }
 }
 
@@ -3693,7 +3693,7 @@
   int uiLength = 1;
   int uiTemp = ++uiCode;
 
-  CHECK(!uiTemp, "Integer overflow");
+  CHECK_VTM(!uiTemp, "Integer overflow");
 
   while (1 != uiTemp)
   {
@@ -3708,7 +3708,7 @@
   int uiLength = 1;
   int uiTemp = ++uiCode2;
 
-  CHECK(!uiTemp, "Integer overflow");
+  CHECK_VTM(!uiTemp, "Integer overflow");
 
   while (1 != uiTemp)
   {
@@ -4172,7 +4172,7 @@
       CU::getRprScaling( sps, pps, m_apcRefPicList[refList][rIdx], xScale, yScale );
       m_scalingRatio[refList][rIdx] = std::pair<int, int>( xScale, yScale );
 
-      CHECK( m_apcRefPicList[refList][rIdx]->unscaledPic == nullptr, "unscaledPic is not properly set" );
+      CHECK_VTM( m_apcRefPicList[refList][rIdx]->unscaledPic == nullptr, "unscaledPic is not properly set" );
 
       if( m_apcRefPicList[refList][rIdx]->isRefScaled( pps ) == false )
       {
@@ -4209,7 +4209,7 @@
             }
           }
 
-          CHECK( j >= MAX_NUM_REF, "scaledRefPic can not hold all reference pictures!" );
+          CHECK_VTM( j >= MAX_NUM_REF, "scaledRefPic can not hold all reference pictures!" );
 
           if( j >= MAX_NUM_REF )
           {
@@ -4275,7 +4275,7 @@
   //Make sure that TMVP is disabled when there are no reference pictures with the same resolution
   if(!refPicIsSameRes)
   {
-    CHECK(getPicHeader()->getEnableTMVPFlag() != 0, "TMVP cannot be enabled in pictures that have no reference pictures with the same resolution")
+    CHECK_VTM(getPicHeader()->getEnableTMVPFlag() != 0, "TMVP cannot be enabled in pictures that have no reference pictures with the same resolution")
   }
 }
 
@@ -4418,7 +4418,7 @@
 
 bool Slice::isLastSliceInSubpic()
 {
-  CHECK(m_pcPPS == NULL, "PPS pointer not initialized");
+  CHECK_VTM(m_pcPPS == NULL, "PPS pointer not initialized");
 
   int lastCTUAddrInSlice = m_sliceMap.getCtuAddrList().back();
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Slice.h ../VVCSoftware_10/source/Lib/CommonLib/Slice.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Slice.h	2022-09-16 14:27:06.136532736 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/Slice.h	2022-05-13 17:45:29.240145077 +0200
@@ -736,7 +736,8 @@
   void                   setNumCtuInSlice( uint32_t u )       { m_numCtuInSlice = u;      }
   uint32_t               getNumCtuInSlice() const             { return m_numCtuInSlice;   }
   std::vector<uint32_t>  getCtuAddrList( ) const              { return m_ctuAddrInSlice;  }
-  uint32_t               getCtuAddrInSlice( int idx ) const   { CHECK(idx >= m_ctuAddrInSlice.size(), "CTU index exceeds number of CTUs in slice."); return m_ctuAddrInSlice[idx]; }
+  uint32_t               getCtuAddrInSlice( int idx ) const   {
+    CHECK_VTM(idx >= m_ctuAddrInSlice.size(), "CTU index exceeds number of CTUs in slice."); return m_ctuAddrInSlice[idx]; }
   void                   pushToCtuAddrInSlice( uint32_t u )   { m_ctuAddrInSlice.push_back(u); m_numCtuInSlice++;}
 
   void  initSliceMap()
@@ -749,7 +750,7 @@
 
   void  addCtusToSlice( uint32_t startX, uint32_t stopX, uint32_t startY, uint32_t stopY, uint32_t picWidthInCtbsY )
   {
-    CHECK( startX >= stopX || startY >= stopY, "Invalid slice definition");
+    CHECK_VTM( startX >= stopX || startY >= stopY, "Invalid slice definition");
     for( uint32_t ctbY = startY; ctbY < stopY; ctbY++ )
     {
       for( uint32_t ctbX = startX; ctbX < stopX; ctbX++ )
@@ -856,7 +857,7 @@
   }
   void  addAllCtusInPicToSubPic(uint32_t startX, uint32_t stopX, uint32_t startY, uint32_t stopY, uint32_t picWidthInCtbsY)
   {
-    CHECK(startX >= stopX || startY >= stopY, "Invalid slice definition");
+    CHECK_VTM(startX >= stopX || startY >= stopY, "Invalid slice definition");
     for (uint32_t ctbY = startY; ctbY < stopY; ctbY++)
     {
       for (uint32_t ctbX = startX; ctbX < stopX; ctbX++)
@@ -1498,8 +1499,10 @@
   ChromaFormat            getChromaFormatIdc () const                                                     { return m_chromaFormatIdc;                                            }
   void                    setChromaFormatIdc (ChromaFormat i)                                             { m_chromaFormatIdc = i;                                               }
 
-  static int              getWinUnitX (int chromaFormatIdc)                                               { CHECK(chromaFormatIdc < 0 || chromaFormatIdc >= NUM_CHROMA_FORMAT, "Invalid chroma format parameter"); return m_winUnitX[chromaFormatIdc]; }
-  static int              getWinUnitY (int chromaFormatIdc)                                               { CHECK(chromaFormatIdc < 0 || chromaFormatIdc >= NUM_CHROMA_FORMAT, "Invalid chroma format parameter"); return m_winUnitY[chromaFormatIdc]; }
+  static int              getWinUnitX (int chromaFormatIdc)                                               {
+    CHECK_VTM(chromaFormatIdc < 0 || chromaFormatIdc >= NUM_CHROMA_FORMAT, "Invalid chroma format parameter"); return m_winUnitX[chromaFormatIdc]; }
+  static int              getWinUnitY (int chromaFormatIdc)                                               {
+    CHECK_VTM(chromaFormatIdc < 0 || chromaFormatIdc >= NUM_CHROMA_FORMAT, "Invalid chroma format parameter"); return m_winUnitY[chromaFormatIdc]; }
 
   // structure
   void                    setMaxPicWidthInLumaSamples( uint32_t u )                                       { m_maxWidthInLumaSamples = u; }
@@ -1513,7 +1516,8 @@
   void      setSubPicInfoPresentFlag(bool b)                                                { m_subPicInfoPresentFlag = b;            }
   bool      getSubPicInfoPresentFlag() const                                                { return m_subPicInfoPresentFlag;         }
 
-  void      setNumSubPics( uint32_t u )                                                     { CHECK( u >= MAX_NUM_SUB_PICS, "Maximum number of subpictures exceeded" );
+  void      setNumSubPics( uint32_t u )                                                     {
+    CHECK_VTM( u >= MAX_NUM_SUB_PICS, "Maximum number of subpictures exceeded" );
                                                                                               m_numSubPics = u;
                                                                                               m_subPicCtuTopLeftX.resize(m_numSubPics);
                                                                                               m_subPicCtuTopLeftY.resize(m_numSubPics);
@@ -1541,12 +1545,18 @@
   void      setLoopFilterAcrossSubpicEnabledFlag( int i, bool u )                           { m_loopFilterAcrossSubpicEnabledFlag[i] = u;     }
   bool      getLoopFilterAcrossSubpicEnabledFlag( int i ) const                             { return  m_loopFilterAcrossSubpicEnabledFlag[i]; }
 
-  void      setSubPicCtuTopLeftX                        (const std::vector<uint32_t> &v)   { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicCtuTopLeftX = v; }
-  void      setSubPicCtuTopLeftY                        (const std::vector<uint32_t> &v)   { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicCtuTopLeftY = v; }
-  void      setSubPicWidth                              (const std::vector<uint32_t> &v)   { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicWidth = v; }
-  void      setSubPicHeight                             (const std::vector<uint32_t> &v)   { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicHeight = v; }
-  void      setSubPicTreatedAsPicFlag                   (const std::vector<bool> &v)       { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicTreatedAsPicFlag = v; }
-  void      setLoopFilterAcrossSubpicEnabledFlag        (const std::vector<bool> &v)       { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_loopFilterAcrossSubpicEnabledFlag = v; }
+  void      setSubPicCtuTopLeftX                        (const std::vector<uint32_t> &v)   {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicCtuTopLeftX = v; }
+  void      setSubPicCtuTopLeftY                        (const std::vector<uint32_t> &v)   {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicCtuTopLeftY = v; }
+  void      setSubPicWidth                              (const std::vector<uint32_t> &v)   {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicWidth = v; }
+  void      setSubPicHeight                             (const std::vector<uint32_t> &v)   {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicHeight = v; }
+  void      setSubPicTreatedAsPicFlag                   (const std::vector<bool> &v)       {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicTreatedAsPicFlag = v; }
+  void      setLoopFilterAcrossSubpicEnabledFlag        (const std::vector<bool> &v)       {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_loopFilterAcrossSubpicEnabledFlag = v; }
 
   bool       getDisableScalingMatrixForLfnstBlks() const { return m_disableScalingMatrixForLfnstBlks; }
   void       setDisableScalingMatrixForLfnstBlks(bool flag) { m_disableScalingMatrixForLfnstBlks = flag; }
@@ -1559,17 +1569,22 @@
   uint32_t                getSubPicIdLen() const                                                          { return  m_subPicIdLen;                   }
   void                    setSubPicId( int i, uint16_t u )                                                { m_subPicId[i] = u;     }
   uint16_t                getSubPicId( int i ) const                                                      { return  m_subPicId[i]; }
-  void                    setSubPicId(const std::vector<uint16_t> &v)                                     { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ; m_subPicId = v; }
+  void                    setSubPicId(const std::vector<uint16_t> &v)                                     {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ; m_subPicId = v; }
   const std::vector<uint16_t> getSubPicIds() const                                                        { return  m_subPicId; }
 
   uint32_t                getNumLongTermRefPicSPS() const                                                 { return m_numLongTermRefPicSPS;                                       }
   void                    setNumLongTermRefPicSPS(uint32_t val)                                           { m_numLongTermRefPicSPS = val;                                        }
 
-  uint32_t                getLtRefPicPocLsbSps(uint32_t index) const                                      { CHECK( index >= MAX_NUM_LONG_TERM_REF_PICS, "Index exceeds boundary" ); return m_ltRefPicPocLsbSps[index]; }
-  void                    setLtRefPicPocLsbSps(uint32_t index, uint32_t val)                              { CHECK( index >= MAX_NUM_LONG_TERM_REF_PICS, "Index exceeds boundary" ); m_ltRefPicPocLsbSps[index] = val;  }
-
-  bool                    getUsedByCurrPicLtSPSFlag(int i) const                                          { CHECK( i >= MAX_NUM_LONG_TERM_REF_PICS, "Index exceeds boundary" ); return m_usedByCurrPicLtSPSFlag[i];    }
-  void                    setUsedByCurrPicLtSPSFlag(int i, bool x)                                        { CHECK( i >= MAX_NUM_LONG_TERM_REF_PICS, "Index exceeds boundary" ); m_usedByCurrPicLtSPSFlag[i] = x;       }
+  uint32_t                getLtRefPicPocLsbSps(uint32_t index) const                                      {
+    CHECK_VTM( index >= MAX_NUM_LONG_TERM_REF_PICS, "Index exceeds boundary" ); return m_ltRefPicPocLsbSps[index]; }
+  void                    setLtRefPicPocLsbSps(uint32_t index, uint32_t val)                              {
+    CHECK_VTM( index >= MAX_NUM_LONG_TERM_REF_PICS, "Index exceeds boundary" ); m_ltRefPicPocLsbSps[index] = val;  }
+
+  bool                    getUsedByCurrPicLtSPSFlag(int i) const                                          {
+    CHECK_VTM( i >= MAX_NUM_LONG_TERM_REF_PICS, "Index exceeds boundary" ); return m_usedByCurrPicLtSPSFlag[i];    }
+  void                    setUsedByCurrPicLtSPSFlag(int i, bool x)                                        {
+    CHECK_VTM( i >= MAX_NUM_LONG_TERM_REF_PICS, "Index exceeds boundary" ); m_usedByCurrPicLtSPSFlag[i] = x;       }
 
   int                     getLog2MinCodingBlockSize() const                                               { return m_log2MinCodingBlockSize;                                     }
   void                    setLog2MinCodingBlockSize(int val)                                              { m_log2MinCodingBlockSize = val;                                      }
@@ -1708,7 +1723,8 @@
   bool                    getProfControlPresentInPhFlag()const                                            { return m_ProfControlPresentInPhFlag; }
   void                    setProfControlPresentInPhFlag(bool b)                                           { m_ProfControlPresentInPhFlag = b;    }
   uint32_t                getMaxTLayers() const                                                           { return m_uiMaxTLayers; }
-  void                    setMaxTLayers( uint32_t uiMaxTLayers )                                          { CHECK( uiMaxTLayers > MAX_TLAYER, "Invalid number T-layers" ); m_uiMaxTLayers = uiMaxTLayers; }
+  void                    setMaxTLayers( uint32_t uiMaxTLayers )                                          {
+    CHECK_VTM( uiMaxTLayers > MAX_TLAYER, "Invalid number T-layers" ); m_uiMaxTLayers = uiMaxTLayers; }
 
   bool                    getPtlDpbHrdParamsPresentFlag()  const                                          { return m_ptlDpbHrdParamsPresentFlag;     }
   void                    setPtlDpbHrdParamsPresentFlag(bool b)                                           {        m_ptlDpbHrdParamsPresentFlag = b; }
@@ -1731,12 +1747,17 @@
   unsigned                getNumVerVirtualBoundaries() const                                              { return m_numVerVirtualBoundaries;                                    }
   void                    setNumHorVirtualBoundaries(unsigned u)                                          { m_numHorVirtualBoundaries = u;                                       }
   unsigned                getNumHorVirtualBoundaries() const                                              { return m_numHorVirtualBoundaries;                                    }
-  void                    setVirtualBoundariesPosX(unsigned u, unsigned idx)                              { CHECK( idx >= 3, "vitrual boundary index exceeds valid range" ); m_virtualBoundariesPosX[idx] = u;    }
-  unsigned                getVirtualBoundariesPosX(unsigned idx) const                                    { CHECK( idx >= 3, "vitrual boundary index exceeds valid range" ); return m_virtualBoundariesPosX[idx]; }
-  void                    setVirtualBoundariesPosY(unsigned u, unsigned idx)                              { CHECK( idx >= 3, "vitrual boundary index exceeds valid range" ); m_virtualBoundariesPosY[idx] = u;    }
-  unsigned                getVirtualBoundariesPosY(unsigned idx) const                                    { CHECK( idx >= 3, "vitrual boundary index exceeds valid range" ); return m_virtualBoundariesPosY[idx]; }
+  void                    setVirtualBoundariesPosX(unsigned u, unsigned idx)                              {
+    CHECK_VTM( idx >= 3, "vitrual boundary index exceeds valid range" ); m_virtualBoundariesPosX[idx] = u;    }
+  unsigned                getVirtualBoundariesPosX(unsigned idx) const                                    {
+    CHECK_VTM( idx >= 3, "vitrual boundary index exceeds valid range" ); return m_virtualBoundariesPosX[idx]; }
+  void                    setVirtualBoundariesPosY(unsigned u, unsigned idx)                              {
+    CHECK_VTM( idx >= 3, "vitrual boundary index exceeds valid range" ); m_virtualBoundariesPosY[idx] = u;    }
+  unsigned                getVirtualBoundariesPosY(unsigned idx) const                                    {
+    CHECK_VTM( idx >= 3, "vitrual boundary index exceeds valid range" ); return m_virtualBoundariesPosY[idx]; }
   uint32_t                getMaxDecPicBuffering(uint32_t tlayer) const                                    { return m_uiMaxDecPicBuffering[tlayer];                               }
-  void                    setMaxDecPicBuffering( uint32_t ui, uint32_t tlayer )                           { CHECK(tlayer >= MAX_TLAYER, "Invalid T-layer"); m_uiMaxDecPicBuffering[tlayer] = ui;    }
+  void                    setMaxDecPicBuffering( uint32_t ui, uint32_t tlayer )                           {
+    CHECK_VTM(tlayer >= MAX_TLAYER, "Invalid T-layer"); m_uiMaxDecPicBuffering[tlayer] = ui;    }
   uint32_t                getMaxLatencyIncreasePlus1(uint32_t tlayer) const                               { return m_uiMaxLatencyIncreasePlus1[tlayer];                          }
   void                    setMaxLatencyIncreasePlus1( uint32_t ui , uint32_t tlayer)                      { m_uiMaxLatencyIncreasePlus1[tlayer] = ui;                            }
   uint32_t                getMaxNumMergeCand() const { return m_maxNumMergeCand; }
@@ -2026,13 +2047,13 @@
 
   const ChromaQpAdj&     getChromaQpOffsetListEntry( int cuChromaQpOffsetIdxPlus1 ) const
   {
-    CHECK(cuChromaQpOffsetIdxPlus1 >= m_chromaQpOffsetListLen+1, "Invalid chroma QP offset");
+    CHECK_VTM(cuChromaQpOffsetIdxPlus1 >= m_chromaQpOffsetListLen+1, "Invalid chroma QP offset");
     return m_ChromaQpAdjTableIncludingNullEntry[cuChromaQpOffsetIdxPlus1]; // Array includes entry [0] for the null offset used when cu_chroma_qp_offset_flag=0, and entries [cu_chroma_qp_offset_idx+1...] otherwise
   }
 
   void                   setChromaQpOffsetListEntry( int cuChromaQpOffsetIdxPlus1, int cbOffset, int crOffset, int jointCbCrOffset )
   {
-    CHECK(cuChromaQpOffsetIdxPlus1 == 0 || cuChromaQpOffsetIdxPlus1 > MAX_QP_OFFSET_LIST_SIZE, "Invalid chroma QP offset");
+    CHECK_VTM(cuChromaQpOffsetIdxPlus1 == 0 || cuChromaQpOffsetIdxPlus1 > MAX_QP_OFFSET_LIST_SIZE, "Invalid chroma QP offset");
     m_ChromaQpAdjTableIncludingNullEntry[cuChromaQpOffsetIdxPlus1].u.comp.CbOffset = cbOffset; // Array includes entry [0] for the null offset used when cu_chroma_qp_offset_flag=0, and entries [cu_chroma_qp_offset_idx+1...] otherwise
     m_ChromaQpAdjTableIncludingNullEntry[cuChromaQpOffsetIdxPlus1].u.comp.CrOffset = crOffset;
     m_ChromaQpAdjTableIncludingNullEntry[cuChromaQpOffsetIdxPlus1].u.comp.JointCbCrOffset = jointCbCrOffset;
@@ -2060,7 +2081,8 @@
   unsigned               getWrapAroundOffset() const                                      { return m_wrapAroundOffset;                    }
   void                   setOutputFlagPresentFlag( bool b )                               { m_OutputFlagPresentFlag = b;                  }
   bool                   getOutputFlagPresentFlag() const                                 { return m_OutputFlagPresentFlag;               }
-  void                   setNumSubPics(uint32_t u )                                       { CHECK( u >= MAX_NUM_SUB_PICS, "Maximum number of subpictures exceeded" );
+  void                   setNumSubPics(uint32_t u )                                       {
+    CHECK_VTM( u >= MAX_NUM_SUB_PICS, "Maximum number of subpictures exceeded" );
                                                                                             m_numSubPics = u;
                                                                                             m_subPicId.resize(m_numSubPics);
                                                                                           }
@@ -2070,7 +2092,8 @@
   void                   setSubPicIdLen( uint32_t u )                                     { m_subPicIdLen = u;                            }
   uint32_t               getSubPicIdLen() const                                           { return  m_subPicIdLen;                        }
   void                   setSubPicId( int i, uint16_t u )                                 { m_subPicId[i] = u;     }
-  void                   setSubPicId(const std::vector<uint16_t> &v)                      { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ; m_subPicId = v; }
+  void                   setSubPicId(const std::vector<uint16_t> &v)                      {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ; m_subPicId = v; }
   uint16_t               getSubPicId( int i ) const                                       { return  m_subPicId[i]; }
   const std::vector<uint16_t> getSubPicIds() const                                        { return  m_subPicId; }
   uint32_t               getSubPicIdxFromSubPicId( uint32_t subPicId ) const;
@@ -2094,14 +2117,21 @@
   uint32_t               getNumTiles( ) const                                             { return  m_numTileCols * m_numTileRows;        }
   void                   setTileColumnWidths( std::vector<uint32_t> widths )              { m_tileColWidth = widths;                      }
   void                   setTileRowHeights( std::vector<uint32_t> heights )               { m_tileRowHeight = heights;                    }
-  void                   addTileColumnWidth( uint32_t u )                                 { CHECK( m_tileColWidth.size()  >= MAX_TILE_COLS, "Number of tile columns exceeds valid range" ); m_tileColWidth.push_back(u);    }
+  void                   addTileColumnWidth( uint32_t u )                                 {
+    CHECK_VTM( m_tileColWidth.size()  >= MAX_TILE_COLS, "Number of tile columns exceeds valid range" ); m_tileColWidth.push_back(u);    }
   void                   addTileRowHeight( uint32_t u )                                   { m_tileRowHeight.push_back(u);   }
-  uint32_t               getTileColumnWidth( int idx ) const                              { CHECK( idx >= m_tileColWidth.size(), "Tile column index exceeds valid range" );                 return  m_tileColWidth[idx];    }
-  uint32_t               getTileRowHeight( int idx ) const                                { CHECK( idx >= m_tileRowHeight.size(), "Tile row index exceeds valid range" );                   return  m_tileRowHeight[idx];   }
-  uint32_t               getTileColumnBd( int idx ) const                                 { CHECK( idx >= m_tileColBd.size(), "Tile column index exceeds valid range" );                    return  m_tileColBd[idx];       }
-  uint32_t               getTileRowBd( int idx ) const                                    { CHECK( idx >= m_tileRowBd.size(), "Tile row index exceeds valid range" );                       return  m_tileRowBd[idx];       }
-  uint32_t               ctuToTileCol( int ctuX ) const                                   { CHECK( ctuX >= m_ctuToTileCol.size(), "CTU address index exceeds valid range" ); return  m_ctuToTileCol[ctuX];                  }
-  uint32_t               ctuToTileRow( int ctuY ) const                                   { CHECK( ctuY >= m_ctuToTileRow.size(), "CTU address index exceeds valid range" ); return  m_ctuToTileRow[ctuY];                  }
+  uint32_t               getTileColumnWidth( int idx ) const                              {
+    CHECK_VTM( idx >= m_tileColWidth.size(), "Tile column index exceeds valid range" );                 return  m_tileColWidth[idx];    }
+  uint32_t               getTileRowHeight( int idx ) const                                {
+    CHECK_VTM( idx >= m_tileRowHeight.size(), "Tile row index exceeds valid range" );                   return  m_tileRowHeight[idx];   }
+  uint32_t               getTileColumnBd( int idx ) const                                 {
+    CHECK_VTM( idx >= m_tileColBd.size(), "Tile column index exceeds valid range" );                    return  m_tileColBd[idx];       }
+  uint32_t               getTileRowBd( int idx ) const                                    {
+    CHECK_VTM( idx >= m_tileRowBd.size(), "Tile row index exceeds valid range" );                       return  m_tileRowBd[idx];       }
+  uint32_t               ctuToTileCol( int ctuX ) const                                   {
+    CHECK_VTM( ctuX >= m_ctuToTileCol.size(), "CTU address index exceeds valid range" ); return  m_ctuToTileCol[ctuX];                  }
+  uint32_t               ctuToTileRow( int ctuY ) const                                   {
+    CHECK_VTM( ctuY >= m_ctuToTileRow.size(), "CTU address index exceeds valid range" ); return  m_ctuToTileRow[ctuY];                  }
   uint32_t               ctuToTileColBd( int ctuX ) const                                 { return  getTileColumnBd(ctuToTileCol( ctuX ));                                                                                  }
   uint32_t               ctuToTileRowBd( int ctuY ) const                                 { return  getTileRowBd(ctuToTileRow( ctuY ));                                                                                     }
   bool                   ctuIsTileColBd( int ctuX ) const                                 { return  ctuX == ctuToTileColBd( ctuX );                                                                                         }
@@ -2113,21 +2143,34 @@
   bool                   getRectSliceFlag( ) const                                        { return  m_rectSliceFlag;                                                                                                        }
   void                   setSingleSlicePerSubPicFlag( bool b )                            { m_singleSlicePerSubPicFlag = b;                                                                                                 }
   bool                   getSingleSlicePerSubPicFlag( ) const                             { return  m_singleSlicePerSubPicFlag;                                                                                             }
-  uint32_t               getCtuToSubPicIdx( int idx ) const                               { CHECK( idx >= m_ctuToSubPicIdx.size(), "CTU address index exceeds valid range" ); CHECK( getNumSubPics() < 1, "Number of subpicture cannot be 0" ); return  m_ctuToSubPicIdx[ idx ]; }
-  void                   setNumSlicesInPic( uint32_t u )                                  { CHECK( u > MAX_SLICES, "Number of slices in picture exceeds valid range" ); m_numSlicesInPic = u;                               }
+  uint32_t               getCtuToSubPicIdx( int idx ) const                               {
+    CHECK_VTM( idx >= m_ctuToSubPicIdx.size(), "CTU address index exceeds valid range" );
+    CHECK_VTM( getNumSubPics() < 1, "Number of subpicture cannot be 0" ); return  m_ctuToSubPicIdx[ idx ]; }
+  void                   setNumSlicesInPic( uint32_t u )                                  {
+    CHECK_VTM( u > MAX_SLICES, "Number of slices in picture exceeds valid range" ); m_numSlicesInPic = u;                               }
   uint32_t               getNumSlicesInPic( ) const                                       { return  m_numSlicesInPic;                                                                                                       }
   void                   setTileIdxDeltaPresentFlag( bool b )                             { m_tileIdxDeltaPresentFlag = b;                                                                                                  }
   bool                   getTileIdxDeltaPresentFlag( ) const                              { return  m_tileIdxDeltaPresentFlag;                                                                                              }
-  void                   setSliceWidthInTiles( int idx, uint32_t u )                      { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setSliceWidthInTiles( u );            }
-  uint32_t               getSliceWidthInTiles( int idx ) const                            { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getSliceWidthInTiles( );      }
-  void                   setSliceHeightInTiles( int idx, uint32_t u )                     { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setSliceHeightInTiles( u );           }
-  uint32_t               getSliceHeightInTiles( int idx ) const                           { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getSliceHeightInTiles( );     }
-  void                   setNumSlicesInTile( int idx, uint32_t u )                        { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setNumSlicesInTile( u );              }
-  uint32_t               getNumSlicesInTile( int idx ) const                              { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getNumSlicesInTile( );        }
-  void                   setSliceHeightInCtu( int idx, uint32_t u )                       { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setSliceHeightInCtu( u );             }
-  uint32_t               getSliceHeightInCtu( int idx ) const                             { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getSliceHeightInCtu( );       }
-  void                   setSliceTileIdx(  int idx, uint32_t u )                          { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setTileIdx( u );                      }
-  uint32_t               getSliceTileIdx( int idx ) const                                 { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getTileIdx( );                }
+  void                   setSliceWidthInTiles( int idx, uint32_t u )                      {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setSliceWidthInTiles( u );            }
+  uint32_t               getSliceWidthInTiles( int idx ) const                            {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getSliceWidthInTiles( );      }
+  void                   setSliceHeightInTiles( int idx, uint32_t u )                     {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setSliceHeightInTiles( u );           }
+  uint32_t               getSliceHeightInTiles( int idx ) const                           {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getSliceHeightInTiles( );     }
+  void                   setNumSlicesInTile( int idx, uint32_t u )                        {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setNumSlicesInTile( u );              }
+  uint32_t               getNumSlicesInTile( int idx ) const                              {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getNumSlicesInTile( );        }
+  void                   setSliceHeightInCtu( int idx, uint32_t u )                       {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setSliceHeightInCtu( u );             }
+  uint32_t               getSliceHeightInCtu( int idx ) const                             {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getSliceHeightInCtu( );       }
+  void                   setSliceTileIdx(  int idx, uint32_t u )                          {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    m_rectSlices[idx].setTileIdx( u );                      }
+  uint32_t               getSliceTileIdx( int idx ) const                                 {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return  m_rectSlices[idx].getTileIdx( );                }
   void                   setRectSlices( std::vector<RectSlice> rectSlices )               { m_rectSlices = rectSlices;                                                                                                      }
   void                   setLoopFilterAcrossTilesEnabledFlag( bool b )                    { m_loopFilterAcrossTilesEnabledFlag = b;                                                                                         }
   bool                   getLoopFilterAcrossTilesEnabledFlag( ) const                     { return  m_loopFilterAcrossTilesEnabledFlag;                                                                                     }
@@ -2144,7 +2187,8 @@
   const SubPic&          getSubPicFromCU (const CodingUnit& cu) const;
   void                   initRasterSliceMap( std::vector<uint32_t> sizes );
   void                   checkSliceMap();
-  SliceMap               getSliceMap( int idx ) const                                     { CHECK( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return m_sliceMap[idx];                             }
+  SliceMap               getSliceMap( int idx ) const                                     {
+    CHECK_VTM( idx >= m_numSlicesInPic, "Slice index exceeds valid range" );    return m_sliceMap[idx];                             }
 
 
 
@@ -2394,10 +2438,14 @@
   unsigned                    getNumVerVirtualBoundaries() const                        { return m_numVerVirtualBoundaries;                                                            }
   void                        setNumHorVirtualBoundaries(unsigned u)                    { m_numHorVirtualBoundaries = u;                                                               }
   unsigned                    getNumHorVirtualBoundaries() const                        { return m_numHorVirtualBoundaries;                                                            }
-  void                        setVirtualBoundariesPosX(unsigned u, unsigned idx)        { CHECK( idx >= 3, "boundary index exceeds valid range" ); m_virtualBoundariesPosX[idx] = u;   }
-  unsigned                    getVirtualBoundariesPosX(unsigned idx) const              { CHECK( idx >= 3, "boundary index exceeds valid range" ); return m_virtualBoundariesPosX[idx];}
-  void                        setVirtualBoundariesPosY(unsigned u, unsigned idx)        { CHECK( idx >= 3, "boundary index exceeds valid range" ); m_virtualBoundariesPosY[idx] = u;   }
-  unsigned                    getVirtualBoundariesPosY(unsigned idx) const              { CHECK( idx >= 3, "boundary index exceeds valid range" ); return m_virtualBoundariesPosY[idx];}
+  void                        setVirtualBoundariesPosX(unsigned u, unsigned idx)        {
+    CHECK_VTM( idx >= 3, "boundary index exceeds valid range" ); m_virtualBoundariesPosX[idx] = u;   }
+  unsigned                    getVirtualBoundariesPosX(unsigned idx) const              {
+    CHECK_VTM( idx >= 3, "boundary index exceeds valid range" ); return m_virtualBoundariesPosX[idx];}
+  void                        setVirtualBoundariesPosY(unsigned u, unsigned idx)        {
+    CHECK_VTM( idx >= 3, "boundary index exceeds valid range" ); m_virtualBoundariesPosY[idx] = u;   }
+  unsigned                    getVirtualBoundariesPosY(unsigned idx) const              {
+    CHECK_VTM( idx >= 3, "boundary index exceeds valid range" ); return m_virtualBoundariesPosY[idx];}
   void                        setPicOutputFlag( bool b )                                { m_picOutputFlag = b;                                                                         }
   bool                        getPicOutputFlag() const                                  { return m_picOutputFlag;                                                                      }
   ReferencePictureList*       getRPL( bool b )                                          { return (b==1) ? getRPL1() : getRPL0();                                                       }
@@ -2829,7 +2877,7 @@
   void                        initEqualRef();
   bool                        isEqualRef( RefPicList e, int iRefIdx1, int iRefIdx2 )
   {
-    CHECK(e>=NUM_REF_PIC_LIST_01, "Invalid reference picture list");
+    CHECK_VTM(e>=NUM_REF_PIC_LIST_01, "Invalid reference picture list");
     if (iRefIdx1 < 0 || iRefIdx2 < 0)
     {
       return false;
@@ -2842,7 +2890,7 @@
 
   void                        setEqualRef( RefPicList e, int iRefIdx1, int iRefIdx2, bool b)
   {
-    CHECK( e >= NUM_REF_PIC_LIST_01, "Invalid reference picture list" );
+    CHECK_VTM( e >= NUM_REF_PIC_LIST_01, "Invalid reference picture list" );
     m_abEqualRef[e][iRefIdx1][iRefIdx2] = m_abEqualRef[e][iRefIdx2][iRefIdx1] = b;
   }
 
@@ -2906,7 +2954,8 @@
   void                        clearSubstreamSizes( )                                 { return m_substreamSizes.clear();                              }
   uint32_t                        getNumberOfSubstreamSizes( )                           { return (uint32_t) m_substreamSizes.size();                        }
   void                        addSubstreamSize( uint32_t size )                          { m_substreamSizes.push_back(size);                             }
-  uint32_t                        getSubstreamSize( uint32_t idx )                           { CHECK(idx>=getNumberOfSubstreamSizes(),"Invalid index"); return m_substreamSizes[idx]; }
+  uint32_t                        getSubstreamSize( uint32_t idx )                           {
+    CHECK_VTM(idx>=getNumberOfSubstreamSizes(),"Invalid index"); return m_substreamSizes[idx]; }
   void                        resetNumberOfSubstream()                               { m_numSubstream = 0;                                           }
   uint32_t                    getNumberOfSubstream()                                 { return (uint32_t) m_numSubstream;                             }
   void                        increaseNumberOfSubstream()                            { m_numSubstream++;                                             }
@@ -2966,7 +3015,8 @@
   void                        scaleRefPicList( Picture *scaledRefPic[ ], PicHeader *picHeader, APS** apss, APS* lmcsAps, APS* scalingListAps, const bool isDecoder );
   void                        freeScaledRefPicList( Picture *scaledRefPic[] );
   bool                        checkRPR();
-  const std::pair<int, int>&  getScalingRatio( const RefPicList refPicList, const int refIdx )  const { CHECK( refIdx < 0, "Invalid reference index" ); return m_scalingRatio[refPicList][refIdx]; }
+  const std::pair<int, int>&  getScalingRatio( const RefPicList refPicList, const int refIdx )  const {
+    CHECK_VTM( refIdx < 0, "Invalid reference index" ); return m_scalingRatio[refPicList][refIdx]; }
   void                        setNumSubstream( const SPS *sps, const PPS *pps );
   void                        setNumEntryPoints( const SPS *sps, const PPS *pps );
   uint32_t                    getNumEntryPoints( ) const { return m_numEntryPoints;  }
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/TrQuant.cpp ../VVCSoftware_10/source/Lib/CommonLib/TrQuant.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/TrQuant.cpp	2022-09-16 14:27:06.136532736 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/TrQuant.cpp	2022-05-13 17:45:29.404143219 +0200
@@ -340,7 +340,7 @@
     {
       intraMode = PLANAR_IDX;
     }
-    CHECK( intraMode >= NUM_INTRA_MODE - 1, "Invalid intra mode" );
+    CHECK_VTM( intraMode >= NUM_INTRA_MODE - 1, "Invalid intra mode" );
 
     if( lfnstIdx < 3 )
     {
@@ -438,7 +438,7 @@
     {
       intraMode = PLANAR_IDX;
     }
-    CHECK( intraMode >= NUM_INTRA_MODE - 1, "Invalid intra mode" );
+    CHECK_VTM( intraMode >= NUM_INTRA_MODE - 1, "Invalid intra mode" );
 
     if( lfnstIdx < 3 )
     {
@@ -526,7 +526,7 @@
   const uint32_t uiWidth      = area.width;
   const uint32_t uiHeight     = area.height;
 
-  CHECK( uiWidth > tu.cs->sps->getMaxTbSize() || uiHeight > tu.cs->sps->getMaxTbSize(), "Maximal allowed transformation size exceeded!" );
+  CHECK_VTM( uiWidth > tu.cs->sps->getMaxTbSize() || uiHeight > tu.cs->sps->getMaxTbSize(), "Maximal allowed transformation size exceeded!" );
   CoeffBuf tempCoeff = CoeffBuf(m_tempCoeff, area);
   xDeQuant(tu, tempCoeff, compID, cQP);
 
@@ -552,21 +552,21 @@
 
 std::pair<int64_t,int64_t> TrQuant::fwdTransformICT( const TransformUnit &tu, const PelBuf &resCb, const PelBuf &resCr, PelBuf &resC1, PelBuf &resC2, int jointCbCr )
 {
-  CHECK( Size(resCb) != Size(resCr), "resCb and resCr have different sizes" );
-  CHECK( Size(resCb) != Size(resC1), "resCb and resC1 have different sizes" );
-  CHECK( Size(resCb) != Size(resC2), "resCb and resC2 have different sizes" );
+  CHECK_VTM( Size(resCb) != Size(resCr), "resCb and resCr have different sizes" );
+  CHECK_VTM( Size(resCb) != Size(resC1), "resCb and resC1 have different sizes" );
+  CHECK_VTM( Size(resCb) != Size(resC2), "resCb and resC2 have different sizes" );
   return (*m_fwdICT[ TU::getICTMode(tu, jointCbCr) ])( resCb, resCr, resC1, resC2 );
 }
 
 void TrQuant::invTransformICT( const TransformUnit &tu, PelBuf &resCb, PelBuf &resCr )
 {
-  CHECK( Size(resCb) != Size(resCr), "resCb and resCr have different sizes" );
+  CHECK_VTM( Size(resCb) != Size(resCr), "resCb and resCr have different sizes" );
   (*m_invICT[ TU::getICTMode(tu) ])( resCb, resCr );
 }
 
 std::vector<int> TrQuant::selectICTCandidates( const TransformUnit &tu, CompStorage* resCb, CompStorage* resCr )
 {
-  CHECK( !resCb[0].valid() || !resCr[0].valid(), "standard components are not valid" );
+  CHECK_VTM( !resCb[0].valid() || !resCr[0].valid(), "standard components are not valid" );
 
   if( !CU::isIntra( *tu.cu ) )
   {
@@ -584,7 +584,7 @@
   {
     if( cbfMask )
     {
-      CHECK( resCb[cbfMask].valid() || resCr[cbfMask].valid(), "target components for cbfMask=" << cbfMask << " are already present" );
+      CHECK_VTM( resCb[cbfMask].valid() || resCr[cbfMask].valid(), "target components for cbfMask=" << cbfMask << " are already present" );
       resCb[cbfMask].create( tu.blocks[COMPONENT_Cb] );
       resCr[cbfMask].create( tu.blocks[COMPONENT_Cr] );
     }
@@ -780,8 +780,8 @@
   {
     const int      shift_1st              = ((floorLog2(width )) + bitDepth + TRANSFORM_MATRIX_SHIFT) - maxLog2TrDynamicRange + COM16_C806_TRANS_PREC;
     const int      shift_2nd              =  (floorLog2(height))            + TRANSFORM_MATRIX_SHIFT                          + COM16_C806_TRANS_PREC;
-    CHECK( shift_1st < 0, "Negative shift" );
-    CHECK( shift_2nd < 0, "Negative shift" );
+    CHECK_VTM( shift_1st < 0, "Negative shift" );
+    CHECK_VTM( shift_2nd < 0, "Negative shift" );
     TCoeff *tmp = (TCoeff *) alloca(width * height * sizeof(TCoeff));
 
     fastFwdTrans[trTypeHor][transformWidthIndex](block, tmp, shift_1st, height, 0, skipWidth);
@@ -790,14 +790,14 @@
   else if( height == 1 ) //1-D horizontal transform
   {
     const int      shift              = ((floorLog2(width )) + bitDepth + TRANSFORM_MATRIX_SHIFT) - maxLog2TrDynamicRange + COM16_C806_TRANS_PREC;
-    CHECK( shift < 0, "Negative shift" );
+    CHECK_VTM( shift < 0, "Negative shift" );
     CHECKD( ( transformWidthIndex < 0 ), "There is a problem with the width." );
     fastFwdTrans[trTypeHor][transformWidthIndex]( block, dstCoeff.buf, shift, 1, 0, skipWidth );
   }
   else //if (iWidth == 1) //1-D vertical transform
   {
     int shift = ( ( floorLog2(height) ) + bitDepth + TRANSFORM_MATRIX_SHIFT ) - maxLog2TrDynamicRange + COM16_C806_TRANS_PREC;
-    CHECK( shift < 0, "Negative shift" );
+    CHECK_VTM( shift < 0, "Negative shift" );
     CHECKD( ( transformHeightIndex < 0 ), "There is a problem with the height." );
     fastFwdTrans[trTypeVer][transformHeightIndex]( block, dstCoeff.buf, shift, 1, 0, skipHeight );
   }
@@ -841,8 +841,8 @@
   {
     const int      shift_1st              =   TRANSFORM_MATRIX_SHIFT + 1 + COM16_C806_TRANS_PREC; // 1 has been added to shift_1st at the expense of shift_2nd
     const int      shift_2nd              = ( TRANSFORM_MATRIX_SHIFT + maxLog2TrDynamicRange - 1 ) - bitDepth + COM16_C806_TRANS_PREC;
-    CHECK( shift_1st < 0, "Negative shift" );
-    CHECK( shift_2nd < 0, "Negative shift" );
+    CHECK_VTM( shift_1st < 0, "Negative shift" );
+    CHECK_VTM( shift_2nd < 0, "Negative shift" );
     TCoeff *tmp = ( TCoeff * ) alloca( width * height * sizeof( TCoeff ) );
   fastInvTrans[trTypeVer][transformHeightIndex](pCoeff.buf, tmp, shift_1st, width, skipWidth, skipHeight, clipMinimum, clipMaximum);
   fastInvTrans[trTypeHor][transformWidthIndex] (tmp,      block, shift_2nd, height,         0, skipWidth, clipMinimum, clipMaximum);
@@ -850,15 +850,15 @@
   else if( width == 1 ) //1-D vertical transform
   {
     int shift = ( TRANSFORM_MATRIX_SHIFT + maxLog2TrDynamicRange - 1 ) - bitDepth + COM16_C806_TRANS_PREC;
-    CHECK( shift < 0, "Negative shift" );
-    CHECK( ( transformHeightIndex < 0 ), "There is a problem with the height." );
+    CHECK_VTM( shift < 0, "Negative shift" );
+    CHECK_VTM( ( transformHeightIndex < 0 ), "There is a problem with the height." );
     fastInvTrans[trTypeVer][transformHeightIndex]( pCoeff.buf, block, shift + 1, 1, 0, skipHeight, clipMinimum, clipMaximum );
   }
   else //if(iHeight == 1) //1-D horizontal transform
   {
     const int      shift              = ( TRANSFORM_MATRIX_SHIFT + maxLog2TrDynamicRange - 1 ) - bitDepth + COM16_C806_TRANS_PREC;
-    CHECK( shift < 0, "Negative shift" );
-    CHECK( ( transformWidthIndex < 0 ), "There is a problem with the width." );
+    CHECK_VTM( shift < 0, "Negative shift" );
+    CHECK_VTM( ( transformWidthIndex < 0 ), "There is a problem with the width." );
     fastInvTrans[trTypeHor][transformWidthIndex]( pCoeff.buf, block, shift + 1, 1, 0, skipWidth, clipMinimum, clipMaximum );
   }
 
@@ -908,7 +908,7 @@
 
   const CPelBuf  resiBuf    = cs.getResiBuf(rect);
 
-  CHECK( cs.sps->getMaxTbSize() < width, "Unsupported transformation size" );
+  CHECK_VTM( cs.sps->getMaxTbSize() < width, "Unsupported transformation size" );
 
   int pos = 0;
   std::vector<TrCost> trCosts;
@@ -996,7 +996,7 @@
   uiAbsSum = 0;
 
   // transform and quantize
-  CHECK(cs.sps->getMaxTbSize() < uiWidth, "Unsupported transformation size");
+  CHECK_VTM(cs.sps->getMaxTbSize() < uiWidth, "Unsupported transformation size");
 
   CoeffBuf tempCoeff(loadTr ? m_mtsCoeffs[tu.mtsIdx[compID]] : m_tempCoeff, rect);
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/TypeDef.h ../VVCSoftware_10/source/Lib/CommonLib/TypeDef.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/TypeDef.h	2022-09-16 14:27:06.136532736 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/TypeDef.h	2022-05-13 17:45:29.408143174 +0200
@@ -1062,9 +1062,9 @@
 
 // if a check fails with THROW or CHECK, please check if ported correctly from assert in revision 1196)
 #define THROW(x)            throw( Exception( "\nERROR: In function \"" ) << __FUNCTION__ << "\" in " << __FILE__ << ":" << __LINE__ << ": " << x )
-#define CHECK(c,x)          if(c){ THROW(x); }
+#define CHECK_VTM(c,x)          if(c){ THROW(x); }
 #define EXIT(x)             throw( Exception( "\n" ) << x << "\n" )
-#define CHECK_NULLPTR(_ptr) CHECK( !( _ptr ), "Accessing an empty pointer pointer!" )
+#define CHECK_NULLPTR(_ptr) CHECK_VTM( !( _ptr ), "Accessing an empty pointer pointer!" )
 
 #if !NDEBUG  // for non MSVC compiler, define _DEBUG if in debug mode to have same behavior between MSVC and others in debug
 #ifndef _DEBUG
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Unit.cpp ../VVCSoftware_10/source/Lib/CommonLib/Unit.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Unit.cpp	2022-09-16 14:27:06.136532736 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/Unit.cpp	2022-05-13 17:45:29.300144398 +0200
@@ -398,7 +398,7 @@
     {
       if( chromaFormat == CHROMA_420 )
       {
-        CHECK( !(blocks[COMPONENT_Cb].width <= 16 && blocks[COMPONENT_Cb].height <= 16), "chroma cu size shall be <= 16x16 for YUV420 format" );
+        CHECK_VTM( !(blocks[COMPONENT_Cb].width <= 16 && blocks[COMPONENT_Cb].height <= 16), "chroma cu size shall be <= 16x16 for YUV420 format" );
       }
       allowCCLM = true;
     }
@@ -407,7 +407,7 @@
     {
       if( chromaFormat == CHROMA_420 )
       {
-        CHECK( !(blocks[COMPONENT_Cb].width == 32 && blocks[COMPONENT_Cb].height == 32), "chroma cu size shall be 32x32 for YUV420 format" );
+        CHECK_VTM( !(blocks[COMPONENT_Cb].width == 32 && blocks[COMPONENT_Cb].height == 32), "chroma cu size shall be 32x32 for YUV420 format" );
       }
       allowCCLM = true;
     }
@@ -416,7 +416,7 @@
     {
       if( chromaFormat == CHROMA_420 )
       {
-        CHECK( !(blocks[COMPONENT_Cb].width == 32 && blocks[COMPONENT_Cb].height == 16), "chroma cu size shall be 32x16 for YUV420 format" );
+        CHECK_VTM( !(blocks[COMPONENT_Cb].width == 32 && blocks[COMPONENT_Cb].height == 16), "chroma cu size shall be 32x16 for YUV420 format" );
       }
       allowCCLM = true;
     }
@@ -431,7 +431,7 @@
       if( colLumaCu->lwidth() < 64 || colLumaCu->lheight() < 64 ) //further split at 64x64 luma node
       {
         const PartSplit cuSplitTypeDepth1Luma = CU::getSplitAtDepth( *colLumaCu, depthFor64x64Node );
-        CHECK( !(cuSplitTypeDepth1Luma >= CU_QUAD_SPLIT && cuSplitTypeDepth1Luma <= CU_TRIV_SPLIT), "split mode shall be BT, TT or QT" );
+        CHECK_VTM( !(cuSplitTypeDepth1Luma >= CU_QUAD_SPLIT && cuSplitTypeDepth1Luma <= CU_TRIV_SPLIT), "split mode shall be BT, TT or QT" );
         if( cuSplitTypeDepth1Luma != CU_QUAD_SPLIT )
         {
           allowCCLM = false;
@@ -762,7 +762,7 @@
 
 TransformUnit& TransformUnit::operator=(const TransformUnit& other)
 {
-  CHECK( chromaFormat != other.chromaFormat, "Incompatible formats" );
+  CHECK_VTM( chromaFormat != other.chromaFormat, "Incompatible formats" );
 
   unsigned numBlocks = ::getNumberValidTBlocks(*cs->pcv);
   for( unsigned i = 0; i < numBlocks; i++ )
@@ -788,7 +788,7 @@
 
 void TransformUnit::copyComponentFrom(const TransformUnit& other, const ComponentID i)
 {
-  CHECK( chromaFormat != other.chromaFormat, "Incompatible formats" );
+  CHECK_VTM( chromaFormat != other.chromaFormat, "Incompatible formats" );
 
   CHECKD( blocks[i].area() != other.blocks[i].area(), "Transformation units cover different areas" );
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Unit.h ../VVCSoftware_10/source/Lib/CommonLib/Unit.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/Unit.h	2022-09-16 14:27:06.136532736 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/Unit.h	2022-05-13 17:45:29.256144895 +0200
@@ -357,8 +357,10 @@
 #endif
   const uint8_t     getSbtIdx() const { assert( ( ( sbtInfo >> 0 ) & 0xf ) < NUMBER_SBT_IDX ); return ( sbtInfo >> 0 ) & 0xf; }
   const uint8_t     getSbtPos() const { return ( sbtInfo >> 4 ) & 0x3; }
-  void              setSbtIdx( uint8_t idx ) { CHECK( idx >= NUMBER_SBT_IDX, "sbt_idx wrong" ); sbtInfo = ( idx << 0 ) + ( sbtInfo & 0xf0 ); }
-  void              setSbtPos( uint8_t pos ) { CHECK( pos >= 4, "sbt_pos wrong" ); sbtInfo = ( pos << 4 ) + ( sbtInfo & 0xcf ); }
+  void              setSbtIdx( uint8_t idx ) {
+    CHECK_VTM( idx >= NUMBER_SBT_IDX, "sbt_idx wrong" ); sbtInfo = ( idx << 0 ) + ( sbtInfo & 0xf0 ); }
+  void              setSbtPos( uint8_t pos ) {
+    CHECK_VTM( pos >= 4, "sbt_pos wrong" ); sbtInfo = ( pos << 4 ) + ( sbtInfo & 0xcf ); }
   uint8_t           getSbtTuSplit() const;
   const uint8_t     checkAllowedSbt() const;
   const bool        checkCCLMAllowed() const;
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/UnitPartitioner.cpp ../VVCSoftware_10/source/Lib/CommonLib/UnitPartitioner.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/UnitPartitioner.cpp	2022-09-16 14:27:06.136532736 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/UnitPartitioner.cpp	2022-05-13 17:45:29.164145938 +0200
@@ -346,8 +346,8 @@
   }
   else if( split == CU_QUAD_SPLIT )
   {
-    CHECK( currBtDepth > 0, "Cannot split a non-square area other than with a binary split" );
-    CHECK( currMtDepth > 0, "Cannot split a non-square area other than with a binary split" );
+    CHECK_VTM( currBtDepth > 0, "Cannot split a non-square area other than with a binary split" );
+    CHECK_VTM( currMtDepth > 0, "Cannot split a non-square area other than with a binary split" );
     currMtDepth = 0;
     currBtDepth = 0;
     currQtDepth++;
@@ -573,7 +573,7 @@
 
   m_partStack.pop_back();
 
-  CHECK( currDepth == 0, "depth is '0', although a split was performed" );
+  CHECK_VTM( currDepth == 0, "depth is '0', although a split was performed" );
   currDepth--;
   currSubdiv--;
   if( currQgEnable() )
@@ -586,34 +586,34 @@
 
   if( currSplit == CU_HORZ_SPLIT || currSplit == CU_VERT_SPLIT || currSplit == CU_TRIH_SPLIT || currSplit == CU_TRIV_SPLIT )
   {
-    CHECK( !m_partStack.back().checkdIfImplicit, "Didn't check if the current split is implicit" );
-    CHECK( currBtDepth == 0, "BT depth is '0', athough a BT split was performed" );
-    CHECK( currMtDepth == 0, "MT depth is '0', athough a BT split was performed" );
+    CHECK_VTM( !m_partStack.back().checkdIfImplicit, "Didn't check if the current split is implicit" );
+    CHECK_VTM( currBtDepth == 0, "BT depth is '0', athough a BT split was performed" );
+    CHECK_VTM( currMtDepth == 0, "MT depth is '0', athough a BT split was performed" );
     currMtDepth--;
     if( m_partStack.back().isImplicit ) currImplicitBtDepth--;
     currBtDepth--;
     if( ( currSplit == CU_TRIH_SPLIT || currSplit == CU_TRIV_SPLIT ) && currIdx != 1 )
     {
-      CHECK( currBtDepth == 0, "BT depth is '0', athough a TT split was performed" );
+      CHECK_VTM( currBtDepth == 0, "BT depth is '0', athough a TT split was performed" );
       currBtDepth--;
       currSubdiv--;
     }
   }
   else if( currSplit == TU_MAX_TR_SPLIT )
   {
-    CHECK( currTrDepth == 0, "TR depth is '0', although a TU split was performed" );
+    CHECK_VTM( currTrDepth == 0, "TR depth is '0', although a TU split was performed" );
     currTrDepth--;
   }
   else if( currSplit >= SBT_VER_HALF_POS0_SPLIT && currSplit <= SBT_HOR_QUAD_POS1_SPLIT )
   {
-    CHECK( currTrDepth == 0, "TR depth is '0', although a TU split was performed" );
+    CHECK_VTM( currTrDepth == 0, "TR depth is '0', although a TU split was performed" );
     currTrDepth--;
   }
   else
   {
-    CHECK( currTrDepth > 0, "RQT found with QTBT partitioner" );
+    CHECK_VTM( currTrDepth > 0, "RQT found with QTBT partitioner" );
 
-    CHECK( currQtDepth == 0, "QT depth is '0', although a QT split was performed" );
+    CHECK_VTM( currQtDepth == 0, "QT depth is '0', although a QT split was performed" );
     currQtDepth--;
     currSubdiv--;
   }
@@ -700,7 +700,7 @@
 
   m_partStack.pop_back();
 
-  CHECK( currDepth == 0, "depth is '0', although a split was performed" );
+  CHECK_VTM( currDepth == 0, "depth is '0', although a split was performed" );
 
   currDepth--;
   currTrDepth--;
@@ -709,7 +709,7 @@
   m_currArea = m_partStack.back().parts[m_partStack.back().idx];
 #endif
 
-  CHECK( !( currSplit == TU_1D_HORZ_SPLIT || currSplit == TU_1D_VERT_SPLIT || currSplit == TU_MAX_TR_SPLIT ), "Unknown 1D partition split type!" );
+  CHECK_VTM( !( currSplit == TU_1D_HORZ_SPLIT || currSplit == TU_1D_VERT_SPLIT || currSplit == TU_MAX_TR_SPLIT ), "Unknown 1D partition split type!" );
 }
 
 bool TUIntraSubPartitioner::nextPart( const CodingStructure &cs, bool autoPop /*= false*/ )
@@ -790,7 +790,7 @@
           if( i &  1 ) blk.x += blk.width;
         }
 
-        CHECK( sub[i].lumaSize().height < MIN_TB_SIZEY, "the split causes the block to be smaller than the minimal TU size" );
+        CHECK_VTM( sub[i].lumaSize().height < MIN_TB_SIZEY, "the split causes the block to be smaller than the minimal TU size" );
       }
 
       return sub;
@@ -883,7 +883,7 @@
         if (i == 1) blk.y += blk.height;
       }
 
-      CHECK(sub[i].lumaSize().height < MIN_TB_SIZEY, "the cs split causes the block to be smaller than the minimal TU size");
+      CHECK_VTM(sub[i].lumaSize().height < MIN_TB_SIZEY, "the cs split causes the block to be smaller than the minimal TU size");
     }
 
     return sub;
@@ -902,7 +902,7 @@
         if( i == 1 ) blk.x += blk.width;
       }
 
-      CHECK( sub[i].lumaSize().width < MIN_TB_SIZEY, "the split causes the block to be smaller than the minimal TU size" );
+      CHECK_VTM( sub[i].lumaSize().width < MIN_TB_SIZEY, "the split causes the block to be smaller than the minimal TU size" );
     }
 
     return sub;
@@ -923,7 +923,7 @@
         if( i == 2 )        blk.y       += 3 * blk.height;
       }
 
-      CHECK( sub[i].lumaSize().height < MIN_TB_SIZEY, "the cs split causes the block to be smaller than the minimal TU size" );
+      CHECK_VTM( sub[i].lumaSize().height < MIN_TB_SIZEY, "the cs split causes the block to be smaller than the minimal TU size" );
     }
 
     return sub;
@@ -945,7 +945,7 @@
         if( i == 2 )        blk.x      += 3 * blk.width;
       }
 
-      CHECK( sub[i].lumaSize().width < MIN_TB_SIZEY, "the cs split causes the block to be smaller than the minimal TU size" );
+      CHECK_VTM( sub[i].lumaSize().width < MIN_TB_SIZEY, "the cs split causes the block to be smaller than the minimal TU size" );
     }
 
     return sub;
@@ -978,7 +978,7 @@
       blkY.height = splitDimensionSize;
       blkY.y = i > 0 ? sub[i - 1].blocks[COMPONENT_Y].y + splitDimensionSize : blkY.y;
 
-      CHECK( sub[i].lumaSize().height < 1, "the cs split causes the block to be smaller than the minimal TU size" );
+      CHECK_VTM( sub[i].lumaSize().height < 1, "the cs split causes the block to be smaller than the minimal TU size" );
     }
   }
   else if( splitType == TU_1D_VERT_SPLIT )
@@ -994,7 +994,7 @@
 
       blkY.width = splitDimensionSize;
       blkY.x = i > 0 ? sub[i - 1].blocks[COMPONENT_Y].x + splitDimensionSize : blkY.x;
-      CHECK( sub[i].lumaSize().width < 1, "the split causes the block to be smaller than the minimal TU size" );
+      CHECK_VTM( sub[i].lumaSize().width < 1, "the split causes the block to be smaller than the minimal TU size" );
     }
   }
   else
@@ -1058,7 +1058,7 @@
   const int numTilesV = std::max<int>( 1, area.height / maxTrSize );
   const int numTiles  = numTilesH * numTilesV;
 
-  CHECK( numTiles > MAX_CU_TILING_PARTITIONS, "CU partitioning requires more partitions than available" );
+  CHECK_VTM( numTiles > MAX_CU_TILING_PARTITIONS, "CU partitioning requires more partitions than available" );
 
   Partitioning ret;
   ret.resize( numTiles, cuArea );
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/UnitTools.cpp ../VVCSoftware_10/source/Lib/CommonLib/UnitTools.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/UnitTools.cpp	2022-09-16 14:27:06.136532736 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/UnitTools.cpp	2022-05-13 17:45:29.132146300 +0200
@@ -118,31 +118,31 @@
   int curPicHeightY = curPPS->getPicHeightInLumaSamples();                      // pps_pic_height_in_luma_samples
   int max8MinCbSizeY = std::max((int)8, (1<<sps->getLog2MinCodingBlockSize())); // Max(8, MinCbSizeY)
 
-  CHECK((curPicWidth * curSeqMaxPicWidthY) < refPicWidth * (curPicWidthY - max8MinCbSizeY), "(curPicWidth * curSeqMaxPicWidthY) should be greater than or equal to refPicWidth * (curPicWidthY - max8MinCbSizeY))");
-  CHECK((curPicHeight * curSeqMaxPicHeightY) < refPicHeight * (curPicHeightY - max8MinCbSizeY), "(curPicHeight * curSeqMaxPicHeightY) should be greater than or equal to refPicHeight * (curPicHeightY - max8MinCbSizeY))");
+  CHECK_VTM((curPicWidth * curSeqMaxPicWidthY) < refPicWidth * (curPicWidthY - max8MinCbSizeY), "(curPicWidth * curSeqMaxPicWidthY) should be greater than or equal to refPicWidth * (curPicWidthY - max8MinCbSizeY))");
+  CHECK_VTM((curPicHeight * curSeqMaxPicHeightY) < refPicHeight * (curPicHeightY - max8MinCbSizeY), "(curPicHeight * curSeqMaxPicHeightY) should be greater than or equal to refPicHeight * (curPicHeightY - max8MinCbSizeY))");
 
-  CHECK(curPicWidth * 2 < refPicWidth, "curPicWidth * 2 shall be greater than or equal to refPicWidth");
-  CHECK(curPicHeight * 2 < refPicHeight, "curPicHeight * 2 shall be greater than or equal to refPicHeight");
-  CHECK(curPicWidth > refPicWidth * 8, "curPicWidth shall be less than or equal to refPicWidth * 8");
-  CHECK(curPicHeight > refPicHeight * 8, "curPicHeight shall be less than or equal to refPicHeight * 8");
+  CHECK_VTM(curPicWidth * 2 < refPicWidth, "curPicWidth * 2 shall be greater than or equal to refPicWidth");
+  CHECK_VTM(curPicHeight * 2 < refPicHeight, "curPicHeight * 2 shall be greater than or equal to refPicHeight");
+  CHECK_VTM(curPicWidth > refPicWidth * 8, "curPicWidth shall be less than or equal to refPicWidth * 8");
+  CHECK_VTM(curPicHeight > refPicHeight * 8, "curPicHeight shall be less than or equal to refPicHeight * 8");
 
   int subWidthC = SPS::getWinUnitX(sps->getChromaFormatIdc());
   int subHeightC = SPS::getWinUnitY(sps->getChromaFormatIdc());
 
-  CHECK(subWidthC * curScalingWindow.getWindowLeftOffset() < (-curPicWidthY) * 15, "The value of SubWidthC * pps_scaling_win_left_offset shall be greater than or equal to -pps_pic_width_in_luma_samples * 15");
-  CHECK(subWidthC * curScalingWindow.getWindowLeftOffset() >= curPicWidthY, "The value of SubWidthC * pps_scaling_win_left_offset shall be less than pps_pic_width_in_luma_samples");
-  CHECK(subWidthC * curScalingWindow.getWindowRightOffset() < (-curPicWidthY) * 15, "The value of SubWidthC * pps_scaling_win_right_offset shall be greater than or equal to -pps_pic_width_in_luma_samples * 15");
-  CHECK(subWidthC * curScalingWindow.getWindowRightOffset() >= curPicWidthY, "The value of SubWidthC * pps_scaling_win_right_offset shall be less than pps_pic_width_in_luma_samples");
-
-  CHECK(subHeightC * curScalingWindow.getWindowTopOffset() < (-curPicHeightY) * 15, "The value of SubHeightC * pps_scaling_win_top_offset shall be greater than or equal to -pps_pic_height_in_luma_samples * 15");
-  CHECK(subHeightC * curScalingWindow.getWindowTopOffset() >= curPicHeightY, "The value of SubHeightC * pps_scaling_win_top_offset shall be less than pps_pic_height_in_luma_samples");
-  CHECK(subHeightC * curScalingWindow.getWindowBottomOffset() < (-curPicHeightY) * 15, "The value of SubHeightC *pps_scaling_win_bottom_offset shall be greater than or equal to -pps_pic_height_in_luma_samples * 15");
-  CHECK(subHeightC * curScalingWindow.getWindowBottomOffset() >= curPicHeightY, "The value of SubHeightC *pps_scaling_win_bottom_offset shall be less than pps_pic_height_in_luma_samples");
-
-  CHECK(subWidthC * (curScalingWindow.getWindowLeftOffset() + curScalingWindow.getWindowRightOffset()) < (-curPicWidthY) * 15, "The value of SubWidthC * ( pps_scaling_win_left_offset + pps_scaling_win_right_offset ) shall be greater than or equal to -pps_pic_width_in_luma_samples * 15");
-  CHECK(subWidthC * (curScalingWindow.getWindowLeftOffset() + curScalingWindow.getWindowRightOffset()) >= curPicWidthY, "The value of SubWidthC * ( pps_scaling_win_left_offset + pps_scaling_win_right_offset ) shall be less than pps_pic_width_in_luma_samples");
-  CHECK(subHeightC * (curScalingWindow.getWindowTopOffset() + curScalingWindow.getWindowBottomOffset()) < (-curPicHeightY) * 15, "The value of SubHeightC * ( pps_scaling_win_top_offset + pps_scaling_win_bottom_offset ) shall be greater than or equal to -pps_pic_height_in_luma_samples * 15");
-  CHECK(subHeightC * (curScalingWindow.getWindowTopOffset() + curScalingWindow.getWindowBottomOffset()) >= curPicHeightY, "The value of SubHeightC * ( pps_scaling_win_top_offset + pps_scaling_win_bottom_offset ) shall be less than pps_pic_height_in_luma_samples");
+  CHECK_VTM(subWidthC * curScalingWindow.getWindowLeftOffset() < (-curPicWidthY) * 15, "The value of SubWidthC * pps_scaling_win_left_offset shall be greater than or equal to -pps_pic_width_in_luma_samples * 15");
+  CHECK_VTM(subWidthC * curScalingWindow.getWindowLeftOffset() >= curPicWidthY, "The value of SubWidthC * pps_scaling_win_left_offset shall be less than pps_pic_width_in_luma_samples");
+  CHECK_VTM(subWidthC * curScalingWindow.getWindowRightOffset() < (-curPicWidthY) * 15, "The value of SubWidthC * pps_scaling_win_right_offset shall be greater than or equal to -pps_pic_width_in_luma_samples * 15");
+  CHECK_VTM(subWidthC * curScalingWindow.getWindowRightOffset() >= curPicWidthY, "The value of SubWidthC * pps_scaling_win_right_offset shall be less than pps_pic_width_in_luma_samples");
+
+  CHECK_VTM(subHeightC * curScalingWindow.getWindowTopOffset() < (-curPicHeightY) * 15, "The value of SubHeightC * pps_scaling_win_top_offset shall be greater than or equal to -pps_pic_height_in_luma_samples * 15");
+  CHECK_VTM(subHeightC * curScalingWindow.getWindowTopOffset() >= curPicHeightY, "The value of SubHeightC * pps_scaling_win_top_offset shall be less than pps_pic_height_in_luma_samples");
+  CHECK_VTM(subHeightC * curScalingWindow.getWindowBottomOffset() < (-curPicHeightY) * 15, "The value of SubHeightC *pps_scaling_win_bottom_offset shall be greater than or equal to -pps_pic_height_in_luma_samples * 15");
+  CHECK_VTM(subHeightC * curScalingWindow.getWindowBottomOffset() >= curPicHeightY, "The value of SubHeightC *pps_scaling_win_bottom_offset shall be less than pps_pic_height_in_luma_samples");
+
+  CHECK_VTM(subWidthC * (curScalingWindow.getWindowLeftOffset() + curScalingWindow.getWindowRightOffset()) < (-curPicWidthY) * 15, "The value of SubWidthC * ( pps_scaling_win_left_offset + pps_scaling_win_right_offset ) shall be greater than or equal to -pps_pic_width_in_luma_samples * 15");
+  CHECK_VTM(subWidthC * (curScalingWindow.getWindowLeftOffset() + curScalingWindow.getWindowRightOffset()) >= curPicWidthY, "The value of SubWidthC * ( pps_scaling_win_left_offset + pps_scaling_win_right_offset ) shall be less than pps_pic_width_in_luma_samples");
+  CHECK_VTM(subHeightC * (curScalingWindow.getWindowTopOffset() + curScalingWindow.getWindowBottomOffset()) < (-curPicHeightY) * 15, "The value of SubHeightC * ( pps_scaling_win_top_offset + pps_scaling_win_bottom_offset ) shall be greater than or equal to -pps_pic_height_in_luma_samples * 15");
+  CHECK_VTM(subHeightC * (curScalingWindow.getWindowTopOffset() + curScalingWindow.getWindowBottomOffset()) >= curPicHeightY, "The value of SubHeightC * ( pps_scaling_win_top_offset + pps_scaling_win_bottom_offset ) shall be less than pps_pic_height_in_luma_samples");
 
   return refPic->isRefScaled( curPPS );
 }
@@ -163,7 +163,7 @@
     }
   }
 
-  CHECK( currentSubPicIdx == NOT_VALID, "Sub-picture was not found" );
+  CHECK_VTM( currentSubPicIdx == NOT_VALID, "Sub-picture was not found" );
 
   if( !slice->getPic()->cs->sps->getSubPicTreatedAsPicFlag( currentSubPicIdx ) )
   {
@@ -225,7 +225,7 @@
       for (int refIdx = 0; refIdx < slice->getNumRefIdx(eRefPicList); refIdx++)
       {
         const Picture* refPic = slice->getRefPic( eRefPicList, refIdx );
-        CHECK( refPic->layerId == slice->getPic()->layerId || refPic->subPictures.size() > 1, "The inter-layer reference shall contain a single subpicture or have same subpicture layout with the current picture" );
+        CHECK_VTM( refPic->layerId == slice->getPic()->layerId || refPic->subPictures.size() > 1, "The inter-layer reference shall contain a single subpicture or have same subpicture layout with the current picture" );
       }
     }
   }
@@ -403,7 +403,7 @@
 ModeType CU::getModeTypeAtDepth( const CodingUnit& cu, const unsigned depth )
 {
   ModeType modeType = ModeType( (cu.modeTypeSeries >> (depth * 3)) & 0x07 );
-  CHECK( depth > cu.depth, " depth is wrong" );
+  CHECK_VTM( depth > cu.depth, " depth is wrong" );
   return modeType;
 }
 
@@ -411,7 +411,7 @@
 
 bool CU::divideTuInRows( const CodingUnit &cu )
 {
-  CHECK( cu.ispMode != HOR_INTRA_SUBPARTITIONS && cu.ispMode != VER_INTRA_SUBPARTITIONS, "Intra Subpartitions type not recognized!" );
+  CHECK_VTM( cu.ispMode != HOR_INTRA_SUBPARTITIONS && cu.ispMode != VER_INTRA_SUBPARTITIONS, "Intra Subpartitions type not recognized!" );
   return cu.ispMode == HOR_INTRA_SUBPARTITIONS ? true : false;
 }
 
@@ -486,7 +486,7 @@
 
 bool CU::canUseLfnstWithISP( const CodingUnit& cu, const ChannelType chType )
 {
-  CHECK( !isLuma( chType ), "Wrong ISP mode!" );
+  CHECK_VTM( !isLuma( chType ), "Wrong ISP mode!" );
   return CU::canUseLfnstWithISP( cu.blocks[chType == CHANNEL_TYPE_LUMA ? 0 : 1], (ISPType)cu.ispMode );
 }
 
@@ -510,7 +510,7 @@
   const int factorToMinSamples = nonSplitDimensionSize < minNumberOfSamplesPerCu ? minNumberOfSamplesPerCu >> floorLog2(nonSplitDimensionSize) : 1;
   partitionSize = ( splitDimensionSize >> divShift ) < factorToMinSamples ? factorToMinSamples : ( splitDimensionSize >> divShift );
 
-  CHECK( floorLog2(partitionSize) + floorLog2(nonSplitDimensionSize) < floorLog2(minNumberOfSamplesPerCu), "A partition has less than the minimum amount of samples!" );
+  CHECK_VTM( floorLog2(partitionSize) + floorLog2(nonSplitDimensionSize) < floorLog2(minNumberOfSamplesPerCu), "A partition has less than the minimum amount of samples!" );
   return partitionSize;
 }
 
@@ -563,7 +563,7 @@
 {
   const int numMPMs = NUM_MOST_PROBABLE_MODES;
   {
-    CHECK(channelType != CHANNEL_TYPE_LUMA, "Not harmonized yet");
+    CHECK_VTM(channelType != CHANNEL_TYPE_LUMA, "Not harmonized yet");
     int numCand      = -1;
     int leftIntraDir = PLANAR_IDX, aboveIntraDir = PLANAR_IDX;
 
@@ -585,7 +585,7 @@
       aboveIntraDir = PU::getIntraDirLuma( *puAbove );
     }
 
-    CHECK(2 >= numMPMs, "Invalid number of most probable modes");
+    CHECK_VTM(2 >= numMPMs, "Invalid number of most probable modes");
 
     const int offset = (int)NUM_LUMA_MODE - 6;
     const int mod = offset + 3;
@@ -660,9 +660,9 @@
     }
     for (int i = 0; i < numMPMs; i++)
     {
-      CHECK(mpm[i] >= NUM_LUMA_MODE, "Invalid MPM");
+      CHECK_VTM(mpm[i] >= NUM_LUMA_MODE, "Invalid MPM");
     }
-    CHECK(numCand == 0, "No candidates found");
+    CHECK_VTM(numCand == 0, "No candidates found");
     return numCand;
   }
 }
@@ -973,7 +973,7 @@
   const CodingStructure &cs  = *pu.cs;
   const Slice &slice         = *pu.cs->slice;
   const uint32_t maxNumMergeCand = pu.cs->sps->getMaxNumMergeCand();
-  CHECK (maxNumMergeCand > MRG_MAX_NUM_CANDS, "selected maximum number of merge candidate exceeds global limit");
+  CHECK_VTM(maxNumMergeCand > MRG_MAX_NUM_CANDS, "selected maximum number of merge candidate exceeds global limit");
   for (uint32_t ui = 0; ui < maxNumMergeCand; ++ui)
   {
     mrgCtx.BcwIdx[ui] = BCW_DEFAULT;
@@ -1576,7 +1576,7 @@
     }
   }
 
-  CHECK( pColSlice == nullptr, "Slice segment not found" );
+  CHECK_VTM( pColSlice == nullptr, "Slice segment not found" );
 
   const Slice &colSlice = *pColSlice;
 
@@ -2458,8 +2458,7 @@
         cMv[l][1].clipToStorageBitDepth();
         break;
 
-      default:
-        CHECK( 1, "Invalid model index!\n" );
+      default: CHECK_VTM( 1, "Invalid model index!\n" );
         break;
       }
     }
@@ -2579,7 +2578,7 @@
     MergeCtx mrgCtx = *affMrgCtx.mrgCtx;
     bool tmpLICFlag = false;
 
-    CHECK( mrgCtx.subPuMvpMiBuf.area() == 0 || !mrgCtx.subPuMvpMiBuf.buf, "Buffer not initialized" );
+    CHECK_VTM( mrgCtx.subPuMvpMiBuf.area() == 0 || !mrgCtx.subPuMvpMiBuf.buf, "Buffer not initialized" );
     mrgCtx.subPuMvpMiBuf.fill( MotionInfo() );
 
     int pos = 0;
@@ -2860,7 +2859,7 @@
   setAllAffineMv( pu, mv[0], mv[1], mv[2], eRefList );
 
   // Set RefIdx
-  CHECK( mvField[0].refIdx != mvField[1].refIdx || mvField[0].refIdx != mvField[2].refIdx, "Affine mv corners don't have the same refIdx." );
+  CHECK_VTM( mvField[0].refIdx != mvField[1].refIdx || mvField[0].refIdx != mvField[2].refIdx, "Affine mv corners don't have the same refIdx." );
   pu.refIdx[eRefList] = mvField[0].refIdx;
 }
 
@@ -3173,7 +3172,7 @@
   }
   else if (pu.mergeType == MRG_TYPE_SUBPU_ATMVP)
   {
-    CHECK(mrgCtx.subPuMvpMiBuf.area() == 0 || !mrgCtx.subPuMvpMiBuf.buf, "Buffer not initialized");
+    CHECK_VTM(mrgCtx.subPuMvpMiBuf.area() == 0 || !mrgCtx.subPuMvpMiBuf.buf, "Buffer not initialized");
     mb.copyFrom(mrgCtx.subPuMvpMiBuf);
   }
   else
@@ -3601,7 +3600,7 @@
   case SBT_HOR_HALF: val = ( ( sbtAllowed >> SBT_HOR_HALF ) & 0x1 ); break;
   case SBT_VER_QUAD: val = ( ( sbtAllowed >> SBT_VER_QUAD ) & 0x1 ); break;
   case SBT_HOR_QUAD: val = ( ( sbtAllowed >> SBT_HOR_QUAD ) & 0x1 ); break;
-  default:           CHECK( 1, "unknown SBT type" );
+  default: CHECK_VTM( 1, "unknown SBT type" );
   }
   return val;
 }
@@ -3667,7 +3666,7 @@
 {
   if( cu.cs->sps->getUseBcw() == false )
   {
-    CHECK(cu.BcwIdx != BCW_DEFAULT, "Error: cu.BcwIdx != BCW_DEFAULT");
+    CHECK_VTM(cu.BcwIdx != BCW_DEFAULT, "Error: cu.BcwIdx != BCW_DEFAULT");
     return false;
   }
 
@@ -3715,11 +3714,11 @@
   }
   else if( cu.firstPU->mergeFlag && cu.firstPU->mergeType == MRG_TYPE_SUBPU_ATMVP )
   {
-    CHECK(cu.BcwIdx != BCW_DEFAULT, " cu.BcwIdx != BCW_DEFAULT ");
+    CHECK_VTM(cu.BcwIdx != BCW_DEFAULT, " cu.BcwIdx != BCW_DEFAULT ");
   }
   else
   {
-    CHECK(cu.BcwIdx != BCW_DEFAULT, " cu.BcwIdx != BCW_DEFAULT ");
+    CHECK_VTM(cu.BcwIdx != BCW_DEFAULT, " cu.BcwIdx != BCW_DEFAULT ");
   }
 
   return BCW_DEFAULT;
@@ -3747,7 +3746,7 @@
     cu.BcwIdx = BCW_DEFAULT;
   }
 
-  CHECK(uhCnt <= 0, " uhCnt <= 0 ");
+  CHECK_VTM(uhCnt <= 0, " uhCnt <= 0 ");
 }
 
 uint8_t CU::deriveBcwIdx( uint8_t bcwLO, uint8_t bcwL1 )
@@ -3829,7 +3828,7 @@
 {
   if( !tu.blocks[compID].valid() )
   {
-    CHECK(tu.cbf[compID] != 0, "cbf must be 0 if the component is not available");
+    CHECK_VTM(tu.cbf[compID] != 0, "cbf must be 0 if the component is not available");
   }
   return ((tu.cbf[compID] >> depth) & 1) == 1;
 }
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/UnitTools.h ../VVCSoftware_10/source/Lib/CommonLib/UnitTools.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/UnitTools.h	2022-09-16 14:27:06.136532736 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/UnitTools.h	2022-05-13 17:45:29.084146843 +0200
@@ -206,8 +206,8 @@
 uint32_t updateCandList(T uiMode, double uiCost, static_vector<T, N>& candModeList, static_vector<double, N>& candCostList
   , size_t uiFastCandNum = N, int* iserttPos = nullptr)
 {
-  CHECK( std::min( uiFastCandNum, candModeList.size() ) != std::min( uiFastCandNum, candCostList.size() ), "Sizes do not match!" );
-  CHECK( uiFastCandNum > candModeList.capacity(), "The vector is to small to hold all the candidates!" );
+  CHECK_VTM( std::min( uiFastCandNum, candModeList.size() ) != std::min( uiFastCandNum, candCostList.size() ), "Sizes do not match!" );
+  CHECK_VTM( uiFastCandNum > candModeList.capacity(), "The vector is to small to hold all the candidates!" );
 
   size_t i;
   size_t shift = 0;
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/WeightPrediction.cpp ../VVCSoftware_10/source/Lib/CommonLib/WeightPrediction.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/WeightPrediction.cpp	2022-09-16 14:27:06.136532736 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/WeightPrediction.cpp	2022-05-13 17:45:29.352143808 +0200
@@ -75,7 +75,7 @@
 void WeightPrediction::getWpScaling(Slice *pcSlice, const int &iRefIdx0, const int &iRefIdx1, WPScalingParam *&wp0,
                                     WPScalingParam *&wp1, const ComponentID maxNumComp)
 {
-  CHECK(iRefIdx0 < 0 && iRefIdx1 < 0, "Both picture reference list indizes smaller than '0'");
+  CHECK_VTM(iRefIdx0 < 0 && iRefIdx1 < 0, "Both picture reference list indizes smaller than '0'");
 
   const bool wpBiPred        = pcSlice->getPPS()->getWPBiPred();
   const bool bBiPred         = (iRefIdx0 >= 0 && iRefIdx1 >= 0);
@@ -158,7 +158,7 @@
 
   const uint32_t numValidComponent = (const uint32_t)pcYuvSrc0.bufs.size();
 
-  CHECK( lumaOnly && chromaOnly, "Not allowed to have both lumaOnly and chromaOnly selected" );
+  CHECK_VTM( lumaOnly && chromaOnly, "Not allowed to have both lumaOnly and chromaOnly selected" );
   int firstComponent = chromaOnly ? 1 : 0;
   int lastComponent = lumaOnly ? 0 : maxNumComp;
   for (int componentIndex = firstComponent; componentIndex < numValidComponent && componentIndex <= lastComponent; componentIndex++)
@@ -276,7 +276,7 @@
 {
   const uint32_t numValidComponent = (const uint32_t)pcYuvSrc0.bufs.size();
 
-  CHECK( lumaOnly && chromaOnly, "Not allowed to have both lumaOnly and chromaOnly selected" );
+  CHECK_VTM( lumaOnly && chromaOnly, "Not allowed to have both lumaOnly and chromaOnly selected" );
   int firstComponent = chromaOnly ? 1 : 0;
   int lastComponent  = lumaOnly ? 0 : maxNumComp;
   for (int componentIndex = firstComponent; componentIndex < numValidComponent && componentIndex <= lastComponent;
@@ -385,7 +385,7 @@
     iRefIdx = pu.refIdx[eRefPicList];
   }
 
-  CHECK(iRefIdx < 0, "Negative reference picture list index");
+  CHECK_VTM(iRefIdx < 0, "Negative reference picture list index");
 
   if (eRefPicList == REF_PIC_LIST_0)
   {
@@ -412,7 +412,7 @@
   WPScalingParam  *pwp0;
   WPScalingParam  *pwp1;
 
-  CHECK( !pu.cs->pps->getWPBiPred(), "Weighted Bi-prediction disabled" );
+  CHECK_VTM( !pu.cs->pps->getWPBiPred(), "Weighted Bi-prediction disabled" );
 
   if (iRefIdx0 < 0 && iRefIdx1 < 0) return;
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/x86/AdaptiveLoopFilterX86.h ../VVCSoftware_10/source/Lib/CommonLib/x86/AdaptiveLoopFilterX86.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/x86/AdaptiveLoopFilterX86.h	2022-09-16 14:27:06.140532690 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/x86/AdaptiveLoopFilterX86.h	2022-05-13 17:45:28.856149426 +0200
@@ -46,9 +46,9 @@
                                         const CPelBuf &srcLuma, const Area &blkDst, const Area &blk, const int shift,
                                         const int vbCTUHeight, int vbPos )
 {
-  CHECK((blk.height & 7) != 0, "Block height must be a multiple of 8");
-  CHECK((blk.width & 7) != 0, "Block width must be a multiple of 8");
-  CHECK((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
+  CHECK_VTM((blk.height & 7) != 0, "Block height must be a multiple of 8");
+  CHECK_VTM((blk.width & 7) != 0, "Block width must be a multiple of 8");
+  CHECK_VTM((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
 
   const size_t imgStride = srcLuma.stride;
   const Pel *  srcExt    = srcLuma.buf;
@@ -301,8 +301,8 @@
   int vbPos)
 
 {
-  CHECK((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
-  CHECK(!isChroma(compId), "ALF 5x5 filter is for chroma only");
+  CHECK_VTM((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
+  CHECK_VTM(!isChroma(compId), "ALF 5x5 filter is for chroma only");
 
 
   const CPelBuf srcBuffer = recSrc.get(compId);
@@ -321,10 +321,10 @@
   constexpr size_t STEP_X = 8;
   constexpr size_t STEP_Y = 4;
 
-  CHECK(blk.y % STEP_Y, "Wrong startHeight in filtering");
-  CHECK(blk.x % STEP_X, "Wrong startWidth in filtering");
-  CHECK(height % STEP_Y, "Wrong endHeight in filtering");
-  CHECK(width % 4, "Wrong endWidth in filtering");
+  CHECK_VTM(blk.y % STEP_Y, "Wrong startHeight in filtering");
+  CHECK_VTM(blk.x % STEP_X, "Wrong startWidth in filtering");
+  CHECK_VTM(height % STEP_Y, "Wrong endHeight in filtering");
+  CHECK_VTM(width % 4, "Wrong endWidth in filtering");
 
   const Pel *src = srcBuffer.buf + blk.y * srcStride + blk.x;
   Pel *      dst = dstBuffer.buf + blkDst.y * dstStride + blkDst.x;
@@ -480,8 +480,8 @@
   const Pel *fClipSet, const ClpRng &clpRng, CodingStructure &cs, const int vbCTUHeight,
   int vbPos)
 {
-  CHECK((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
-  CHECK(isChroma(compId), "7x7 ALF filter is meant for luma only");
+  CHECK_VTM((vbCTUHeight & (vbCTUHeight - 1)) != 0, "vbCTUHeight must be a power of 2");
+  CHECK_VTM(isChroma(compId), "7x7 ALF filter is meant for luma only");
 
 
   const CPelBuf srcBuffer = recSrc.get(compId);
@@ -499,10 +499,10 @@
   constexpr size_t STEP_X = 8;
   constexpr size_t STEP_Y = 4;
 
-  CHECK(blk.y % STEP_Y, "Wrong startHeight in filtering");
-  CHECK(blk.x % STEP_X, "Wrong startWidth in filtering");
-  CHECK(height % STEP_Y, "Wrong endHeight in filtering");
-  CHECK(width % STEP_X, "Wrong endWidth in filtering");
+  CHECK_VTM(blk.y % STEP_Y, "Wrong startHeight in filtering");
+  CHECK_VTM(blk.x % STEP_X, "Wrong startWidth in filtering");
+  CHECK_VTM(height % STEP_Y, "Wrong endHeight in filtering");
+  CHECK_VTM(width % STEP_X, "Wrong endWidth in filtering");
 
   const Pel *src = srcBuffer.buf + blk.y * srcStride + blk.x;
   Pel *      dst = dstBuffer.buf + blkDst.y * dstStride + blkDst.x;
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/x86/BufferX86.h ../VVCSoftware_10/source/Lib/CommonLib/x86/BufferX86.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/x86/BufferX86.h	2022-09-16 14:27:06.140532690 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/x86/BufferX86.h	2022-05-13 17:45:28.936148520 +0200
@@ -53,8 +53,8 @@
 {
   if( W == 8 )
   {
-    CHECK(offset & 1, "offset must be even");
-    CHECK(offset < -32768 || offset > 32767, "offset must be a 16-bit value");
+    CHECK_VTM(offset & 1, "offset must be even");
+    CHECK_VTM(offset < -32768 || offset > 32767, "offset must be a 16-bit value");
 
     __m128i vibdimin = _mm_set1_epi16(clpRng.min);
     __m128i vibdimax = _mm_set1_epi16(clpRng.max);
@@ -122,7 +122,7 @@
 {
   if (width < 8)
   {
-    CHECK(width < 4, "width must be at least 4");
+    CHECK_VTM(width < 4, "width must be at least 4");
 
     for (size_t x = 0; x < width; x += 4)
     {
@@ -154,7 +154,7 @@
 void paddingSimd(Pel *dst, int stride, int width, int height, int padSize)
 {
   size_t extWidth = width + 2 * padSize;
-  CHECK(extWidth < 8, "width plus 2 times padding size must be at least 8");
+  CHECK_VTM(extWidth < 8, "width plus 2 times padding size must be at least 8");
 
   if (padSize == 1)
   {
@@ -224,7 +224,7 @@
   }
   else
   {
-    CHECK(false, "padding size must be 1 or 2");
+    CHECK_VTM(false, "padding size must be 1 or 2");
   }
 }
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/x86/InterpolationFilterX86.h ../VVCSoftware_10/source/Lib/CommonLib/x86/InterpolationFilterX86.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/x86/InterpolationFilterX86.h	2022-09-16 14:27:06.140532690 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/x86/InterpolationFilterX86.h	2022-05-13 17:45:28.812149924 +0200
@@ -1083,8 +1083,8 @@
 
   __m128i mmShift = _mm_cvtsi64_si128(shift);
 
-  CHECK(isLast, "Not Supported");
-  CHECK(width % 4 != 0, "Not Supported");
+  CHECK_VTM(isLast, "Not Supported");
+  CHECK_VTM(width % 4 != 0, "Not Supported");
 
   for (int row = 0; row < height; row++)
   {
@@ -1122,7 +1122,7 @@
   for (int n = 0; n < 2; n++)
     mmCoeff[n] = _mm_set1_epi16(c[n]);
 
-  CHECK(isLast, "Not Supported");
+  CHECK_VTM(isLast, "Not Supported");
 
 #if USE_AVX2
   __m256i mm256Offset = _mm256_set1_epi16(offset);
@@ -1188,7 +1188,7 @@
   int shift    = IF_FILTER_PREC;
   // with the current settings (IF_INTERNAL_PREC = 14 and IF_FILTER_PREC = 6), though headroom can be
   // negative for bit depths greater than 14, shift will remain non-negative for bit depths of 8->20
-  CHECK( shift < 0, "Negative shift" );
+  CHECK_VTM( shift < 0, "Negative shift" );
 
 
   if( isLast )
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/x86/RdCostX86.h ../VVCSoftware_10/source/Lib/CommonLib/x86/RdCostX86.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/CommonLib/x86/RdCostX86.h	2022-09-16 14:27:06.140532690 +0200
+++ ../VVCSoftware_10/source/Lib/CommonLib/x86/RdCostX86.h	2022-05-13 17:45:28.816149879 +0200
@@ -274,7 +274,7 @@
   else
   {
     // Do with step of 4
-    CHECK( ( iCols & 3 ) != 0, "Not divisible by 4: " << iCols );
+    CHECK_VTM( ( iCols & 3 ) != 0, "Not divisible by 4: " << iCols );
     __m128i vzero = _mm_setzero_si128();
     __m128i vsum32 = vzero;
     for( int iY = 0; iY < iRows; iY += iSubStep )
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/AnnexBread.cpp ../VVCSoftware_10/source/Lib/DecoderLib/AnnexBread.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/AnnexBread.cpp	2022-09-16 14:27:06.140532690 +0200
+++ ../VVCSoftware_10/source/Lib/DecoderLib/AnnexBread.cpp	2022-05-13 17:45:28.744150695 +0200
@@ -107,7 +107,7 @@
     statBits.bits+=8; statBits.count++;
 #endif
 #endif
-    CHECK( zero_byte != 0, "Zero byte not '0'" );
+    CHECK_VTM( zero_byte != 0, "Zero byte not '0'" );
     stats.m_numZeroByteBytes++;
   }
 
@@ -181,7 +181,7 @@
     statBits.bits+=8; statBits.count++;
 #endif
 #endif
-    CHECK( trailing_zero_8bits != 0, "Trailing zero bits not '0'" );
+    CHECK_VTM( trailing_zero_8bits != 0, "Trailing zero bits not '0'" );
     stats.m_numTrailingZero8BitsBytes++;
   }
 }
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/AnnexBread.h ../VVCSoftware_10/source/Lib/DecoderLib/AnnexBread.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/AnnexBread.h	2022-09-16 14:27:06.140532690 +0200
+++ ../VVCSoftware_10/source/Lib/DecoderLib/AnnexBread.h	2022-05-13 17:45:28.740150740 +0200
@@ -86,7 +86,7 @@
    */
   bool eofBeforeNBytes(uint32_t n)
   {
-    CHECK(n > 4, "Unsupported look-ahead value");
+    CHECK_VTM(n > 4, "Unsupported look-ahead value");
     if (m_NumFutureBytes >= n)
     {
       return false;
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/BinDecoder.cpp ../VVCSoftware_10/source/Lib/DecoderLib/BinDecoder.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/BinDecoder.cpp	2022-09-16 14:27:06.140532690 +0200
+++ ../VVCSoftware_10/source/Lib/DecoderLib/BinDecoder.cpp	2022-05-13 17:45:28.748150649 +0200
@@ -72,7 +72,7 @@
 
 void BinDecoderBase::start()
 {
-  CHECK( m_Bitstream->getNumBitsUntilByteAligned(), "Bitstream is not byte aligned." );
+  CHECK_VTM( m_Bitstream->getNumBitsUntilByteAligned(), "Bitstream is not byte aligned." );
 #if RExt__DECODER_DEBUG_BIT_STATISTICS
   CodingStatistics::UpdateCABACStat(STATS__CABAC_INITIALISATION, 512, 510, 0);
 #endif
@@ -86,7 +86,7 @@
 {
   unsigned lastByte;
   m_Bitstream->peekPreviousByte( lastByte );
-  CHECK( ( ( lastByte << ( 8 + m_bitsNeeded ) ) & 0xff ) != 0x80,
+  CHECK_VTM( ( ( lastByte << ( 8 + m_bitsNeeded ) ) & 0xff ) != 0x80,
         "No proper stop/alignment pattern at end of CABAC stream." );
 }
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/CABACReader.cpp ../VVCSoftware_10/source/Lib/DecoderLib/CABACReader.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/CABACReader.cpp	2022-09-16 14:27:06.140532690 +0200
+++ ../VVCSoftware_10/source/Lib/DecoderLib/CABACReader.cpp	2022-05-13 17:45:28.644151827 +0200
@@ -112,7 +112,7 @@
 {
   if( noTrailingBytesExpected )
   {
-    CHECK( 0 != m_Bitstream->getNumBitsLeft(), "Bits left when not supposed" );
+    CHECK_VTM( 0 != m_Bitstream->getNumBitsLeft(), "Bits left when not supposed" );
   }
   else
   {
@@ -178,7 +178,7 @@
         if( isChroma( (ComponentID)compIdx ) )
         {
           int apsIdx = cs.slice->getTileGroupApsIdChroma();
-          CHECK(cs.slice->getAlfAPSs()[apsIdx] == nullptr, "APS not initialized");
+          CHECK_VTM(cs.slice->getAlfAPSs()[apsIdx] == nullptr, "APS not initialized");
           const AlfParam& alfParam = cs.slice->getAlfAPSs()[apsIdx]->getAlfAPSParam();
           const int numAlts = alfParam.numAlternativesChroma;
           uint8_t* ctbAlfAlternative = cs.slice->getPic()->getAlfCtuAlternativeData( compIdx );
@@ -497,7 +497,7 @@
 
   const PartSplit splitMode = split_cu_mode( cs, partitioner );
 
-  CHECK( !partitioner.canSplit( splitMode, cs ), "Got an invalid split!" );
+  CHECK_VTM( !partitioner.canSplit( splitMode, cs ), "Got an invalid split!" );
 
   if( splitMode != CU_DONT_SPLIT )
   {
@@ -520,7 +520,7 @@
           }
           lumaContinue   = partitioner.nextPart(cs);
           chromaContinue = pPartitionerChroma->nextPart(cs);
-          CHECK(lumaContinue != chromaContinue, "luma chroma partition should be matched");
+          CHECK_VTM(lumaContinue != chromaContinue, "luma chroma partition should be matched");
           beContinue = lumaContinue;
         }
         else
@@ -537,7 +537,7 @@
             coding_tree(cs, *pPartitionerChroma, *pCuCtxChroma);
           }
           chromaContinue = pPartitionerChroma->nextPart(cs);
-          CHECK(lumaContinue != chromaContinue, "luma chroma partition should be matched");
+          CHECK_VTM(lumaContinue != chromaContinue, "luma chroma partition should be matched");
           beContinue = lumaContinue;
         }
       }
@@ -582,7 +582,7 @@
       cs.modeType = partitioner.modeType = mode_constraint(cs, partitioner, splitMode);   // change for child nodes
       // decide chroma split or not
       bool chromaNotSplit = modeTypeParent == MODE_TYPE_ALL && partitioner.modeType == MODE_TYPE_INTRA;
-      CHECK(chromaNotSplit && partitioner.chType != CHANNEL_TYPE_LUMA, "chType must be luma");
+      CHECK_VTM(chromaNotSplit && partitioner.chType != CHANNEL_TYPE_LUMA, "chType must be luma");
       if (partitioner.treeType == TREE_D)
       {
         cs.treeType = partitioner.treeType = chromaNotSplit ? TREE_L : TREE_D;
@@ -599,7 +599,7 @@
       partitioner.exitCurrSplit();
       if( chromaNotSplit )
       {
-        CHECK( partitioner.chType != CHANNEL_TYPE_LUMA, "must be luma status" );
+        CHECK_VTM( partitioner.chType != CHANNEL_TYPE_LUMA, "must be luma status" );
         partitioner.chType = CHANNEL_TYPE_CHROMA;
         cs.treeType = partitioner.treeType = TREE_C;
 
@@ -624,7 +624,7 @@
   partitioner.setCUData( cu );
   cu.slice   = cs.slice;
   cu.tileIdx = cs.pps->getTileIdx( currArea.lumaPos() );
-  CHECK( cu.cs->treeType != partitioner.treeType, "treeType mismatch" );
+  CHECK_VTM( cu.cs->treeType != partitioner.treeType, "treeType mismatch" );
   int lumaQPinLocalDualTree = -1;
 
   // Predict QP on start of quantization group
@@ -641,7 +641,7 @@
     //derive chroma qp, but the chroma qp is saved in cuCtx.qp which is used for luma qp
     //therefore, after decoding the chroma CU, the cuCtx.qp shall be recovered to luma qp in order to decode next luma cu qp
     const CodingUnit* colLumaCu = cs.getLumaCU( lumaRefPos );
-    CHECK( colLumaCu == nullptr, "colLumaCU shall exist" );
+    CHECK_VTM( colLumaCu == nullptr, "colLumaCU shall exist" );
     lumaQPinLocalDualTree = cuCtx.qp;
 
     if (colLumaCu)
@@ -829,7 +829,7 @@
 void CABACReader::coding_unit( CodingUnit &cu, Partitioner &partitioner, CUCtx& cuCtx )
 {
   CodingStructure& cs = *cu.cs;
-  CHECK( cu.treeType != partitioner.treeType || cu.modeType != partitioner.modeType, "treeType or modeType mismatch" );
+  CHECK_VTM( cu.treeType != partitioner.treeType || cu.modeType != partitioner.modeType, "treeType or modeType mismatch" );
   DTRACE( g_trace_ctx, D_SYNTAX, "coding_unit() treeType=%d modeType=%d\n", cu.treeType, cu.modeType );
   PredictionUnit&    pu = cs.addPU(cu, partitioner.chType);
   // skip flag
@@ -1237,7 +1237,7 @@
     return;
   }
 
-  CHECK(!(BCW_NUM > 1 && (BCW_NUM == 2 || (BCW_NUM & 0x01) == 1)), " !( BCW_NUM > 1 && ( BCW_NUM == 2 || ( BCW_NUM & 0x01 ) == 1 ) ) ");
+  CHECK_VTM(!(BCW_NUM > 1 && (BCW_NUM == 2 || (BCW_NUM & 0x01) == 1)), " !( BCW_NUM > 1 && ( BCW_NUM == 2 || ( BCW_NUM & 0x01 ) == 1 ) ) ");
 
   RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET(STATS__CABAC_BITS__BCW_IDX);
 
@@ -1373,7 +1373,7 @@
   int mpmFlag[4];
   for( int k = 0; k < numBlocks; k++ )
   {
-    CHECK(numBlocks != 1, "not supported yet");
+    CHECK_VTM(numBlocks != 1, "not supported yet");
     if ( cu.firstPU->multiRefIdx )
     {
       mpmFlag[0] = true;
@@ -1458,7 +1458,7 @@
   }
   PredictionUnit *pu = cu.firstPU;
 
-  CHECK(pu->cu != &cu, "Inkonsistent PU-CU mapping");
+  CHECK_VTM(pu->cu != &cu, "Inkonsistent PU-CU mapping");
   intra_chroma_pred_mode(*pu);
 }
 
@@ -1472,7 +1472,7 @@
   if (symbol == 0)
   {
     pu.intraDir[1] = lmModeList[symbol];
-    CHECK(pu.intraDir[1] != LM_CHROMA_IDX, "should be LM_CHROMA");
+    CHECK_VTM(pu.intraDir[1] != LM_CHROMA_IDX, "should be LM_CHROMA");
   }
   else
   {
@@ -1514,9 +1514,9 @@
   unsigned chromaCandModes[NUM_CHROMA_MODE];
   PU::getIntraChromaCandModes(pu, chromaCandModes);
 
-  CHECK(candId >= NUM_CHROMA_MODE, "Chroma prediction mode index out of bounds");
-  CHECK(PU::isLMCMode(chromaCandModes[candId]), "The intra dir cannot be LM_CHROMA for this path");
-  CHECK(chromaCandModes[candId] == DM_CHROMA_IDX, "The intra dir cannot be DM_CHROMA for this path");
+  CHECK_VTM(candId >= NUM_CHROMA_MODE, "Chroma prediction mode index out of bounds");
+  CHECK_VTM(PU::isLMCMode(chromaCandModes[candId]), "The intra dir cannot be LM_CHROMA for this path");
+  CHECK_VTM(chromaCandModes[candId] == DM_CHROMA_IDX, "The intra dir cannot be DM_CHROMA for this path");
 
   pu.intraDir[1] = chromaCandModes[candId];
 }
@@ -1787,7 +1787,7 @@
   {
     cuPaletteSubblockInfo(cu, compBegin, numComp, subSetId, prevRunPos, prevRunType);
   }
-  CHECK(cu.curPLTSize[compBegin] > maxPltSize, " Current palette size is larger than maximum palette size");
+  CHECK_VTM(cu.curPLTSize[compBegin] > maxPltSize, " Current palette size is larger than maximum palette size");
 }
 
 void CABACReader::cuPaletteSubblockInfo(CodingUnit& cu, ComponentID compBegin, uint32_t numComp, int subSetId, uint32_t& prevRunPos, unsigned& prevRunType)
@@ -2140,7 +2140,7 @@
   {
     RefPicList eCurRefList = (RefPicList)(pu.cu->smvdMode - 1);
     pu.mvd[1 - eCurRefList].set( -pu.mvd[eCurRefList].hor, -pu.mvd[eCurRefList].ver );
-    CHECK(!((pu.mvd[1 - eCurRefList].getHor() >= MVD_MIN) && (pu.mvd[1 - eCurRefList].getHor() <= MVD_MAX)) || !((pu.mvd[1 - eCurRefList].getVer() >= MVD_MIN) && (pu.mvd[1 - eCurRefList].getVer() <= MVD_MAX)), "Illegal MVD value");
+    CHECK_VTM(!((pu.mvd[1 - eCurRefList].getHor() >= MVD_MIN) && (pu.mvd[1 - eCurRefList].getHor() <= MVD_MAX)) || !((pu.mvd[1 - eCurRefList].getVer() >= MVD_MIN) && (pu.mvd[1 - eCurRefList].getVer() <= MVD_MAX)), "Illegal MVD value");
     pu.refIdx[1 - eCurRefList] = pu.cs->slice->getSymRefIdx( 1 - eCurRefList );
   }
 }
@@ -2342,8 +2342,8 @@
       xReadTruncBinCode(splitDir, GEO_NUM_PARTITION_MODE);
       pu.geoSplitDir          = splitDir;
       const int maxNumGeoCand = pu.cs->sps->getMaxNumGeoCand();
-      CHECK(maxNumGeoCand < 2, "Incorrect max number of geo candidates");
-      CHECK(pu.cu->lheight() > 64 || pu.cu->lwidth() > 64, "Incorrect block size of geo flag");
+      CHECK_VTM(maxNumGeoCand < 2, "Incorrect max number of geo candidates");
+      CHECK_VTM(pu.cu->lheight() > 64 || pu.cu->lwidth() > 64, "Incorrect block size of geo flag");
       int numCandminus2 = maxNumGeoCand - 2;
       pu.mergeIdx       = 0;
       int mergeCand0    = 0;
@@ -2706,7 +2706,7 @@
     }
   }
   rMvd = Mv(horAbs, verAbs);
-  CHECK(!((horAbs >= MVD_MIN) && (horAbs <= MVD_MAX)) || !((verAbs >= MVD_MIN) && (verAbs <= MVD_MAX)), "Illegal MVD value");
+  CHECK_VTM(!((horAbs >= MVD_MIN) && (horAbs <= MVD_MAX)) || !((verAbs >= MVD_MIN) && (verAbs <= MVD_MAX)), "Illegal MVD value");
 }
 
 //================================================================================
@@ -2849,7 +2849,7 @@
 {
   RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__DELTA_QP_EP );
 
-  CHECK( predQP == std::numeric_limits<int>::max(), "Invalid predicted QP" );
+  CHECK_VTM( predQP == std::numeric_limits<int>::max(), "Invalid predicted QP" );
   int qpY = predQP;
   int DQp = unary_max_symbol( Ctx::DeltaQP(), Ctx::DeltaQP(1), CU_DQP_TU_CMAX );
   if( DQp >= CU_DQP_TU_CMAX )
@@ -3175,7 +3175,7 @@
 
 static void check_coeff_conformance(const CoeffCodingContext& cctx, const TCoeff coeff)
 {
-  CHECK( coeff < cctx.minCoeff() || coeff > cctx.maxCoeff(),
+  CHECK_VTM( coeff < cctx.minCoeff() || coeff > cctx.maxCoeff(),
          "TransCoeffLevel outside allowable range" );
 }
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/DecCu.cpp ../VVCSoftware_10/source/Lib/DecoderLib/DecCu.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/DecCu.cpp	2022-09-16 14:27:06.140532690 +0200
+++ ../VVCSoftware_10/source/Lib/DecoderLib/DecCu.cpp	2022-05-13 17:45:28.748150649 +0200
@@ -340,10 +340,10 @@
   const PredictionUnit &pu = *tu.cs->getPU(tu.blocks[COMPONENT_Y], CHANNEL_TYPE_LUMA);
   const Slice          &slice = *cs.slice;
 
-  CHECK(!tu.Y().valid() || !tu.Cb().valid() || !tu.Cr().valid(), "Invalid TU");
-  CHECK(&pu != tu.cu->firstPU, "wrong PU fetch");
-  CHECK(tu.cu->ispMode, "adaptive color transform cannot be applied to ISP");
-  CHECK(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "chroma should use DM mode for adaptive color transform");
+  CHECK_VTM(!tu.Y().valid() || !tu.Cb().valid() || !tu.Cr().valid(), "Invalid TU");
+  CHECK_VTM(&pu != tu.cu->firstPU, "wrong PU fetch");
+  CHECK_VTM(tu.cu->ispMode, "adaptive color transform cannot be applied to ISP");
+  CHECK_VTM(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "chroma should use DM mode for adaptive color transform");
 
   bool flag = slice.getLmcsEnabledFlag() && (slice.isIntra() || (!slice.isIntra() && m_pcReshape->getCTUFlag()));
   if (flag && slice.getPicHeader()->getLmcsChromaResidualScaleFlag())
@@ -646,10 +646,10 @@
   m_pcIntraPred->geneIntrainterPred(cu);
 
   // inter prediction
-  CHECK(CU::isIBC(cu) && cu.firstPU->ciipFlag, "IBC and Ciip cannot be used together");
-  CHECK(CU::isIBC(cu) && cu.affine, "IBC and Affine cannot be used together");
-  CHECK(CU::isIBC(cu) && cu.geoFlag, "IBC and geo cannot be used together");
-  CHECK(CU::isIBC(cu) && cu.firstPU->mmvdMergeFlag, "IBC and MMVD cannot be used together");
+  CHECK_VTM(CU::isIBC(cu) && cu.firstPU->ciipFlag, "IBC and Ciip cannot be used together");
+  CHECK_VTM(CU::isIBC(cu) && cu.affine, "IBC and Affine cannot be used together");
+  CHECK_VTM(CU::isIBC(cu) && cu.geoFlag, "IBC and geo cannot be used together");
+  CHECK_VTM(CU::isIBC(cu) && cu.firstPU->mmvdMergeFlag, "IBC and MMVD cannot be used together");
   const bool luma = cu.Y().valid();
   const bool chroma = isChromaEnabled(cu.chromaFormat) && cu.Cb().valid();
   if (luma && (chroma || !isChromaEnabled(cu.chromaFormat)))
@@ -864,7 +864,7 @@
     {
       if (pu.mmvdMergeFlag || pu.cu->mmvdSkip)
       {
-        CHECK(pu.ciipFlag == true, "invalid Ciip");
+        CHECK_VTM(pu.ciipFlag == true, "invalid Ciip");
         if (pu.cs->sps->getSbTMVPEnabledFlag())
         {
           Size bufSize = g_miScaling.scale(pu.lumaSize());
@@ -965,7 +965,7 @@
               pu.mvpNum[eRefList] = affineAMVPInfo.numCand;
 
               //    Mv mv[3];
-              CHECK( pu.refIdx[eRefList] < 0, "Unexpected negative refIdx." );
+              CHECK_VTM( pu.refIdx[eRefList] < 0, "Unexpected negative refIdx." );
               if (!cu.cs->pcv->isEncoder)
               {
                 pu.mvdAffi[eRefList][0].changeAffinePrecAmvr2Internal(pu.cu->imv);
@@ -1004,7 +1004,7 @@
           }
           if (pu.cs->sps->getMaxNumIBCMergeCand() == 1)
           {
-            CHECK( pu.mvpIdx[REF_PIC_LIST_0], "mvpIdx for IBC mode should be 0" );
+            CHECK_VTM( pu.mvpIdx[REF_PIC_LIST_0], "mvpIdx for IBC mode should be 0" );
           }
           pu.mv[REF_PIC_LIST_0] = amvpInfo.mvCand[pu.mvpIdx[REF_PIC_LIST_0]] + mvd;
           pu.mv[REF_PIC_LIST_0].mvCliptoStorageBitDepth();
@@ -1047,7 +1047,7 @@
       const unsigned int  lcuWidth = pu.cs->slice->getSPS()->getMaxCUWidth();
       int xPred = pu.mv[0].getHor() >> MV_FRACTIONAL_BITS_INTERNAL;
       int yPred = pu.mv[0].getVer() >> MV_FRACTIONAL_BITS_INTERNAL;
-      CHECK(!m_pcInterPred->isLumaBvValid(lcuWidth, cuPelX, cuPelY, roiWidth, roiHeight, xPred, yPred), "invalid block vector for IBC detected.");
+      CHECK_VTM(!m_pcInterPred->isLumaBvValid(lcuWidth, cuPelX, cuPelY, roiWidth, roiHeight, xPred, yPred), "invalid block vector for IBC detected.");
     }
   }
 }
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/DecLib.cpp ../VVCSoftware_10/source/Lib/DecoderLib/DecLib.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/DecLib.cpp	2022-09-16 14:27:06.140532690 +0200
+++ ../VVCSoftware_10/source/Lib/DecoderLib/DecLib.cpp	2022-05-13 17:45:28.680151420 +0200
@@ -81,7 +81,7 @@
       bitstreamFile = new std::ifstream( bitstreamFileName.c_str(), std::ifstream::in | std::ifstream::binary );
       bytestream    = new InputByteStream( *bitstreamFile );
 
-      CHECK( !*bitstreamFile, "failed to open bitstream file " << bitstreamFileName.c_str() << " for reading" ) ;
+      CHECK_VTM( !*bitstreamFile, "failed to open bitstream file " << bitstreamFileName.c_str() << " for reading" ) ;
       // create decoder class
       pcDecLib = new DecLib;
       pcDecLib->create();
@@ -151,9 +151,9 @@
             {
               if( pic->poc == poc && (!bDecodeUntilPocFound || expectedPoc == poc ) )
               {
-                CHECK( pcEncPic->slices.size() == 0, "at least one slice should be available" );
+                CHECK_VTM( pcEncPic->slices.size() == 0, "at least one slice should be available" );
 
-                CHECK( expectedPoc != poc, "mismatch in POC - check encoder configuration" );
+                CHECK_VTM( expectedPoc != poc, "mismatch in POC - check encoder configuration" );
 
                 if( debugCTU < 0 || poc != debugPOC )
                 {
@@ -355,7 +355,7 @@
 
   if( !bRet )
   {
-    CHECK( bDecodeUntilPocFound, " decoding failed - check decodeBitstream2 parameter File: " << bitstreamFileName.c_str() );
+    CHECK_VTM( bDecodeUntilPocFound, " decoding failed - check decodeBitstream2 parameter File: " << bitstreamFileName.c_str() );
     if( pcDecLib )
     {
       pcDecLib->destroy();
@@ -850,7 +850,7 @@
   msg( INFO, "\ninserting lost poc : %d\n",iLostPoc);
   Picture *cFillPic = xGetNewPicBuffer( *( m_parameterSetManager.getFirstSPS() ), *( m_parameterSetManager.getFirstPPS() ), 0, layerId );
 
-  CHECK( !cFillPic->slices.size(), "No slices in picture" );
+  CHECK_VTM( !cFillPic->slices.size(), "No slices in picture" );
 
   cFillPic->slices[0]->initSlice();
 
@@ -894,7 +894,7 @@
   msg(INFO, "\ninserting unavailable poc : %d\n", iUnavailablePoc);
   Picture* cFillPic = xGetNewPicBuffer( *( m_parameterSetManager.getFirstSPS() ), *( m_parameterSetManager.getFirstPPS() ), 0, layerId );
 
-  CHECK(!cFillPic->slices.size(), "No slices in picture");
+  CHECK_VTM(!cFillPic->slices.size(), "No slices in picture");
 
   cFillPic->slices[0]->initSlice();
 
@@ -929,7 +929,7 @@
   if (m_prevEOS[layerId])
   {
     bool isIrapOrGdrPu = !m_pcPic->cs->pps->getMixedNaluTypesInPicFlag() && ( m_pcPic->slices[0]->isIRAP() || m_pcPic->slices[0]->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR );
-    CHECK(!isIrapOrGdrPu, "when present, the next PU of a particular layer after an EOS NAL unit that belongs to the same layer shall be an IRAP or GDR PU");
+    CHECK_VTM(!isIrapOrGdrPu, "when present, the next PU of a particular layer after an EOS NAL unit that belongs to the same layer shall be an IRAP or GDR PU");
 
     m_prevEOS[layerId] = false;
   }
@@ -956,7 +956,7 @@
           break;
         }
       }
-      CHECK(!layerIdFind, "each picture in an AU in a CVS shall have nuh_layer_id equal to the nuh_layer_id of one of the pictures present in the first AU of the CVS");
+      CHECK_VTM(!layerIdFind, "each picture in an AU in a CVS shall have nuh_layer_id equal to the nuh_layer_id of one of the pictures present in the first AU of the CVS");
     }
 
 
@@ -975,7 +975,7 @@
             break;
           }
         }
-        CHECK(!eosLayerIdFind, "When nal_unit_type is equal to EOS_NUT, nuh_layer_id shall be equal to one of the nuh_layer_id values of the layers present in the CVS");
+        CHECK_VTM(!eosLayerIdFind, "When nal_unit_type is equal to EOS_NUT, nuh_layer_id shall be equal to one of the nuh_layer_id values of the layers present in the CVS");
       }
     }
   }
@@ -997,7 +997,7 @@
   {
     bool anchor = m_accessUnitNoOutputPriorPicFlags[0];
     bool isDiffFlagsInAu = std::find(m_accessUnitNoOutputPriorPicFlags.begin(), m_accessUnitNoOutputPriorPicFlags.end(), !anchor) != m_accessUnitNoOutputPriorPicFlags.end();
-    CHECK(isDiffFlagsInAu, "The value of no_output_of_prior_pics_flag, when present, is required to be the same for all pictures in an AU");
+    CHECK_VTM(isDiffFlagsInAu, "The value of no_output_of_prior_pics_flag, when present, is required to be the same for all pictures in an AU");
   }
 }
 
@@ -1019,7 +1019,7 @@
       break;
     }
   }
-  CHECK(!isPicTidInAuSame, "All pictures in an AU shall have the same value of TemporalId");
+  CHECK_VTM(!isPicTidInAuSame, "All pictures in an AU shall have the same value of TemporalId");
 
   for (auto tid = m_accessUnitSeiTids.begin(); tid != m_accessUnitSeiTids.end(); tid++)
   {
@@ -1029,7 +1029,7 @@
       break;
     }
   }
-  CHECK(!isSeiTidInAuSameAsAuTid, "The TemporalId of an SEI NAL unit shall be equal to the TemporalId of the AU containing the NAL unit");
+  CHECK_VTM(!isSeiTidInAuSameAsAuTid, "The TemporalId of an SEI NAL unit shall be equal to the TemporalId of the AU containing the NAL unit");
 
   for (auto tempNalu = m_accessUnitNals.begin(); tempNalu != m_accessUnitNals.end(); tempNalu++)
   {
@@ -1039,7 +1039,7 @@
       break;
     }
   }
-  CHECK(!isFdNaluLayerIdSameAsVclNaluLayerId, "The nuh_layer_id of a filler data NAL unit shall be equal to the nuh_layer_id of associated VCL NAL unit");
+  CHECK_VTM(!isFdNaluLayerIdSameAsVclNaluLayerId, "The nuh_layer_id of a filler data NAL unit shall be equal to the nuh_layer_id of associated VCL NAL unit");
 
   for (auto tempNalu = m_accessUnitNals.begin(); tempNalu != m_accessUnitNals.end(); tempNalu++)
   {
@@ -1049,7 +1049,7 @@
       break;
     }
   }
-  CHECK(!isFdTidInAuSameAsAuTid, "The TemporalId of a filler data NAL unit shall be equal to the TemporalId of the AU containing the NAL unit");
+  CHECK_VTM(!isFdTidInAuSameAsAuTid, "The TemporalId of a filler data NAL unit shall be equal to the TemporalId of the AU containing the NAL unit");
 }
 
 void DecLib::checkSEIInAccessUnit()
@@ -1084,7 +1084,7 @@
           break;
         }
       }
-      CHECK(!olsIncludeAllLayersFind, "When there is no OLS that includes all layers in the current CVS in the entire bitstream, there shall be no non-scalable-nested SEI message with payloadType equal to 0 (BP), 1 (PT), 130 (DUI), or 203 (SLI)");
+      CHECK_VTM(!olsIncludeAllLayersFind, "When there is no OLS that includes all layers in the current CVS in the entire bitstream, there shall be no non-scalable-nested SEI message with payloadType equal to 0 (BP), 1 (PT), 130 (DUI), or 203 (SLI)");
     }
   }
 }
@@ -1172,7 +1172,7 @@
         }
       }
     }    
-    CHECK(count > 4, "There shall be less than or equal to 4 identical sei_payload( ) syntax structures within a picture unit.");
+    CHECK_VTM(count > 4, "There shall be less than or equal to 4 identical sei_payload( ) syntax structures within a picture unit.");
   }
 
   // free SEI message list memory
@@ -1246,11 +1246,11 @@
     if (NALUnit::isVclNalUnitType(nalu))
     {
       firstVCLFound = true;
-      CHECK( suffixAPSFound, "When any suffix APS NAL units are present in a PU, they shall follow the last VCL unit of the PU" );
+      CHECK_VTM( suffixAPSFound, "When any suffix APS NAL units are present in a PU, they shall follow the last VCL unit of the PU" );
     }
     else if (nalu == NAL_UNIT_PREFIX_APS)
     {
-      CHECK( firstVCLFound, "When any prefix APS NAL units are present in a PU, they shall precede the first VCL unit of the PU");
+      CHECK_VTM( firstVCLFound, "When any prefix APS NAL units are present in a PU, they shall precede the first VCL unit of the PU");
     }
     else if (nalu == NAL_UNIT_SUFFIX_APS)
     {
@@ -1278,12 +1278,12 @@
           THROW("APS activation failed!");
         }
 
-        CHECK( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+        CHECK_VTM( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
         //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
 
-        CHECK( sps->getChromaFormatIdc() == CHROMA_400 && aps->chromaPresentFlag, "When ChromaArrayType is equal to 0, the value of aps_chroma_present_flag of an ALF_APS shall be equal to 0" );
+        CHECK_VTM( sps->getChromaFormatIdc() == CHROMA_400 && aps->chromaPresentFlag, "When ChromaArrayType is equal to 0, the value of aps_chroma_present_flag of an ALF_APS shall be equal to 0" );
 
-        CHECK(((sps->getCCALFEnabledFlag() == false) && (aps->getCcAlfAPSParam().newCcAlfFilter[0] || aps->getCcAlfAPSParam().newCcAlfFilter[1])), "When sps_ccalf_enabled_flag is 0, the values of alf_cc_cb_filter_signal_flag and alf_cc_cr_filter_signal_flag shall be equal to 0");
+        CHECK_VTM(((sps->getCCALFEnabledFlag() == false) && (aps->getCcAlfAPSParam().newCcAlfFilter[0] || aps->getCcAlfAPSParam().newCcAlfFilter[1])), "When sps_ccalf_enabled_flag is 0, the values of alf_cc_cb_filter_signal_flag and alf_cc_cr_filter_signal_flag shall be equal to 0");
       }
     }
   }
@@ -1300,10 +1300,10 @@
         THROW("APS activation failed!");
       }
 
-      CHECK( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+      CHECK_VTM( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
       //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
 
-      CHECK(((sps->getCCALFEnabledFlag() == false) && (aps->getCcAlfAPSParam().newCcAlfFilter[0] || aps->getCcAlfAPSParam().newCcAlfFilter[1])), "When sps_ccalf_enabled_flag is 0, the values of alf_cc_cb_filter_signal_flag and alf_cc_cr_filter_signal_flag shall be equal to 0");
+      CHECK_VTM(((sps->getCCALFEnabledFlag() == false) && (aps->getCcAlfAPSParam().newCcAlfFilter[0] || aps->getCcAlfAPSParam().newCcAlfFilter[1])), "When sps_ccalf_enabled_flag is 0, the values of alf_cc_cb_filter_signal_flag and alf_cc_cr_filter_signal_flag shall be equal to 0");
     }
   }
 
@@ -1329,7 +1329,7 @@
         THROW("APS activation failed!");
       }
 
-      CHECK( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+      CHECK_VTM( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
       //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
 
       filterParam.ccAlfFilterCount[COMPONENT_Cb - 1] = aps->getCcAlfAPSParam().ccAlfFilterCount[COMPONENT_Cb - 1];
@@ -1357,7 +1357,7 @@
         THROW("APS activation failed!");
       }
 
-      CHECK( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+      CHECK_VTM( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
       //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
 
       filterParam.ccAlfFilterCount[COMPONENT_Cr - 1] = aps->getCcAlfAPSParam().ccAlfFilterCount[COMPONENT_Cr - 1];
@@ -1376,7 +1376,7 @@
   if (picHeader->getLmcsEnabledFlag() && lmcsAPS == nullptr)
   {
     lmcsAPS = parameterSetManager.getAPS(picHeader->getLmcsAPSId(), LMCS_APS);
-    CHECK(lmcsAPS == nullptr, "No LMCS APS present");
+    CHECK_VTM(lmcsAPS == nullptr, "No LMCS APS present");
     if (lmcsAPS)
     {
       parameterSetManager.clearAPSChangedFlag(picHeader->getLmcsAPSId(), LMCS_APS);
@@ -1385,11 +1385,11 @@
         THROW("LMCS APS activation failed!");
       }
 
-      CHECK( sps->getChromaFormatIdc() == CHROMA_400 && lmcsAPS->chromaPresentFlag, "When ChromaArrayType is equal to 0, the value of aps_chroma_present_flag of an LMCS_APS shall be equal to 0");
+      CHECK_VTM( sps->getChromaFormatIdc() == CHROMA_400 && lmcsAPS->chromaPresentFlag, "When ChromaArrayType is equal to 0, the value of aps_chroma_present_flag of an LMCS_APS shall be equal to 0");
 
-      CHECK( lmcsAPS->getReshaperAPSInfo().maxNbitsNeededDeltaCW - 1 < 0 || lmcsAPS->getReshaperAPSInfo().maxNbitsNeededDeltaCW - 1 > sps->getBitDepth(CHANNEL_TYPE_LUMA) - 2, "The value of lmcs_delta_cw_prec_minus1 of an LMCS_APS shall be in the range of 0 to BitDepth 2, inclusive" );
+      CHECK_VTM( lmcsAPS->getReshaperAPSInfo().maxNbitsNeededDeltaCW - 1 < 0 || lmcsAPS->getReshaperAPSInfo().maxNbitsNeededDeltaCW - 1 > sps->getBitDepth(CHANNEL_TYPE_LUMA) - 2, "The value of lmcs_delta_cw_prec_minus1 of an LMCS_APS shall be in the range of 0 to BitDepth 2, inclusive" );
 
-      CHECK( lmcsAPS->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+      CHECK_VTM( lmcsAPS->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
       //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
     }
   }
@@ -1398,7 +1398,7 @@
   if( picHeader->getExplicitScalingListEnabledFlag() && scalingListAPS == nullptr)
   {
     scalingListAPS = parameterSetManager.getAPS( picHeader->getScalingListAPSId(), SCALING_LIST_APS );
-    CHECK( scalingListAPS == nullptr, "No SCALING LIST APS present" );
+    CHECK_VTM( scalingListAPS == nullptr, "No SCALING LIST APS present" );
     if( scalingListAPS )
     {
       parameterSetManager.clearAPSChangedFlag( picHeader->getScalingListAPSId(), SCALING_LIST_APS );
@@ -1407,10 +1407,10 @@
         THROW( "SCALING LIST APS activation failed!" );
       }
 
-      CHECK( (sps->getChromaFormatIdc() == CHROMA_400 && scalingListAPS->chromaPresentFlag) || (sps->getChromaFormatIdc() != CHROMA_400 && !scalingListAPS->chromaPresentFlag),
+      CHECK_VTM( (sps->getChromaFormatIdc() == CHROMA_400 && scalingListAPS->chromaPresentFlag) || (sps->getChromaFormatIdc() != CHROMA_400 && !scalingListAPS->chromaPresentFlag),
         "The value of aps_chroma_present_flag of the APS NAL unit having aps_params_type equal to SCALING_APS and adaptation_parameter_set_id equal to ph_scaling_list_aps_id shall be equal to ChromaArrayType  = =  0 ? 0 : 1" );
 
-      CHECK( scalingListAPS->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+      CHECK_VTM( scalingListAPS->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
       //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
     }
   }
@@ -1424,7 +1424,7 @@
   const APS* scalinglistAPS = m_pcPic->cs->scalinglistAps;
   APS** apss = m_parameterSetManager.getAPSs();
 
-  CHECK(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
+  CHECK_VTM(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
         pps->getTemporalId() == nalu.m_temporalId &&
         pps->getPuCounter() > m_puCounter, "Violating Parameter Sets Inclusion Indication SEI constraint");
 
@@ -1432,20 +1432,20 @@
   {
     if (apss[i] != nullptr)
     {
-      CHECK(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
+      CHECK_VTM(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
             apss[i]->getTemporalId() == nalu.m_temporalId &&
             apss[i]->getPuCounter() > m_puCounter, "Violating Parameter Sets Inclusion Indication SEI constraint");
     }
   }
   if (lmcsAPS != nullptr)
   {
-    CHECK(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
+    CHECK_VTM(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
           lmcsAPS->getTemporalId() == nalu.m_temporalId &&
           lmcsAPS->getPuCounter() > m_puCounter, "Violating Parameter Sets Inclusion Indication SEI constraint");
   }
   if (scalinglistAPS != nullptr)
   {
-    CHECK(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
+    CHECK_VTM(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
           scalinglistAPS->getTemporalId() == nalu.m_temporalId &&
           scalinglistAPS->getPuCounter() > m_puCounter, "Violating Parameter Sets Inclusion Indication SEI constraint");
   }
@@ -1459,13 +1459,13 @@
     APS** apss = m_parameterSetManager.getAPSs();
     memset(apss, 0, sizeof(*apss) * ALF_CTB_MAX_NUM_APS);
     const PPS *pps = m_parameterSetManager.getPPS(m_picHeader.getPPSId()); // this is a temporary PPS object. Do not store this value
-    CHECK(pps == 0, "Referred to PPS not present");
+    CHECK_VTM(pps == 0, "Referred to PPS not present");
 
     const SPS *sps = m_parameterSetManager.getSPS(pps->getSPSId());             // this is a temporary SPS object. Do not store this value
-    CHECK(sps == 0, "Referred to SPS not present");
+    CHECK_VTM(sps == 0, "Referred to SPS not present");
 
     const VPS *vps = m_parameterSetManager.getVPS( sps->getVPSId() );
-    CHECK(vps == 0, "Referred to VPS not present");
+    CHECK_VTM(vps == 0, "Referred to VPS not present");
 
     if( nullptr != pps->pcv )
     {
@@ -1492,7 +1492,7 @@
     else
     {
       //VPS in the bitstream: check that SPS and VPS signalling are compatible
-      CHECK(sps->getMaxTLayers() > m_vps->getMaxSubLayers(), "The SPS signals more temporal sub-layers than allowed by the VPS");
+      CHECK_VTM(sps->getMaxTLayers() > m_vps->getMaxSubLayers(), "The SPS signals more temporal sub-layers than allowed by the VPS");
     }
 
     m_parameterSetManager.getApsMap()->clearActive();
@@ -1527,7 +1527,7 @@
 
     m_pcPic->allocateNewSlice();
     // make the slice-pilot a real slice, and set up the slice-pilot for the next slice
-    CHECK(m_pcPic->slices.size() != (m_uiSliceSegmentIdx + 1), "Invalid number of slices");
+    CHECK_VTM(m_pcPic->slices.size() != (m_uiSliceSegmentIdx + 1), "Invalid number of slices");
     m_apcSlicePilot = m_pcPic->swapSliceObject(m_apcSlicePilot, m_uiSliceSegmentIdx);
 
     // we now have a real slice:
@@ -1624,7 +1624,7 @@
   {
     // make the slice-pilot a real slice, and set up the slice-pilot for the next slice
     m_pcPic->allocateNewSlice();
-    CHECK(m_pcPic->slices.size() != (size_t)(m_uiSliceSegmentIdx + 1), "Invalid number of slices");
+    CHECK_VTM(m_pcPic->slices.size() != (size_t)(m_uiSliceSegmentIdx + 1), "Invalid number of slices");
     m_apcSlicePilot = m_pcPic->swapSliceObject(m_apcSlicePilot, m_uiSliceSegmentIdx);
 
     Slice *pSlice = m_pcPic->slices[m_uiSliceSegmentIdx]; // we now have a real slice.
@@ -1709,18 +1709,18 @@
     {
       m_clsVPSid = sps->getVPSId();
     }
-    CHECK(m_clsVPSid != sps->getVPSId(), "The value of sps_video_parameter_set_id shall be the same in all SPSs that are referred to by CLVSs in a CVS.");
+    CHECK_VTM(m_clsVPSid != sps->getVPSId(), "The value of sps_video_parameter_set_id shall be the same in all SPSs that are referred to by CLVSs in a CVS.");
   }
 
   if (((vps!=nullptr)&&(vps->getVPSGeneralHrdParamsPresentFlag()))||(sps->getGeneralHrdParametersPresentFlag()))
   {
     if (((vps != nullptr) && (vps->getVPSGeneralHrdParamsPresentFlag())) && (sps->getGeneralHrdParametersPresentFlag()))
     {
-      CHECK(!(*vps->getGeneralHrdParameters() == *sps->getGeneralHrdParameters()), "It is a requirement of bitstream conformance that the content of the general_hrd_parameters( ) syntax structure present in any VPSs or SPSs in the bitstream shall be identical");
+      CHECK_VTM(!(*vps->getGeneralHrdParameters() == *sps->getGeneralHrdParameters()), "It is a requirement of bitstream conformance that the content of the general_hrd_parameters( ) syntax structure present in any VPSs or SPSs in the bitstream shall be identical");
     }
     if (!m_isFirstGeneralHrd)
     {
-      CHECK(!(m_prevGeneralHrdParams == (sps->getGeneralHrdParametersPresentFlag() ? *sps->getGeneralHrdParameters() : *vps->getGeneralHrdParameters())), "It is a requirement of bitstream conformance that the content of the general_hrd_parameters( ) syntax structure present in any VPSs or SPSs in the bitstream shall be identical");
+      CHECK_VTM(!(m_prevGeneralHrdParams == (sps->getGeneralHrdParametersPresentFlag() ? *sps->getGeneralHrdParameters() : *vps->getGeneralHrdParameters())), "It is a requirement of bitstream conformance that the content of the general_hrd_parameters( ) syntax structure present in any VPSs or SPSs in the bitstream shall be identical");
     }
     m_prevGeneralHrdParams = (sps->getGeneralHrdParametersPresentFlag() ? *sps->getGeneralHrdParameters() : *vps->getGeneralHrdParameters());
   }
@@ -1732,44 +1732,44 @@
     m_clvssSPSid[layerId] = pps->getSPSId();
   }
 
-  CHECK( m_clvssSPSid[layerId] != pps->getSPSId(), "The value of pps_seq_parameter_set_id shall be the same in all PPSs that are referred to by coded pictures in a CLVS" );
+  CHECK_VTM( m_clvssSPSid[layerId] != pps->getSPSId(), "The value of pps_seq_parameter_set_id shall be the same in all PPSs that are referred to by coded pictures in a CLVS" );
 
-  CHECK(sps->getGDREnabledFlag() == false && m_picHeader.getGdrPicFlag(), "When sps_gdr_enabled_flag is equal to 0, the value of ph_gdr_pic_flag shall be equal to 0 ");
+  CHECK_VTM(sps->getGDREnabledFlag() == false && m_picHeader.getGdrPicFlag(), "When sps_gdr_enabled_flag is equal to 0, the value of ph_gdr_pic_flag shall be equal to 0 ");
   if( !sps->getUseWP() )
   {
-    CHECK( pps->getUseWP(), "When sps_weighted_pred_flag is equal to 0, the value of pps_weighted_pred_flag shall be equal to 0." );
+    CHECK_VTM( pps->getUseWP(), "When sps_weighted_pred_flag is equal to 0, the value of pps_weighted_pred_flag shall be equal to 0." );
   }
 
   if( !sps->getUseWPBiPred() )
   {
-    CHECK( pps->getWPBiPred(), "When sps_weighted_bipred_flag is equal to 0, the value of pps_weighted_bipred_flag shall be equal to 0." );
+    CHECK_VTM( pps->getWPBiPred(), "When sps_weighted_bipred_flag is equal to 0, the value of pps_weighted_bipred_flag shall be equal to 0." );
   }
 
   const int minCuSize = 1 << sps->getLog2MinCodingBlockSize();
-  CHECK( ( pps->getPicWidthInLumaSamples() % ( std::max( 8, minCuSize) ) ) != 0, "Coded frame width must be a multiple of Max(8, the minimum unit size)" );
-  CHECK( ( pps->getPicHeightInLumaSamples() % ( std::max( 8, minCuSize) ) ) != 0, "Coded frame height must be a multiple of Max(8, the minimum unit size)" );
+  CHECK_VTM( ( pps->getPicWidthInLumaSamples() % ( std::max( 8, minCuSize) ) ) != 0, "Coded frame width must be a multiple of Max(8, the minimum unit size)" );
+  CHECK_VTM( ( pps->getPicHeightInLumaSamples() % ( std::max( 8, minCuSize) ) ) != 0, "Coded frame height must be a multiple of Max(8, the minimum unit size)" );
   if (!sps->getResChangeInClvsEnabledFlag())
   {
-    CHECK(pps->getPicWidthInLumaSamples() != sps->getMaxPicWidthInLumaSamples(), "When sps_res_change_in_clvs_allowed_flag equal to 0, the value of pps_pic_width_in_luma_samples shall be equal to sps_pic_width_max_in_luma_samples.");
-    CHECK(pps->getPicHeightInLumaSamples() != sps->getMaxPicHeightInLumaSamples(), "When sps_res_change_in_clvs_allowed_flag equal to 0, the value of pps_pic_height_in_luma_samples shall be equal to sps_pic_height_max_in_luma_samples.");
+    CHECK_VTM(pps->getPicWidthInLumaSamples() != sps->getMaxPicWidthInLumaSamples(), "When sps_res_change_in_clvs_allowed_flag equal to 0, the value of pps_pic_width_in_luma_samples shall be equal to sps_pic_width_max_in_luma_samples.");
+    CHECK_VTM(pps->getPicHeightInLumaSamples() != sps->getMaxPicHeightInLumaSamples(), "When sps_res_change_in_clvs_allowed_flag equal to 0, the value of pps_pic_height_in_luma_samples shall be equal to sps_pic_height_max_in_luma_samples.");
   }
   if (sps->getResChangeInClvsEnabledFlag())
   {
-    CHECK(sps->getSubPicInfoPresentFlag() != 0, "When sps_res_change_in_clvs_allowed_flag is equal to 1, the value of sps_subpic_info_present_flag shall be equal to 0.");
+    CHECK_VTM(sps->getSubPicInfoPresentFlag() != 0, "When sps_res_change_in_clvs_allowed_flag is equal to 1, the value of sps_subpic_info_present_flag shall be equal to 0.");
   }
-  CHECK(sps->getResChangeInClvsEnabledFlag() && sps->getVirtualBoundariesEnabledFlag(), "when the value of sps_res_change_in_clvs_allowed_flag is equal to 1, the value of sps_virtual_boundaries_present_flag shall be equal to 0");
+  CHECK_VTM(sps->getResChangeInClvsEnabledFlag() && sps->getVirtualBoundariesEnabledFlag(), "when the value of sps_res_change_in_clvs_allowed_flag is equal to 1, the value of sps_virtual_boundaries_present_flag shall be equal to 0");
 
   if( sps->getCTUSize() + 2 * ( 1 << sps->getLog2MinCodingBlockSize() ) > pps->getPicWidthInLumaSamples() )
   {
-    CHECK( pps->getWrapAroundEnabledFlag(), "Wraparound shall be disabled when the value of ( CtbSizeY / MinCbSizeY + 1) is greater than or equal to ( pps_pic_width_in_luma_samples / MinCbSizeY - 1 )" );
+    CHECK_VTM( pps->getWrapAroundEnabledFlag(), "Wraparound shall be disabled when the value of ( CtbSizeY / MinCbSizeY + 1) is greater than or equal to ( pps_pic_width_in_luma_samples / MinCbSizeY - 1 )" );
   }
 
   if( vps != nullptr && vps->m_numOutputLayersInOls[vps->m_targetOlsIdx] > 1 )
   {
-    CHECK( sps->getMaxPicWidthInLumaSamples() > vps->getOlsDpbPicSize( vps->m_targetOlsIdx ).width, "sps_pic_width_max_in_luma_samples shall be less than or equal to the value of vps_ols_dpb_pic_width[ i ]" );
-    CHECK( sps->getMaxPicHeightInLumaSamples() > vps->getOlsDpbPicSize( vps->m_targetOlsIdx ).height, "sps_pic_height_max_in_luma_samples shall be less than or equal to the value of vps_ols_dpb_pic_height[ i ]" );
-    CHECK( sps->getChromaFormatIdc() > vps->getOlsDpbChromaFormatIdc( vps->m_targetOlsIdx ), "sps_chroma_format_idc shall be less than or equal to the value of vps_ols_dpb_chroma_format[ i ]");
-    CHECK((sps->getBitDepth(CHANNEL_TYPE_LUMA) - 8) > vps->getOlsDpbBitDepthMinus8(vps->m_targetOlsIdx),
+    CHECK_VTM( sps->getMaxPicWidthInLumaSamples() > vps->getOlsDpbPicSize( vps->m_targetOlsIdx ).width, "sps_pic_width_max_in_luma_samples shall be less than or equal to the value of vps_ols_dpb_pic_width[ i ]" );
+    CHECK_VTM( sps->getMaxPicHeightInLumaSamples() > vps->getOlsDpbPicSize( vps->m_targetOlsIdx ).height, "sps_pic_height_max_in_luma_samples shall be less than or equal to the value of vps_ols_dpb_pic_height[ i ]" );
+    CHECK_VTM( sps->getChromaFormatIdc() > vps->getOlsDpbChromaFormatIdc( vps->m_targetOlsIdx ), "sps_chroma_format_idc shall be less than or equal to the value of vps_ols_dpb_chroma_format[ i ]");
+    CHECK_VTM((sps->getBitDepth(CHANNEL_TYPE_LUMA) - 8) > vps->getOlsDpbBitDepthMinus8(vps->m_targetOlsIdx),
           "sps_bitdepth_minus8 shall be less than or equal to the value of vps_ols_dpb_bitdepth_minus8[ i ]");
   }
 
@@ -1789,8 +1789,8 @@
     }
     else
     {
-      CHECK(m_layerChromaFormat[curLayerIdx] != curLayerChromaFormat, "Different chroma format in the same layer.");
-      CHECK(m_layerBitDepth[curLayerIdx] != curLayerBitDepth, "Different bit-depth in the same layer.");
+      CHECK_VTM(m_layerChromaFormat[curLayerIdx] != curLayerChromaFormat, "Different chroma format in the same layer.");
+      CHECK_VTM(m_layerBitDepth[curLayerIdx] != curLayerBitDepth, "Different bit-depth in the same layer.");
     }
 
     for (int i = 0; i < curLayerIdx; i++)
@@ -1798,75 +1798,75 @@
       if (vps->getDirectRefLayerFlag(curLayerIdx, i))
       {
         int refLayerChromaFormat = m_layerChromaFormat[i];
-        CHECK(curLayerChromaFormat != refLayerChromaFormat, "The chroma formats of the current layer and the reference layer are different");
+        CHECK_VTM(curLayerChromaFormat != refLayerChromaFormat, "The chroma formats of the current layer and the reference layer are different");
         int refLayerBitDepth = m_layerBitDepth[i];
-        CHECK(curLayerBitDepth != refLayerBitDepth, "The bit-depth of the current layer and the reference layer are different");
+        CHECK_VTM(curLayerBitDepth != refLayerBitDepth, "The bit-depth of the current layer and the reference layer are different");
       }
     }
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getOneTilePerPicConstraintFlag())
   {
-    CHECK(pps->getNumTiles() != 1, "When one_tile_per_pic_constraint_flag is equal to 1, each picture shall contain only one tile");
+    CHECK_VTM(pps->getNumTiles() != 1, "When one_tile_per_pic_constraint_flag is equal to 1, each picture shall contain only one tile");
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getOneSlicePerPicConstraintFlag())
   {
-    CHECK( pps->getRectSliceFlag() && pps->getNumSlicesInPic() != 1, "When one_slice_per_pic_constraint_flag is equal to 1 and if pps_rect_slice_flag is equal to 1, the value of pps_num_slices_in_pic_minus1 shall be equal to 0");
+    CHECK_VTM( pps->getRectSliceFlag() && pps->getNumSlicesInPic() != 1, "When one_slice_per_pic_constraint_flag is equal to 1 and if pps_rect_slice_flag is equal to 1, the value of pps_num_slices_in_pic_minus1 shall be equal to 0");
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoRprConstraintFlag())
   {
-    CHECK(sps->getRprEnabledFlag(), "When gci_no_ref_pic_resampling_constraint_flag is equal to 1, the value of sps_ref_pic_resampling_enabled_flag shall be equal to 0");
+    CHECK_VTM(sps->getRprEnabledFlag(), "When gci_no_ref_pic_resampling_constraint_flag is equal to 1, the value of sps_ref_pic_resampling_enabled_flag shall be equal to 0");
   }
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoResChangeInClvsConstraintFlag())
   {
-    CHECK(sps->getResChangeInClvsEnabledFlag(), "When gci_no_res_change_in_clvs_constraint_flag is equal to 1, the value of sps_res_change_in_clvs_allowed_flag shall be equal to 0");
+    CHECK_VTM(sps->getResChangeInClvsEnabledFlag(), "When gci_no_res_change_in_clvs_constraint_flag is equal to 1, the value of sps_res_change_in_clvs_allowed_flag shall be equal to 0");
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoIdrRplConstraintFlag())
   {
-    CHECK(sps->getIDRRefParamListPresent(), "When gci_no_idr_rpl_constraint_flag equal to 1 , the value of sps_idr_rpl_present_flag shall be equal to 0")
+    CHECK_VTM(sps->getIDRRefParamListPresent(), "When gci_no_idr_rpl_constraint_flag equal to 1 , the value of sps_idr_rpl_present_flag shall be equal to 0")
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoMixedNaluTypesInPicConstraintFlag())
   {
-    CHECK(pps->getMixedNaluTypesInPicFlag(), "When gci_no_mixed_nalu_types_in_pic_constraint_flag equal to 1, the value of pps_mixed_nalu_types_in_pic_flag shall be equal to 0")
+    CHECK_VTM(pps->getMixedNaluTypesInPicFlag(), "When gci_no_mixed_nalu_types_in_pic_constraint_flag equal to 1, the value of pps_mixed_nalu_types_in_pic_flag shall be equal to 0")
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoRectSliceConstraintFlag())
   {
-    CHECK(pps->getRectSliceFlag(), "When gci_no_rectangular_slice_constraint_flag equal to 1, the value of pps_rect_slice_flag shall be equal to 0")
+    CHECK_VTM(pps->getRectSliceFlag(), "When gci_no_rectangular_slice_constraint_flag equal to 1, the value of pps_rect_slice_flag shall be equal to 0")
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getOneSlicePerSubpicConstraintFlag())
   {
-    CHECK(!(pps->getSingleSlicePerSubPicFlag()), "When gci_one_slice_per_subpic_constraint_flag equal to 1, the value of pps_single_slice_per_subpic_flag shall be equal to 1")
+    CHECK_VTM(!(pps->getSingleSlicePerSubPicFlag()), "When gci_one_slice_per_subpic_constraint_flag equal to 1, the value of pps_single_slice_per_subpic_flag shall be equal to 1")
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoSubpicInfoConstraintFlag())
   {
-    CHECK(sps->getSubPicInfoPresentFlag(), "When gci_no_subpic_info_constraint_flag is equal to 1, the value of sps_subpic_info_present_flag shall be equal to 0")
+    CHECK_VTM(sps->getSubPicInfoPresentFlag(), "When gci_no_subpic_info_constraint_flag is equal to 1, the value of sps_subpic_info_present_flag shall be equal to 0")
   }
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoMttConstraintFlag())
   {
-    CHECK((sps->getMaxMTTHierarchyDepth() || sps->getMaxMTTHierarchyDepthI() || sps->getMaxMTTHierarchyDepthIChroma()), "When gci_no_mtt_constraint_flag is equal to 1, the values of sps_max_mtt_hierarchy_depth_intra_slice_luma, sps_max_mtt_hierarchy_depth_inter_slice and sps_max_mtt_hierarchy_depth_intra_slice_chroma shall be equal to 0");
+    CHECK_VTM((sps->getMaxMTTHierarchyDepth() || sps->getMaxMTTHierarchyDepthI() || sps->getMaxMTTHierarchyDepthIChroma()), "When gci_no_mtt_constraint_flag is equal to 1, the values of sps_max_mtt_hierarchy_depth_intra_slice_luma, sps_max_mtt_hierarchy_depth_inter_slice and sps_max_mtt_hierarchy_depth_intra_slice_chroma shall be equal to 0");
   }
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoWeightedPredictionConstraintFlag())
   {
-    CHECK((sps->getUseWP() || sps->getUseWPBiPred()), "When gci_no_weighted_prediction_constraint_flag is equal to 1, the values of sps_weighted_pred_flag and sps_weighted_bipred_flag shall be equal to 0");
+    CHECK_VTM((sps->getUseWP() || sps->getUseWPBiPred()), "When gci_no_weighted_prediction_constraint_flag is equal to 1, the values of sps_weighted_pred_flag and sps_weighted_bipred_flag shall be equal to 0");
   }
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoChromaQpOffsetConstraintFlag())
   {
-    CHECK((pps->getCuChromaQpOffsetListEnabledFlag()), "When gci_no_ChromaQpOffset_constraint_flag is equal to 1, the values of pps_cu_chroma_qp_offset_list_enabled_flag shall be equal to 0");
+    CHECK_VTM((pps->getCuChromaQpOffsetListEnabledFlag()), "When gci_no_ChromaQpOffset_constraint_flag is equal to 1, the values of pps_cu_chroma_qp_offset_list_enabled_flag shall be equal to 0");
   }
 
-  CHECK(sps->getCTUSize() > (1 << sps->getProfileTierLevel()->getConstraintInfo()->getMaxLog2CtuSizeConstraintIdc()), "The CTU size specified by sps_log2_ctu_size_minus5 shall not exceed the constraint specified by gci_three_minus_max_log2_ctu_size_constraint_idc");
+  CHECK_VTM(sps->getCTUSize() > (1 << sps->getProfileTierLevel()->getConstraintInfo()->getMaxLog2CtuSizeConstraintIdc()), "The CTU size specified by sps_log2_ctu_size_minus5 shall not exceed the constraint specified by gci_three_minus_max_log2_ctu_size_constraint_idc");
 
   if (sps->getProfileTierLevel()->getConstraintInfo()->getNoLumaTransformSize64ConstraintFlag())
   {
-    CHECK(sps->getLog2MaxTbSize() != 5, "When gci_no_luma_transform_size_64_constraint_flag is equal to 1, the value of sps_max_luma_transform_size_64_flag shall be equal to 0");
+    CHECK_VTM(sps->getLog2MaxTbSize() != 5, "When gci_no_luma_transform_size_64_constraint_flag is equal to 1, the value of sps_max_luma_transform_size_64_flag shall be equal to 0");
   }
 
   if (sps->getMaxPicWidthInLumaSamples() == pps->getPicWidthInLumaSamples() &&
@@ -1874,10 +1874,10 @@
   {
     const Window& spsConfWin = sps->getConformanceWindow();
     const Window& ppsConfWin = pps->getConformanceWindow();
-    CHECK(spsConfWin.getWindowLeftOffset() != ppsConfWin.getWindowLeftOffset(), "When picture size is equal to maximum picutre size, conformance window left offset in SPS and PPS shall be equal");
-    CHECK(spsConfWin.getWindowRightOffset() != ppsConfWin.getWindowRightOffset(), "When picture size is equal to maximum picutre size, conformance window right offset in SPS and PPS shall be equal");
-    CHECK(spsConfWin.getWindowTopOffset() != ppsConfWin.getWindowTopOffset(), "When picture size is equal to maximum picutre size, conformance window top offset in SPS and PPS shall be equal");
-    CHECK(spsConfWin.getWindowBottomOffset() != ppsConfWin.getWindowBottomOffset(), "When picture size is equal to maximum picutre size, conformance window bottom offset in SPS and PPS shall be equal");
+    CHECK_VTM(spsConfWin.getWindowLeftOffset() != ppsConfWin.getWindowLeftOffset(), "When picture size is equal to maximum picutre size, conformance window left offset in SPS and PPS shall be equal");
+    CHECK_VTM(spsConfWin.getWindowRightOffset() != ppsConfWin.getWindowRightOffset(), "When picture size is equal to maximum picutre size, conformance window right offset in SPS and PPS shall be equal");
+    CHECK_VTM(spsConfWin.getWindowTopOffset() != ppsConfWin.getWindowTopOffset(), "When picture size is equal to maximum picutre size, conformance window top offset in SPS and PPS shall be equal");
+    CHECK_VTM(spsConfWin.getWindowBottomOffset() != ppsConfWin.getWindowBottomOffset(), "When picture size is equal to maximum picutre size, conformance window bottom offset in SPS and PPS shall be equal");
   }
   int levelIdcSps = int(sps->getProfileTierLevel()->getLevelIdc());
   int maxLevelIdxDci = 0;
@@ -1890,19 +1890,19 @@
         maxLevelIdxDci = int(m_dci->getProfileTierLevel(i).getLevelIdc());
       }
     }
-    CHECK(levelIdcSps > maxLevelIdxDci, "max level signaled in the DCI shall not be less than the level signaled in the SPS");
+    CHECK_VTM(levelIdcSps > maxLevelIdxDci, "max level signaled in the DCI shall not be less than the level signaled in the SPS");
   }
 
 
   if( slice->getPicHeader()->getGdrOrIrapPicFlag() && !slice->getPicHeader()->getGdrPicFlag() && ( !vps || vps->getIndependentLayerFlag( vps->getGeneralLayerIdx( layerId ) ) ) )
   {
-    CHECK( slice->getPicHeader()->getPicInterSliceAllowedFlag(),
+    CHECK_VTM( slice->getPicHeader()->getPicInterSliceAllowedFlag(),
       "When ph_gdr_or_irap_pic_flag is equal to 1 and ph_gdr_pic_flag is equal to 0 and vps_independent_layer_flag[ GeneralLayerIdx[ nuh_layer_id ] ] is equal to 1, ph_inter_slice_allowed_flag shall be equal to 0" );
   }
 
   if( sps->getVPSId() && vps->m_numLayersInOls[vps->m_targetOlsIdx] == 1 )
   {    
-    CHECK( !sps->getPtlDpbHrdParamsPresentFlag(), "When sps_video_parameter_set_id is greater than 0 and there is an OLS that contains only one layer with nuh_layer_id equal to the nuh_layer_id of the SPS, the value of sps_ptl_dpb_hrd_params_present_flag shall be equal to 1" );
+    CHECK_VTM( !sps->getPtlDpbHrdParamsPresentFlag(), "When sps_video_parameter_set_id is greater than 0 and there is an OLS that contains only one layer with nuh_layer_id equal to the nuh_layer_id of the SPS, the value of sps_ptl_dpb_hrd_params_present_flag shall be equal to 1" );
   }
 
   ProfileLevelTierFeatures ptlFeatures;
@@ -1910,25 +1910,25 @@
   const ProfileFeatures *profileFeatures = ptlFeatures.getProfileFeatures();
   if (profileFeatures != nullptr)
   {
-    CHECK(sps->getBitDepth(CHANNEL_TYPE_LUMA) > profileFeatures->maxBitDepth, "Bit depth exceeds profile limit");
-    CHECK(sps->getChromaFormatIdc() > profileFeatures->maxChromaFormat, "Chroma format exceeds profile limit");
+    CHECK_VTM(sps->getBitDepth(CHANNEL_TYPE_LUMA) > profileFeatures->maxBitDepth, "Bit depth exceeds profile limit");
+    CHECK_VTM(sps->getChromaFormatIdc() > profileFeatures->maxChromaFormat, "Chroma format exceeds profile limit");
   }
   else
   {
-    CHECK(sps->getProfileTierLevel()->getProfileIdc() != Profile::NONE, "Unknown profile");
+    CHECK_VTM(sps->getProfileTierLevel()->getProfileIdc() != Profile::NONE, "Unknown profile");
     msg(WARNING, "Warning: Profile set to none or unknown value\n");
   }
   const LevelTierFeatures *levelTierFeatures = ptlFeatures.getLevelTierFeatures();
   if (levelTierFeatures != nullptr)
   {
-    CHECK(pps->getNumTileColumns() > levelTierFeatures->maxTileCols,
+    CHECK_VTM(pps->getNumTileColumns() > levelTierFeatures->maxTileCols,
           "Number of tile columns signaled in PPS exceeds level limit");
-    CHECK(pps->getNumTiles() > levelTierFeatures->maxTilesPerAu, "Number of tiles signaled in PPS exceeds level limit");
+    CHECK_VTM(pps->getNumTiles() > levelTierFeatures->maxTilesPerAu, "Number of tiles signaled in PPS exceeds level limit");
   }
   else if (profileFeatures != nullptr)
   {
-    CHECK(sps->getProfileTierLevel()->getLevelIdc() == Level::LEVEL15_5, "Cannot use level 15.5 with given profile");
-    CHECK(sps->getProfileTierLevel()->getLevelIdc() != Level::NONE, "Unknown level");
+    CHECK_VTM(sps->getProfileTierLevel()->getLevelIdc() == Level::LEVEL15_5, "Cannot use level 15.5 with given profile");
+    CHECK_VTM(sps->getProfileTierLevel()->getLevelIdc() != Level::NONE, "Unknown level");
     msg(WARNING, "Warning: Level set to none, invalid or unknown value\n");
   }
 }
@@ -1985,7 +1985,7 @@
   }
   else
   {
-    CHECK(nalu.m_nalUnitType != m_pcPic->slices[m_uiSliceSegmentIdx - 1]->getNalUnitType() && !m_pcPic->cs->pps->getMixedNaluTypesInPicFlag(), "If pps_mixed_nalu_types_in_pic_flag is equal to 0, the value of NAL unit type shall be the same for all coded slice NAL units of a picture");
+    CHECK_VTM(nalu.m_nalUnitType != m_pcPic->slices[m_uiSliceSegmentIdx - 1]->getNalUnitType() && !m_pcPic->cs->pps->getMixedNaluTypesInPicFlag(), "If pps_mixed_nalu_types_in_pic_flag is equal to 0, the value of NAL unit type shall be the same for all coded slice NAL units of a picture");
     m_apcSlicePilot->copySliceInfo( m_pcPic->slices[m_uiSliceSegmentIdx-1] );
   }
 
@@ -2003,13 +2003,13 @@
       && naluTemporalId.m_nalUnitType != NAL_UNIT_EOB)
 
     {
-      CHECK( naluTemporalId.m_temporalId < nalu.m_temporalId, "TemporalId shall be greater than or equal to the TemporalId of the layer access unit containing the NAL unit" );
+      CHECK_VTM( naluTemporalId.m_temporalId < nalu.m_temporalId, "TemporalId shall be greater than or equal to the TemporalId of the layer access unit containing the NAL unit" );
     }
   }
 
   if (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_GDR)
   {
-    CHECK(nalu.m_temporalId != 0, "Current GDR picture has TemporalId not equal to 0");
+    CHECK_VTM(nalu.m_temporalId != 0, "Current GDR picture has TemporalId not equal to 0");
   }
 
   m_HLSReader.setBitstream( &nalu.getBitstream() );
@@ -2022,15 +2022,15 @@
   }
 
   PPS *pps = m_parameterSetManager.getPPS(m_picHeader.getPPSId());
-  CHECK(pps == 0, "No PPS present");
+  CHECK_VTM(pps == 0, "No PPS present");
   SPS *sps = m_parameterSetManager.getSPS(pps->getSPSId());
-  CHECK(sps == 0, "No SPS present");
+  CHECK_VTM(sps == 0, "No SPS present");
   VPS *vps = m_parameterSetManager.getVPS(sps->getVPSId());
 
 
   if (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA && vps != nullptr && (vps->getIndependentLayerFlag(vps->getGeneralLayerIdx(nalu.m_nuhLayerId)) == 1))
   {
-    CHECK(nalu.m_temporalId == 0, "TemporalID of STSA picture shall not be zero in independent layers");
+    CHECK_VTM(nalu.m_temporalId == 0, "TemporalID of STSA picture shall not be zero in independent layers");
   }
 
   int currSubPicIdx = pps->getSubPicIdxFromSubPicId( m_apcSlicePilot->getSliceSubPicId() );
@@ -2039,8 +2039,8 @@
   {
     currSliceAddr -= pps->getSubPic(sp).getNumSlicesInSubPic();
   }
-  CHECK( currSubPicIdx < m_maxDecSubPicIdx, "Error in the order of coded slice NAL units of subpictures" );
-  CHECK( currSubPicIdx == m_maxDecSubPicIdx && currSliceAddr <= m_maxDecSliceAddrInSubPic, "Error in the order of coded slice NAL units within a subpicture" );
+  CHECK_VTM( currSubPicIdx < m_maxDecSubPicIdx, "Error in the order of coded slice NAL units of subpictures" );
+  CHECK_VTM( currSubPicIdx == m_maxDecSubPicIdx && currSliceAddr <= m_maxDecSliceAddrInSubPic, "Error in the order of coded slice NAL units within a subpicture" );
   if( currSubPicIdx == m_maxDecSubPicIdx )
   {
     m_maxDecSliceAddrInSubPic = currSliceAddr;
@@ -2052,10 +2052,10 @@
   }
   if ((sps->getVPSId() == 0) && (m_prevLayerID != MAX_INT))
   {
-    CHECK(m_prevLayerID != nalu.m_nuhLayerId, "All VCL NAL unit in the CVS shall have the same value of nuh_layer_id "
+    CHECK_VTM(m_prevLayerID != nalu.m_nuhLayerId, "All VCL NAL unit in the CVS shall have the same value of nuh_layer_id "
                                               "when sps_video_parameter_set_id is equal to 0");
   }
-  CHECK((sps->getVPSId() > 0) && (vps == 0), "Invalid VPS");
+  CHECK_VTM((sps->getVPSId() > 0) && (vps == 0), "Invalid VPS");
 
   if( vps != nullptr && !vps->getIndependentLayerFlag( vps->getGeneralLayerIdx( nalu.m_nuhLayerId ) ) )
   {
@@ -2171,13 +2171,13 @@
 
   {
     PPS *pps = m_parameterSetManager.getPPS(m_picHeader.getPPSId());
-    CHECK(pps == 0, "No PPS present");
+    CHECK_VTM(pps == 0, "No PPS present");
     SPS *sps = m_parameterSetManager.getSPS(pps->getSPSId());
-    CHECK(sps == 0, "No SPS present");
+    CHECK_VTM(sps == 0, "No SPS present");
     if (sps->getVPSId() > 0)
     {
       VPS *vps = m_parameterSetManager.getVPS(sps->getVPSId());
-      CHECK(vps == 0, "No VPS present");
+      CHECK_VTM(vps == 0, "No VPS present");
       bool isCurLayerNotOutput = true;
       for (int i = 0; i < vps->getNumLayersInOls(vps->m_targetOlsIdx); i++)
       {
@@ -2315,12 +2315,12 @@
   if (pcSlice->getSPS()->getProfileTierLevel()->getConstraintInfo()->getNoApsConstraintFlag())
   {
     bool flag = pcSlice->getSPS()->getCCALFEnabledFlag() || pcSlice->getPicHeader()->getNumAlfAps() || pcSlice->getPicHeader()->getAlfEnabledFlag(COMPONENT_Cb) || pcSlice->getPicHeader()->getAlfEnabledFlag(COMPONENT_Cr);
-    CHECK(flag, "When no_aps_constraint_flag is equal to 1, the values of ph_num_alf_aps_ids_luma, sh_num_alf_aps_ids_luma, ph_alf_cb_flag, ph_alf_cr_flag, sh_alf_cb_flag, sh_alf_cr_flag, and sps_ccalf_enabled_flag shall all be equal to 0")
+    CHECK_VTM(flag, "When no_aps_constraint_flag is equal to 1, the values of ph_num_alf_aps_ids_luma, sh_num_alf_aps_ids_luma, ph_alf_cb_flag, ph_alf_cr_flag, sh_alf_cb_flag, sh_alf_cr_flag, and sps_ccalf_enabled_flag shall all be equal to 0")
   }
   if( pcSlice->getNalUnitLayerId() != pcSlice->getSPS()->getLayerId() )
   {
-    CHECK( pcSlice->getSPS()->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of SPS cannot be greater than layer Id of VCL NAL unit the refer to it" );
-    CHECK( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of SPS and layer Id of current slice are different" );
+    CHECK_VTM( pcSlice->getSPS()->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of SPS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+    CHECK_VTM( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of SPS and layer Id of current slice are different" );
     for (int i = 0; i < pcSlice->getVPS()->getNumOutputLayerSets(); i++ )
     {
       bool isCurrLayerInOls = false;
@@ -2337,13 +2337,13 @@
           isRefLayerInOls = true;
         }
       }
-      CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to SPS in layer B, all OLS that contains layer A shall also contains layer B" );
+      CHECK_VTM( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to SPS in layer B, all OLS that contains layer A shall also contains layer B" );
     }
   }
   if( pcSlice->getNalUnitLayerId() != pcSlice->getPPS()->getLayerId() )
   {
-    CHECK( pcSlice->getPPS()->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of PPS cannot be greater than layer Id of VCL NAL unit the refer to it" );
-    CHECK( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of PPS and layer Id of current slice are different" );
+    CHECK_VTM( pcSlice->getPPS()->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of PPS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+    CHECK_VTM( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of PPS and layer Id of current slice are different" );
     for (int i = 0; i < pcSlice->getVPS()->getNumOutputLayerSets(); i++ )
     {
       bool isCurrLayerInOls = false;
@@ -2360,7 +2360,7 @@
           isRefLayerInOls = true;
         }
       }
-      CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to PPS in layer B, all OLS that contains layer A shall also contains layer B" );
+      CHECK_VTM( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to PPS in layer B, all OLS that contains layer A shall also contains layer B" );
     }
   }
 
@@ -2532,8 +2532,8 @@
     APS* scalingListAPS = pcSlice->getPicHeader()->getScalingListAPS();
     if( pcSlice->getNalUnitLayerId() != scalingListAPS->getLayerId() )
     {
-      CHECK( scalingListAPS->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
-      CHECK( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
+      CHECK_VTM( scalingListAPS->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+      CHECK_VTM( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
       for (int i = 0; i < pcSlice->getVPS()->getNumOutputLayerSets(); i++ )
       {
         bool isCurrLayerInOls = false;
@@ -2549,7 +2549,7 @@
             isRefLayerInOls = true;
           }
         }
-        CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
+        CHECK_VTM( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
       }
     }
     ScalingList scalingList = scalingListAPS->getScalingList();
@@ -2574,12 +2574,12 @@
       }
       else
       {
-        CHECK(lmcsAPS->getAPSId() != m_sliceLmcsApsId, "same APS ID shall be used for all slices in one picture");
+        CHECK_VTM(lmcsAPS->getAPSId() != m_sliceLmcsApsId, "same APS ID shall be used for all slices in one picture");
       }
       if( pcSlice->getNalUnitLayerId() != lmcsAPS->getLayerId() )
       {
-        CHECK( lmcsAPS->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
-        CHECK( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
+        CHECK_VTM( lmcsAPS->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+        CHECK_VTM( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
         for (int i = 0; i < pcSlice->getVPS()->getNumOutputLayerSets(); i++ )
         {
           bool isCurrLayerInOls = false;
@@ -2595,7 +2595,7 @@
               isRefLayerInOls = true;
             }
           }
-          CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
+          CHECK_VTM( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
         }
       }
       SliceReshapeInfo& sInfo = lmcsAPS->getReshaperAPSInfo();
@@ -2711,7 +2711,7 @@
   VPS* vps = new VPS();
   m_HLSReader.setBitstream( &nalu.getBitstream() );
 
-  CHECK( nalu.m_temporalId, "The value of TemporalId of VPS NAL units shall be equal to 0" );
+  CHECK_VTM( nalu.m_temporalId, "The value of TemporalId of VPS NAL units shall be equal to 0" );
 
   m_HLSReader.parseVPS( vps );
 
@@ -2731,7 +2731,7 @@
 {
   m_HLSReader.setBitstream(&nalu.getBitstream());
 
-  CHECK(nalu.m_temporalId, "The value of TemporalId of DCI NAL units shall be equal to 0");
+  CHECK_VTM(nalu.m_temporalId, "The value of TemporalId of DCI NAL units shall be equal to 0");
   if (!m_dci)
   {
     m_dci = new DCI;
@@ -2741,7 +2741,7 @@
   {
     DCI dupDCI;
     m_HLSReader.parseDCI(&dupDCI);
-    CHECK( !m_dci->IsIndenticalDCI(dupDCI), "Two signaled DCIs are different");
+    CHECK_VTM( !m_dci->IsIndenticalDCI(dupDCI), "Two signaled DCIs are different");
   }
 }
 
@@ -2750,7 +2750,7 @@
   SPS* sps = new SPS();
   m_HLSReader.setBitstream( &nalu.getBitstream() );
 
-  CHECK( nalu.m_temporalId, "The value of TemporalId of SPS NAL units shall be equal to 0" );
+  CHECK_VTM( nalu.m_temporalId, "The value of TemporalId of SPS NAL units shall be equal to 0" );
 
   m_HLSReader.parseSPS( sps );
   sps->setLayerId( nalu.m_nuhLayerId );
@@ -2987,25 +2987,25 @@
 {
   if (cInfo != NULL)
   {
-    CHECK(cInfo->getNoTrailConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_TRAIL,
+    CHECK_VTM(cInfo->getNoTrailConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_TRAIL,
       "Non-conforming bitstream. no_trail_constraint_flag is equal to 1 but bitstream contains NAL unit of type TRAIL_NUT.");
-    CHECK(cInfo->getNoStsaConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_STSA,
+    CHECK_VTM(cInfo->getNoStsaConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_STSA,
       "Non-conforming bitstream. no_stsa_constraint_flag is equal to 1 but bitstream contains NAL unit of type STSA_NUT.");
-    CHECK(cInfo->getNoRaslConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_RASL,
+    CHECK_VTM(cInfo->getNoRaslConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_RASL,
       "Non-conforming bitstream. no_rasl_constraint_flag is equal to 1 but bitstream contains NAL unit of type RASL_NUT.");
-    CHECK(cInfo->getNoRadlConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_RADL,
+    CHECK_VTM(cInfo->getNoRadlConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_RADL,
       "Non-conforming bitstream. no_radl_constraint_flag is equal to 1 but bitstream contains NAL unit of type RADL_NUT.");
-    CHECK(cInfo->getNoIdrConstraintFlag() && (naluType == NAL_UNIT_CODED_SLICE_IDR_W_RADL),
+    CHECK_VTM(cInfo->getNoIdrConstraintFlag() && (naluType == NAL_UNIT_CODED_SLICE_IDR_W_RADL),
       "Non-conforming bitstream. no_idr_constraint_flag is equal to 1 but bitstream contains NAL unit of type IDR_W_RADL.");
-    CHECK(cInfo->getNoIdrConstraintFlag() && (naluType == NAL_UNIT_CODED_SLICE_IDR_N_LP),
+    CHECK_VTM(cInfo->getNoIdrConstraintFlag() && (naluType == NAL_UNIT_CODED_SLICE_IDR_N_LP),
       "Non-conforming bitstream. no_idr_constraint_flag is equal to 1 but bitstream contains NAL unit of type IDR_N_LP.");
-    CHECK(cInfo->getNoCraConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_CRA,
+    CHECK_VTM(cInfo->getNoCraConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_CRA,
       "Non-conforming bitstream. no_cra_constraint_flag is equal to 1 but bitstream contains NAL unit of type CRA_NUT.");
-    CHECK(cInfo->getNoGdrConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_GDR,
+    CHECK_VTM(cInfo->getNoGdrConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_GDR,
       "Non-conforming bitstream. no_gdr_constraint_flag is equal to 1 but bitstream contains NAL unit of type GDR_NUT.");
-    CHECK(cInfo->getNoApsConstraintFlag() && naluType == NAL_UNIT_PREFIX_APS,
+    CHECK_VTM(cInfo->getNoApsConstraintFlag() && naluType == NAL_UNIT_PREFIX_APS,
       "Non-conforming bitstream. no_aps_constraint_flag is equal to 1 but bitstream contains NAL unit of type APS_PREFIX_NUT.");
-    CHECK(cInfo->getNoApsConstraintFlag() && naluType == NAL_UNIT_SUFFIX_APS,
+    CHECK_VTM(cInfo->getNoApsConstraintFlag() && naluType == NAL_UNIT_SUFFIX_APS,
       "Non-conforming bitstream. no_aps_constraint_flag is equal to 1 but bitstream contains NAL unit of type APS_SUFFIX_NUT.");
   }
 }
@@ -3013,9 +3013,9 @@
 {
   if (pcSlice->getPPS()->getMixedNaluTypesInPicFlag())
   {
-    CHECK(pcSlice->getPPS()->getNumSlicesInPic() < 2, "mixed nal unit type picture, but with less than 2 slices");
+    CHECK_VTM(pcSlice->getPPS()->getNumSlicesInPic() < 2, "mixed nal unit type picture, but with less than 2 slices");
 
-    CHECK( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR, "picture with mixed NAL unit type cannot have GDR slice");
+    CHECK_VTM( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR, "picture with mixed NAL unit type cannot have GDR slice");
 
     //Check that if current slice is IRAP type, the other type of NAL can only be TRAIL_NUT
     if( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )
@@ -3023,7 +3023,7 @@
       for( int i = 0; i < m_uiSliceSegmentIdx; i++ )
       {
         Slice* PreSlice = m_pcPic->slices[i];
-        CHECK( (pcSlice->getNalUnitType() != PreSlice->getNalUnitType()) && (PreSlice->getNalUnitType() != NAL_UNIT_CODED_SLICE_TRAIL), "In a mixed NAL unt type picture, an IRAP slice can be mixed with Trail slice(s) only");
+        CHECK_VTM( (pcSlice->getNalUnitType() != PreSlice->getNalUnitType()) && (PreSlice->getNalUnitType() != NAL_UNIT_CODED_SLICE_TRAIL), "In a mixed NAL unt type picture, an IRAP slice can be mixed with Trail slice(s) only");
       }
     }
 
@@ -3040,7 +3040,7 @@
           hasDiffTypes = true;
         }
       }
-      CHECK( !hasDiffTypes, "VCL NAL units of the picture shall have two or more different nal_unit_type values");
+      CHECK_VTM( !hasDiffTypes, "VCL NAL units of the picture shall have two or more different nal_unit_type values");
     }
 
   }
@@ -3053,7 +3053,7 @@
       if (PreSlice->getNalUnitType() != pcSlice->getNalUnitType())
         sameNalUnitType = false;
     }
-    CHECK(!sameNalUnitType, "pps_mixed_nalu_types_in_pic_flag is zero, but have different nal unit types");
+    CHECK_VTM(!sameNalUnitType, "pps_mixed_nalu_types_in_pic_flag is zero, but have different nal unit types");
   }
 }
 /**
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/DecSlice.cpp ../VVCSoftware_10/source/Lib/DecoderLib/DecSlice.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/DecSlice.cpp	2022-09-16 14:27:06.148532600 +0200
+++ ../VVCSoftware_10/source/Lib/DecoderLib/DecSlice.cpp	2022-05-13 17:45:28.712151057 +0200
@@ -122,7 +122,7 @@
 
   // Quantization parameter
     pic->m_prevQP[0] = pic->m_prevQP[1] = slice->getSliceQp();
-  CHECK( pic->m_prevQP[0] == std::numeric_limits<int>::max(), "Invalid previous QP" );
+    CHECK_VTM( pic->m_prevQP[0] == std::numeric_limits<int>::max(), "Invalid previous QP" );
 
   DTRACE( g_trace_ctx, D_HEADER, "=========== POC: %d ===========\n", slice->getPOC() );
 
@@ -244,7 +244,7 @@
     if( ctuIdx == slice->getNumCtuInSlice()-1 )
     {
       unsigned binVal = cabacReader.terminating_bit();
-      CHECK( !binVal, "Expecting a terminating bit" );
+      CHECK_VTM( !binVal, "Expecting a terminating bit" );
 #if DECODER_CHECK_SUBSTREAM_AND_SLICE_TRAILING_BYTES
       cabacReader.remaining_bytes( false );
 #endif
@@ -255,7 +255,7 @@
       // The sub-stream/stream should be terminated after this CTU.
       // (end of slice-segment, end of tile, end of wavefront-CTU-row)
       unsigned binVal = cabacReader.terminating_bit();
-      CHECK( !binVal, "Expecting a terminating bit" );
+      CHECK_VTM( !binVal, "Expecting a terminating bit" );
       if( entryPointPresent )
       {
 #if DECODER_CHECK_SUBSTREAM_AND_SLICE_TRAILING_BYTES
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/NALread.cpp ../VVCSoftware_10/source/Lib/DecoderLib/NALread.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/NALread.cpp	2022-09-16 14:27:06.148532600 +0200
+++ ../VVCSoftware_10/source/Lib/DecoderLib/NALread.cpp	2022-05-13 17:45:28.644151827 +0200
@@ -65,7 +65,7 @@
   bitstream->clearEmulationPreventionByteLocation();
   for (it_read = it_write = nalUnitBuf.begin(); it_read != nalUnitBuf.end(); it_read++, it_write++, pos++)
   {
-    CHECK(zeroCount >= 2 && *it_read < 0x03, "Zero count is '2' and read value is small than '3'");
+    CHECK_VTM(zeroCount >= 2 && *it_read < 0x03, "Zero count is '2' and read value is small than '3'");
     if (zeroCount == 2 && *it_read == 0x03)
     {
       bitstream->pushEmulationPreventionByteLocation( pos );
@@ -79,12 +79,12 @@
       {
         break;
       }
-      CHECK(*it_read > 0x03, "Read a value bigger than '3'");
+      CHECK_VTM(*it_read > 0x03, "Read a value bigger than '3'");
     }
     zeroCount = (*it_read == 0x00) ? zeroCount+1 : 0;
     *it_write = *it_read;
   }
-  CHECK(zeroCount != 0, "Zero count not '0'");
+  CHECK_VTM(zeroCount != 0, "Zero count not '0'");
 
   if (isVclNalUnit)
   {
@@ -129,7 +129,7 @@
   nalu.m_forbiddenZeroBit   = bs.read(1);                 // forbidden zero bit
   nalu.m_nuhReservedZeroBit = bs.read(1);                 // nuh_reserved_zero_bit
   nalu.m_nuhLayerId         = bs.read(6);                 // nuh_layer_id
-  CHECK(nalu.m_nuhLayerId > 55, "The value of nuh_layer_id shall be in the range of 0 to 55, inclusive");
+  CHECK_VTM(nalu.m_nuhLayerId > 55, "The value of nuh_layer_id shall be in the range of 0 to 55, inclusive");
   nalu.m_nalUnitType        = (NalUnitType) bs.read(5);   // nal_unit_type
   nalu.m_temporalId         = bs.read(3) - 1;             // nuh_temporal_id_plus1
 
@@ -149,7 +149,7 @@
     }
     else
     {
-      CHECK(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA
+      CHECK_VTM(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA
         , "When NAL unit type is equal to STSA_NUT, TemporalId shall not be equal to 0");
     }
   }
@@ -170,7 +170,7 @@
 bool checkPictureHeaderInSliceHeaderFlag(InputNALUnit& nalu)
 {
   InputBitstream& bitstream = nalu.getBitstream();
-  CHECK(bitstream.getByteLocation() != 2, "The picture_header_in_slice_header_flag is the first bit after the NAL unit header");
+  CHECK_VTM(bitstream.getByteLocation() != 2, "The picture_header_in_slice_header_flag is the first bit after the NAL unit header");
   return (bool)bitstream.read(1);
 }
 //! \}
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/SEIread.cpp ../VVCSoftware_10/source/Lib/DecoderLib/SEIread.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/SEIread.cpp	2022-09-16 14:27:06.148532600 +0200
+++ ../VVCSoftware_10/source/Lib/DecoderLib/SEIread.cpp	2022-05-13 17:45:28.696151238 +0200
@@ -119,7 +119,7 @@
 {
   SEIMessages   seiListInCurNalu;
   setBitstream(bs);
-  CHECK(m_pcBitstream->getNumBitsUntilByteAligned(), "Bitstream not aligned");
+  CHECK_VTM(m_pcBitstream->getNumBitsUntilByteAligned(), "Bitstream not aligned");
 
   do
   {
@@ -127,14 +127,14 @@
     seiListInCurNalu.push_back(seis.back());
     /* SEI messages are an integer number of bytes, something has failed
     * in the parsing if bitstream not byte-aligned */
-    CHECK(m_pcBitstream->getNumBitsUntilByteAligned(), "Bitstream not aligned");
+    CHECK_VTM(m_pcBitstream->getNumBitsUntilByteAligned(), "Bitstream not aligned");
   }
   while (m_pcBitstream->getNumBitsLeft() > 8);
 
   const SEIMessages fillerData = getSeisByType(seiListInCurNalu, SEI::FILLER_PAYLOAD);
-  CHECK(fillerData.size() > 0 && fillerData.size() != seiListInCurNalu.size(), "When an SEI NAL unit contains an SEI message with payloadType equal to filler payload, the SEI NAL unit shall not contain any other SEI message with payloadType not equal to filler payload");
+  CHECK_VTM(fillerData.size() > 0 && fillerData.size() != seiListInCurNalu.size(), "When an SEI NAL unit contains an SEI message with payloadType equal to filler payload, the SEI NAL unit shall not contain any other SEI message with payloadType not equal to filler payload");
   const SEIMessages pictureTiming = getSeisByType(seiListInCurNalu, SEI::PICTURE_TIMING);
-  CHECK(hrd.getGeneralHrdParameters().getGeneralSamePicTimingInAllOlsFlag() && pictureTiming.size() > 0 && pictureTiming.size() != pictureTiming.size(),
+  CHECK_VTM(hrd.getGeneralHrdParameters().getGeneralSamePicTimingInAllOlsFlag() && pictureTiming.size() > 0 && pictureTiming.size() != pictureTiming.size(),
         "When general_same_pic_timing_in_all_ols_flag is equal to 1 [...], and when an SEI NAL unit contains a non-scalable-nested SEI message with "
         "payloadType equal to 1 (PT), the SEI NAL unit shall not contain any other SEI message with payloadType not equal 1.");
 
@@ -399,7 +399,7 @@
 
 void SEIReader::xParseSEIuserDataUnregistered(SEIuserDataUnregistered &sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
 {
-  CHECK(payloadSize < ISO_IEC_11578_LEN, "Payload too small");
+  CHECK_VTM(payloadSize < ISO_IEC_11578_LEN, "Payload too small");
   uint32_t val;
   output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
 
@@ -512,7 +512,7 @@
           }
         }
       }
-      CHECK(lowestLayerId!= nuhLayerId, "nuh_layer_id is not equal to the lowest layer among Olss that the scalable SEI applies");
+      CHECK_VTM(lowestLayerId!= nuhLayerId, "nuh_layer_id is not equal to the lowest layer among Olss that the scalable SEI applies");
     }
   }
   else
@@ -539,7 +539,7 @@
   }
 
   sei_read_uvlc(decodedMessageOutputStream, symbol, "sn_num_seis_minus1"); sei.m_snNumSEIs = symbol + 1;
-  CHECK (sei.m_snNumSEIs > 64, "The value of sn_num_seis_minus1 shall be in the range of 0 to 63");
+  CHECK_VTM(sei.m_snNumSEIs > 64, "The value of sn_num_seis_minus1 shall be in the range of 0 to 63");
 
   // byte alignment
   while (m_pcBitstream->getNumBitsRead() % 8 != 0)
@@ -583,34 +583,34 @@
 
   for (auto nestedsei : sei.m_nestedSEIs)
   {
-    CHECK(nestedsei->payloadType() == SEI::FILLER_PAYLOAD || nestedsei->payloadType() == SEI::SCALABLE_NESTING, "An SEI message that has payloadType equal to filler payload or scalable nesting shall not be contained in a scalable nesting SEI message");
+    CHECK_VTM(nestedsei->payloadType() == SEI::FILLER_PAYLOAD || nestedsei->payloadType() == SEI::SCALABLE_NESTING, "An SEI message that has payloadType equal to filler payload or scalable nesting shall not be contained in a scalable nesting SEI message");
 
-    CHECK(nestedsei->payloadType() != SEI::FILLER_PAYLOAD && nestedsei->payloadType() != SEI::DECODED_PICTURE_HASH && nalUnitType != NAL_UNIT_PREFIX_SEI, "When a scalable nesting SEI message contains an SEI message that has payloadType not equal to filler payload or decoded picture hash, the SEI NAL unit containing the scalable nesting SEI message shall have nal_unit_type equal to PREFIX_SEI_NUT");
+    CHECK_VTM(nestedsei->payloadType() != SEI::FILLER_PAYLOAD && nestedsei->payloadType() != SEI::DECODED_PICTURE_HASH && nalUnitType != NAL_UNIT_PREFIX_SEI, "When a scalable nesting SEI message contains an SEI message that has payloadType not equal to filler payload or decoded picture hash, the SEI NAL unit containing the scalable nesting SEI message shall have nal_unit_type equal to PREFIX_SEI_NUT");
 
-    CHECK(nestedsei->payloadType() == SEI::DECODED_PICTURE_HASH && nalUnitType != NAL_UNIT_SUFFIX_SEI, "When a scalable nesting SEI message contains an SEI message that has payloadType equal to decoded picture hash, the SEI NAL unit containing the scalable nesting SEI message shall have nal_unit_type equal to SUFFIX_SEI_NUT");
+    CHECK_VTM(nestedsei->payloadType() == SEI::DECODED_PICTURE_HASH && nalUnitType != NAL_UNIT_SUFFIX_SEI, "When a scalable nesting SEI message contains an SEI message that has payloadType equal to decoded picture hash, the SEI NAL unit containing the scalable nesting SEI message shall have nal_unit_type equal to SUFFIX_SEI_NUT");
 
-    CHECK(nestedsei->payloadType() == SEI::DECODED_PICTURE_HASH && !sei.m_snSubpicFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to decoded picture hash, the value of sn_subpic_flag shall be equal to 1");
+    CHECK_VTM(nestedsei->payloadType() == SEI::DECODED_PICTURE_HASH && !sei.m_snSubpicFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to decoded picture hash, the value of sn_subpic_flag shall be equal to 1");
 
-    CHECK(nestedsei->payloadType() == SEI::SUBPICTURE_LEVEL_INFO && sei.m_snSubpicFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to SLI, the value of sn_subpic_flag shall be equal to 0");
+    CHECK_VTM(nestedsei->payloadType() == SEI::SUBPICTURE_LEVEL_INFO && sei.m_snSubpicFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to SLI, the value of sn_subpic_flag shall be equal to 0");
 
-    CHECK(vps->getGeneralHrdParameters()->getGeneralSamePicTimingInAllOlsFlag() && nestedsei->payloadType() == SEI::PICTURE_TIMING, "When general_same_pic_timing_in_all_ols_flag is equal to 1, there shall be no SEI NAL unit that contain a scalable-nested SEI message with payloadType equal to PT");
+    CHECK_VTM(vps->getGeneralHrdParameters()->getGeneralSamePicTimingInAllOlsFlag() && nestedsei->payloadType() == SEI::PICTURE_TIMING, "When general_same_pic_timing_in_all_ols_flag is equal to 1, there shall be no SEI NAL unit that contain a scalable-nested SEI message with payloadType equal to PT");
 
     for (int i = 0; i < vclAssociatedSeiList.size(); i++)
     {
-      CHECK(nestedsei->payloadType() == vclAssociatedSeiList[i] && sei.m_snOlsFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to a value in vclAssociatedSeiList, the value of sn_ols_flag shall be equal to 0");
+      CHECK_VTM(nestedsei->payloadType() == vclAssociatedSeiList[i] && sei.m_snOlsFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to a value in vclAssociatedSeiList, the value of sn_ols_flag shall be equal to 0");
     }
 
     if (nestedsei->payloadType() == SEI::BUFFERING_PERIOD || nestedsei->payloadType() == SEI::PICTURE_TIMING || nestedsei->payloadType() == SEI::DECODING_UNIT_INFO || nestedsei->payloadType() == SEI::SUBPICTURE_LEVEL_INFO)
     {
       containBPorPTorDUIorSLI = true;
-      CHECK(!sei.m_snOlsFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to BP, PT, or DUI, or SLI, the value of sn_ols_flag shall be equal to 1");
+      CHECK_VTM(!sei.m_snOlsFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to BP, PT, or DUI, or SLI, the value of sn_ols_flag shall be equal to 1");
     }
     if (!(nestedsei->payloadType() == SEI::BUFFERING_PERIOD || nestedsei->payloadType() == SEI::PICTURE_TIMING || nestedsei->payloadType() == SEI::DECODING_UNIT_INFO || nestedsei->payloadType() == SEI::SUBPICTURE_LEVEL_INFO))
     {
       containNoBPorPTorDUIorSLI = true;
     }
   }
-  CHECK(containBPorPTorDUIorSLI && containNoBPorPTorDUIorSLI, "When a scalable nesting SEI message contains a BP, PT, DUI, or SLI SEI message, the scalable nesting SEI message shall not contain any other SEI message with payloadType not equal to BP, PT, DUI, or SLI");
+  CHECK_VTM(containBPorPTorDUIorSLI && containNoBPorPTorDUIorSLI, "When a scalable nesting SEI message contains a BP, PT, DUI, or SLI SEI message, the scalable nesting SEI message shall not contain any other SEI message with payloadType not equal to BP, PT, DUI, or SLI");
 }
 
 void SEIReader::xParseSEIDecodingUnitInfo(SEIDecodingUnitInfo& sei, uint32_t payloadSize, const SEIBufferingPeriod& bp, const uint32_t temporalId, std::ostream *pDecodedMessageOutputStream)
@@ -695,7 +695,7 @@
     sei.m_decodingUnitDpbDuParamsInPicTimingSeiFlag = false;
   }
 
-  CHECK(sei.m_altCpbParamsPresentFlag && sei.m_bpDecodingUnitHrdParamsPresentFlag,"When bp_alt_cpb_params_present_flag is equal to 1, the value of bp_du_hrd_params_present_flag shall be equal to 0");
+  CHECK_VTM(sei.m_altCpbParamsPresentFlag && sei.m_bpDecodingUnitHrdParamsPresentFlag,"When bp_alt_cpb_params_present_flag is equal to 1, the value of bp_du_hrd_params_present_flag shall be equal to 0");
 
   sei_read_flag( pDecodedMessageOutputStream, code, "concatenation_flag");
   sei.m_concatenationFlag = code;
@@ -1033,7 +1033,7 @@
   if( !sei.m_arrangementCancelFlag )
   {
     sei_read_code( pDecodedMessageOutputStream, 7, val, "fp_arrangement_type" );             sei.m_arrangementType = val;
-    CHECK( ( sei.m_arrangementType <= 2 ) || ( sei.m_arrangementType >= 6 ), "Invalid arrangement type" );
+    CHECK_VTM( ( sei.m_arrangementType <= 2 ) || ( sei.m_arrangementType >= 6 ), "Invalid arrangement type" );
 
     sei_read_flag( pDecodedMessageOutputStream, val, "fp_quincunx_sampling_flag" );          sei.m_quincunxSamplingFlag = val;
 
@@ -1422,7 +1422,8 @@
     sei_read_flag(pDecodedMessageOutputStream,      val,    "sli_sublayer_info_present_flag");        sei.m_sliSublayerInfoPresentFlag = val;
     while (!isByteAligned())
     {
-      sei_read_flag( pDecodedMessageOutputStream,   val,    "sli_alignment_zero_bit" );           CHECK (val != 0, "sli_alignment_zero_bit not equal to zero" );
+      sei_read_flag( pDecodedMessageOutputStream,   val,    "sli_alignment_zero_bit" );
+      CHECK_VTM(val != 0, "sli_alignment_zero_bit not equal to zero" );
     }
   }
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/VLCReader.cpp ../VVCSoftware_10/source/Lib/DecoderLib/VLCReader.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/DecoderLib/VLCReader.cpp	2022-09-16 14:27:06.148532600 +0200
+++ ../VVCSoftware_10/source/Lib/DecoderLib/VLCReader.cpp	2022-05-13 17:45:28.656151691 +0200
@@ -134,7 +134,7 @@
 void VLCReader::xReadCode (uint32_t uiLength, uint32_t& ruiCode)
 #endif
 {
-  CHECK( uiLength == 0, "Reading a code of length '0'" );
+  CHECK_VTM( uiLength == 0, "Reading a code of length '0'" );
   m_pcBitstream->read (uiLength, ruiCode);
 #if RExt__DECODER_DEBUG_BIT_STATISTICS
   CodingStatistics::IncrementStatisticEP(pSymbolName, uiLength, ruiCode);
@@ -233,15 +233,15 @@
 {
   uint32_t bit;
   READ_FLAG( bit, "rbsp_stop_one_bit");
-  CHECK(bit!=1, "Trailing bit not '1'");
+  CHECK_VTM(bit!=1, "Trailing bit not '1'");
   int cnt = 0;
   while (m_pcBitstream->getNumBitsUntilByteAligned())
   {
     READ_FLAG( bit, "rbsp_alignment_zero_bit");
-    CHECK(bit!=0, "Alignment bit is not '0'");
+    CHECK_VTM(bit!=0, "Alignment bit is not '0'");
     cnt++;
   }
-  CHECK(cnt >= 8, "Read more than '8' trailing bits");
+  CHECK_VTM(cnt >= 8, "Read more than '8' trailing bits");
 }
 
 void AUDReader::parseAccessUnitDelimiter(InputBitstream* bs, uint32_t &audIrapOrGdrAuFlag, uint32_t &picType)
@@ -268,7 +268,7 @@
   while( m_pcBitstream->getNumBitsLeft() >8 )
   {
     READ_CODE (8, ffByte, "ff_byte");
-    CHECK(ffByte!=0xff, "Invalid filler data : not '0xff'");
+    CHECK_VTM(ffByte!=0xff, "Invalid filler data : not '0xff'");
     fdSize++;
   }
   xReadRbspTrailingBits();
@@ -419,7 +419,7 @@
 
   int   iCode;
   READ_CODE(6, uiCode, "pps_pic_parameter_set_id");
-  CHECK(uiCode > 63, "PPS id exceeds boundary (63)");
+  CHECK_VTM(uiCode > 63, "PPS id exceeds boundary (63)");
   pcPPS->setPPSId (uiCode);
 
   READ_CODE(4, uiCode, "pps_seq_parameter_set_id");
@@ -472,12 +472,12 @@
     {
       pcPPS->setNumSubPics(1);
     }
-    CHECK( uiCode > MAX_NUM_SUB_PICS-1,  "Number of sub-pictures exceeds limit");
+    CHECK_VTM( uiCode > MAX_NUM_SUB_PICS-1,  "Number of sub-pictures exceeds limit");
 
     READ_UVLC( uiCode, "pps_subpic_id_len_minus1" );                       pcPPS->setSubPicIdLen( uiCode + 1 );
-    CHECK( uiCode > 15, "Invalid pps_subpic_id_len_minus1 signalled");
+    CHECK_VTM( uiCode > 15, "Invalid pps_subpic_id_len_minus1 signalled");
 
-    CHECK((1 << pcPPS->getSubPicIdLen()) < pcPPS->getNumSubPics(), "pps_subpic_id_len exceeds valid range");
+    CHECK_VTM((1 << pcPPS->getSubPicIdLen()) < pcPPS->getNumSubPics(), "pps_subpic_id_len exceeds valid range");
     for( int picIdx = 0; picIdx < pcPPS->getNumSubPics( ); picIdx++ )
     {
       READ_CODE( pcPPS->getSubPicIdLen( ), uiCode, "pps_subpic_id[i]" );   pcPPS->setSubPicId( picIdx, uiCode );
@@ -490,23 +490,23 @@
 
     // CTU size - required to match size in SPS
     READ_CODE(2, uiCode, "pps_log2_ctu_size_minus5");                 pcPPS->setLog2CtuSize(uiCode + 5);
-    CHECK(uiCode > 2, "pps_log2_ctu_size_minus5 must be less than or equal to 2");
+    CHECK_VTM(uiCode > 2, "pps_log2_ctu_size_minus5 must be less than or equal to 2");
 
     // number of explicit tile columns/rows
     READ_UVLC( uiCode, "pps_num_exp_tile_columns_minus1" );               pcPPS->setNumExpTileColumns( uiCode + 1 );
     READ_UVLC( uiCode, "pps_num_exp_tile_rows_minus1" );                  pcPPS->setNumExpTileRows( uiCode + 1 );
-    CHECK(pcPPS->getNumExpTileColumns() > MAX_TILE_COLS,              "Number of explicit tile columns exceeds valid range");
+    CHECK_VTM(pcPPS->getNumExpTileColumns() > MAX_TILE_COLS,              "Number of explicit tile columns exceeds valid range");
 
     // tile sizes
     for( colIdx = 0; colIdx < pcPPS->getNumExpTileColumns(); colIdx++ )
     {
       READ_UVLC( uiCode, "pps_tile_column_width_minus1[i]" );             pcPPS->addTileColumnWidth( uiCode + 1 );
-      CHECK(uiCode  > (pcPPS->getPicWidthInCtu()-1),                 "The value of pps_tile_column_width_minus1[i] shall be in the range of 0 to PicWidthInCtbY-1, inclusive");
+      CHECK_VTM(uiCode  > (pcPPS->getPicWidthInCtu()-1),                 "The value of pps_tile_column_width_minus1[i] shall be in the range of 0 to PicWidthInCtbY-1, inclusive");
     }
     for( rowIdx = 0; rowIdx < pcPPS->getNumExpTileRows(); rowIdx++ )
     {
       READ_UVLC( uiCode, "pps_tile_row_height_minus1[i]" );               pcPPS->addTileRowHeight( uiCode + 1 );
-      CHECK(uiCode > (pcPPS->getPicHeightInCtu() - 1),                "The value of pps_tile_row_height_minus shall be in the range of 0 to PicHeightInCtbY-1, inclusive");
+      CHECK_VTM(uiCode > (pcPPS->getPicHeightInCtu() - 1),                "The value of pps_tile_row_height_minus shall be in the range of 0 to PicHeightInCtbY-1, inclusive");
     }
     pcPPS->initTiles();
     // rectangular slice signalling
@@ -534,7 +534,7 @@
       int32_t tileIdx = 0;
 
       READ_UVLC( uiCode, "pps_num_slices_in_pic_minus1" );                pcPPS->setNumSlicesInPic( uiCode + 1 );
-      CHECK(pcPPS->getNumSlicesInPic() > MAX_SLICES,                  "Number of slices in picture exceeds valid range");
+      CHECK_VTM(pcPPS->getNumSlicesInPic() > MAX_SLICES,                  "Number of slices in picture exceeds valid range");
       if ((pcPPS->getNumSlicesInPic() - 1) > 1)
       {
         READ_CODE(1, uiCode, "pps_tile_idx_delta_present_flag");
@@ -641,7 +641,7 @@
             int32_t  tileIdxDelta;
             READ_SVLC( tileIdxDelta, "pps_tile_idx_delta[i]" );
             tileIdx += tileIdxDelta;
-            CHECK( tileIdx < 0 || tileIdx >= pcPPS->getNumTiles(), "Invalid pps_tile_idx_delta.");
+            CHECK_VTM( tileIdx < 0 || tileIdx >= pcPPS->getNumTiles(), "Invalid pps_tile_idx_delta.");
           }
           else
           {
@@ -673,11 +673,11 @@
   READ_FLAG( uiCode,   "pps_cabac_init_present_flag" );            pcPPS->setCabacInitPresentFlag( uiCode ? true : false );
 
   READ_UVLC(uiCode, "pps_num_ref_idx_default_active_minus1[0]");
-  CHECK(uiCode > 14, "Invalid code read");
+  CHECK_VTM(uiCode > 14, "Invalid code read");
   pcPPS->setNumRefIdxL0DefaultActive(uiCode+1);
 
   READ_UVLC(uiCode, "pps_num_ref_idx_default_active_minus1[1]");
-  CHECK(uiCode > 14, "Invalid code read");
+  CHECK_VTM(uiCode > 14, "Invalid code read");
   pcPPS->setNumRefIdxL1DefaultActive(uiCode+1);
 
   READ_FLAG(uiCode, "pps_rpl1_idx_present_flag");
@@ -705,13 +705,13 @@
   {
   READ_SVLC( iCode, "pps_cb_qp_offset");
   pcPPS->setQpOffset(COMPONENT_Cb, iCode);
-  CHECK( pcPPS->getQpOffset(COMPONENT_Cb) < -12, "Invalid Cb QP offset" );
-  CHECK( pcPPS->getQpOffset(COMPONENT_Cb) >  12, "Invalid Cb QP offset" );
+  CHECK_VTM( pcPPS->getQpOffset(COMPONENT_Cb) < -12, "Invalid Cb QP offset" );
+  CHECK_VTM( pcPPS->getQpOffset(COMPONENT_Cb) >  12, "Invalid Cb QP offset" );
 
   READ_SVLC( iCode, "pps_cr_qp_offset");
   pcPPS->setQpOffset(COMPONENT_Cr, iCode);
-  CHECK( pcPPS->getQpOffset(COMPONENT_Cr) < -12, "Invalid Cr QP offset" );
-  CHECK( pcPPS->getQpOffset(COMPONENT_Cr) >  12, "Invalid Cr QP offset" );
+  CHECK_VTM( pcPPS->getQpOffset(COMPONENT_Cr) < -12, "Invalid Cr QP offset" );
+  CHECK_VTM( pcPPS->getQpOffset(COMPONENT_Cr) >  12, "Invalid Cr QP offset" );
 
   READ_FLAG(uiCode, "pps_joint_cbcr_qp_offset_present_flag");
   pcPPS->setJointCbCrQpOffsetPresentFlag(uiCode ? true : false);
@@ -726,10 +726,10 @@
   }
   pcPPS->setQpOffset(JOINT_CbCr, iCode);
 
-  CHECK( pcPPS->getQpOffset(JOINT_CbCr) < -12, "Invalid CbCr QP offset" );
-  CHECK( pcPPS->getQpOffset(JOINT_CbCr) >  12, "Invalid CbCr QP offset" );
+  CHECK_VTM( pcPPS->getQpOffset(JOINT_CbCr) < -12, "Invalid CbCr QP offset" );
+  CHECK_VTM( pcPPS->getQpOffset(JOINT_CbCr) >  12, "Invalid CbCr QP offset" );
 
-  CHECK(MAX_NUM_COMPONENT>3, "Invalid maximal number of components");
+  CHECK_VTM(MAX_NUM_COMPONENT>3, "Invalid maximal number of components");
 
   READ_FLAG( uiCode, "pps_slice_chroma_qp_offsets_present_flag" );
   pcPPS->setSliceChromaQpFlag( uiCode ? true : false );
@@ -743,7 +743,7 @@
   {
     uint32_t tableSizeMinus1 = 0;
     READ_UVLC(tableSizeMinus1, "pps_chroma_qp_offset_list_len_minus1");
-    CHECK(tableSizeMinus1 >= MAX_QP_OFFSET_LIST_SIZE, "Table size exceeds maximum");
+    CHECK_VTM(tableSizeMinus1 >= MAX_QP_OFFSET_LIST_SIZE, "Table size exceeds maximum");
 
     for (int cuChromaQpOffsetIdx = 0; cuChromaQpOffsetIdx <= (tableSizeMinus1); cuChromaQpOffsetIdx++)
     {
@@ -751,9 +751,9 @@
       int crOffset;
       int jointCbCrOffset;
       READ_SVLC(cbOffset, "pps_cb_qp_offset_list[i]");
-      CHECK(cbOffset < -12 || cbOffset > 12, "Invalid chroma QP offset");
+      CHECK_VTM(cbOffset < -12 || cbOffset > 12, "Invalid chroma QP offset");
       READ_SVLC(crOffset, "pps_cr_qp_offset_list[i]");
-      CHECK(crOffset < -12 || crOffset > 12, "Invalid chroma QP offset");
+      CHECK_VTM(crOffset < -12 || crOffset > 12, "Invalid chroma QP offset");
       if (pcPPS->getJointCbCrQpOffsetPresentFlag())
       {
         READ_SVLC(jointCbCrOffset, "pps_joint_cbcr_qp_offset_list[i]");
@@ -762,11 +762,11 @@
       {
         jointCbCrOffset = 0;
       }
-      CHECK(jointCbCrOffset < -12 || jointCbCrOffset > 12, "Invalid chroma QP offset");
+      CHECK_VTM(jointCbCrOffset < -12 || jointCbCrOffset > 12, "Invalid chroma QP offset");
       // table uses +1 for index (see comment inside the function)
       pcPPS->setChromaQpOffsetListEntry(cuChromaQpOffsetIdx + 1, cbOffset, crOffset, jointCbCrOffset);
     }
-    CHECK(pcPPS->getChromaQpOffsetListLen() != tableSizeMinus1 + 1, "Invalid chroma QP offset list length");
+    CHECK_VTM(pcPPS->getChromaQpOffsetListLen() != tableSizeMinus1 + 1, "Invalid chroma QP offset list length");
   }
   }
   else
@@ -794,29 +794,29 @@
     if(!pcPPS->getPPSDeblockingFilterDisabledFlag())
     {
       READ_SVLC( iCode, "pps_beta_offset_div2" );                    pcPPS->setDeblockingFilterBetaOffsetDiv2( iCode );
-      CHECK(  pcPPS->getDeblockingFilterBetaOffsetDiv2() < -12 ||
+      CHECK_VTM(  pcPPS->getDeblockingFilterBetaOffsetDiv2() < -12 ||
               pcPPS->getDeblockingFilterBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
 
       READ_SVLC( iCode, "pps_tc_offset_div2");                       pcPPS->setDeblockingFilterTcOffsetDiv2( iCode );
-      CHECK(  pcPPS->getDeblockingFilterTcOffsetDiv2() < -12 ||
+      CHECK_VTM(  pcPPS->getDeblockingFilterTcOffsetDiv2() < -12 ||
               pcPPS->getDeblockingFilterTcOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
 
       if( pcPPS->getPPSChromaToolFlag() )
       {
         READ_SVLC( iCode, "pps_cb_beta_offset_div2" );                   pcPPS->setDeblockingFilterCbBetaOffsetDiv2( iCode );
-        CHECK( pcPPS->getDeblockingFilterCbBetaOffsetDiv2() < -12 ||
+        CHECK_VTM( pcPPS->getDeblockingFilterCbBetaOffsetDiv2() < -12 ||
           pcPPS->getDeblockingFilterCbBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
 
         READ_SVLC( iCode, "pps_cb_tc_offset_div2" );                     pcPPS->setDeblockingFilterCbTcOffsetDiv2( iCode );
-        CHECK( pcPPS->getDeblockingFilterCbTcOffsetDiv2() < -12 ||
+        CHECK_VTM( pcPPS->getDeblockingFilterCbTcOffsetDiv2() < -12 ||
           pcPPS->getDeblockingFilterCbTcOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
 
         READ_SVLC( iCode, "pps_cr_beta_offset_div2") ;                   pcPPS->setDeblockingFilterCrBetaOffsetDiv2( iCode );
-        CHECK( pcPPS->getDeblockingFilterCrBetaOffsetDiv2() < -12 ||
+        CHECK_VTM( pcPPS->getDeblockingFilterCrBetaOffsetDiv2() < -12 ||
           pcPPS->getDeblockingFilterCrBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
 
         READ_SVLC( iCode, "pps_cr_tc_offset_div2" );                     pcPPS->setDeblockingFilterCrTcOffsetDiv2( iCode );
-        CHECK(pcPPS->getDeblockingFilterCrTcOffsetDiv2() < -12 ||
+        CHECK_VTM(pcPPS->getDeblockingFilterCrTcOffsetDiv2() < -12 ||
           pcPPS->getDeblockingFilterCrTcOffsetDiv2() > 12, "Invalid deblocking filter configuration");
       }
       else
@@ -955,7 +955,7 @@
   {
     ccAlfParam.newCcAlfFilter[COMPONENT_Cr - 1] = 0;
   }
-  CHECK(param.newFilterFlag[CHANNEL_TYPE_LUMA] == 0 && param.newFilterFlag[CHANNEL_TYPE_CHROMA] == 0
+  CHECK_VTM(param.newFilterFlag[CHANNEL_TYPE_LUMA] == 0 && param.newFilterFlag[CHANNEL_TYPE_CHROMA] == 0
           && ccAlfParam.newCcAlfFilter[COMPONENT_Cb - 1] == 0 && ccAlfParam.newCcAlfFilter[COMPONENT_Cr - 1] == 0,
         "bitstream conformance error: one of alf_luma_filter_signal_flag, alf_chroma_filter_signal_flag, "
         "alf_cross_component_cb_filter_signal_flag, and alf_cross_component_cr_filter_signal_flag shall be nonzero");
@@ -1174,12 +1174,12 @@
       payloadBitsRem--;
     }
     READ_FLAG(symbol, "vui_payload_bit_equal_to_one");
-    CHECK(symbol != 1, "vui_payload_bit_equal_to_one not equal to 1");
+    CHECK_VTM(symbol != 1, "vui_payload_bit_equal_to_one not equal to 1");
     payloadBitsRem--;
     while(payloadBitsRem)
     {
       READ_FLAG(symbol, "vui_payload_bit_equal_to_zero");
-      CHECK(symbol != 0, "vui_payload_bit_equal_to_zero not equal to 0");
+      CHECK_VTM(symbol != 0, "vui_payload_bit_equal_to_zero not equal to 0");
       payloadBitsRem--;
     }
   }
@@ -1194,7 +1194,7 @@
   READ_CODE(32, symbol, "time_scale");                       hrd->setTimeScale(symbol);
   READ_FLAG(symbol, "general_nal_hrd_parameters_present_flag");           hrd->setGeneralNalHrdParametersPresentFlag(symbol == 1 ? true : false);
   READ_FLAG(symbol, "general_vcl_hrd_parameters_present_flag");           hrd->setGeneralVclHrdParametersPresentFlag(symbol == 1 ? true : false);
-  CHECK((hrd->getGeneralNalHrdParametersPresentFlag() == 0) && (hrd->getGeneralVclHrdParametersPresentFlag() == 0), "general_nal_hrd_params_present_flag and general_vcl_hrd_params_present_flag in each general_hrd_parameters( ) syntax structure shall not be both equal to 0.");
+  CHECK_VTM((hrd->getGeneralNalHrdParametersPresentFlag() == 0) && (hrd->getGeneralVclHrdParametersPresentFlag() == 0), "general_nal_hrd_params_present_flag and general_vcl_hrd_params_present_flag in each general_hrd_parameters( ) syntax structure shall not be both equal to 0.");
   READ_FLAG(symbol, "general_same_pic_timing_in_all_ols_flag");           hrd->setGeneralSamePicTimingInAllOlsFlag(symbol == 1 ? true : false);
   READ_FLAG(symbol, "general_decoding_unit_hrd_params_present_flag");     hrd->setGeneralDecodingUnitHrdParamsPresentFlag(symbol == 1 ? true : false);
   if (hrd->getGeneralDecodingUnitHrdParamsPresentFlag())
@@ -1208,7 +1208,7 @@
     READ_CODE(4, symbol, "cpb_size_du_scale");                  hrd->setCpbSizeDuScale(symbol);
   }
   READ_UVLC(symbol, "hrd_cpb_cnt_minus1");                      hrd->setHrdCpbCntMinus1(symbol);
-  CHECK(symbol > 31,"The value of hrd_cpb_cnt_minus1 shall be in the range of 0 to 31, inclusive");
+  CHECK_VTM(symbol > 31,"The value of hrd_cpb_cnt_minus1 shall be in the range of 0 to 31, inclusive");
 }
 void HLSyntaxReader::parseOlsHrdParameters(GeneralHrdParams * generalHrd, OlsHrdParams *olsHrd, uint32_t firstSubLayer, uint32_t maxNumSubLayersMinus1)
 {
@@ -1317,13 +1317,13 @@
   READ_CODE(4, uiCode, "sps_seq_parameter_set_id");              pcSPS->setSPSId(uiCode);
   READ_CODE( 4,  uiCode, "sps_video_parameter_set_id" );      pcSPS->setVPSId( uiCode );
   READ_CODE(3, uiCode, "sps_max_sub_layers_minus1");          pcSPS->setMaxTLayers   (uiCode + 1);
-  CHECK(uiCode > 6, "Invalid maximum number of T-layer signalled");
+  CHECK_VTM(uiCode > 6, "Invalid maximum number of T-layer signalled");
   READ_CODE(2, uiCode, "sps_chroma_format_idc");
   pcSPS->setChromaFormatIdc(ChromaFormat(uiCode));
 
   READ_CODE(2, uiCode, "sps_log2_ctu_size_minus5");
   pcSPS->setCTUSize(1 << (uiCode + 5));
-  CHECK(uiCode > 2, "sps_log2_ctu_size_minus5 must be less than or equal to 2");
+  CHECK_VTM(uiCode > 2, "sps_log2_ctu_size_minus5 must be less than or equal to 2");
   unsigned ctbLog2SizeY = uiCode + 5;
   pcSPS->setMaxCUWidth(pcSPS->getCTUSize());
   pcSPS->setMaxCUHeight(pcSPS->getCTUSize());
@@ -1331,7 +1331,7 @@
 
   if( !pcSPS->getVPSId() )
   {
-    CHECK( !pcSPS->getPtlDpbHrdParamsPresentFlag(), "When sps_video_parameter_set_id is equal to 0, the value of sps_ptl_dpb_hrd_params_present_flag shall be equal to 1" );
+    CHECK_VTM( !pcSPS->getPtlDpbHrdParamsPresentFlag(), "When sps_video_parameter_set_id is equal to 0, the value of sps_ptl_dpb_hrd_params_present_flag shall be equal to 1" );
   }
 
   if (pcSPS->getPtlDpbHrdParamsPresentFlag())
@@ -1348,7 +1348,7 @@
   READ_FLAG(uiCode, "sps_ref_pic_resampling_enabled_flag");          pcSPS->setRprEnabledFlag(uiCode);
   if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoRprConstraintFlag())
   {
-    CHECK(uiCode != 0, "When gci_no_ref_pic_resampling_constraint_flag is equal to 1, sps_ref_pic_resampling_enabled_flag shall be equal to 0");
+    CHECK_VTM(uiCode != 0, "When gci_no_ref_pic_resampling_constraint_flag is equal to 1, sps_ref_pic_resampling_enabled_flag shall be equal to 0");
   }
   if (uiCode)
   {
@@ -1361,7 +1361,7 @@
 
   if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoResChangeInClvsConstraintFlag())
   {
-    CHECK(uiCode != 0, "When no_res_change_in_clvs_constraint_flag is equal to 1, sps_res_change_in_clvs_allowed_flag shall be equal to 0");
+    CHECK_VTM(uiCode != 0, "When no_res_change_in_clvs_constraint_flag is equal to 1, sps_res_change_in_clvs_allowed_flag shall be equal to 0");
   }
 
   READ_UVLC( uiCode, "sps_pic_width_max_in_luma_samples" );          pcSPS->setMaxPicWidthInLumaSamples( uiCode );
@@ -1380,13 +1380,13 @@
   READ_FLAG( uiCode, "sps_subpic_info_present_flag" );               pcSPS->setSubPicInfoPresentFlag(uiCode);
   if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoSubpicInfoConstraintFlag())
   {
-    CHECK(uiCode != 0, "When gci_no_subpic_info_constraint_flag is equal to 1, the value of sps_subpic_info_present_flag shall be equal to 0");
+    CHECK_VTM(uiCode != 0, "When gci_no_subpic_info_constraint_flag is equal to 1, the value of sps_subpic_info_present_flag shall be equal to 0");
   }
 
   if (pcSPS->getSubPicInfoPresentFlag())
   {
     READ_UVLC(uiCode, "sps_num_subpics_minus1"); pcSPS->setNumSubPics(uiCode + 1);
-    CHECK(uiCode > (pcSPS->getMaxPicWidthInLumaSamples() / (1 << pcSPS->getCTUSize())) * (pcSPS->getMaxPicHeightInLumaSamples() / (1 << pcSPS->getCTUSize())) - 1, "Invalid sps_num_subpics_minus1 value");
+    CHECK_VTM(uiCode > (pcSPS->getMaxPicWidthInLumaSamples() / (1 << pcSPS->getCTUSize())) * (pcSPS->getMaxPicHeightInLumaSamples() / (1 << pcSPS->getCTUSize())) - 1, "Invalid sps_num_subpics_minus1 value");
     if( pcSPS->getNumSubPics() == 1 )
     {
       pcSPS->setSubPicCtuTopLeftX( 0, 0 );
@@ -1450,9 +1450,9 @@
           if (pcSPS->getSubPicSameSizeFlag())
           {
             numSubpicCols = tmpWidthVal / pcSPS->getSubPicWidth(0);
-            CHECK(!(tmpWidthVal % pcSPS->getSubPicWidth(0) == 0), "sps_subpic_width_minus1[0] is invalid.");
-            CHECK(!(tmpHeightVal % pcSPS->getSubPicHeight(0) == 0), "sps_subpic_height_minus1[0] is invalid.");
-            CHECK(!(numSubpicCols * (tmpHeightVal / pcSPS->getSubPicHeight(0)) == pcSPS->getNumSubPics()), "when sps_subpic_same_size_flag is equal to, sps_num_subpics_minus1 is invalid");
+            CHECK_VTM(!(tmpWidthVal % pcSPS->getSubPicWidth(0) == 0), "sps_subpic_width_minus1[0] is invalid.");
+            CHECK_VTM(!(tmpHeightVal % pcSPS->getSubPicHeight(0) == 0), "sps_subpic_height_minus1[0] is invalid.");
+            CHECK_VTM(!(numSubpicCols * (tmpHeightVal / pcSPS->getSubPicHeight(0)) == pcSPS->getNumSubPics()), "when sps_subpic_same_size_flag is equal to, sps_num_subpics_minus1 is invalid");
           }
         }
         else
@@ -1473,8 +1473,8 @@
     }
 
     READ_UVLC( uiCode, "sps_subpic_id_len_minus1" );                       pcSPS->setSubPicIdLen( uiCode + 1 );
-    CHECK( uiCode > 15, "Invalid sps_subpic_id_len_minus1 value" );
-    CHECK( (1 << (uiCode + 1)) < pcSPS->getNumSubPics(), "Invalid sps_subpic_id_len_minus1 value" );
+    CHECK_VTM( uiCode > 15, "Invalid sps_subpic_id_len_minus1 value" );
+    CHECK_VTM( (1 << (uiCode + 1)) < pcSPS->getNumSubPics(), "Invalid sps_subpic_id_len_minus1 value" );
     READ_FLAG( uiCode, "sps_subpic_id_mapping_explicitly_signalled_flag" );    pcSPS->setSubPicIdMappingExplicitlySignalledFlag( uiCode != 0 );
     if (pcSPS->getSubPicIdMappingExplicitlySignalledFlag())
     {
@@ -1507,11 +1507,11 @@
   }
 
   READ_UVLC(uiCode, "sps_bitdepth_minus8");
-  CHECK(uiCode > 8, "Invalid bit depth signalled");
+  CHECK_VTM(uiCode > 8, "Invalid bit depth signalled");
   const Profile::Name profile = pcSPS->getProfileTierLevel()->getProfileIdc();
   if (profile != Profile::NONE)
   {
-    CHECK(uiCode + 8 > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "sps_bitdepth_minus8 exceeds range supported by signalled profile");
+    CHECK_VTM(uiCode + 8 > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "sps_bitdepth_minus8 exceeds range supported by signalled profile");
   }
   pcSPS->setBitDepth(CHANNEL_TYPE_LUMA, 8 + uiCode);
   pcSPS->setBitDepth(CHANNEL_TYPE_CHROMA, 8 + uiCode);
@@ -1521,13 +1521,13 @@
   READ_FLAG( uiCode, "sps_entropy_coding_sync_enabled_flag" );       pcSPS->setEntropyCodingSyncEnabledFlag(uiCode == 1);
   READ_FLAG( uiCode, "sps_entry_point_offsets_present_flag");   pcSPS->setEntryPointsPresentFlag(uiCode == 1);
   READ_CODE(4, uiCode, "sps_log2_max_pic_order_cnt_lsb_minus4");     pcSPS->setBitsForPOC( 4 + uiCode );
-  CHECK(uiCode > 12, "sps_log2_max_pic_order_cnt_lsb_minus4 shall be in the range of 0 to 12");
+  CHECK_VTM(uiCode > 12, "sps_log2_max_pic_order_cnt_lsb_minus4 shall be in the range of 0 to 12");
   
   READ_FLAG(uiCode, "sps_poc_msb_cycle_flag");                    pcSPS->setPocMsbCycleFlag(uiCode ? true : false);
   if (pcSPS->getPocMsbCycleFlag())
   {
     READ_UVLC(uiCode, "sps_poc_msb_cycle_len_minus1");                  pcSPS->setPocMsbCycleLen(1 + uiCode);
-    CHECK(uiCode > (32 - ( pcSPS->getBitsForPOC() - 4 )- 5), "The value of sps_poc_msb_cycle_len_minus1 shall be in the range of 0 to 32 - sps_log2_max_pic_order_cnt_lsb_minus4 - 5, inclusive");
+    CHECK_VTM(uiCode > (32 - ( pcSPS->getBitsForPOC() - 4 )- 5), "The value of sps_poc_msb_cycle_len_minus1 shall be in the range of 0 to 32 - sps_log2_max_pic_order_cnt_lsb_minus4 - 5, inclusive");
   }
 
   // extra bits are for future extensions, we will read, but ignore them,
@@ -1569,30 +1569,30 @@
   READ_UVLC(uiCode, "sps_log2_min_luma_coding_block_size_minus2");
   int log2MinCUSize = uiCode + 2;
   pcSPS->setLog2MinCodingBlockSize(log2MinCUSize);
-  CHECK(uiCode > ctbLog2SizeY - 2, "Invalid sps_log2_min_luma_coding_block_size_minus2 signalled");
+  CHECK_VTM(uiCode > ctbLog2SizeY - 2, "Invalid sps_log2_min_luma_coding_block_size_minus2 signalled");
 
-  CHECK(log2MinCUSize > std::min(6, (int)(ctbLog2SizeY)), "sps_log2_min_luma_coding_block_size_minus2 shall be in the range of 0 to min (4, log2_ctu_size - 2)");
+  CHECK_VTM(log2MinCUSize > std::min(6, (int)(ctbLog2SizeY)), "sps_log2_min_luma_coding_block_size_minus2 shall be in the range of 0 to min (4, log2_ctu_size - 2)");
   const int minCuSize = 1 << pcSPS->getLog2MinCodingBlockSize();
-  CHECK( ( pcSPS->getMaxPicWidthInLumaSamples() % ( std::max( 8, minCuSize ) ) ) != 0, "Coded frame width must be a multiple of Max(8, the minimum unit size)" );
-  CHECK( ( pcSPS->getMaxPicHeightInLumaSamples() % ( std::max( 8, minCuSize ) ) ) != 0, "Coded frame height must be a multiple of Max(8, the minimum unit size)" );
+  CHECK_VTM( ( pcSPS->getMaxPicWidthInLumaSamples() % ( std::max( 8, minCuSize ) ) ) != 0, "Coded frame width must be a multiple of Max(8, the minimum unit size)" );
+  CHECK_VTM( ( pcSPS->getMaxPicHeightInLumaSamples() % ( std::max( 8, minCuSize ) ) ) != 0, "Coded frame height must be a multiple of Max(8, the minimum unit size)" );
 
   READ_FLAG(uiCode, "sps_partition_constraints_override_enabled_flag"); pcSPS->setSplitConsOverrideEnabledFlag(uiCode);
   READ_UVLC(uiCode, "sps_log2_diff_min_qt_min_cb_intra_slice_luma");
   unsigned minQtLog2SizeIntraY = uiCode + pcSPS->getLog2MinCodingBlockSize();
   minQT[0] = 1 << minQtLog2SizeIntraY;
-  CHECK(minQT[0] > 64, "The value of sps_log2_diff_min_qt_min_cb_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
-  CHECK(minQT[0] > (1<<ctbLog2SizeY), "The value of sps_log2_diff_min_qt_min_cb_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
+  CHECK_VTM(minQT[0] > 64, "The value of sps_log2_diff_min_qt_min_cb_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
+  CHECK_VTM(minQT[0] > (1<<ctbLog2SizeY), "The value of sps_log2_diff_min_qt_min_cb_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
   READ_UVLC(uiCode, "sps_max_mtt_hierarchy_depth_intra_slice_luma");     maxBTD[0] = uiCode;
-  CHECK(uiCode > 2 * (ctbLog2SizeY - log2MinCUSize), "sps_max_mtt_hierarchy_depth_intra_slice_luma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
+  CHECK_VTM(uiCode > 2 * (ctbLog2SizeY - log2MinCUSize), "sps_max_mtt_hierarchy_depth_intra_slice_luma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
 
   maxTTSize[0] = maxBTSize[0] = minQT[0];
   if (maxBTD[0] != 0)
   {
     READ_UVLC(uiCode, "sps_log2_diff_max_bt_min_qt_intra_slice_luma");     maxBTSize[0] <<= uiCode;
-    CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of sps_log2_diff_max_bt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
+    CHECK_VTM(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of sps_log2_diff_max_bt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
     READ_UVLC(uiCode, "sps_log2_diff_max_tt_min_qt_intra_slice_luma");     maxTTSize[0] <<= uiCode;
-    CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of sps_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
-    CHECK(maxTTSize[0] > 64, "The value of sps_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraY");
+    CHECK_VTM(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of sps_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
+    CHECK_VTM(maxTTSize[0] > 64, "The value of sps_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraY");
   }
   if( pcSPS->getChromaFormatIdc() != CHROMA_400 )
   {
@@ -1606,29 +1606,29 @@
   {
     READ_UVLC(uiCode, "sps_log2_diff_min_qt_min_cb_intra_slice_chroma"); minQT[2] = 1 << (uiCode + pcSPS->getLog2MinCodingBlockSize());
     READ_UVLC(uiCode, "sps_max_mtt_hierarchy_depth_intra_slice_chroma"); maxBTD[2] = uiCode;
-    CHECK(uiCode > 2 * (ctbLog2SizeY - log2MinCUSize), "sps_max_mtt_hierarchy_depth_intra_slice_chroma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
+    CHECK_VTM(uiCode > 2 * (ctbLog2SizeY - log2MinCUSize), "sps_max_mtt_hierarchy_depth_intra_slice_chroma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
     maxTTSize[2] = maxBTSize[2] = minQT[2];
     if (maxBTD[2] != 0)
     {
       READ_UVLC(uiCode, "sps_log2_diff_max_bt_min_qt_intra_slice_chroma");       maxBTSize[2] <<= uiCode;
       READ_UVLC(uiCode, "sps_log2_diff_max_tt_min_qt_intra_slice_chroma");       maxTTSize[2] <<= uiCode;
-      CHECK(maxTTSize[2] > 64, "The value of sps_log2_diff_max_tt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
-      CHECK(maxBTSize[2] > 64, "The value of sps_log2_diff_max_bt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
+      CHECK_VTM(maxTTSize[2] > 64, "The value of sps_log2_diff_max_tt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
+      CHECK_VTM(maxBTSize[2] > 64, "The value of sps_log2_diff_max_bt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
     }
   }
   READ_UVLC(uiCode, "sps_log2_diff_min_qt_min_cb_inter_slice");
   unsigned minQtLog2SizeInterY = uiCode + pcSPS->getLog2MinCodingBlockSize();
   minQT[1] = 1 << minQtLog2SizeInterY;
   READ_UVLC(uiCode, "sps_max_mtt_hierarchy_depth_inter_slice");     maxBTD[1] = uiCode;
-  CHECK(uiCode > 2*(ctbLog2SizeY - log2MinCUSize), "sps_max_mtt_hierarchy_depth_inter_slice shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
+  CHECK_VTM(uiCode > 2*(ctbLog2SizeY - log2MinCUSize), "sps_max_mtt_hierarchy_depth_inter_slice shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
   maxTTSize[1] = maxBTSize[1] = minQT[1];
   if (maxBTD[1] != 0)
   {
     READ_UVLC(uiCode, "sps_log2_diff_max_bt_min_qt_inter_slice");     maxBTSize[1] <<= uiCode;
-    CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of sps_log2_diff_max_bt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
+    CHECK_VTM(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of sps_log2_diff_max_bt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
     READ_UVLC(uiCode, "sps_log2_diff_max_tt_min_qt_inter_slice");     maxTTSize[1] <<= uiCode;
-    CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of sps_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
-    CHECK(maxTTSize[1] > 64, "The value of sps_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeInterY");
+    CHECK_VTM(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of sps_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
+    CHECK_VTM(maxTTSize[1] > 64, "The value of sps_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeInterY");
   }
 
   pcSPS->setMinQTSizes(minQT);
@@ -1671,11 +1671,11 @@
       int32_t qpTableStart = 0;
       READ_SVLC(qpTableStart, "sps_qp_table_starts_minus26");
       chromaQpMappingTableParams.setQpTableStartMinus26(i, qpTableStart);
-      CHECK(qpTableStart < -26 - pcSPS->getQpBDOffset(CHANNEL_TYPE_LUMA) || qpTableStart > 36,
+      CHECK_VTM(qpTableStart < -26 - pcSPS->getQpBDOffset(CHANNEL_TYPE_LUMA) || qpTableStart > 36,
             "The value of sps_qp_table_start_minus26[ i ] shall be in the range of -26 - QpBdOffset to 36 inclusive");
       READ_UVLC(uiCode, "sps_num_points_in_qp_table_minus1");
       chromaQpMappingTableParams.setNumPtsInCQPTableMinus1(i, uiCode);
-      CHECK(uiCode > 36 - qpTableStart, "The value of sps_num_points_in_qp_table_minus1[ i ] shall be in the range of "
+      CHECK_VTM(uiCode > 36 - qpTableStart, "The value of sps_num_points_in_qp_table_minus1[ i ] shall be in the range of "
                                         "0 to 36 - sps_qp_table_start_minus26[ i ], inclusive");
       std::vector<int> deltaQpInValMinus1(chromaQpMappingTableParams.getNumPtsInCQPTableMinus1(i) + 1);
       std::vector<int> deltaQpOutVal(chromaQpMappingTableParams.getNumPtsInCQPTableMinus1(i) + 1);
@@ -1722,7 +1722,7 @@
   READ_FLAG( uiCode, "sps_idr_rpl_present_flag" );       pcSPS->setIDRRefParamListPresent( (bool) uiCode );
   if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoIdrRplConstraintFlag())
   {
-    CHECK(uiCode != 0, "When gci_no_idr_rpl_constraint_flag equal to 1 , the value of sps_idr_rpl_present_flag shall be equal to 0");
+    CHECK_VTM(uiCode != 0, "When gci_no_idr_rpl_constraint_flag equal to 1 , the value of sps_idr_rpl_present_flag shall be equal to 0");
   }
 
   READ_FLAG(uiCode, "sps_rpl1_same_as_rpl0_flag");
@@ -1770,7 +1770,7 @@
   {
     for (int i = 0; i < pcSPS->getNumSubPics(); i++)
     {
-      CHECK(pcSPS->getSubPicTreatedAsPicFlag(i) && (pcSPS->getSubPicWidth(i) != (pcSPS->getMaxPicWidthInLumaSamples() + pcSPS->getCTUSize() - 1) / pcSPS->getCTUSize()), "sps_ref_wraparound_enabled_flag cannot be equal to 1 when there is at least one subpicture with SubPicTreatedAsPicFlag equal to 1 and the subpicture's width is not equal to picture's width");
+      CHECK_VTM(pcSPS->getSubPicTreatedAsPicFlag(i) && (pcSPS->getSubPicWidth(i) != (pcSPS->getMaxPicWidthInLumaSamples() + pcSPS->getCTUSize() - 1) / pcSPS->getCTUSize()), "sps_ref_wraparound_enabled_flag cannot be equal to 1 when there is at least one subpicture with SubPicTreatedAsPicFlag equal to 1 and the subpicture's width is not equal to picture's width");
     }
   }
 
@@ -1816,17 +1816,17 @@
   }
 
   READ_UVLC(uiCode, "sps_six_minus_max_num_merge_cand");
-  CHECK(MRG_MAX_NUM_CANDS <= uiCode, "Incorrrect max number of merge candidates!");
+  CHECK_VTM(MRG_MAX_NUM_CANDS <= uiCode, "Incorrrect max number of merge candidates!");
   pcSPS->setMaxNumMergeCand(MRG_MAX_NUM_CANDS - uiCode);
   READ_FLAG(uiCode, "sps_sbt_enabled_flag");                        pcSPS->setUseSBT                 ( uiCode != 0 );
   READ_FLAG( uiCode,    "sps_affine_enabled_flag" );                            pcSPS->setUseAffine              ( uiCode != 0 );
   if ( pcSPS->getUseAffine() )
   {
     READ_UVLC(uiCode, "sps_five_minus_max_num_subblock_merge_cand");
-    CHECK(
+    CHECK_VTM(
       uiCode > 5 - (pcSPS->getSbTMVPEnabledFlag() ? 1 : 0),
       "The value of sps_five_minus_max_num_subblock_merge_cand shall be in the range of 0 to 5 - sps_sbtmvp_enabled_flag");
-    CHECK(AFFINE_MRG_MAX_NUM_CANDS < uiCode, "The value of sps_five_minus_max_num_subblock_merge_cand shall be in the range of 0 to 5 - sps_sbtmvp_enabled_flag");
+    CHECK_VTM(AFFINE_MRG_MAX_NUM_CANDS < uiCode, "The value of sps_five_minus_max_num_subblock_merge_cand shall be in the range of 0 to 5 - sps_sbtmvp_enabled_flag");
     pcSPS->setMaxNumAffineMergeCand(AFFINE_MRG_MAX_NUM_CANDS - uiCode);
     READ_FLAG( uiCode,  "sps_affine_type_flag" );                       pcSPS->setUseAffineType          ( uiCode != 0 );
     if( pcSPS->getAMVREnabledFlag())
@@ -1855,7 +1855,7 @@
       if (pcSPS->getMaxNumMergeCand() >= 3)
       {
         READ_UVLC(uiCode, "sps_max_num_merge_cand_minus_max_num_gpm_cand");
-        CHECK(pcSPS->getMaxNumMergeCand() - 2 < uiCode,
+        CHECK_VTM(pcSPS->getMaxNumMergeCand() - 2 < uiCode,
               "sps_max_num_merge_cand_minus_max_num_gpm_cand must not be greater than the number of merge candidates minus 2");
         pcSPS->setMaxNumGeoCand((uint32_t)(pcSPS->getMaxNumMergeCand() - uiCode));
       }
@@ -1872,7 +1872,7 @@
   }
 
   READ_UVLC(uiCode, "sps_log2_parallel_merge_level_minus2");
-  CHECK(uiCode + 2 > ctbLog2SizeY, "The value of sps_log2_parallel_merge_level_minus2 shall be in the range of 0 to ctbLog2SizeY - 2");
+  CHECK_VTM(uiCode + 2 > ctbLog2SizeY, "The value of sps_log2_parallel_merge_level_minus2 shall be in the range of 0 to ctbLog2SizeY - 2");
   pcSPS->setLog2ParallelMergeLevelMinus2(uiCode);
 
 
@@ -1910,14 +1910,14 @@
   {
     READ_UVLC(uiCode, "sps_internal_bit_depth_minus_input_bit_depth");
     pcSPS->setInternalMinusInputBitDepth(CHANNEL_TYPE_LUMA, uiCode);
-    CHECK(uiCode > 8, "Invalid sps_internal_bit_depth_minus_input_bit_depth signalled");
+    CHECK_VTM(uiCode > 8, "Invalid sps_internal_bit_depth_minus_input_bit_depth signalled");
     pcSPS->setInternalMinusInputBitDepth(CHANNEL_TYPE_CHROMA, uiCode);
   }
   READ_FLAG(uiCode, "sps_ibc_enabled_flag");                                    pcSPS->setIBCFlag(uiCode);
   if (pcSPS->getIBCFlag())
   {
     READ_UVLC(uiCode, "sps_six_minus_max_num_ibc_merge_cand");
-    CHECK(IBC_MRG_MAX_NUM_CANDS <= uiCode, "Incorrect max number of IBC merge candidates!");
+    CHECK_VTM(IBC_MRG_MAX_NUM_CANDS <= uiCode, "Incorrect max number of IBC merge candidates!");
     pcSPS->setMaxNumIBCMergeCand(IBC_MRG_MAX_NUM_CANDS - uiCode);
   }
   else
@@ -1942,7 +1942,7 @@
   READ_FLAG(uiCode, "sps_explicit_scaling_list_enabled_flag");                 pcSPS->setScalingListFlag(uiCode);
   if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoExplicitScaleListConstraintFlag())
   {
-    CHECK(uiCode != 0, "When gci_no_explicit_scaling_list_constraint_flag is equal to 1, sps_explicit_scaling_list_enabled_flag shall be equal to 0");
+    CHECK_VTM(uiCode != 0, "When gci_no_explicit_scaling_list_constraint_flag is equal to 1, sps_explicit_scaling_list_enabled_flag shall be equal to 0");
   }
 
   if (pcSPS->getUseLFNST() && pcSPS->getScalingListFlag())
@@ -1964,7 +1964,7 @@
   READ_FLAG( uiCode, "sps_virtual_boundaries_enabled_flag" ); pcSPS->setVirtualBoundariesEnabledFlag( uiCode != 0 );
   if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoVirtualBoundaryConstraintFlag())
   {
-    CHECK(uiCode != 0, "When gci_no_virtual_boundaries_constraint_flag is equal to 1, sps_virtual_boundaries_enabled_flag shall be equal to 0");
+    CHECK_VTM(uiCode != 0, "When gci_no_virtual_boundaries_constraint_flag is equal to 1, sps_virtual_boundaries_enabled_flag shall be equal to 0");
   }
 
   if( pcSPS->getVirtualBoundariesEnabledFlag() )
@@ -1975,30 +1975,30 @@
     READ_UVLC(uiCode, "sps_num_ver_virtual_boundaries");        pcSPS->setNumVerVirtualBoundaries( uiCode );
     if (pcSPS->getMaxPicWidthInLumaSamples() <= 8)
     {
-      CHECK(pcSPS->getNumVerVirtualBoundaries() != 0, "SPS: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
+      CHECK_VTM(pcSPS->getNumVerVirtualBoundaries() != 0, "SPS: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
     }
     else
     {
-      CHECK(pcSPS->getNumVerVirtualBoundaries() > 3, "SPS: The number of vertical virtual boundaries shall be in the range of 0 to 3");
+      CHECK_VTM(pcSPS->getNumVerVirtualBoundaries() > 3, "SPS: The number of vertical virtual boundaries shall be in the range of 0 to 3");
     }
     for( unsigned i = 0; i < pcSPS->getNumVerVirtualBoundaries(); i++ )
     {
       READ_UVLC(uiCode, "sps_virtual_boundary_pos_x_minus1[i]");        pcSPS->setVirtualBoundariesPosX((uiCode + 1) << 3, i);
-      CHECK(uiCode > (((pcSPS->getMaxPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_width_max_in_luma_samples / 8 ) - 2, inclusive.");
+      CHECK_VTM(uiCode > (((pcSPS->getMaxPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_width_max_in_luma_samples / 8 ) - 2, inclusive.");
     }
     READ_UVLC(uiCode, "sps_num_hor_virtual_boundaries");        pcSPS->setNumHorVirtualBoundaries( uiCode );
     if (pcSPS->getMaxPicHeightInLumaSamples() <= 8)
     {
-      CHECK(pcSPS->getNumHorVirtualBoundaries() != 0, "SPS: When picture height is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
+      CHECK_VTM(pcSPS->getNumHorVirtualBoundaries() != 0, "SPS: When picture height is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
     }
     else
     {
-      CHECK(pcSPS->getNumHorVirtualBoundaries() > 3, "SPS: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
+      CHECK_VTM(pcSPS->getNumHorVirtualBoundaries() > 3, "SPS: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
     }
     for( unsigned i = 0; i < pcSPS->getNumHorVirtualBoundaries(); i++ )
     {
       READ_UVLC(uiCode, "sps_virtual_boundary_pos_y_minus1[i]");        pcSPS->setVirtualBoundariesPosY((uiCode + 1) << 3, i);
-      CHECK(uiCode > (((pcSPS->getMaxPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_height_max_in_luma_samples / 8 ) - 2, inclusive.");
+      CHECK_VTM(uiCode > (((pcSPS->getMaxPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_height_max_in_luma_samples / 8 ) - 2, inclusive.");
     }
   }
   else
@@ -2033,7 +2033,7 @@
   }
 
   READ_FLAG(     uiCode, "sps_field_seq_flag");                       pcSPS->setFieldSeqFlag(uiCode);
-  CHECK( pcSPS->getProfileTierLevel()->getFrameOnlyConstraintFlag() && uiCode, "When ptl_frame_only_constraint_flag equal to 1 , the value of sps_field_seq_flag shall be equal to 0");
+  CHECK_VTM( pcSPS->getProfileTierLevel()->getFrameOnlyConstraintFlag() && uiCode, "When ptl_frame_only_constraint_flag equal to 1 , the value of sps_field_seq_flag shall be equal to 0");
 
   READ_FLAG( uiCode, "sps_vui_parameters_present_flag" );             pcSPS->setVuiParametersPresentFlag(uiCode);
 
@@ -2044,7 +2044,7 @@
     while (!isByteAligned())
     {
       READ_FLAG(uiCode, "sps_vui_alignment_zero_bit");
-      CHECK(uiCode != 0, "sps_vui_alignment_zero_bit not equal to 0");
+      CHECK_VTM(uiCode != 0, "sps_vui_alignment_zero_bit not equal to 0");
     }
     parseVUI(pcSPS->getVuiParameters(), pcSPS);
   }
@@ -2080,7 +2080,7 @@
         switch (SPSExtensionFlagIndex(i))
         {
         case SPS_EXT__REXT:
-          CHECK(bSkipTrailingExtensionBits, "Skipping trailing extension bits not supported");
+          CHECK_VTM(bSkipTrailingExtensionBits, "Skipping trailing extension bits not supported");
           {
             SPSRExt &spsRangeExtension = pcSPS->getSpsRangeExtension();
             READ_FLAG( uiCode, "transform_skip_rotation_enabled_flag");     spsRangeExtension.setTransformSkipRotationEnabledFlag(uiCode != 0);
@@ -2149,15 +2149,17 @@
   uint32_t  uiCode;
 
   READ_CODE(4, uiCode, "vps_video_parameter_set_id");
-  CHECK( uiCode == 0, "vps_video_parameter_set_id equal to zero is reserved and shall not be used in a bitstream" );
+  CHECK_VTM( uiCode == 0, "vps_video_parameter_set_id equal to zero is reserved and shall not be used in a bitstream" );
   pcVPS->setVPSId(uiCode);
 
-  READ_CODE(6, uiCode, "vps_max_layers_minus1");              pcVPS->setMaxLayers(uiCode + 1);    CHECK(uiCode + 1 > MAX_VPS_LAYERS, "Signalled number of layers larger than MAX_VPS_LAYERS.");
+  READ_CODE(6, uiCode, "vps_max_layers_minus1");              pcVPS->setMaxLayers(uiCode + 1);
+  CHECK_VTM(uiCode + 1 > MAX_VPS_LAYERS, "Signalled number of layers larger than MAX_VPS_LAYERS.");
   if (pcVPS->getMaxLayers() - 1 == 0)
   {
     pcVPS->setEachLayerIsAnOlsFlag(1);
   }
-  READ_CODE(3, uiCode, "vps_max_sublayers_minus1");           pcVPS->setMaxSubLayers(uiCode + 1); CHECK(uiCode + 1 > MAX_VPS_SUBLAYERS, "Signalled number of sublayers larger than MAX_VPS_SUBLAYERS.");
+  READ_CODE(3, uiCode, "vps_max_sublayers_minus1");           pcVPS->setMaxSubLayers(uiCode + 1);
+  CHECK_VTM(uiCode + 1 > MAX_VPS_SUBLAYERS, "Signalled number of sublayers larger than MAX_VPS_SUBLAYERS.");
   if( pcVPS->getMaxLayers() > 1 && pcVPS->getMaxSubLayers() > 1)
   {
     READ_FLAG(uiCode, "vps_default_ptl_dpb_hrd_max_tid_flag"); pcVPS->setDefaultPtlDpbHrdMaxTidFlag(uiCode);
@@ -2195,7 +2197,7 @@
             sumUiCode++;
           }
         }
-        CHECK(sumUiCode == 0, "There has to be at least one value of j such that the value of vps_direct_dependency_flag[ i ][ j ] is equal to 1,when vps_independent_layer_flag[ i ] is equal to 0 ");
+        CHECK_VTM(sumUiCode == 0, "There has to be at least one value of j such that the value of vps_direct_dependency_flag[ i ][ j ] is equal to 1,when vps_independent_layer_flag[ i ] is equal to 0 ");
         READ_FLAG(uiCode, "vps_max_tid_ref_present_flag[ i ]");
         if (uiCode)
         {
@@ -2224,7 +2226,8 @@
     {
       if (!pcVPS->getAllIndependentLayersFlag())
       {
-        READ_CODE(2, uiCode, "vps_ols_mode_idc");         pcVPS->setOlsModeIdc(uiCode); CHECK(uiCode > MAX_VPS_OLS_MODE_IDC, "vps_ols_mode_idc shall be in the range of 0 to 2");
+        READ_CODE(2, uiCode, "vps_ols_mode_idc");         pcVPS->setOlsModeIdc(uiCode);
+        CHECK_VTM(uiCode > MAX_VPS_OLS_MODE_IDC, "vps_ols_mode_idc shall be in the range of 0 to 2");
       }
       if (pcVPS->getOlsModeIdc() == 2)
       {
@@ -2245,7 +2248,7 @@
     pcVPS->setNumPtls(1);
   }
   pcVPS->deriveOutputLayerSets();
-  CHECK( uiCode >= pcVPS->getTotalNumOLSs(),"The value of vps_num_ptls_minus1 shall be less than TotalNumOlss");
+  CHECK_VTM( uiCode >= pcVPS->getTotalNumOLSs(),"The value of vps_num_ptls_minus1 shall be less than TotalNumOlss");
   std::vector<bool> isPTLReferred( pcVPS->getNumPtls(), false);
 
   for (int i = 0; i < pcVPS->getNumPtls(); i++)
@@ -2271,10 +2274,10 @@
   while (m_pcBitstream->getNumBitsUntilByteAligned())
   {
     READ_FLAG( uiCode, "vps_ptl_reserved_zero_bit");
-    CHECK(uiCode!=0, "Alignment bit is not '0'");
+    CHECK_VTM(uiCode!=0, "Alignment bit is not '0'");
     cnt++;
   }
-  CHECK(cnt >= 8, "Read more than '8' alignment bits");
+  CHECK_VTM(cnt >= 8, "Read more than '8' alignment bits");
   std::vector<ProfileTierLevel> ptls;
   ptls.resize(pcVPS->getNumPtls());
   for (int i = 0; i < pcVPS->getNumPtls(); i++)
@@ -2299,14 +2302,14 @@
   }
   for( int i = 0; i < pcVPS->getNumPtls(); i++ )
   {
-    CHECK( !isPTLReferred[i],"Each profile_tier_level( ) syntax structure in the VPS shall be referred to by at least one value of vps_ols_ptl_idx[ i ] for i in the range of 0 to TotalNumOlss ? 1, inclusive");
+    CHECK_VTM( !isPTLReferred[i],"Each profile_tier_level( ) syntax structure in the VPS shall be referred to by at least one value of vps_ols_ptl_idx[ i ] for i in the range of 0 to TotalNumOlss ? 1, inclusive");
   }
 
   if( !pcVPS->getEachLayerIsAnOlsFlag() )
   {
     READ_UVLC( uiCode, "vps_num_dpb_params_minus1" ); pcVPS->m_numDpbParams = uiCode + 1;
 
-    CHECK( pcVPS->m_numDpbParams > pcVPS->getNumMultiLayeredOlss(),"The value of vps_num_dpb_params_minus1 shall be in the range of 0 to NumMultiLayerOlss - 1, inclusive");
+    CHECK_VTM( pcVPS->m_numDpbParams > pcVPS->getNumMultiLayeredOlss(),"The value of vps_num_dpb_params_minus1 shall be in the range of 0 to NumMultiLayerOlss - 1, inclusive");
     std::vector<bool> isDPBParamReferred(pcVPS->m_numDpbParams, false);
 
     if( pcVPS->m_numDpbParams > 0 && pcVPS->getMaxSubLayers() > 1 )
@@ -2322,7 +2325,7 @@
       {
         READ_CODE(3, uiCode, "vps_dpb_max_tid[i]");
         pcVPS->m_dpbMaxTemporalId.push_back(uiCode);
-        CHECK (uiCode > (pcVPS->getMaxSubLayers() - 1), "The value of vps_dpb_max_tid[i] shall be in the range of 0 to vps_max_sublayers_minus1, inclusive." )
+        CHECK_VTM(uiCode > (pcVPS->getMaxSubLayers() - 1), "The value of vps_dpb_max_tid[i] shall be in the range of 0 to vps_max_sublayers_minus1, inclusive." )
       }
       else
       {
@@ -2362,7 +2365,7 @@
         const Profile::Name profile = pcVPS->getProfileTierLevel(pcVPS->getOlsPtlIdx(i)).getProfileIdc();
         if (profile != Profile::NONE)
         {
-          CHECK(uiCode + 8 > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "vps_ols_dpb_bitdepth_minus8[ i ] exceeds range supported by signalled profile");
+          CHECK_VTM(uiCode + 8 > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "vps_ols_dpb_bitdepth_minus8[ i ] exceeds range supported by signalled profile");
         }
         if ((pcVPS->m_numDpbParams > 1) && (pcVPS->m_numDpbParams != pcVPS->m_numMultiLayeredOlss))
         {
@@ -2382,7 +2385,7 @@
     }
     for( int i = 0; i < pcVPS->m_numDpbParams; i++ )
     {
-      CHECK( !isDPBParamReferred[i],"Each dpb_parameters( ) syntax structure in the VPS shall be referred to by at least one value of vps_ols_dpb_params_idx[i] for i in the range of 0 to NumMultiLayerOlss - 1, inclusive");
+      CHECK_VTM( !isDPBParamReferred[i],"Each dpb_parameters( ) syntax structure in the VPS shall be referred to by at least one value of vps_ols_dpb_params_idx[i] for i in the range of 0 to NumMultiLayerOlss - 1, inclusive");
     }
   }
 
@@ -2402,7 +2405,7 @@
       pcVPS->setVPSSublayerCpbParamsPresentFlag(0);
     }
     READ_UVLC(uiCode, "vps_num_ols_timing_hrd_params_minus1"); pcVPS->setNumOlsTimingHrdParamsMinus1(uiCode);
-    CHECK( uiCode >= pcVPS->getNumMultiLayeredOlss(),"The value of vps_num_ols_timing_hrd_params_minus1 shall be in the range of 0 to NumMultiLayerOlss - 1, inclusive");
+    CHECK_VTM( uiCode >= pcVPS->getNumMultiLayeredOlss(),"The value of vps_num_ols_timing_hrd_params_minus1 shall be in the range of 0 to NumMultiLayerOlss - 1, inclusive");
     std::vector<bool> isHRDParamReferred( uiCode + 1, false);
     pcVPS->m_olsHrdParams.clear();
     pcVPS->m_olsHrdParams.resize(pcVPS->getNumOlsTimingHrdParamsMinus1(), std::vector<OlsHrdParams>(pcVPS->getMaxSubLayers()));
@@ -2411,7 +2414,7 @@
       if (!pcVPS->getDefaultPtlDpbHrdMaxTidFlag())
       {
         READ_CODE(3, uiCode, "vps_hrd_max_tid[i]");  pcVPS->setHrdMaxTid(i, uiCode);
-        CHECK (uiCode > (pcVPS->getMaxSubLayers() - 1), "The value of vps_hrd_max_tid[i] shall be in the range of 0 to vps_max_sublayers_minus1, inclusive." )
+        CHECK_VTM(uiCode > (pcVPS->getMaxSubLayers() - 1), "The value of vps_hrd_max_tid[i] shall be in the range of 0 to vps_max_sublayers_minus1, inclusive." )
       }
       else
       {
@@ -2429,7 +2432,7 @@
       if (((pcVPS->getNumOlsTimingHrdParamsMinus1() + 1) != pcVPS->m_numMultiLayeredOlss) && (pcVPS->getNumOlsTimingHrdParamsMinus1() > 0))
       {
         READ_UVLC(uiCode, "vps_ols_timing_hrd_idx[i]"); pcVPS->setOlsTimingHrdIdx(i, uiCode);
-        CHECK(uiCode > pcVPS->getNumOlsTimingHrdParamsMinus1(), "The value of vps_ols_timing_hrd_idx[[ i ] shall be in the range of 0 to vps_num_ols_timing_hrd_params_minus1, inclusive.");
+        CHECK_VTM(uiCode > pcVPS->getNumOlsTimingHrdParamsMinus1(), "The value of vps_ols_timing_hrd_idx[[ i ] shall be in the range of 0 to vps_num_ols_timing_hrd_params_minus1, inclusive.");
       }
       else if (pcVPS->getNumOlsTimingHrdParamsMinus1() == 0)
       {
@@ -2443,7 +2446,7 @@
     }
     for( int i = 0; i <= pcVPS->getNumOlsTimingHrdParamsMinus1(); i++ )
     {
-      CHECK( !isHRDParamReferred[i], "Each vps_ols_timing_hrd_parameters( ) syntax structure in the VPS shall be referred to by at least one value of vps_ols_timing_hrd_idx[ i ] for i in the range of 1 to NumMultiLayerOlss - 1, inclusive");
+      CHECK_VTM( !isHRDParamReferred[i], "Each vps_ols_timing_hrd_parameters( ) syntax structure in the VPS shall be referred to by at least one value of vps_ols_timing_hrd_idx[ i ] for i in the range of 1 to NumMultiLayerOlss - 1, inclusive");
     }
   }
   else
@@ -2497,15 +2500,15 @@
   {
     picHeader->setPicIntraSliceAllowedFlag(true);
   }
-  CHECK(picHeader->getPicInterSliceAllowedFlag() == 0 && picHeader->getPicIntraSliceAllowedFlag() == 0, "Invalid picture without intra or inter slice");
+  CHECK_VTM(picHeader->getPicInterSliceAllowedFlag() == 0 && picHeader->getPicIntraSliceAllowedFlag() == 0, "Invalid picture without intra or inter slice");
   // parameter sets
   READ_UVLC(uiCode, "ph_pic_parameter_set_id");
   picHeader->setPPSId(uiCode);
   pps = parameterSetManager->getPPS(picHeader->getPPSId());
-  CHECK(pps == 0, "Invalid PPS");
+  CHECK_VTM(pps == 0, "Invalid PPS");
   picHeader->setSPSId(pps->getSPSId());
   sps = parameterSetManager->getSPS(picHeader->getSPSId());
-  CHECK(sps == 0, "Invalid SPS");
+  CHECK_VTM(sps == 0, "Invalid SPS");
   READ_CODE(sps->getBitsForPOC(), uiCode, "ph_pic_order_cnt_lsb");
   picHeader->setPocLsb(uiCode);
   if( picHeader->getGdrPicFlag() )
@@ -2666,7 +2669,7 @@
   }
   if (pps->getPicWidthInLumaSamples() == sps->getMaxPicWidthInLumaSamples() && pps->getPicHeightInLumaSamples() == sps->getMaxPicHeightInLumaSamples())
   {
-    CHECK(pps->getConformanceWindowFlag(), "When pps_pic_width_in_luma_samples is equal to sps_pic_width_max_in_luma_samples and pps_pic_height_in_luma_samples is equal to sps_pic_height_max_in_luma_samples, the value of pps_conformance_window_flag shall be equal to 0");
+    CHECK_VTM(pps->getConformanceWindowFlag(), "When pps_pic_width_in_luma_samples is equal to sps_pic_width_max_in_luma_samples and pps_pic_height_in_luma_samples is equal to sps_pic_height_max_in_luma_samples, the value of pps_conformance_window_flag shall be equal to 0");
     pps->getConformanceWindow().setWindowLeftOffset(sps->getConformanceWindow().getWindowLeftOffset());
     pps->getConformanceWindow().setWindowRightOffset(sps->getConformanceWindow().getWindowRightOffset());
     pps->getConformanceWindow().setWindowTopOffset(sps->getConformanceWindow().getWindowTopOffset());
@@ -2691,11 +2694,11 @@
     pps->setSliceTileIdx( 0, 0 );
     pps->initRectSliceMap(sps);
     // when no Pic partition, number of sub picture shall be less than 2
-    CHECK(pps->getNumSubPics()>=2, "error, no picture partitions, but have equal to or more than 2 sub pictures");
+    CHECK_VTM(pps->getNumSubPics()>=2, "error, no picture partitions, but have equal to or more than 2 sub pictures");
   }
   else
   {
-    CHECK(pps->getCtuSize() != sps->getCTUSize(), "PPS CTU size does not match CTU size in SPS");
+    CHECK_VTM(pps->getCtuSize() != sps->getCTUSize(), "PPS CTU size does not match CTU size in SPS");
     if (pps->getRectSliceFlag())
     {
       pps->initRectSliceMap(sps);
@@ -2706,11 +2709,11 @@
 
   // set wraparound offset from PPS and SPS info
   int minCbSizeY = (1 << sps->getLog2MinCodingBlockSize());
-  CHECK( !sps->getWrapAroundEnabledFlag() && pps->getWrapAroundEnabledFlag(), "When sps_ref_wraparound_enabled_flag is equal to 0, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
-  CHECK( (((sps->getCTUSize() / minCbSizeY) + 1) > ((pps->getPicWidthInLumaSamples() / minCbSizeY) - 1)) && pps->getWrapAroundEnabledFlag(), "When the value of CtbSizeY / MinCbSizeY + 1 is greater than pps_pic_width_in_luma_samples / MinCbSizeY - 1, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
+  CHECK_VTM( !sps->getWrapAroundEnabledFlag() && pps->getWrapAroundEnabledFlag(), "When sps_ref_wraparound_enabled_flag is equal to 0, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
+  CHECK_VTM( (((sps->getCTUSize() / minCbSizeY) + 1) > ((pps->getPicWidthInLumaSamples() / minCbSizeY) - 1)) && pps->getWrapAroundEnabledFlag(), "When the value of CtbSizeY / MinCbSizeY + 1 is greater than pps_pic_width_in_luma_samples / MinCbSizeY - 1, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
   if( pps->getWrapAroundEnabledFlag() )
   {
-    CHECK((pps->getPicWidthMinusWrapAroundOffset() > (pps->getPicWidthInLumaSamples() / minCbSizeY - sps->getCTUSize() / minCbSizeY - 2)), "pps_pic_width_minus_wraparound_ofsfet shall be less than or equal to pps_pic_width_in_luma_samples/MinCbSizeY - CtbSizeY/MinCbSizeY-2");
+    CHECK_VTM((pps->getPicWidthMinusWrapAroundOffset() > (pps->getPicWidthInLumaSamples() / minCbSizeY - sps->getCTUSize() / minCbSizeY - 2)), "pps_pic_width_minus_wraparound_ofsfet shall be less than or equal to pps_pic_width_in_luma_samples/MinCbSizeY - CtbSizeY/MinCbSizeY-2");
     pps->setWrapAroundOffset(minCbSizeY * (pps->getPicWidthInLumaSamples()/minCbSizeY- pps->getPicWidthMinusWrapAroundOffset()));
   }
   else
@@ -2728,30 +2731,30 @@
       READ_UVLC(uiCode, "ph_num_ver_virtual_boundaries");        picHeader->setNumVerVirtualBoundaries( uiCode );
       if (pps->getPicWidthInLumaSamples() <= 8)
       {
-        CHECK(picHeader->getNumVerVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
+        CHECK_VTM(picHeader->getNumVerVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
       }
       else
       {
-        CHECK(picHeader->getNumVerVirtualBoundaries() > 3, "PH: The number of vertical virtual boundaries shall be in the range of 0 to 3");
+        CHECK_VTM(picHeader->getNumVerVirtualBoundaries() > 3, "PH: The number of vertical virtual boundaries shall be in the range of 0 to 3");
       }
       for( unsigned i = 0; i < picHeader->getNumVerVirtualBoundaries(); i++ )
       {
         READ_UVLC(uiCode, "ph_virtual_boundary_pos_x_minus1[i]");        picHeader->setVirtualBoundariesPosX((uiCode + 1) << 3, i);
-        CHECK(uiCode > (((pps->getPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_width_in_luma_samples / 8 ) - 2, inclusive.");
+        CHECK_VTM(uiCode > (((pps->getPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_width_in_luma_samples / 8 ) - 2, inclusive.");
       }
       READ_UVLC(uiCode, "ph_num_hor_virtual_boundaries");        picHeader->setNumHorVirtualBoundaries( uiCode );
       if (pps->getPicHeightInLumaSamples() <= 8)
       {
-        CHECK(picHeader->getNumHorVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
+        CHECK_VTM(picHeader->getNumHorVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
       }
       else
       {
-        CHECK(picHeader->getNumHorVirtualBoundaries() > 3, "PH: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
+        CHECK_VTM(picHeader->getNumHorVirtualBoundaries() > 3, "PH: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
       }
       for( unsigned i = 0; i < picHeader->getNumHorVirtualBoundaries(); i++ )
       {
         READ_UVLC(uiCode, "ph_virtual_boundary_pos_y_minus1[i]");        picHeader->setVirtualBoundariesPosY((uiCode + 1) << 3, i);
-        CHECK(uiCode > (((pps->getPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_height_in_luma_samples / 8 ) - 2, inclusive.");
+        CHECK_VTM(uiCode > (((pps->getPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_height_in_luma_samples / 8 ) - 2, inclusive.");
       }
     }
     else
@@ -2918,31 +2921,31 @@
       READ_UVLC(uiCode, "ph_log2_diff_min_qt_min_cb_intra_slice_luma");
       unsigned minQtLog2SizeIntraY = uiCode + sps->getLog2MinCodingBlockSize();
       minQT[0] = 1 << minQtLog2SizeIntraY;
-      CHECK(minQT[0] > 64, "The value of ph_log2_diff_min_qt_min_cb_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
+      CHECK_VTM(minQT[0] > 64, "The value of ph_log2_diff_min_qt_min_cb_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
       READ_UVLC(uiCode, "ph_max_mtt_hierarchy_depth_intra_slice_luma");         maxBTD[0] = uiCode;
 
       maxTTSize[0] = maxBTSize[0] = minQT[0];
       if (maxBTD[0] != 0)
       {
         READ_UVLC(uiCode, "ph_log2_diff_max_bt_min_qt_intra_slice_luma");       maxBTSize[0] <<= uiCode;
-        CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of ph_log2_diff_max_bt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
+        CHECK_VTM(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of ph_log2_diff_max_bt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
         READ_UVLC(uiCode, "ph_log2_diff_max_tt_min_qt_intra_slice_luma");       maxTTSize[0] <<= uiCode;
-        CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of ph_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
-        CHECK(maxTTSize[0] > 64, "The value of ph_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraY");
+        CHECK_VTM(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of ph_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
+        CHECK_VTM(maxTTSize[0] > 64, "The value of ph_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraY");
       }
 
       if (sps->getUseDualITree())
       {
         READ_UVLC(uiCode, "ph_log2_diff_min_qt_min_cb_intra_slice_chroma");     minQT[2] = 1 << (uiCode + sps->getLog2MinCodingBlockSize());
-        CHECK(minQT[2] > 64, "The value of ph_log2_diff_min_qt_min_cb_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
+        CHECK_VTM(minQT[2] > 64, "The value of ph_log2_diff_min_qt_min_cb_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
         READ_UVLC(uiCode, "ph_max_mtt_hierarchy_depth_intra_slice_chroma");     maxBTD[2] = uiCode;
         maxTTSize[2] = maxBTSize[2] = minQT[2];
         if (maxBTD[2] != 0)
         {
           READ_UVLC(uiCode, "ph_log2_diff_max_bt_min_qt_intra_slice_chroma");   maxBTSize[2] <<= uiCode;
           READ_UVLC(uiCode, "ph_log2_diff_max_tt_min_qt_intra_slice_chroma");   maxTTSize[2] <<= uiCode;
-          CHECK(maxBTSize[2] > 64, "The value of ph_log2_diff_max_bt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
-          CHECK(maxTTSize[2] > 64, "The value of ph_log2_diff_max_tt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
+          CHECK_VTM(maxBTSize[2] > 64, "The value of ph_log2_diff_max_bt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
+          CHECK_VTM(maxTTSize[2] > 64, "The value of ph_log2_diff_max_tt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
         }
       }
     }
@@ -2978,18 +2981,18 @@
       READ_UVLC(uiCode, "ph_log2_diff_min_qt_min_cb_inter_slice");
       unsigned minQtLog2SizeInterY = uiCode + sps->getLog2MinCodingBlockSize();
       minQT[1] = 1 << minQtLog2SizeInterY;
-      CHECK(minQT[1] > 64, "The value of ph_log2_diff_min_qt_min_cb_inter_slice shall be in the range of 0 to min(6, CtbLog2SizeY) - MinCbLog2SizeY.");
-      CHECK(minQT[1] > (1<<ctbLog2SizeY), "The value of ph_log2_diff_min_qt_min_cb_inter_slice shall be in the range of 0 to min(6, CtbLog2SizeY) - MinCbLog2SizeY");
+      CHECK_VTM(minQT[1] > 64, "The value of ph_log2_diff_min_qt_min_cb_inter_slice shall be in the range of 0 to min(6, CtbLog2SizeY) - MinCbLog2SizeY.");
+      CHECK_VTM(minQT[1] > (1<<ctbLog2SizeY), "The value of ph_log2_diff_min_qt_min_cb_inter_slice shall be in the range of 0 to min(6, CtbLog2SizeY) - MinCbLog2SizeY");
       READ_UVLC(uiCode, "ph_max_mtt_hierarchy_depth_inter_slice");              maxBTD[1] = uiCode;
 
       maxTTSize[1] = maxBTSize[1] = minQT[1];
       if (maxBTD[1] != 0)
       {
         READ_UVLC(uiCode, "ph_log2_diff_max_bt_min_qt_inter_slice");            maxBTSize[1] <<= uiCode;
-        CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of ph_log2_diff_max_bt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
+        CHECK_VTM(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of ph_log2_diff_max_bt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
         READ_UVLC(uiCode, "ph_log2_diff_max_tt_min_qt_inter_slice");            maxTTSize[1] <<= uiCode;
-        CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of ph_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
-        CHECK(maxTTSize[1] > 64, "The value of ph_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeInterY.");
+        CHECK_VTM(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of ph_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
+        CHECK_VTM(maxTTSize[1] > 64, "The value of ph_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeInterY.");
       }
     }
     // delta quantization and chrom and chroma offset
@@ -3221,34 +3224,34 @@
       {
         READ_SVLC( iCode, "ph_beta_offset_div2" );
         picHeader->setDeblockingFilterBetaOffsetDiv2(iCode);
-        CHECK(  picHeader->getDeblockingFilterBetaOffsetDiv2() < -12 ||
+        CHECK_VTM(  picHeader->getDeblockingFilterBetaOffsetDiv2() < -12 ||
                 picHeader->getDeblockingFilterBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration");
 
         READ_SVLC( iCode, "ph_tc_offset_div2" );
         picHeader->setDeblockingFilterTcOffsetDiv2(iCode);
-        CHECK(  picHeader->getDeblockingFilterTcOffsetDiv2() < -12 ||
+        CHECK_VTM(  picHeader->getDeblockingFilterTcOffsetDiv2() < -12 ||
                 picHeader->getDeblockingFilterTcOffsetDiv2() > 12, "Invalid deblocking filter configuration");
 
         if( pps->getPPSChromaToolFlag() )
         {
           READ_SVLC( iCode, "ph_cb_beta_offset_div2" );
           picHeader->setDeblockingFilterCbBetaOffsetDiv2(iCode);
-          CHECK(  picHeader->getDeblockingFilterCbBetaOffsetDiv2() < -12 ||
+          CHECK_VTM(  picHeader->getDeblockingFilterCbBetaOffsetDiv2() < -12 ||
                   picHeader->getDeblockingFilterCbBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration");
 
           READ_SVLC( iCode, "ph_cb_tc_offset_div2" );
           picHeader->setDeblockingFilterCbTcOffsetDiv2(iCode);
-          CHECK(  picHeader->getDeblockingFilterCbTcOffsetDiv2() < -12 ||
+          CHECK_VTM(  picHeader->getDeblockingFilterCbTcOffsetDiv2() < -12 ||
                   picHeader->getDeblockingFilterCbTcOffsetDiv2() > 12, "Invalid deblocking filter configuration");
 
           READ_SVLC( iCode, "ph_cr_beta_offset_div2" );
           picHeader->setDeblockingFilterCrBetaOffsetDiv2(iCode);
-          CHECK(  picHeader->getDeblockingFilterCrBetaOffsetDiv2() < -12 ||
+          CHECK_VTM(  picHeader->getDeblockingFilterCrBetaOffsetDiv2() < -12 ||
                   picHeader->getDeblockingFilterCrBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration");
 
           READ_SVLC( iCode, "ph_cr_tc_offset_div2" );
           picHeader->setDeblockingFilterCrTcOffsetDiv2(iCode);
-          CHECK(  picHeader->getDeblockingFilterCrTcOffsetDiv2() < -12 ||
+          CHECK_VTM(  picHeader->getDeblockingFilterCrTcOffsetDiv2() < -12 ||
                   picHeader->getDeblockingFilterCrTcOffsetDiv2() > 12, "Invalid deblocking filter configuration");
         }
         else
@@ -3314,11 +3317,11 @@
     for (int i = 0; i < picHeader->getNumAlfAps(); i++)
     {
       aps = parameterSetManager->getAPS(apsId[i], ALF_APS);
-      CHECK(aps->getTemporalId() > curPicTid, "The TemporalId of the APS NAL unit having aps_params_type equal to ALF_APS and adaptation_parameter_set_id equal to ph_alf_aps_id_luma[ i ] shall be less than or equal to the TemporalId of the picture associated with the PH.");
+      CHECK_VTM(aps->getTemporalId() > curPicTid, "The TemporalId of the APS NAL unit having aps_params_type equal to ALF_APS and adaptation_parameter_set_id equal to ph_alf_aps_id_luma[ i ] shall be less than or equal to the TemporalId of the picture associated with the PH.");
       if( pcSlice->getNalUnitLayerId() != aps->getLayerId() )
       {
-        CHECK( aps->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
-        CHECK( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
+        CHECK_VTM( aps->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+        CHECK_VTM( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
         for (int i = 0; i < pcSlice->getVPS()->getNumOutputLayerSets(); i++ )
         {
           bool isCurrLayerInOls = false;
@@ -3334,7 +3337,7 @@
               isRefLayerInOls = true;
             }
           }
-          CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
+          CHECK_VTM( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
         }
       }
     }
@@ -3343,11 +3346,11 @@
     {
       int chromaAlfApsId = picHeader->getAlfApsIdChroma();
       aps = parameterSetManager->getAPS(chromaAlfApsId, ALF_APS);
-      CHECK(aps->getTemporalId() > curPicTid, "The TemporalId of the APS NAL unit having aps_params_type equal to ALF_APS and adaptation_parameter_set_id equal to ph_alf_aps_id_chroma shall be less than or equal to the TemporalId of the picture associated with the PH.");
+      CHECK_VTM(aps->getTemporalId() > curPicTid, "The TemporalId of the APS NAL unit having aps_params_type equal to ALF_APS and adaptation_parameter_set_id equal to ph_alf_aps_id_chroma shall be less than or equal to the TemporalId of the picture associated with the PH.");
       if( pcSlice->getNalUnitLayerId() != aps->getLayerId() )
       {
-        CHECK( aps->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
-        CHECK( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
+        CHECK_VTM( aps->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+        CHECK_VTM( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
         for (int i = 0; i < pcSlice->getVPS()->getNumOutputLayerSets(); i++ )
         {
           bool isCurrLayerInOls = false;
@@ -3363,7 +3366,7 @@
               isRefLayerInOls = true;
             }
           }
-          CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
+          CHECK_VTM( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
         }
       }
     }
@@ -3386,27 +3389,27 @@
     parsePictureHeader(picHeader, parameterSetManager, false);
     picHeader->setValid();
   }
-  CHECK(picHeader==0, "Invalid Picture Header");
-  CHECK(picHeader->isValid()==false, "Invalid Picture Header");
+  CHECK_VTM(picHeader==0, "Invalid Picture Header");
+  CHECK_VTM(picHeader->isValid()==false, "Invalid Picture Header");
   checkAlfNaluTidAndPicTid(pcSlice, picHeader, parameterSetManager);
   pps = parameterSetManager->getPPS( picHeader->getPPSId() );
   //!KS: need to add error handling code here, if PPS is not available
-  CHECK(pps==0, "Invalid PPS");
+  CHECK_VTM(pps==0, "Invalid PPS");
   sps = parameterSetManager->getSPS(pps->getSPSId());
   //!KS: need to add error handling code here, if SPS is not available
-  CHECK(sps==0, "Invalid SPS");
+  CHECK_VTM(sps==0, "Invalid SPS");
   if (sps->getProfileTierLevel()->getConstraintInfo()->getPicHeaderInSliceHeaderConstraintFlag())
   {
-    CHECK(pcSlice->getPictureHeaderInSliceHeader() == false, "PH shall be present in SH, when pic_header_in_slice_header_constraint_flag is equal to 1");
+    CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() == false, "PH shall be present in SH, when pic_header_in_slice_header_constraint_flag is equal to 1");
   }
-  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getRplInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, rpl_info_in_ph_flag shall be equal to 0");
-  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getDbfInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, dbf_info_in_ph_flag shall be equal to 0");
-  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getSaoInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, sao_info_in_ph_flag shall be equal to 0");
-  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getAlfInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, alf_info_in_ph_flag shall be equal to 0");
-  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getWpInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, wp_info_in_ph_flag shall be equal to 0");
-  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getQpDeltaInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, qp_delta_info_in_ph_flag shall be equal to 0");
-  CHECK(pcSlice->getPictureHeaderInSliceHeader() && sps->getSubPicInfoPresentFlag() == 1, "When sps_subpic_info_present_flag is equal to 1, the value of sh_picture_header_in_slice_header_flag shall be equal to 0");
-  CHECK(sps->getSubPicInfoPresentFlag() == 1 && sps->getVirtualBoundariesEnabledFlag() == 1 && sps->getVirtualBoundariesPresentFlag() == 0,
+  CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() && pps->getRplInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, rpl_info_in_ph_flag shall be equal to 0");
+  CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() && pps->getDbfInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, dbf_info_in_ph_flag shall be equal to 0");
+  CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() && pps->getSaoInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, sao_info_in_ph_flag shall be equal to 0");
+  CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() && pps->getAlfInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, alf_info_in_ph_flag shall be equal to 0");
+  CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() && pps->getWpInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, wp_info_in_ph_flag shall be equal to 0");
+  CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() && pps->getQpDeltaInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, qp_delta_info_in_ph_flag shall be equal to 0");
+  CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() && sps->getSubPicInfoPresentFlag() == 1, "When sps_subpic_info_present_flag is equal to 1, the value of sh_picture_header_in_slice_header_flag shall be equal to 0");
+  CHECK_VTM(sps->getSubPicInfoPresentFlag() == 1 && sps->getVirtualBoundariesEnabledFlag() == 1 && sps->getVirtualBoundariesPresentFlag() == 0,
         "when sps_subpic_info_present_flag is equal to 1 and sps_virtual_boundaries_enabled_flag is equal to 1, sps_virtual_boundaries_present_flag shall be equal 1");
 
   const ChromaFormat chFmt = sps->getChromaFormatIdc();
@@ -3489,7 +3492,7 @@
     {
       int bitsSliceAddress = ceilLog2(currSubPic.getNumSlicesInSubPic());
       READ_CODE(bitsSliceAddress, uiCode, "sh_slice_address");  sliceAddr = uiCode;
-      CHECK(sliceAddr >= currSubPic.getNumSlicesInSubPic(), "Invalid slice address");
+      CHECK_VTM(sliceAddr >= currSubPic.getNumSlicesInSubPic(), "Invalid slice address");
     }
     uint32_t picLevelSliceIdx = sliceAddr;
     for(int subpic = 0; subpic < currSubPicIdx; subpic++)
@@ -3521,10 +3524,10 @@
       }
       if (!pps->getRectSliceFlag() && sps->getProfileTierLevel()->getConstraintInfo()->getOneSlicePerPicConstraintFlag())
       {
-        CHECK(pps->getNumTiles() != uiCode + 1, "When pps_rect_slice_flag is equal to 0 and one_slice_per_pic_constraint_flag equal to 1, the value of sh_num_tiles_in_slice_minus1 present in each slice header shall be equal to NumTilesInPic - 1");
+        CHECK_VTM(pps->getNumTiles() != uiCode + 1, "When pps_rect_slice_flag is equal to 0 and one_slice_per_pic_constraint_flag equal to 1, the value of sh_num_tiles_in_slice_minus1 present in each slice header shall be equal to NumTilesInPic - 1");
       }
     }
-    CHECK(sliceAddr >= pps->getNumTiles(), "Invalid slice address");
+    CHECK_VTM(sliceAddr >= pps->getNumTiles(), "Invalid slice address");
     pcSlice->initSliceMap();
     pcSlice->setSliceID(sliceAddr);
 
@@ -3532,7 +3535,7 @@
     {
       uint32_t tileX = tileIdx % pps->getNumTileColumns();
       uint32_t tileY = tileIdx / pps->getNumTileColumns();
-      CHECK(tileY >= pps->getNumTileRows(), "Number of tiles in slice exceeds the remaining number of tiles in picture");
+      CHECK_VTM(tileY >= pps->getNumTileRows(), "Number of tiles in slice exceeds the remaining number of tiles in picture");
 
       pcSlice->addCtusToSlice(pps->getTileColumnBd(tileX), pps->getTileColumnBd(tileX + 1),
                               pps->getTileRowBd(tileY), pps->getTileRowBd(tileY + 1), pps->getPicWidthInCtu());
@@ -3545,7 +3548,7 @@
     VPS *vps = parameterSetManager->getVPS(sps->getVPSId());
     if (pcSlice->isIRAP() && (sps->getVPSId() == 0 || pcSlice->getPOC() != prevPicPOC || vps->getIndependentLayerFlag(vps->getGeneralLayerIdx(pcSlice->getNalUnitLayerId())) == 1))
     {
-      CHECK(uiCode != 2, "When nal_unit_type is in the range of IDR_W_RADL to CRA_NUT, inclusive, and vps_independent_layer_flag[ GeneralLayerIdx[ nuh_layer_id ] ] is equal to 1 or the current picture is the first picture in the current AU, sh_slice_type shall be equal to 2");
+      CHECK_VTM(uiCode != 2, "When nal_unit_type is in the range of IDR_W_RADL to CRA_NUT, inclusive, and vps_independent_layer_flag[ GeneralLayerIdx[ nuh_layer_id ] ] is equal to 1 or the current picture is the first picture in the current AU, sh_slice_type shall be equal to 2");
     }
   }
   else
@@ -3554,7 +3557,7 @@
   }
   if (!picHeader->getPicIntraSliceAllowedFlag())
   {
-    CHECK(pcSlice->getSliceType() == I_SLICE, "when ph_intra_slice_allowed_flag = 0, no I_Slice is allowed");
+    CHECK_VTM(pcSlice->getSliceType() == I_SLICE, "when ph_intra_slice_allowed_flag = 0, no I_Slice is allowed");
   }
   if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR)
   {
@@ -3582,8 +3585,8 @@
         READ_CODE(3, uiCode, "sh_alf_aps_id_luma[i]");
         apsId[i] = uiCode;
         APS* APStoCheckLuma = parameterSetManager->getAPS(apsId[i], ALF_APS);
-        CHECK(APStoCheckLuma == nullptr, "referenced APS not found");
-        CHECK(APStoCheckLuma->getAlfAPSParam().newFilterFlag[CHANNEL_TYPE_LUMA] != 1, "bitstream conformance error, alf_luma_filter_signal_flag shall be equal to 1");
+        CHECK_VTM(APStoCheckLuma == nullptr, "referenced APS not found");
+        CHECK_VTM(APStoCheckLuma->getAlfAPSParam().newFilterFlag[CHANNEL_TYPE_LUMA] != 1, "bitstream conformance error, alf_luma_filter_signal_flag shall be equal to 1");
       }
 
 
@@ -3603,8 +3606,8 @@
         READ_CODE(3, uiCode, "sh_alf_aps_id_chroma");
         pcSlice->setTileGroupApsIdChroma(uiCode);
         APS* APStoCheckChroma = parameterSetManager->getAPS(uiCode, ALF_APS);
-        CHECK(APStoCheckChroma == nullptr, "referenced APS not found");
-        CHECK(APStoCheckChroma->getAlfAPSParam().newFilterFlag[CHANNEL_TYPE_CHROMA] != 1, "bitstream conformance error, alf_chroma_filter_signal_flag shall be equal to 1");
+        CHECK_VTM(APStoCheckChroma == nullptr, "referenced APS not found");
+        CHECK_VTM(APStoCheckChroma->getAlfAPSParam().newFilterFlag[CHANNEL_TYPE_CHROMA] != 1, "bitstream conformance error, alf_chroma_filter_signal_flag shall be equal to 1");
       }
     }
     else
@@ -3927,9 +3930,9 @@
 
     if (pcSlice->isInterP() || pcSlice->isInterB())
     {
-      CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_0) == 0, "Number of active entries in RPL0 of P or B picture shall be greater than 0");
+      CHECK_VTM(pcSlice->getNumRefIdx(REF_PIC_LIST_0) == 0, "Number of active entries in RPL0 of P or B picture shall be greater than 0");
       if (pcSlice->isInterB())
-        CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0, "Number of active entries in RPL1 of B picture shall be greater than 0");
+        CHECK_VTM(pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0, "Number of active entries in RPL1 of B picture shall be greater than 0");
     }
 
 
@@ -3981,8 +3984,8 @@
     {
       if (pps->getWpInfoInPhFlag())
       {
-        CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_0) > picHeader->getNumL0Weights(), "ERROR: Number of active reference picture L0 is greater than the number of weighted prediction signalled in Picture Header");
-        CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_1) > picHeader->getNumL1Weights(), "ERROR: Number of active reference picture L1 is greater than the number of weighted prediction signalled in Picture Header");
+        CHECK_VTM(pcSlice->getNumRefIdx(REF_PIC_LIST_0) > picHeader->getNumL0Weights(), "ERROR: Number of active reference picture L0 is greater than the number of weighted prediction signalled in Picture Header");
+        CHECK_VTM(pcSlice->getNumRefIdx(REF_PIC_LIST_1) > picHeader->getNumL1Weights(), "ERROR: Number of active reference picture L1 is greater than the number of weighted prediction signalled in Picture Header");
         pcSlice->setWpScaling(picHeader->getWpScalingAll());
       }
       else
@@ -4020,8 +4023,8 @@
     pcSlice->setSliceQp(26 + pps->getPicInitQPMinus26() + qpDelta);
     pcSlice->setSliceQpBase(pcSlice->getSliceQp());
 
-    CHECK( pcSlice->getSliceQp() < -sps->getQpBDOffset(CHANNEL_TYPE_LUMA), "Invalid slice QP delta" );
-    CHECK( pcSlice->getSliceQp() > MAX_QP, "Invalid slice QP" );
+    CHECK_VTM( pcSlice->getSliceQp() < -sps->getQpBDOffset(CHANNEL_TYPE_LUMA), "Invalid slice QP delta" );
+    CHECK_VTM( pcSlice->getSliceQp() > MAX_QP, "Invalid slice QP" );
 
     if (pps->getSliceChromaQpFlag())
     {
@@ -4029,28 +4032,28 @@
       {
         READ_SVLC( iCode, "sh_cb_qp_offset" );
         pcSlice->setSliceChromaQpDelta(COMPONENT_Cb, iCode );
-        CHECK( pcSlice->getSliceChromaQpDelta(COMPONENT_Cb) < -12, "Invalid chroma QP offset" );
-        CHECK( pcSlice->getSliceChromaQpDelta(COMPONENT_Cb) >  12, "Invalid chroma QP offset" );
-        CHECK( (pps->getQpOffset(COMPONENT_Cb) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cb)) < -12, "Invalid chroma QP offset" );
-        CHECK( (pps->getQpOffset(COMPONENT_Cb) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cb)) >  12, "Invalid chroma QP offset" );
+        CHECK_VTM( pcSlice->getSliceChromaQpDelta(COMPONENT_Cb) < -12, "Invalid chroma QP offset" );
+        CHECK_VTM( pcSlice->getSliceChromaQpDelta(COMPONENT_Cb) >  12, "Invalid chroma QP offset" );
+        CHECK_VTM( (pps->getQpOffset(COMPONENT_Cb) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cb)) < -12, "Invalid chroma QP offset" );
+        CHECK_VTM( (pps->getQpOffset(COMPONENT_Cb) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cb)) >  12, "Invalid chroma QP offset" );
       }
 
       if (numValidComp>COMPONENT_Cr)
       {
         READ_SVLC( iCode, "sh_cr_qp_offset" );
         pcSlice->setSliceChromaQpDelta(COMPONENT_Cr, iCode );
-        CHECK( pcSlice->getSliceChromaQpDelta(COMPONENT_Cr) < -12, "Invalid chroma QP offset" );
-        CHECK( pcSlice->getSliceChromaQpDelta(COMPONENT_Cr) >  12, "Invalid chroma QP offset" );
-        CHECK( (pps->getQpOffset(COMPONENT_Cr) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cr)) < -12, "Invalid chroma QP offset" );
-        CHECK( (pps->getQpOffset(COMPONENT_Cr) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cr)) >  12, "Invalid chroma QP offset" );
+        CHECK_VTM( pcSlice->getSliceChromaQpDelta(COMPONENT_Cr) < -12, "Invalid chroma QP offset" );
+        CHECK_VTM( pcSlice->getSliceChromaQpDelta(COMPONENT_Cr) >  12, "Invalid chroma QP offset" );
+        CHECK_VTM( (pps->getQpOffset(COMPONENT_Cr) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cr)) < -12, "Invalid chroma QP offset" );
+        CHECK_VTM( (pps->getQpOffset(COMPONENT_Cr) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cr)) >  12, "Invalid chroma QP offset" );
         if (sps->getJointCbCrEnabledFlag())
         {
           READ_SVLC(iCode, "sh_joint_cbcr_qp_offset" );
           pcSlice->setSliceChromaQpDelta(JOINT_CbCr, iCode);
-          CHECK( pcSlice->getSliceChromaQpDelta(JOINT_CbCr) < -12, "Invalid chroma QP offset");
-          CHECK( pcSlice->getSliceChromaQpDelta(JOINT_CbCr) >  12, "Invalid chroma QP offset");
-          CHECK( (pps->getQpOffset(JOINT_CbCr) + pcSlice->getSliceChromaQpDelta(JOINT_CbCr)) < -12, "Invalid chroma QP offset");
-          CHECK( (pps->getQpOffset(JOINT_CbCr) + pcSlice->getSliceChromaQpDelta(JOINT_CbCr)) >  12, "Invalid chroma QP offset");
+          CHECK_VTM( pcSlice->getSliceChromaQpDelta(JOINT_CbCr) < -12, "Invalid chroma QP offset");
+          CHECK_VTM( pcSlice->getSliceChromaQpDelta(JOINT_CbCr) >  12, "Invalid chroma QP offset");
+          CHECK_VTM( (pps->getQpOffset(JOINT_CbCr) + pcSlice->getSliceChromaQpDelta(JOINT_CbCr)) < -12, "Invalid chroma QP offset");
+          CHECK_VTM( (pps->getQpOffset(JOINT_CbCr) + pcSlice->getSliceChromaQpDelta(JOINT_CbCr)) >  12, "Invalid chroma QP offset");
         }
       }
     }
@@ -4098,26 +4101,26 @@
         if(!pcSlice->getDeblockingFilterDisable())
         {
           READ_SVLC( iCode, "sh_luma_beta_offset_div2" );                     pcSlice->setDeblockingFilterBetaOffsetDiv2( iCode );
-          CHECK(  pcSlice->getDeblockingFilterBetaOffsetDiv2() < -12 ||
+          CHECK_VTM(  pcSlice->getDeblockingFilterBetaOffsetDiv2() < -12 ||
                   pcSlice->getDeblockingFilterBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration");
           READ_SVLC( iCode, "sh_luma_tc_offset_div2" );                       pcSlice->setDeblockingFilterTcOffsetDiv2( iCode );
-          CHECK(  pcSlice->getDeblockingFilterTcOffsetDiv2() < -12 ||
+          CHECK_VTM(  pcSlice->getDeblockingFilterTcOffsetDiv2() < -12 ||
                   pcSlice->getDeblockingFilterTcOffsetDiv2() > 12, "Invalid deblocking filter configuration");
 
           if( pps->getPPSChromaToolFlag() )
           {
             READ_SVLC( iCode, "sh_cb_beta_offset_div2" );                  pcSlice->setDeblockingFilterCbBetaOffsetDiv2( iCode );
-            CHECK( pcSlice->getDeblockingFilterCbBetaOffsetDiv2() < -12 ||
+            CHECK_VTM( pcSlice->getDeblockingFilterCbBetaOffsetDiv2() < -12 ||
               pcSlice->getDeblockingFilterCbBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
             READ_SVLC( iCode, "sh_cb_tc_offset_div2" );                    pcSlice->setDeblockingFilterCbTcOffsetDiv2( iCode );
-            CHECK( pcSlice->getDeblockingFilterCbTcOffsetDiv2() < -12 ||
+            CHECK_VTM( pcSlice->getDeblockingFilterCbTcOffsetDiv2() < -12 ||
               pcSlice->getDeblockingFilterCbTcOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
 
             READ_SVLC( iCode, "sh_cr_beta_offset_div2" );                  pcSlice->setDeblockingFilterCrBetaOffsetDiv2( iCode );
-            CHECK( pcSlice->getDeblockingFilterCrBetaOffsetDiv2() < -12 ||
+            CHECK_VTM( pcSlice->getDeblockingFilterCrBetaOffsetDiv2() < -12 ||
               pcSlice->getDeblockingFilterCrBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
             READ_SVLC( iCode, "sh_cr_tc_offset_div2" );                    pcSlice->setDeblockingFilterCrTcOffsetDiv2( iCode );
-            CHECK( pcSlice->getDeblockingFilterCrTcOffsetDiv2() < -12 ||
+            CHECK_VTM( pcSlice->getDeblockingFilterCrTcOffsetDiv2() < -12 ||
               pcSlice->getDeblockingFilterCrTcOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
           }
           else
@@ -4270,14 +4273,14 @@
   PPS* pps = NULL;
   SPS* sps = NULL;
 
-  CHECK(picHeader==0, "Invalid Picture Header");
-  CHECK(picHeader->isValid()==false, "Invalid Picture Header");
+  CHECK_VTM(picHeader==0, "Invalid Picture Header");
+  CHECK_VTM(picHeader->isValid()==false, "Invalid Picture Header");
   pps = parameterSetManager->getPPS( picHeader->getPPSId() );
   //!KS: need to add error handling code here, if PPS is not available
-  CHECK(pps==0, "Invalid PPS");
+  CHECK_VTM(pps==0, "Invalid PPS");
   sps = parameterSetManager->getSPS(pps->getSPSId());
   //!KS: need to add error handling code here, if SPS is not available
-  CHECK(sps==0, "Invalid SPS");
+  CHECK_VTM(sps==0, "Invalid SPS");
 
   DTRACE_UPDATE( g_trace_ctx, std::make_pair( "final", 0 ) );
 
@@ -4361,7 +4364,7 @@
 
     /* picture format */
     READ_CODE(4, symbol, "gci_sixteen_minus_max_bitdepth_constraint_idc"); cinfo->setMaxBitDepthConstraintIdc(symbol>8 ? 16 : (16 - symbol));
-    CHECK(symbol>8, "gci_sixteen_minus_max_bitdepth_constraint_idc shall be in the range 0 to 8, inclusive");
+    CHECK_VTM(symbol>8, "gci_sixteen_minus_max_bitdepth_constraint_idc shall be in the range 0 to 8, inclusive");
     READ_CODE(2, symbol, "gci_three_minus_max_chroma_format_constraint_idc"); cinfo->setMaxChromaFormatConstraintIdc((ChromaFormat)(3 - symbol));
 
     /* NAL unit type related */
@@ -4442,12 +4445,14 @@
     uint32_t const numReservedBits = symbol;
     for (int i = 0; i < numReservedBits; i++)
     {
-      READ_FLAG(symbol, "gci_reserved_zero_bit");                    CHECK(symbol != 0, "gci_reserved_zero_bit not equal to zero");
+      READ_FLAG(symbol, "gci_reserved_zero_bit");
+      CHECK_VTM(symbol != 0, "gci_reserved_zero_bit not equal to zero");
     }
   }
   while (!isByteAligned())
   {
-    READ_FLAG(symbol, "gci_alignment_zero_bit");                     CHECK(symbol != 0, "gci_alignment_zero_bit not equal to zero");
+    READ_FLAG(symbol, "gci_alignment_zero_bit");
+    CHECK_VTM(symbol != 0, "gci_alignment_zero_bit not equal to zero");
   }
 }
 
@@ -4465,7 +4470,7 @@
 
   READ_FLAG(      symbol,   "ptl_frame_only_constraint_flag"   ); ptl->setFrameOnlyConstraintFlag(symbol);
   READ_FLAG(      symbol,   "ptl_multilayer_enabled_flag"      ); ptl->setMultiLayerEnabledFlag(symbol);
-  CHECK((ptl->getProfileIdc() == Profile::MAIN_10 || ptl->getProfileIdc() == Profile::MAIN_10_444
+  CHECK_VTM((ptl->getProfileIdc() == Profile::MAIN_10 || ptl->getProfileIdc() == Profile::MAIN_10_444
          || ptl->getProfileIdc() == Profile::MAIN_10_STILL_PICTURE
          || ptl->getProfileIdc() == Profile::MAIN_10_444_STILL_PICTURE)
           && symbol,
@@ -4483,7 +4488,8 @@
 
   while (!isByteAligned())
   {
-    READ_FLAG(    symbol,   "ptl_reserved_zero_bit"         ); CHECK (symbol != 0, "ptl_reserved_zero_bit not equal to zero");
+    READ_FLAG(    symbol,   "ptl_reserved_zero_bit"         );
+    CHECK_VTM(symbol != 0, "ptl_reserved_zero_bit not equal to zero");
   }
 
   for (int i = maxNumSubLayersMinus1 - 1; i >= 0; i--)
@@ -4535,7 +4541,7 @@
 {
   if (noTrailingBytesExpected)
   {
-    CHECK( 0 != m_pcBitstream->getNumBitsLeft(), "Bits left although no bits expected" );
+    CHECK_VTM( 0 != m_pcBitstream->getNumBitsLeft(), "Bits left although no bits expected" );
   }
   else
   {
@@ -4572,12 +4578,12 @@
   int iDeltaDenom;
   // decode delta_luma_log2_weight_denom :
   READ_UVLC( uiLog2WeightDenomLuma, "luma_log2_weight_denom" );
-  CHECK( uiLog2WeightDenomLuma > 7, "The value of luma_log2_weight_denom shall be in the range of 0 to 7" );
+  CHECK_VTM( uiLog2WeightDenomLuma > 7, "The value of luma_log2_weight_denom shall be in the range of 0 to 7" );
   if( bChroma )
   {
     READ_SVLC( iDeltaDenom, "delta_chroma_log2_weight_denom" );
-    CHECK((iDeltaDenom + (int)uiLog2WeightDenomLuma)<0, "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
-    CHECK((iDeltaDenom + (int)uiLog2WeightDenomLuma)>7, "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
+    CHECK_VTM((iDeltaDenom + (int)uiLog2WeightDenomLuma)<0, "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
+    CHECK_VTM((iDeltaDenom + (int)uiLog2WeightDenomLuma)>7, "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
     uiLog2WeightDenomChroma = (uint32_t)(iDeltaDenom + uiLog2WeightDenomLuma);
   }
 
@@ -4630,13 +4636,13 @@
       {
         int iDeltaWeight;
         READ_SVLC( iDeltaWeight, iNumRef==0?"delta_luma_weight_l0[i]":"delta_luma_weight_l1[i]" );
-        CHECK( iDeltaWeight < -128, "delta_luma_weight_lx shall be in the rage of -128 to 127" );
-        CHECK( iDeltaWeight >  127, "delta_luma_weight_lx shall be in the rage of -128 to 127" );
+        CHECK_VTM( iDeltaWeight < -128, "delta_luma_weight_lx shall be in the rage of -128 to 127" );
+        CHECK_VTM( iDeltaWeight >  127, "delta_luma_weight_lx shall be in the rage of -128 to 127" );
         wp[COMPONENT_Y].codedWeight = (iDeltaWeight + (1 << wp[COMPONENT_Y].log2WeightDenom));
         READ_SVLC(wp[COMPONENT_Y].codedOffset, iNumRef == 0 ? "luma_offset_l0[i]" : "luma_offset_l1[i]");
         const int range=sps->getSpsRangeExtension().getHighPrecisionOffsetsEnabledFlag() ? (1<<sps->getBitDepth(CHANNEL_TYPE_LUMA))/2 : 128;
-        CHECK(wp[0].codedOffset < -range, "luma_offset_lx shall be in the rage of -128 to 127");
-        CHECK(wp[0].codedOffset >= range, "luma_offset_lx shall be in the rage of -128 to 127");
+        CHECK_VTM(wp[0].codedOffset < -range, "luma_offset_lx shall be in the rage of -128 to 127");
+        CHECK_VTM(wp[0].codedOffset >= range, "luma_offset_lx shall be in the rage of -128 to 127");
       }
       else
       {
@@ -4652,14 +4658,14 @@
           {
             int iDeltaWeight;
             READ_SVLC( iDeltaWeight, iNumRef==0?"delta_chroma_weight_l0[i]":"delta_chroma_weight_l1[i]" );
-            CHECK( iDeltaWeight < -128, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
-            CHECK( iDeltaWeight >  127, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
+            CHECK_VTM( iDeltaWeight < -128, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
+            CHECK_VTM( iDeltaWeight >  127, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
             wp[j].codedWeight = (iDeltaWeight + (1 << wp[j].log2WeightDenom));
 
             int iDeltaChroma;
             READ_SVLC( iDeltaChroma, iNumRef==0?"delta_chroma_offset_l0[i]":"delta_chroma_offset_l1[i]" );
-            CHECK( iDeltaChroma <  -4*range, "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
-            CHECK( iDeltaChroma >  4*(range-1), "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
+            CHECK_VTM( iDeltaChroma <  -4*range, "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
+            CHECK_VTM( iDeltaChroma >  4*(range-1), "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
             int pred          = (range - ((range * wp[j].codedWeight) >> (wp[j].log2WeightDenom)));
             wp[j].codedOffset = Clip3(-range, range - 1, (iDeltaChroma + pred));
           }
@@ -4684,7 +4690,7 @@
       wp[COMPONENT_Cr].presentFlag = false;
     }
   }
-  CHECK(uiTotalSignalledWeightFlags>24, "Too many weight flag signalled");
+  CHECK_VTM(uiTotalSignalledWeightFlags>24, "Too many weight flag signalled");
 }
 
 void HLSyntaxReader::parsePredWeightTable(PicHeader *picHeader, const SPS *sps)
@@ -4699,12 +4705,12 @@
 
   int deltaDenom;
   READ_UVLC(log2WeightDenomLuma, "luma_log2_weight_denom");
-  CHECK(log2WeightDenomLuma > 7, "The value of luma_log2_weight_denom shall be in the range of 0 to 7");
+  CHECK_VTM(log2WeightDenomLuma > 7, "The value of luma_log2_weight_denom shall be in the range of 0 to 7");
   if (chroma)
   {
     READ_SVLC(deltaDenom, "delta_chroma_log2_weight_denom");
-    CHECK((deltaDenom + (int) log2WeightDenomLuma) < 0, "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
-    CHECK((deltaDenom + (int) log2WeightDenomLuma) > 7, "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
+    CHECK_VTM((deltaDenom + (int) log2WeightDenomLuma) < 0, "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
+    CHECK_VTM((deltaDenom + (int) log2WeightDenomLuma) > 7, "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
     log2WeightDenomChroma = (uint32_t)(deltaDenom + log2WeightDenomLuma);
   }
 
@@ -4762,13 +4768,13 @@
       {
         int deltaWeight;
         READ_SVLC(deltaWeight, numRef == 0 ? "delta_luma_weight_l0[i]" : "delta_luma_weight_l1[i]");
-        CHECK(deltaWeight < -128, "delta_luma_weight_lx shall be in the rage of -128 to 127");
-        CHECK(deltaWeight > 127, "delta_luma_weight_lx shall be in the rage of -128 to 127");
+        CHECK_VTM(deltaWeight < -128, "delta_luma_weight_lx shall be in the rage of -128 to 127");
+        CHECK_VTM(deltaWeight > 127, "delta_luma_weight_lx shall be in the rage of -128 to 127");
         wp[COMPONENT_Y].codedWeight = (deltaWeight + (1 << wp[COMPONENT_Y].log2WeightDenom));
         READ_SVLC(wp[COMPONENT_Y].codedOffset, numRef == 0 ? "luma_offset_l0[i]" : "luma_offset_l1[i]");
         const int range = sps->getSpsRangeExtension().getHighPrecisionOffsetsEnabledFlag() ? (1 << sps->getBitDepth(CHANNEL_TYPE_LUMA)) / 2 : 128;
-        CHECK(wp[0].codedOffset < -range, "luma_offset_lx shall be in the rage of -128 to 127");
-        CHECK(wp[0].codedOffset >= range, "luma_offset_lx shall be in the rage of -128 to 127");
+        CHECK_VTM(wp[0].codedOffset < -range, "luma_offset_lx shall be in the rage of -128 to 127");
+        CHECK_VTM(wp[0].codedOffset >= range, "luma_offset_lx shall be in the rage of -128 to 127");
       }
       else
       {
@@ -4784,14 +4790,14 @@
           {
             int deltaWeight;
             READ_SVLC(deltaWeight, numRef == 0 ? "delta_chroma_weight_l0[i]" : "delta_chroma_weight_l1[i]");
-            CHECK( deltaWeight < -128, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
-            CHECK( deltaWeight >  127, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
+            CHECK_VTM( deltaWeight < -128, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
+            CHECK_VTM( deltaWeight >  127, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
             wp[j].codedWeight = (deltaWeight + (1 << wp[j].log2WeightDenom));
 
             int deltaChroma;
             READ_SVLC(deltaChroma, numRef == 0 ? "delta_chroma_offset_l0[i]" : "delta_chroma_offset_l1[i]");
-            CHECK( deltaChroma <  -4*range, "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
-            CHECK( deltaChroma >=  4*range, "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
+            CHECK_VTM( deltaChroma <  -4*range, "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
+            CHECK_VTM( deltaChroma >=  4*range, "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
             int pred          = (range - ((range * wp[j].codedWeight) >> (wp[j].log2WeightDenom)));
             wp[j].codedOffset = Clip3(-range, range - 1, (deltaChroma + pred));
           }
@@ -4830,7 +4836,7 @@
       picHeader->setNumL1Weights(numLxWeights);
     }
   }
-  CHECK(totalSignalledWeightFlags > 24, "Too many weight flag signalled");
+  CHECK_VTM(totalSignalledWeightFlags > 24, "Too many weight flag signalled");
 }
 
 /** decode quantization matrix
@@ -4912,7 +4918,7 @@
   int *dst = scalingList->getScalingListAddress(scalingListId);
 
   int PredListId = scalingList->getRefMatrixId(scalingListId);
-  CHECK(isPredictor && PredListId > scalingListId, "Scaling List error predictor!");
+  CHECK_VTM(isPredictor && PredListId > scalingListId, "Scaling List error predictor!");
   const int *srcPred = (isPredictor) ? ((scalingListId == PredListId) ? scalingList->getScalingListDefaultAddress(scalingListId) : scalingList->getScalingListAddress(PredListId)) : NULL;
   if(isPredictor && scalingListId == PredListId)
     scalingList->setScalingListDC(PredListId, SCALING_LIST_DC);
@@ -4966,7 +4972,7 @@
   cnt--;
 
   // we should not have a negative number of bits
-  CHECK (cnt<0, "Negative number of bits");
+  CHECK_VTM(cnt<0, "Negative number of bits");
 
   // we have more data, if cnt is not zero
   return (cnt>0);
@@ -4997,7 +5003,7 @@
         READ_FLAG( code, isChroma ? "alf_chroma_coeff_sign" : "alf_luma_coeff_sign" );
         coeff[ ind * MAX_NUM_ALF_LUMA_COEFF + i ] = ( code ) ? -coeff[ ind * MAX_NUM_ALF_LUMA_COEFF + i ] : coeff[ ind * MAX_NUM_ALF_LUMA_COEFF + i ];
        }
-      CHECK( isChroma &&
+       CHECK_VTM( isChroma &&
              ( coeff[ind * MAX_NUM_ALF_LUMA_COEFF + i] > 127 || coeff[ind * MAX_NUM_ALF_LUMA_COEFF + i] < -128 )
              , "AlfCoeffC shall be in the range of -128 to 127, inclusive" );
     }
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/AQp.cpp ../VVCSoftware_10/source/Lib/EncoderLib/AQp.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/AQp.cpp	2022-09-16 14:27:06.148532600 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/AQp.cpp	2022-05-13 17:45:29.464142540 +0200
@@ -123,8 +123,8 @@
           pBlkY += iStride;
         }
 
-        CHECK((uiCurrAQPartWidth&1)!=0,  "Odd part width unsupported");
-        CHECK((uiCurrAQPartHeight&1)!=0, "Odd part height unsupported");
+        CHECK_VTM((uiCurrAQPartWidth&1)!=0,  "Odd part width unsupported");
+        CHECK_VTM((uiCurrAQPartHeight&1)!=0, "Odd part height unsupported");
         const uint32_t pixelWidthOfQuadrants  = uiCurrAQPartWidth >>1;
         const uint32_t pixelHeightOfQuadrants = uiCurrAQPartHeight>>1;
         const uint32_t numPixInAQPart         = pixelWidthOfQuadrants * pixelHeightOfQuadrants;
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/CABACWriter.cpp ../VVCSoftware_10/source/Lib/EncoderLib/CABACWriter.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/CABACWriter.cpp	2022-09-16 14:27:06.148532600 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/CABACWriter.cpp	2022-05-13 17:45:29.692139958 +0200
@@ -306,7 +306,7 @@
 {
   if( !sliceEnabled )
   {
-    CHECK( ctbPars.modeIdc != SAO_MODE_OFF, "Sao must be off, if it is disabled on slice level" );
+    CHECK_VTM( ctbPars.modeIdc != SAO_MODE_OFF, "Sao must be off, if it is disabled on slice level" );
     return;
   }
   const bool isFirstCompOfChType = ( getFirstComponentOfChannel( toChannelType(compID) ) == compID );
@@ -325,7 +325,7 @@
     }
     else
     {
-      CHECK(!( ctbPars.typeIdc < SAO_TYPE_START_BO ), "Unspecified error");
+      CHECK_VTM(!( ctbPars.typeIdc < SAO_TYPE_START_BO ), "Unspecified error");
       m_BinEncoder.encodeBin  ( 1, Ctx::SaoTypeIdx() );
       m_BinEncoder.encodeBinEP( 1 );
     }
@@ -374,7 +374,7 @@
       if( isFirstCompOfChType )
       {
         // sao_eo_class_luma / sao_eo_class_chroma
-        CHECK( ctbPars.typeIdc - SAO_TYPE_START_EO < 0, "sao edge offset class is outside valid range" );
+        CHECK_VTM( ctbPars.typeIdc - SAO_TYPE_START_EO < 0, "sao edge offset class is outside valid range" );
         m_BinEncoder.encodeBinsEP( ctbPars.typeIdc - SAO_TYPE_START_EO, NUM_SAO_EO_TYPES_LOG2 );
       }
     }
@@ -426,7 +426,7 @@
 
   split_cu_mode( splitMode, cs, partitioner );
 
-  CHECK( !partitioner.canSplit( splitMode, cs ), "The chosen split mode is invalid!" );
+  CHECK_VTM( !partitioner.canSplit( splitMode, cs ), "The chosen split mode is invalid!" );
 
   if( splitMode != CU_DONT_SPLIT )
   {
@@ -448,7 +448,7 @@
             }
             lumaContinue = partitioner.nextPart(cs);
             chromaContinue = pPartitionerChroma->nextPart(cs);
-            CHECK(lumaContinue != chromaContinue, "luma chroma partition should be matched");
+            CHECK_VTM(lumaContinue != chromaContinue, "luma chroma partition should be matched");
             beContinue = lumaContinue;
           }
           else
@@ -464,7 +464,7 @@
               coding_tree(cs, *pPartitionerChroma, *pCuCtxChroma);
             }
             chromaContinue = pPartitionerChroma->nextPart(cs);
-            CHECK(lumaContinue != chromaContinue, "luma chroma partition should be matched");
+            CHECK_VTM(lumaContinue != chromaContinue, "luma chroma partition should be matched");
             beContinue = lumaContinue;
           }
         }
@@ -480,7 +480,7 @@
         partitioner.modeType = modeTypeChild;
 
         bool chromaNotSplit = modeTypeParent == MODE_TYPE_ALL && modeTypeChild == MODE_TYPE_INTRA ? true : false;
-        CHECK( chromaNotSplit && partitioner.chType != CHANNEL_TYPE_LUMA, "chType must be luma" );
+        CHECK_VTM( chromaNotSplit && partitioner.chType != CHANNEL_TYPE_LUMA, "chType must be luma" );
         if( partitioner.treeType == TREE_D )
         {
           partitioner.treeType = chromaNotSplit ? TREE_L : TREE_D;
@@ -500,7 +500,7 @@
       {
         if (isChromaEnabled(cs.pcv->chrFormat))
         {
-        CHECK( partitioner.chType != CHANNEL_TYPE_LUMA, "must be luma status" );
+          CHECK_VTM( partitioner.chType != CHANNEL_TYPE_LUMA, "must be luma status" );
         partitioner.chType = CHANNEL_TYPE_CHROMA;
         partitioner.treeType = TREE_C;
 
@@ -525,7 +525,7 @@
     cuCtx.qgStart = false;
     cuCtx.qp = CU::predictQP( cu, cuCtx.qp );
   }
-  CHECK( cu.treeType != partitioner.treeType, "treeType mismatch" );
+  CHECK_VTM( cu.treeType != partitioner.treeType, "treeType mismatch" );
 
 
   // coding unit
@@ -544,11 +544,11 @@
 
 void CABACWriter::mode_constraint( const PartSplit split, const CodingStructure& cs, Partitioner& partitioner, const ModeType modeType )
 {
-  CHECK( split == CU_DONT_SPLIT, "splitMode shall not be no split" );
+  CHECK_VTM( split == CU_DONT_SPLIT, "splitMode shall not be no split" );
   int val = cs.signalModeCons( split, partitioner, partitioner.modeType );
   if( val == LDT_MODE_TYPE_SIGNAL )
   {
-    CHECK( modeType == MODE_TYPE_ALL, "shall not be no constraint case" );
+    CHECK_VTM( modeType == MODE_TYPE_ALL, "shall not be no constraint case" );
     bool flag = modeType == MODE_TYPE_INTRA;
     int ctxIdx = DeriveCtx::CtxModeConsFlag( cs, partitioner );
     m_BinEncoder.encodeBin( flag, Ctx::ModeConsFlag( ctxIdx ) );
@@ -656,8 +656,8 @@
   // skip data
   if( cu.skip )
   {
-    CHECK( !cu.firstPU->mergeFlag, "Merge flag has to be on!" );
-    CHECK(cu.colorTransform, "ACT should not be enabled for skip mode");
+    CHECK_VTM( !cu.firstPU->mergeFlag, "Merge flag has to be on!" );
+    CHECK_VTM(cu.colorTransform, "ACT should not be enabled for skip mode");
     PredictionUnit&   pu = *cu.firstPU;
     prediction_unit ( pu );
     end_of_ctu      ( cu, cuCtx );
@@ -673,7 +673,7 @@
   }
   if (CU::isPLT(cu))
   {
-    CHECK(cu.colorTransform, "ACT should not be enabled for PLT mode");
+    CHECK_VTM(cu.colorTransform, "ACT should not be enabled for PLT mode");
     if (cu.isSepTree())
     {
       if (isLuma(partitioner.chType))
@@ -881,7 +881,7 @@
     return;
   }
 
-  CHECK(!(BCW_NUM > 1 && (BCW_NUM == 2 || (BCW_NUM & 0x01) == 1)), " !( BCW_NUM > 1 && ( BCW_NUM == 2 || ( BCW_NUM & 0x01 ) == 1 ) ) ");
+  CHECK_VTM(!(BCW_NUM > 1 && (BCW_NUM == 2 || (BCW_NUM & 0x01) == 1)), " !( BCW_NUM > 1 && ( BCW_NUM == 2 || ( BCW_NUM & 0x01 ) == 1 ) ) ");
   const uint8_t bcwCodingIdx = (uint8_t)g_BcwCodingOrder[CU::getValidBcwIdx(cu)];
 
   const int32_t numBcw = (cu.slice->getCheckLDC()) ? 5 : 3;
@@ -1064,7 +1064,7 @@
     }
     if ( pu->multiRefIdx )
     {
-      CHECK(mpm_idx >= numMPMs, "use of non-MPM");
+      CHECK_VTM(mpm_idx >= numMPMs, "use of non-MPM");
     }
     else
     {
@@ -1120,7 +1120,7 @@
             ipred_mode--;
           }
         }
-        CHECK(ipred_mode >= 64, "Incorrect mode");
+        CHECK_VTM(ipred_mode >= 64, "Incorrect mode");
         xWriteTruncBinCode(ipred_mode, NUM_LUMA_MODE - NUM_MOST_PROBABLE_MODES);  // Remaining mode is truncated binary coded
       }
     }
@@ -1163,7 +1163,7 @@
   }
   if ( pu.multiRefIdx )
   {
-    CHECK(mpm_idx >= numMPMs, "use of non-MPM");
+    CHECK_VTM(mpm_idx >= numMPMs, "use of non-MPM");
   }
   else
   {
@@ -1242,13 +1242,13 @@
       break;
     }
   }
-  CHECK(symbol < 0, "invalid symbol found");
+  CHECK_VTM(symbol < 0, "invalid symbol found");
 
   m_BinEncoder.encodeBin(symbol == 0 ? 0 : 1, Ctx::CclmModeIdx(0));
 
   if (symbol > 0)
   {
-    CHECK(symbol > 2, "invalid symbol for MMLM");
+    CHECK_VTM(symbol > 2, "invalid symbol for MMLM");
     unsigned int symbol_minus_1 = symbol - 1;
     m_BinEncoder.encodeBinEP(symbol_minus_1);
   }
@@ -1261,7 +1261,7 @@
   const unsigned intraDir = pu.intraDir[1];
   if (pu.cu->colorTransform)
   {
-    CHECK(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "chroma should use DM for adaptive color transform");
+    CHECK_VTM(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "chroma should use DM for adaptive color transform");
     return;
   }
   if (pu.cs->sps->getUseLMChroma() && pu.cu->checkCCLMAllowed())
@@ -1294,8 +1294,8 @@
     }
   }
 
-  CHECK(candId >= NUM_CHROMA_MODE, "Chroma prediction mode index out of bounds");
-  CHECK(chromaCandModes[candId] == DM_CHROMA_IDX, "The intra dir cannot be DM_CHROMA for this path");
+  CHECK_VTM(candId >= NUM_CHROMA_MODE, "Chroma prediction mode index out of bounds");
+  CHECK_VTM(chromaCandModes[candId] == DM_CHROMA_IDX, "The intra dir cannot be DM_CHROMA for this path");
   {
     m_BinEncoder.encodeBinsEP(candId, 2);
   }
@@ -1317,7 +1317,7 @@
 
     if( !cu.rootCbf )
     {
-      CHECK(cu.colorTransform, "ACT should not be enabled for root_cbf = 0");
+      CHECK_VTM(cu.colorTransform, "ACT should not be enabled for root_cbf = 0");
       return;
     }
   }
@@ -1363,7 +1363,7 @@
 
   if (cu.isSepTree())
   {
-    CHECK(cu.colorTransform, "adaptive color transform should be disabled when dualtree and localtree are enabled");
+    CHECK_VTM(cu.colorTransform, "adaptive color transform should be disabled when dualtree and localtree are enabled");
     return;
   }
 
@@ -1517,7 +1517,7 @@
   {
     cuPaletteSubblockInfo(cu, compBegin, numComp, subSetId, prevRunPos, prevRunType);
   }
-  CHECK(cu.curPLTSize[compBegin] > maxPltSize, " Current palette size is larger than maximum palette size");
+  CHECK_VTM(cu.curPLTSize[compBegin] > maxPltSize, " Current palette size is larger than maximum palette size");
 }
 void CABACWriter::cuPaletteSubblockInfo(const CodingUnit& cu, ComponentID compBegin, uint32_t numComp, int subSetId, uint32_t& prevRunPos, unsigned& prevRunType)
 {
@@ -1738,7 +1738,7 @@
 
 void CABACWriter::prediction_unit( const PredictionUnit& pu )
 {
-  CHECK( pu.cu->treeType == TREE_C, "cannot be chroma CU" );
+  CHECK_VTM( pu.cu->treeType == TREE_C, "cannot be chroma CU" );
 #if ENABLE_SPLIT_PARALLELISM
   CHECK( pu.cacheUsed, "Processing a PU that should be in cache!" );
   CHECK( pu.cu->cacheUsed, "Processing a CU that should be in cache!" );
@@ -1746,7 +1746,7 @@
 #endif
   if( pu.cu->skip )
   {
-    CHECK( !pu.mergeFlag, "merge_flag must be true for skipped CUs" );
+    CHECK_VTM( !pu.mergeFlag, "merge_flag must be true for skipped CUs" );
   }
   else
   {
@@ -1764,7 +1764,7 @@
     mvd_coding(mvd, 0); // already changed to signaling precision
     if (pu.cs->sps->getMaxNumIBCMergeCand() == 1)
     {
-      CHECK( pu.mvpIdx[REF_PIC_LIST_0], "mvpIdx for IBC mode should be 0" );
+      CHECK_VTM( pu.mvpIdx[REF_PIC_LIST_0], "mvpIdx for IBC mode should be 0" );
     }
     else
     mvp_flag(pu, REF_PIC_LIST_0);
@@ -2044,9 +2044,9 @@
       xWriteTruncBinCode(splitDir, GEO_NUM_PARTITION_MODE);
       candIdx1 -= candIdx1 < candIdx0 ? 0 : 1;
       const int maxNumGeoCand = pu.cs->sps->getMaxNumGeoCand();
-      CHECK(maxNumGeoCand < 2, "Incorrect max number of geo candidates");
-      CHECK(candIdx0 >= maxNumGeoCand, "Incorrect candIdx0");
-      CHECK(candIdx1 >= maxNumGeoCand, "Incorrect candIdx1");
+      CHECK_VTM(maxNumGeoCand < 2, "Incorrect max number of geo candidates");
+      CHECK_VTM(candIdx0 >= maxNumGeoCand, "Incorrect candIdx0");
+      CHECK_VTM(candIdx1 >= maxNumGeoCand, "Incorrect candIdx1");
       int numCandminus2 = maxNumGeoCand - 2;
       m_BinEncoder.encodeBin( candIdx0 == 0 ? 0 : 1, Ctx::MergeIdx() );
       if( candIdx0 > 0 )
@@ -2163,7 +2163,7 @@
 {
   if ( pu.cu->smvdMode )
   {
-    CHECK( pu.refIdx[eRefList] != pu.cs->slice->getSymRefIdx( eRefList ), "Invalid reference index!\n" );
+    CHECK_VTM( pu.refIdx[eRefList] != pu.cs->slice->getSymRefIdx( eRefList ), "Invalid reference index!\n" );
     return;
   }
 
@@ -2218,12 +2218,12 @@
 {
   if (!pu.cs->sps->getUseCiip())
   {
-    CHECK(pu.ciipFlag == true, "invalid Ciip SPS");
+    CHECK_VTM(pu.ciipFlag == true, "invalid Ciip SPS");
     return;
   }
   if (pu.cu->skip)
   {
-    CHECK(pu.ciipFlag == true, "invalid Ciip and skip");
+    CHECK_VTM(pu.ciipFlag == true, "invalid Ciip and skip");
     return;
   }
   m_BinEncoder.encodeBin(pu.ciipFlag, Ctx::CiipFlag());
@@ -2253,14 +2253,14 @@
   // split_transform_flag
   if( partitioner.canSplit( TU_MAX_TR_SPLIT, cs ) )
   {
-    CHECK( !split, "transform split implied" );
+    CHECK_VTM( !split, "transform split implied" );
   }
   else if( cu.sbtInfo && partitioner.canSplit( PartSplit( cu.getSbtTuSplit() ), cs ) )
   {
-    CHECK( !split, "transform split implied - sbt" );
+    CHECK_VTM( !split, "transform split implied - sbt" );
   }
   else
-  CHECK( split && !cu.ispMode, "transform split not allowed with QTBT" );
+    CHECK_VTM( split && !cu.ispMode, "transform split not allowed with QTBT" );
 
 
   if( split )
@@ -2340,17 +2340,17 @@
   int       verMvd = rMvd.getVer();
   if ( imv > 0 )
   {
-    CHECK((horMvd % 2) != 0 && (verMvd % 2) != 0, "IMV: MVD is not a multiple of 2");
+    CHECK_VTM((horMvd % 2) != 0 && (verMvd % 2) != 0, "IMV: MVD is not a multiple of 2");
     horMvd >>= 1;
     verMvd >>= 1;
     if (imv < IMV_HPEL)
     {
-      CHECK((horMvd % 2) != 0 && (verMvd % 2) != 0, "IMV: MVD is not a multiple of 4");
+      CHECK_VTM((horMvd % 2) != 0 && (verMvd % 2) != 0, "IMV: MVD is not a multiple of 4");
       horMvd >>= 1;
       verMvd >>= 1;
       if (imv == IMV_4PEL)//IMV_4PEL
       {
-        CHECK((horMvd % 4) != 0 && (verMvd % 4) != 0, "IMV: MVD is not a multiple of 16");
+        CHECK_VTM((horMvd % 4) != 0 && (verMvd % 4) != 0, "IMV: MVD is not a multiple of 16");
         horMvd >>= 2;
         verMvd >>= 2;
       }
@@ -2410,7 +2410,7 @@
   const UnitArea&         area = partitioner.currArea();
   const unsigned          trDepth = partitioner.currTrDepth;
   ChromaCbfs              chromaCbfs;
-  CHECK(tu.depth != trDepth, " transform unit should be not be futher partitioned");
+  CHECK_VTM(tu.depth != trDepth, " transform unit should be not be futher partitioned");
 
   // cbf_cb & cbf_cr
   if (area.chromaFormat != CHROMA_400)
@@ -2449,21 +2449,21 @@
   {
     if (!CU::isIntra(cu) && trDepth == 0 && !chromaCbfs.sigChroma(area.chromaFormat))
     {
-      CHECK(!TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "Luma cbf must be true for inter units with no chroma coeffs");
+      CHECK_VTM(!TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "Luma cbf must be true for inter units with no chroma coeffs");
     }
     else if (cu.sbtInfo && tu.noResidual)
     {
-      CHECK(TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "Luma cbf must be false for inter sbt no-residual tu");
+      CHECK_VTM(TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "Luma cbf must be false for inter sbt no-residual tu");
     }
     else if (cu.sbtInfo && !chromaCbfs.sigChroma(area.chromaFormat))
     {
       assert(!tu.noResidual);
-      CHECK(!TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "Luma cbf must be true for inter sbt residual tu");
+      CHECK_VTM(!TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "Luma cbf must be true for inter sbt residual tu");
     }
     else
     {
       bool lumaCbfIsInferredACT = (cu.colorTransform && cu.predMode == MODE_INTRA && trDepth == 0 && !chromaCbfs.sigChroma(area.chromaFormat));
-      CHECK(lumaCbfIsInferredACT && !TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "adaptive color transform cannot have all zero coefficients");
+      CHECK_VTM(lumaCbfIsInferredACT && !TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "adaptive color transform cannot have all zero coefficients");
       bool lastCbfIsInferred    = lumaCbfIsInferredACT; // ISP and ACT are mutually exclusive
       bool previousCbf          = false;
       bool rootCbfSoFar         = false;
@@ -2554,7 +2554,7 @@
 
 void CABACWriter::cu_qp_delta( const CodingUnit& cu, int predQP, const int8_t qp )
 {
-  CHECK(!( predQP != std::numeric_limits<int>::max()), "Unspecified error");
+  CHECK_VTM(!( predQP != std::numeric_limits<int>::max()), "Unspecified error");
   int       DQp         = qp - predQP;
   int       qpBdOffsetY = cu.cs->sps->getQpBDOffset( CHANNEL_TYPE_LUMA );
   DQp                   = ( DQp + (MAX_QP + 1) + (MAX_QP + 1) / 2 + qpBdOffsetY + (qpBdOffsetY / 2)) % ((MAX_QP + 1) + qpBdOffsetY) - (MAX_QP + 1) / 2 - (qpBdOffsetY / 2);
@@ -2614,7 +2614,7 @@
     return;
   }
 
-  CHECK( tu.jointCbCr && tu.jointCbCr != cbfMask, "wrong value of jointCbCr (" << (int)tu.jointCbCr << " vs " << (int)cbfMask << ")" );
+  CHECK_VTM( tu.jointCbCr && tu.jointCbCr != cbfMask, "wrong value of jointCbCr (" << (int)tu.jointCbCr << " vs " << (int)cbfMask << ")" );
   if( ( CU::isIntra( *tu.cu ) && cbfMask ) || ( cbfMask == 3 ) )
   {
     m_BinEncoder.encodeBin( tu.jointCbCr ? 1 : 0, Ctx::JointCbCrFlag( cbfMask - 1 ) );
@@ -2656,7 +2656,7 @@
       sigGroupFlags.set( scanPos >> cctx.log2CGSize() );
     }
   }
-  CHECK( scanPosLast < 0, "Coefficient coding called for empty TU" );
+  CHECK_VTM( scanPosLast < 0, "Coefficient coding called for empty TU" );
   cctx.setScanPosLast(scanPosLast);
 
   if (cuCtx && tu.mtsIdx[compID] != MTS_SKIP && tu.blocks[compID].height >= 4 && tu.blocks[compID].width >= 4)
@@ -2753,7 +2753,7 @@
 {
   if( !CU::isIntra( cu ) || !isLuma( cu.chType ) || cu.firstPU->multiRefIdx || !cu.cs->sps->getUseISP() || cu.bdpcmMode || !CU::canUseISP( cu, getFirstComponentOfChannel( cu.chType ) ) || cu.colorTransform )
   {
-    CHECK( cu.ispMode != NOT_INTRA_SUBPARTITIONS, "cu.ispMode != 0" );
+    CHECK_VTM( cu.ispMode != NOT_INTRA_SUBPARTITIONS, "cu.ispMode != 0" );
     return;
   }
   if ( cu.ispMode == NOT_INTRA_SUBPARTITIONS )
@@ -3181,7 +3181,7 @@
 
 void CABACWriter::unary_max_symbol( unsigned symbol, unsigned ctxId0, unsigned ctxIdN, unsigned maxSymbol )
 {
-  CHECK( symbol > maxSymbol, "symbol > maxSymbol" );
+  CHECK_VTM( symbol > maxSymbol, "symbol > maxSymbol" );
   const unsigned totalBinsToWrite = std::min( symbol + 1, maxSymbol );
   for( unsigned binsWritten = 0; binsWritten < totalBinsToWrite; ++binsWritten )
   {
@@ -3211,7 +3211,7 @@
     bins  <<= 1;
     numBins++;
   }
-  CHECK(!( numBins <= 32 ), "Unspecified error");
+  CHECK_VTM(!( numBins <= 32 ), "Unspecified error");
   m_BinEncoder.encodeBinsEP( bins, numBins );
 }
 
@@ -3291,7 +3291,7 @@
                                             const int curIdx, const uint8_t *filterControlIdc, Position lumaPos,
                                             const int filterCount)
 {
-  CHECK(idcVal > filterCount, "Filter index is too large");
+  CHECK_VTM(idcVal > filterCount, "Filter index is too large");
 
   const uint32_t curSliceIdx    = cs.slice->getIndependentSliceIdx();
   const uint32_t curTileIdx     = cs.pps->getTileIdx( lumaPos );
@@ -3404,7 +3404,7 @@
     m_BinEncoder.encodeBin(useTemporalFilt, Ctx::AlfUseTemporalFilt());
     if (useTemporalFilt)
     {
-      CHECK((filterSetIdx - NUM_FIXED_FILTER_SETS) >= (numAvailableFiltSets - NUM_FIXED_FILTER_SETS), "temporal non-latest set");
+      CHECK_VTM((filterSetIdx - NUM_FIXED_FILTER_SETS) >= (numAvailableFiltSets - NUM_FIXED_FILTER_SETS), "temporal non-latest set");
       if (numAps > 1)
       {
         xWriteTruncBinCode(filterSetIdx - NUM_FIXED_FILTER_SETS, numAvailableFiltSets - NUM_FIXED_FILTER_SETS);
@@ -3412,13 +3412,13 @@
     }
     else
     {
-      CHECK(filterSetIdx >= NUM_FIXED_FILTER_SETS, "fixed set larger than temporal");
+      CHECK_VTM(filterSetIdx >= NUM_FIXED_FILTER_SETS, "fixed set larger than temporal");
       xWriteTruncBinCode(filterSetIdx, NUM_FIXED_FILTER_SETS);
     }
   }
   else
   {
-    CHECK(filterSetIdx >= NUM_FIXED_FILTER_SETS, "fixed set numavail < num_fixed");
+    CHECK_VTM(filterSetIdx >= NUM_FIXED_FILTER_SETS, "fixed set numavail < num_fixed");
     xWriteTruncBinCode(filterSetIdx, NUM_FIXED_FILTER_SETS);
   }
 }
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncAdaptiveLoopFilter.cpp ../VVCSoftware_10/source/Lib/EncoderLib/EncAdaptiveLoopFilter.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncAdaptiveLoopFilter.cpp	2022-09-16 14:27:06.148532600 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/EncAdaptiveLoopFilter.cpp	2022-05-13 17:45:29.544141634 +0200
@@ -465,7 +465,7 @@
 void EncAdaptiveLoopFilter::create( const EncCfg* encCfg, const int picWidth, const int picHeight, const ChromaFormat chromaFormatIDC, const int maxCUWidth, const int maxCUHeight, const int maxCUDepth, const int inputBitDepth[MAX_NUM_CHANNEL_TYPE], const int internalBitDepth[MAX_NUM_CHANNEL_TYPE] )
 {
   AdaptiveLoopFilter::create( picWidth, picHeight, chromaFormatIDC, maxCUWidth, maxCUHeight, maxCUDepth, inputBitDepth );
-  CHECK( encCfg == nullptr, "encCfg must not be null" );
+  CHECK_VTM( encCfg == nullptr, "encCfg must not be null" );
   m_encCfg = encCfg;
 
   for( int channelIdx = 0; channelIdx < MAX_NUM_CHANNEL_TYPE; channelIdx++ )
@@ -1126,7 +1126,7 @@
 
   setEnableFlag(m_alfParamTemp, channel, true);
 #if ENABLE_QPA
-  CHECK ((chromaWeight > 0.0) && (cs.slice->getFirstCtuRsAddrInSlice() != 0), "incompatible start CTU address, must be 0");
+  CHECK_VTM((chromaWeight > 0.0) && (cs.slice->getFirstCtuRsAddrInSlice() != 0), "incompatible start CTU address, must be 0");
 #endif
 
   reconstructCoeff(m_alfParamTemp, channel, true, isLuma(channel));
@@ -1772,7 +1772,7 @@
   int uiLength = 1;
   int uiTemp = ++uiCode;
 
-  CHECK( !uiTemp, "Integer overflow" );
+  CHECK_VTM( !uiTemp, "Integer overflow" );
 
   while( 1 != uiTemp )
   {
@@ -2557,7 +2557,7 @@
   {
     newApsId = ALF_CTB_MAX_NUM_APS - 1;
   }
-  CHECK(newApsId >= ALF_CTB_MAX_NUM_APS, "Wrong APS index assignment in getAvaiApsIdsLuma");
+  CHECK_VTM(newApsId >= ALF_CTB_MAX_NUM_APS, "Wrong APS index assignment in getAvaiApsIdsLuma");
   return result;
 }
 void  EncAdaptiveLoopFilter::initDistortion()
@@ -3291,7 +3291,7 @@
         signaledFilterCount++;
       }
     }
-    CHECK(signaledFilterCount != filterCount, "Number of filter signaled not same as indicated");
+    CHECK_VTM(signaledFilterCount != filterCount, "Number of filter signaled not same as indicated");
   }
 
   return bits;
@@ -3331,8 +3331,8 @@
 
   for (int k = 0; k < size; k++)
   {
-    CHECK( filterCoeffInt[k] < -(1 << CCALF_DYNAMIC_RANGE), "this is not possible: filterCoeffInt[k] <  -(1 << CCALF_DYNAMIC_RANGE)");
-    CHECK( filterCoeffInt[k] > (1 << CCALF_DYNAMIC_RANGE), "this is not possible: filterCoeffInt[k] >  (1 << CCALF_DYNAMIC_RANGE)");
+    CHECK_VTM( filterCoeffInt[k] < -(1 << CCALF_DYNAMIC_RANGE), "this is not possible: filterCoeffInt[k] <  -(1 << CCALF_DYNAMIC_RANGE)");
+    CHECK_VTM( filterCoeffInt[k] > (1 << CCALF_DYNAMIC_RANGE), "this is not possible: filterCoeffInt[k] >  (1 << CCALF_DYNAMIC_RANGE)");
   }
 
   // Refine quanitzation
@@ -3358,7 +3358,7 @@
             break;
           }
         }
-        CHECK( org_idx < 0, "this is wrong, does not find coeff from forward_tab");
+        CHECK_VTM( org_idx < 0, "this is wrong, does not find coeff from forward_tab");
         if ( (org_idx - delta < 0) || (org_idx - delta >= CCALF_CANDS_COEFF_NR * 2 - 1) )
           continue;
 
@@ -3375,8 +3375,8 @@
       if (errMin < errRef)
       {
         minIndex -= delta;
-        CHECK( minIndex < 0, "this is wrong, index - delta < 0");
-        CHECK( minIndex >= CCALF_CANDS_COEFF_NR * 2 - 1, "this is wrong, index - delta >= CCALF_CANDS_COEFF_NR * 2 - 1");
+        CHECK_VTM( minIndex < 0, "this is wrong, index - delta < 0");
+        CHECK_VTM( minIndex >= CCALF_CANDS_COEFF_NR * 2 - 1, "this is wrong, index - delta >= CCALF_CANDS_COEFF_NR * 2 - 1");
         filterCoeffInt[idxMin] = forward_tab[minIndex];
         modified++;
         errRef = errMin;
@@ -3386,7 +3386,7 @@
 
   for (int k = 0; k < (size + 1); k++)
   {
-    CHECK((filterCoeffInt[k] < -(1 << CCALF_DYNAMIC_RANGE)) || (filterCoeffInt[k] > (1 << CCALF_DYNAMIC_RANGE)), "Exceeded valid range for CC ALF coefficient");
+    CHECK_VTM((filterCoeffInt[k] < -(1 << CCALF_DYNAMIC_RANGE)) || (filterCoeffInt[k] > (1 << CCALF_DYNAMIC_RANGE)), "Exceeded valid range for CC ALF coefficient");
     filterCoeff[filterIdx][k] = filterCoeffInt[k];
   }
 }
@@ -3874,7 +3874,7 @@
         }
         m_bestFilterIdxEnabled[filterIdx] = ( filterIdx < m_bestFilterCount ) ? true : false;
       }
-      CHECK( filterCount != m_bestFilterCount, "Number of filters enabled did not match the filter count");
+      CHECK_VTM( filterCount != m_bestFilterCount, "Number of filters enabled did not match the filter count");
     }
 
     m_ccAlfFilterParam.ccAlfFilterCount[compID - 1] = m_bestFilterCount;
@@ -4146,7 +4146,7 @@
 
 void EncAdaptiveLoopFilter::calcCovarianceCcAlf(Pel ELocal[MAX_NUM_CC_ALF_CHROMA_COEFF][1], const Pel *rec, const int stride, const AlfFilterShape& shape, int vbDistance)
 {
-  CHECK(shape.filterType != CC_ALF, "Bad CC ALF shape");
+  CHECK_VTM(shape.filterType != CC_ALF, "Bad CC ALF shape");
 
   const Pel *recYM1 = rec - 1 * stride;
   const Pel *recY0  = rec;
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncCfg.h ../VVCSoftware_10/source/Lib/EncoderLib/EncCfg.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncCfg.h	2022-09-16 14:27:06.148532600 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/EncCfg.h	2022-05-13 17:45:29.548141589 +0200
@@ -981,7 +981,8 @@
   void      setDualITree                    ( bool b )       { m_dualITree = b; }
   bool      getDualITree                    ()         const { return m_dualITree; }
   void      setSubPicInfoPresentFlag                        (bool b)                    { m_subPicInfoPresentFlag = b; }
-  void      setNumSubPics                               ( uint32_t u )              { CHECK( u >= MAX_NUM_SUB_PICS, "Maximum number of subpictures exceeded" );
+  void      setNumSubPics                               ( uint32_t u )              {
+    CHECK_VTM( u >= MAX_NUM_SUB_PICS, "Maximum number of subpictures exceeded" );
                                                                                       m_numSubPics = u;
                                                                                       m_subPicCtuTopLeftX.resize(m_numSubPics);
                                                                                       m_subPicCtuTopLeftY.resize(m_numSubPics);
@@ -998,18 +999,25 @@
   void      setSubPicHeight                             (uint32_t u, int i)         { m_subPicHeight[i] = u; }
   void      setSubPicTreatedAsPicFlag                   (bool b, int i)             { m_subPicTreatedAsPicFlag[i] = b; }
   void      setLoopFilterAcrossSubpicEnabledFlag        (bool b, int i)             { m_loopFilterAcrossSubpicEnabledFlag[i] = b; }
-  void      setSubPicCtuTopLeftX                        (const std::vector<uint32_t> &v)   { CHECK(v.size() != (m_subPicSameSizeFlag ? 0 : m_numSubPics), "number of vector entries must be equal to numSubPics(subPicSameSize=0) or 0(subPicSameSize=1)"); m_subPicCtuTopLeftX = v; }
-  void      setSubPicCtuTopLeftY                        (const std::vector<uint32_t> &v)   { CHECK(v.size() != (m_subPicSameSizeFlag ? 0 : m_numSubPics), "number of vector entries must be equal to numSubPics(subPicSameSize=0) or 0(subPicSameSize=1)"); m_subPicCtuTopLeftY = v; }
-  void      setSubPicWidth                              (const std::vector<uint32_t> &v)   { CHECK(v.size() != (m_subPicSameSizeFlag ? 1 : m_numSubPics), "number of vector entries must be equal to numSubPics(subPicSameSize=0) or 1(subPicSameSize=1)"); m_subPicWidth = v; }
-  void      setSubPicHeight                             (const std::vector<uint32_t> &v)   { CHECK(v.size() != (m_subPicSameSizeFlag ? 1 : m_numSubPics), "number of vector entries must be equal to numSubPics(subPicSameSize=0) or 1(subPicSameSize=1)"); m_subPicHeight = v; }
-  void      setSubPicTreatedAsPicFlag                   (const std::vector<bool> &v)       { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicTreatedAsPicFlag = v; }
-  void      setLoopFilterAcrossSubpicEnabledFlag        (const std::vector<bool> &v)       { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_loopFilterAcrossSubpicEnabledFlag = v; }
+  void      setSubPicCtuTopLeftX                        (const std::vector<uint32_t> &v)   {
+    CHECK_VTM(v.size() != (m_subPicSameSizeFlag ? 0 : m_numSubPics), "number of vector entries must be equal to numSubPics(subPicSameSize=0) or 0(subPicSameSize=1)"); m_subPicCtuTopLeftX = v; }
+  void      setSubPicCtuTopLeftY                        (const std::vector<uint32_t> &v)   {
+    CHECK_VTM(v.size() != (m_subPicSameSizeFlag ? 0 : m_numSubPics), "number of vector entries must be equal to numSubPics(subPicSameSize=0) or 0(subPicSameSize=1)"); m_subPicCtuTopLeftY = v; }
+  void      setSubPicWidth                              (const std::vector<uint32_t> &v)   {
+    CHECK_VTM(v.size() != (m_subPicSameSizeFlag ? 1 : m_numSubPics), "number of vector entries must be equal to numSubPics(subPicSameSize=0) or 1(subPicSameSize=1)"); m_subPicWidth = v; }
+  void      setSubPicHeight                             (const std::vector<uint32_t> &v)   {
+    CHECK_VTM(v.size() != (m_subPicSameSizeFlag ? 1 : m_numSubPics), "number of vector entries must be equal to numSubPics(subPicSameSize=0) or 1(subPicSameSize=1)"); m_subPicHeight = v; }
+  void      setSubPicTreatedAsPicFlag                   (const std::vector<bool> &v)       {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_subPicTreatedAsPicFlag = v; }
+  void      setLoopFilterAcrossSubpicEnabledFlag        (const std::vector<bool> &v)       {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics") ;m_loopFilterAcrossSubpicEnabledFlag = v; }
 
   void      setSubPicIdMappingExplicitlySignalledFlag   (bool b)                    { m_subPicIdMappingExplicitlySignalledFlag = b; }
   void      setSubPicIdMappingInSpsFlag                 (bool b)                    { m_subPicIdMappingInSpsFlag = b; }
   void      setSubPicIdLen                              (uint32_t u)                { m_subPicIdLen = u; }
   void      setSubPicId                                 (uint32_t b, int i)         { m_subPicId[i] = b; }
-  void      setSubPicId                                 (const std::vector<uint16_t> &v)   { CHECK(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics"); m_subPicId = v; }
+  void      setSubPicId                                 (const std::vector<uint16_t> &v)   {
+    CHECK_VTM(v.size()!=m_numSubPics, "number of vector entries must be equal to numSubPics"); m_subPicId = v; }
 
   bool      getSubPicInfoPresentFlag                    ()                          { return m_subPicInfoPresentFlag; }
   bool      getSubPicSameSizeFlag                       ()                          { return m_subPicSameSizeFlag; }
@@ -1301,7 +1309,8 @@
 #else
   int       getBaseQP                       ()       { return  m_iQP; }
 #endif
-  int       getPad                          ( int i )      { CHECK(i >= 2, "Invalid index");                      return  m_aiPad[i]; }
+  int       getPad                          ( int i )      {
+    CHECK_VTM(i >= 2, "Invalid index");                      return  m_aiPad[i]; }
 
   bool      getAccessUnitDelimiter() const  { return m_AccessUnitDelimiter; }
   void      setAccessUnitDelimiter(bool val){ m_AccessUnitDelimiter = val; }
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncCu.cpp ../VVCSoftware_10/source/Lib/EncoderLib/EncCu.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncCu.cpp	2022-09-16 14:27:06.148532600 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/EncCu.cpp	2022-06-21 09:30:29.946579255 +0200
@@ -48,6 +48,8 @@
 
 
 #include "CommonLib/dtrace_buffer.h"
+#include "PartitionGlobalManager.h"
+#include "PartitionUtils.h"
 
 #include <stdio.h>
 #include <cmath>
@@ -253,7 +255,7 @@
 // Public member functions
 // ====================================================================================================================
 
-void EncCu::compressCtu( CodingStructure& cs, const UnitArea& area, const unsigned ctuRsAddr, const int prevQP[], const int currQP[] )
+void EncCu::compressCtu( CodingStructure& cs, const UnitArea& area, const unsigned ctuRsAddr, const int prevQP[], const int currQP[], PartitionTree *luma_tree, PartitionTree *chroma_tree )
 {
   m_modeCtrl->initCTUEncoding( *cs.slice );
   cs.treeType = TREE_D;
@@ -332,7 +334,38 @@
   tempCS->baseQP       = bestCS->baseQP       = currQP[CH_L];
   tempCS->prevQP[CH_L] = bestCS->prevQP[CH_L] = prevQP[CH_L];
 
-  xCompressCU(tempCS, bestCS, partitioner);
+  //Load the best partition of the CTU
+  if(param_partition->is_readPartition()){
+    load_partition->load_ctu(load_partition->getM_cur_tree());
+  }
+
+  Mv* mvUni = (Mv *) malloc(2*sizeof(Mv));
+  int * pocRef = (int *) malloc(2 * sizeof(int));
+  mvUni[0].setHor(9999);
+
+
+  if(tempCS->slice->getSliceType()!=I_SLICE && (param_partition->is_predictPartitionInter() || param_partition->is_writePartition())){
+    vector<float> *pred_vector_luma = new vector<float>();
+    xCompressCU(tempCS, bestCS, partitioner, luma_tree, mvUni, pocRef, MAX_DOUBLE, pred_vector_luma);
+    delete pred_vector_luma;
+  }
+  else{
+    xCompressCU(tempCS, bestCS, partitioner, luma_tree);
+  }
+
+
+  if(param_partition->is_writePartition()){
+    luma_tree->set_mvUni(mvUni);
+    luma_tree->set_pocRef(pocRef);
+  }
+  free(mvUni);
+  free(pocRef);
+
+  //Reset the CTU at starting point
+  if(param_partition->is_readPartition()){
+    load_partition->reset_ctu();
+  }
+
   cs.slice->m_mapPltCost[0].clear();
   cs.slice->m_mapPltCost[1].clear();
   // all signals were already copied during compression if the CTU was split - at this point only the structures are copied to the top level CS
@@ -352,7 +385,17 @@
     tempCS->baseQP       = bestCS->baseQP       = currQP[CH_C];
     tempCS->prevQP[CH_C] = bestCS->prevQP[CH_C] = prevQP[CH_C];
 
-    xCompressCU(tempCS, bestCS, partitioner);
+    //Load chroma CTU partition
+    if(param_partition->is_readPartition()){
+      load_partition->load_ctu(load_partition->getM_cur_tree());
+    }
+
+    xCompressCU(tempCS, bestCS, partitioner, chroma_tree);
+
+    //Reset the CTU at starting point
+    if(param_partition->is_readPartition()){
+      load_partition->reset_ctu();
+    }
 
     const bool copyUnsplitCTUSignals = bestCS->cus.size() == 1;
     cs.useSubStructure(*bestCS, partitioner.chType, CS::getArea(*bestCS, area, partitioner.chType),
@@ -370,9 +413,9 @@
 
   // Ensure that a coding was found
   // Selected mode's RD-cost must be not MAX_DOUBLE.
-  CHECK( bestCS->cus.empty()                                   , "No possible encoding found" );
-  CHECK( bestCS->cus[0]->predMode == NUMBER_OF_PREDICTION_MODES, "No possible encoding found" );
-  CHECK( bestCS->cost             == MAX_DOUBLE                , "No possible encoding found" );
+  CHECK_VTM( bestCS->cus.empty()                                   , "No possible encoding found" );
+  CHECK_VTM( bestCS->cus[0]->predMode == NUMBER_OF_PREDICTION_MODES, "No possible encoding found" );
+  CHECK_VTM( bestCS->cost             == MAX_DOUBLE                , "No possible encoding found" );
 }
 
 // ====================================================================================================================
@@ -501,7 +544,7 @@
     if( tempCS->cus.size() == 1 )
     {
       const CodingUnit& cu = *tempCS->cus.front();
-      CHECK( cu.skip && !cu.firstPU->mergeFlag, "Skip flag without a merge flag is not allowed!" );
+      CHECK_VTM( cu.skip && !cu.firstPU->mergeFlag, "Skip flag without a merge flag is not allowed!" );
     }
 
 #if WCG_EXT
@@ -527,9 +570,9 @@
 
 }
 
-void EncCu::xCompressCU( CodingStructure*& tempCS, CodingStructure*& bestCS, Partitioner& partitioner, double maxCostAllowed )
+void EncCu::xCompressCU( CodingStructure*& tempCS, CodingStructure*& bestCS, Partitioner& partitioner, PartitionTree *tree, Mv* mvUni, int * pocRef, double maxCostAllowed, vector<float> *pred_vector_luma)
 {
-  CHECK(maxCostAllowed < 0, "Wrong value of maxCostAllowed!");
+  CHECK_VTM(maxCostAllowed < 0, "Wrong value of maxCostAllowed!");
 #if ENABLE_SPLIT_PARALLELISM
   CHECK( m_dataId != tempCS->picture->scheduler.getDataId(), "Working in the wrong dataId!" );
 
@@ -674,6 +717,29 @@
     }
   }
 
+  //Get the split from the saved dat file
+  bool try_split[5] = {false};
+  if (param_partition->is_readPartition() && !tree->get_chroma_stop()) {
+    load_partition->shall_we_split(try_split);
+  }
+
+  double curRdCost = bestCS->cost;
+  PartitionTree qtTree(tree->getM_width(), tree->getM_height(), nullptr, nullptr, tree->getM_cur_param(),
+                       tree->isM_is_bin(), tree->isM_is_tern(), curRdCost);
+  PartitionTree bthTree(tree->getM_width(), tree->getM_height(), nullptr, nullptr, tree->getM_cur_param(),
+                        tree->isM_is_bin(), tree->isM_is_tern(), curRdCost);
+  PartitionTree btvTree(tree->getM_width(), tree->getM_height(), nullptr, nullptr, tree->getM_cur_param(),
+                        tree->isM_is_bin(), tree->isM_is_tern(), curRdCost);
+  PartitionTree tthTree(tree->getM_width(), tree->getM_height(), nullptr, nullptr, tree->getM_cur_param(),
+                        tree->isM_is_bin(), tree->isM_is_tern(), curRdCost);
+  PartitionTree ttvTree(tree->getM_width(), tree->getM_height(), nullptr, nullptr, tree->getM_cur_param(),
+                        tree->isM_is_bin(), tree->isM_is_tern(), curRdCost);
+
+  uint8_t * splitDecision = nullptr;
+  bool firstPass = true;
+  EncTestModeType previous_mode = ETM_INVALID;
+  bool firstPassInter = true;
+
   do
   {
     for (int i = compBegin; i < (compBegin + numComp); i++)
@@ -685,6 +751,87 @@
     EncTestMode currTestMode = m_modeCtrl->currTestMode();
     currTestMode.maxCostAllowed = maxCostAllowed;
 
+    if (param_partition->is_predictPartition() && tempCS->area.blocks[0].height == 64 &&
+        tempCS->area.blocks[0].width == 64 && firstPass && isLuma( partitioner.chType )) {
+      clock_t start = clock();
+      firstPass=false;
+      std::vector<fdeep::internal::tensor> result;
+      std::vector<float> currPixels = getCurrCuLuma(tempCS);
+      result = predict_partition->model->predict({fdeep::tensor(fdeep::tensor_shape(68, 68, 1), currPixels),fdeep::tensor(fdeep::tensor_shape(1), predict_partition->getQp())});
+
+      pred_vector_luma = new vector<float>();
+      for(int i=0;i<result[0].as_vector()->size();i++){
+        pred_vector_luma->push_back(result[0].as_vector()->at(i));
+      }
+      time_cnn += ((double) clock() - start) / CLOCKS_PER_SEC;
+    }
+
+//    if (param_partition->is_predictPartitionInter() && tempCS->area.blocks[0].height == 64 &&
+//        tempCS->area.blocks[0].width == 64 && firstPass && tempCS->picture->poc!=0) {
+//      clock_t start = clock();
+//      firstPass=false;
+//      std::vector<fdeep::internal::tensor> result;
+//      std::vector<float> currPixels = getCurrCuLuma(tempCS);
+//      result = predict_partitionInter->model->predict({fdeep::tensor(fdeep::tensor_shape(68, 68, 1), currPixels),fdeep::tensor(fdeep::tensor_shape(1), tempCS->baseQP)});
+//
+//      pred_vector_luma = new vector<float>();
+//      for(int i=0;i<result[0].as_vector()->size();i++){
+//        pred_vector_luma->push_back(result[0].as_vector()->at(i));
+//      }
+//      time_cnn += ((double) clock() - start) / CLOCKS_PER_SEC;
+//    }
+
+    if(param_partition->is_predictPartition() && ((isLuma( partitioner.chType ) && currTestMode.type == ETM_INTRA && tempCS->area.blocks[0].height !=128 && tempCS->area.blocks[0].width !=128 && !(tempCS->area.blocks[0].width ==4 && tempCS->area.blocks[0].height ==4)))){
+      clock_t start = clock();
+      splitDecision = splitChoiceML(predict_partition->getQp(), tempCS->area.blocks[0].width, tempCS->area.blocks[0].height, tempCS->area.blocks[0].x%64, tempCS->area.blocks[0].y%64, pred_vector_luma);
+      time_cnn += ((double) clock() - start) / CLOCKS_PER_SEC;
+    }
+
+    if(param_partition->is_predictPartitionInter() && firstPassInter && previous_mode == ETM_INTER_ME && !(tempCS->area.blocks[0].width ==4 && tempCS->area.blocks[0].height ==4) /*&& pred_vector_luma != nullptr && pred_vector_luma->size() != 0 && tempCS->area.blocks[0].x + tempCS->area.blocks[0].width <= tempCS->picture->lwidth() &&  tempCS->area.blocks[0].y + tempCS->area.blocks[0].height <= tempCS->picture->lheight()*/){
+      clock_t start = clock();
+      firstPassInter = false;
+      //std::cout<<tempCS->area.blocks[0].width<<"x"<<tempCS->area.blocks[0].height<<" / "<<tempCS->area.blocks[0].x<<"x"<<tempCS->area.blocks[0].y<<std::endl;
+      //int * mean_split = predictSplit(pred_vector_luma, tempCS->area.blocks[0].x%128, tempCS->area.blocks[0].y%128, tempCS->area.blocks[0].width, tempCS->area.blocks[0].height);
+      //call boolean function
+      //splitDecision = splitChoice(mean_split);
+      splitDecision = splitChoiceML_inter(tempCS->baseQP, tempCS->area.blocks[0].width, tempCS->area.blocks[0].height, tempCS->area.blocks[0].x%128, tempCS->area.blocks[0].y%128, pred_vector_luma);
+      //delete [] mean_split;
+      time_cnn += ((double) clock() - start) / CLOCKS_PER_SEC;
+      if(tempCS->area.blocks[0].height !=128 && tempCS->area.blocks[0].width !=128 /*&& tempCS->area.blocks[0].height !=64 && tempCS->area.blocks[0].width !=64*/){ //if when using intra cnn
+        start = clock();
+        firstPassInter = false;
+        //int * mean_split = predictSplitIntra(pred_vector_luma, tempCS->area.blocks[0].x%64, tempCS->area.blocks[0].y%64, tempCS->area.blocks[0].width, tempCS->area.blocks[0].height);
+        //call boolean function
+        //splitDecision = splitChoice(mean_split);
+        splitDecision = splitChoiceML_inter(tempCS->baseQP, tempCS->area.blocks[0].width, tempCS->area.blocks[0].height, tempCS->area.blocks[0].x%64, tempCS->area.blocks[0].y%64, pred_vector_luma);
+        //delete [] mean_split;
+        time_cnn += ((double) clock() - start) / CLOCKS_PER_SEC;
+      }
+    }
+
+    uint8_t splitDecisionCNN = 1;
+    if(param_partition->is_predictPartition() && splitDecision!= nullptr && tempCS->area.blocks[0].height !=128 && tempCS->area.blocks[0].width !=128 && getInverseSplit(currTestMode.type) != -1){
+      splitDecisionCNN = splitDecision[getInverseSplit(currTestMode.type)];
+    }
+    if(param_partition->is_predictPartitionInter() && splitDecision!= nullptr && getInverseSplit(currTestMode.type) != -1){
+      splitDecisionCNN = splitDecision[getInverseSplit(currTestMode.type)];
+    }
+
+
+    bool isTestMode = true;
+    if (param_partition->is_readPartition() && !tree->get_chroma_stop()) {
+      isTestMode = false;
+      int tmp = -1;
+      for (int i = 0; i < 5; i++) {
+        if (try_split[i]) {
+          tmp = i;
+        }
+      }
+      if (getSplit(tmp) == currTestMode.type) {
+        isTestMode = true;
+      }
+    }
+
     if (pps.getUseDQP() && partitioner.isSepTree(*tempCS) && isChroma( partitioner.chType ))
     {
       const Position chromaCentral(tempCS->area.Cb().chromaPos().offset(tempCS->area.Cb().chromaSize().width >> 1, tempCS->area.Cb().chromaSize().height >> 1));
@@ -726,6 +873,9 @@
 
     if( currTestMode.type == ETM_INTER_ME )
     {
+
+      if(param_partition->is_readPartition()) {
+        if (load_partition->getM_cur_tree()->getM_leaves() == nullptr) {
       if( ( currTestMode.opts & ETO_IMV ) != 0 )
       {
         const bool skipAltHpelIF = ( int( ( currTestMode.opts & ETO_IMV ) >> ETO_IMV_SHIFT ) == 4 ) && ( bestIntPelCost > 1.25 * bestCS->cost );
@@ -742,33 +892,155 @@
         xCheckRDCostInter( tempCS, bestCS, partitioner, currTestMode );
         tempCS->bestCS = nullptr;
       }
+        }
+      }
+      else {
+        if ((currTestMode.opts & ETO_IMV) != 0) {
+          const bool skipAltHpelIF =
+                  (int((currTestMode.opts & ETO_IMV) >> ETO_IMV_SHIFT) == 4) && (bestIntPelCost > 1.25 * bestCS->cost);
+          if (!skipAltHpelIF) {
+            tempCS->bestCS = bestCS;
+            xCheckRDCostInterIMV(tempCS, bestCS, partitioner, currTestMode, bestIntPelCost);
+            tempCS->bestCS = nullptr;
+          }
+        } else {
+          tempCS->bestCS = bestCS;
+
+          Mv* mvUniBis = (Mv *) malloc(2*sizeof(Mv));
+          int * pocRefBis = (int *) malloc(2 * sizeof(int));
+          unsigned long * costRef = (unsigned long *) malloc(2 * sizeof(unsigned long));
+          costRef[0]=std::numeric_limits<Distortion>::max();
+          costRef[1]=std::numeric_limits<Distortion>::max();
+          RefPicList * refPicList = (RefPicList *) malloc(2 * sizeof(RefPicList));
+          int * pocRefIdx = (int *) malloc(2 * sizeof(int));
+
+          xCheckRDCostInter(tempCS, bestCS, partitioner, currTestMode, mvUniBis, pocRefBis, costRef, refPicList, pocRefIdx);
+
+          if((param_partition->is_writePartition() || param_partition->is_predictPartitionInter()) && mvUni[0].getHor()==9999){
+            clock_t start = clock();
+            if(costRef[1]==std::numeric_limits<Distortion>::max()){
+              mvUniBis[1]=mvUniBis[0];
+              pocRefBis[1]=pocRefBis[0];
+              refPicList[1] = refPicList[0];
+              pocRefIdx[1] = pocRefIdx[0];
+            }
+            mvUni[0].set(mvUniBis[0].getHor(),mvUniBis[0].getVer());
+            mvUni[1].set(mvUniBis[1].getHor(),mvUniBis[1].getVer());
+            mvUni[0].changePrecision(MV_PRECISION_INTERNAL, MV_PRECISION_INT);
+            mvUni[1].changePrecision(MV_PRECISION_INTERNAL, MV_PRECISION_INT);
+            pocRef[0] = pocRefBis[0];
+            pocRef[1] = pocRefBis[1];
+
+
+            if(param_partition->is_predictPartitionInter()){
+              Picture * pic = tempCS->picture;
+              Picture * pic_ref0 = tempCS->slice->getRefPic(refPicList[0], pocRefIdx[0]);
+              Picture * pic_ref1 = tempCS->slice->getRefPic(refPicList[1], pocRefIdx[1]);
+              std::vector<float> currPixels = getCtusLumaInter(pic, pic_ref0, pic_ref1, tempCS->area.blocks[0].x, tempCS->area.blocks[0].y, mvUni);
+              std::vector<fdeep::internal::tensor> result;
+              result = predict_partitionInter->model->predict({fdeep::tensor(fdeep::tensor_shape(128,128, 3), currPixels),fdeep::tensor(fdeep::tensor_shape(1), tempCS->baseQP)});
+
+              //pred_vector_luma = new vector<float>();
+              for(int i=0;i<result[0].as_vector()->size();i++){
+                pred_vector_luma->push_back(result[0].as_vector()->at(i));
+                //std::cout<<pred_vector_luma->at(i)<<" ";
+              }
+              //std::cout<<pred_vector_luma->at(0)<<" "<<pred_vector_luma->at(1)<<" "<<pred_vector_luma->at(result[0].as_vector()->size()-2)<<" "<<pred_vector_luma->at(result[0].as_vector()->size()-1)<<std::endl;
+              //std::cout<<std::endl;
+            }
+
+            // Added by Souhaiel
+//            if(param_partition->is_predictPartitionInter()){
+//              Picture * pic = tempCS->picture;
+//              std::vector<float> currPixels = getCtusLumaInterBenchmark(pic, tempCS->area.blocks[0].x, tempCS->area.blocks[0].y);
+//              std::vector<fdeep::internal::tensor> result;
+//              result = predict_partitionInter->model->predict({fdeep::tensor(fdeep::tensor_shape(128,128, 1), currPixels),fdeep::tensor(fdeep::tensor_shape(1), tempCS->baseQP)});
+////              pred_vector_luma = new vector<float>();
+//              for(int i=0;i<result[0].as_vector()->size();i++){
+//                pred_vector_luma->push_back(result[0].as_vector()->at(i));
+// //                std::cout<<pred_vector_luma->at(i)<<" ";
+//              }
+//            }
+            // added by souhaiel ends here
+
+            time_cnn += ((double) clock() - start) / CLOCKS_PER_SEC;
+
+            //std::cout<<"OUT : Im ref 0 : "<<pocRef[0]<<" / X : "<<mvUni[0].getHor()<<" / Y : "<<mvUni[0].getVer()<<" / Cost : "<<costRef[0]<<std::endl;
+            //std::cout<<"OUT : Im ref 1 : "<<pocRef[1]<<" / X : "<<mvUni[1].getHor()<<" / Y : "<<mvUni[1].getVer()<<" / Cost : "<<costRef[1]<<std::endl;
+          }
 
+          free(mvUniBis);
+          free(pocRefBis);
+          free(costRef);
+          free(refPicList);
+          free(pocRefIdx);
+          tempCS->bestCS = nullptr;
+        }
+      }
     }
     else if (currTestMode.type == ETM_HASH_INTER)
     {
+      if(param_partition->is_readPartition()) {
+        if (load_partition->getM_cur_tree()->getM_leaves() == nullptr) {
+          xCheckRDCostHashInter( tempCS, bestCS, partitioner, currTestMode );
+        }
+      }
+      else{
       xCheckRDCostHashInter( tempCS, bestCS, partitioner, currTestMode );
     }
+    }
     else if( currTestMode.type == ETM_AFFINE )
     {
+      if(param_partition->is_readPartition()) {
+        if (load_partition->getM_cur_tree()->getM_leaves() == nullptr) {
       xCheckRDCostAffineMerge2Nx2N( tempCS, bestCS, partitioner, currTestMode );
     }
+      }
+      else{
+        xCheckRDCostAffineMerge2Nx2N( tempCS, bestCS, partitioner, currTestMode );
+      }
+    }
 #if REUSE_CU_RESULTS
     else if( currTestMode.type == ETM_RECO_CACHED )
     {
+      if(param_partition->is_readPartition()) {
+        if (load_partition->getM_cur_tree()->getM_leaves() == nullptr) {
+          xReuseCachedResult( tempCS, bestCS, partitioner );
+        }
+      }
+      else{
       xReuseCachedResult( tempCS, bestCS, partitioner );
     }
+    }
 #endif
     else if( currTestMode.type == ETM_MERGE_SKIP )
     {
+      if(param_partition->is_readPartition()) {
+        if (load_partition->getM_cur_tree()->getM_leaves() == nullptr) {
       xCheckRDCostMerge2Nx2N( tempCS, bestCS, partitioner, currTestMode );
       CodingUnit* cu = bestCS->getCU(partitioner.chType);
       if (cu)
       cu->mmvdSkip = cu->skip == false ? false : cu->mmvdSkip;
     }
+      }
+      else{
+        xCheckRDCostMerge2Nx2N( tempCS, bestCS, partitioner, currTestMode );
+        CodingUnit* cu = bestCS->getCU(partitioner.chType);
+        if (cu)
+        cu->mmvdSkip = cu->skip == false ? false : cu->mmvdSkip;
+      }
+    }
     else if( currTestMode.type == ETM_MERGE_GEO )
     {
+      if(param_partition->is_readPartition()) {
+        if (load_partition->getM_cur_tree()->getM_leaves() == nullptr) {
       xCheckRDCostMergeGeo2Nx2N( tempCS, bestCS, partitioner, currTestMode );
     }
+      }
+      else{
+        xCheckRDCostMergeGeo2Nx2N(tempCS, bestCS, partitioner, currTestMode);
+      }
+    }
     else if( currTestMode.type == ETM_INTRA )
     {
       if (slice.getSPS()->getUseColorTrans() && !CS::isDualITree(*tempCS))
@@ -797,28 +1069,57 @@
         }
         else
         {
-          CHECK(tempCS->tmpColorSpaceIntraCost[1] != MAX_DOUBLE, "the RD test of the second color space should be skipped");
+          CHECK_VTM(tempCS->tmpColorSpaceIntraCost[1] != MAX_DOUBLE, "the RD test of the second color space should be skipped");
         }
       }
       else
       {
+        if(param_partition->is_readPartition() && !tree->get_chroma_stop()){
+          if(load_partition->getM_cur_tree()->getM_leaves() == nullptr){
         xCheckRDCostIntra(tempCS, bestCS, partitioner, currTestMode, false);
       }
     }
+        else{
+          xCheckRDCostIntra(tempCS, bestCS, partitioner, currTestMode, false);
+        }
+      }
+    }
     else if (currTestMode.type == ETM_PALETTE)
     {
+      if(param_partition->is_readPartition()) {
+        if (load_partition->getM_cur_tree()->getM_leaves() == nullptr) {
       xCheckPLT( tempCS, bestCS, partitioner, currTestMode );
     }
+      }
+      else {
+        xCheckPLT(tempCS, bestCS, partitioner, currTestMode);
+      }
+    }
     else if (currTestMode.type == ETM_IBC)
     {
+      if(param_partition->is_readPartition()) {
+        if (load_partition->getM_cur_tree()->getM_leaves() == nullptr) {
       xCheckRDCostIBCMode(tempCS, bestCS, partitioner, currTestMode);
     }
+      }
+      else{
+        xCheckRDCostIBCMode(tempCS, bestCS, partitioner, currTestMode);
+      }
+    }
     else if (currTestMode.type == ETM_IBC_MERGE)
     {
+      if(param_partition->is_readPartition()){
+        if(load_partition->getM_cur_tree()->getM_leaves() == nullptr){
+          xCheckRDCostIBCModeMerge2Nx2N(tempCS, bestCS, partitioner, currTestMode);
+        }
+      }
+      else{
       xCheckRDCostIBCModeMerge2Nx2N(tempCS, bestCS, partitioner, currTestMode);
     }
+    }
     else if( isModeSplit( currTestMode ) )
     {
+      if(isTestMode && splitDecisionCNN){
       if (bestCS->cus.size() != 0)
       {
         splitmode = bestCS->cus[0]->splitSeries;
@@ -832,17 +1133,17 @@
         //change cons modes
         if( signalModeConsVal == LDT_MODE_TYPE_SIGNAL )
         {
-          CHECK( numRoundRdo != 2, "numRoundRdo shall be 2 - [LDT_MODE_TYPE_SIGNAL]" );
+            CHECK_VTM( numRoundRdo != 2, "numRoundRdo shall be 2 - [LDT_MODE_TYPE_SIGNAL]" );
           tempCS->modeType = partitioner.modeType = (i == 0) ? MODE_TYPE_INTER : MODE_TYPE_INTRA;
         }
         else if( signalModeConsVal == LDT_MODE_TYPE_INFER )
         {
-          CHECK( numRoundRdo != 1, "numRoundRdo shall be 1 - [LDT_MODE_TYPE_INFER]" );
+            CHECK_VTM( numRoundRdo != 1, "numRoundRdo shall be 1 - [LDT_MODE_TYPE_INFER]" );
           tempCS->modeType = partitioner.modeType = MODE_TYPE_INTRA;
         }
         else if( signalModeConsVal == LDT_MODE_TYPE_INHERIT )
         {
-          CHECK( numRoundRdo != 1, "numRoundRdo shall be 1 - [LDT_MODE_TYPE_INHERIT]" );
+            CHECK_VTM( numRoundRdo != 1, "numRoundRdo shall be 1 - [LDT_MODE_TYPE_INHERIT]" );
           tempCS->modeType = partitioner.modeType = modeTypeParent;
         }
 
@@ -861,7 +1162,8 @@
           }
         }
 
-        xCheckModeSplit( tempCS, bestCS, partitioner, currTestMode, modeTypeParent, skipInterPass );
+          xCheckModeSplit( tempCS, bestCS, partitioner, currTestMode, modeTypeParent, skipInterPass, &qtTree, &bthTree,
+                           &btvTree, &tthTree, &ttvTree, mvUni, pocRef, pred_vector_luma );
         //recover cons modes
         tempCS->modeType = partitioner.modeType = modeTypeParent;
         tempCS->treeType = partitioner.treeType = treeTypeParent;
@@ -892,12 +1194,55 @@
         }
       }
     }
+    }
     else
     {
       THROW( "Don't know how to handle mode: type = " << currTestMode.type << ", options = " << currTestMode.opts );
     }
+    previous_mode = currTestMode.type;
   } while( m_modeCtrl->nextMode( *tempCS, partitioner ) );
 
+  /*if(tempCS->picture->getPOC()!=0 && firstPassInter){
+    std::cout<<tempCS->area.blocks[0].width<<"x"<<tempCS->area.blocks[0].height<<" / "<<tempCS->area.blocks[0].x<<"x"<<tempCS->area.blocks[0].y<<std::endl;
+  }*/
+
+  if (param_partition->is_writePartition() && !tree->get_chroma_stop()) {
+    double bestCost = bestCS->cost;
+    double qtCost = qtTree.get_rd_cost();
+    double bthCost = bthTree.get_rd_cost();
+    double btvCost = btvTree.get_rd_cost();
+    double tthCost = tthTree.get_rd_cost();
+    double ttvCost = ttvTree.get_rd_cost();
+
+    bestCost = (qtCost < bestCost) ? qtCost : bestCost;
+    bestCost = (bthCost < bestCost) ? bthCost : bestCost;
+    bestCost = (btvCost < bestCost) ? btvCost : bestCost;
+    bestCost = (tthCost < bestCost) ? tthCost : bestCost;
+    bestCost = (ttvCost < bestCost) ? ttvCost : bestCost;
+
+    // Second conditions means "there was a split"
+    if (bestCost == bthCost && bthCost != curRdCost) {
+      PartitionTree::transfer_leaves(&bthTree, tree);
+    } else if (bestCost == btvCost && btvCost != curRdCost) {
+      PartitionTree::transfer_leaves(&btvTree, tree);
+    } else if (bestCost == tthCost && tthCost != curRdCost) {
+      PartitionTree::transfer_leaves(&tthTree, tree);
+    } else if (bestCost == ttvCost && ttvCost != curRdCost) {
+      PartitionTree::transfer_leaves(&ttvTree, tree);
+    } else if (bestCost == qtCost && qtCost != curRdCost) {
+      PartitionTree::transfer_leaves(&qtTree, tree);
+    }
+    /*if(bestCS->picture[0].lwidth() < bestCS->area[0].x + bestCS->area[0].width || bestCS->picture[0].lheight() < bestCS->area[0].y + bestCS->area[0].height || costActualBlock==MAX_DOUBLE){
+      costActualBlock = bestCost;
+    }*/
+    //tree->set_rd_cost_without_split(costActualBlock);
+    tree->set_rd_cost(bestCost);
+  }
+
+  if(splitDecision!= nullptr){
+    delete [] splitDecision;
+  }
+
 
   //////////////////////////////////////////////////////////////////////////
   // Finishing CU
@@ -928,7 +1273,7 @@
   int numCUInThisNode = (int)bestCS->cus.size();
   if( numCUInThisNode > 1 && bestCS->cus.back()->chType == CHANNEL_TYPE_CHROMA && !CS::isDualITree( *bestCS ) )
   {
-    CHECK( bestCS->cus[numCUInThisNode-2]->chType != CHANNEL_TYPE_LUMA, "wrong chType" );
+    CHECK_VTM( bestCS->cus[numCUInThisNode-2]->chType != CHANNEL_TYPE_LUMA, "wrong chType" );
     bestCS->prevQP[partitioner.chType] = bestCS->cus[numCUInThisNode-2]->qp;
   }
   else
@@ -963,7 +1308,7 @@
 #endif
   if (bestCS->cus.size() == 1) // no partition
   {
-    CHECK(bestCS->cus[0]->tileIdx != bestCS->pps->getTileIdx(bestCS->area.lumaPos()), "Wrong tile index!");
+    CHECK_VTM(bestCS->cus[0]->tileIdx != bestCS->pps->getTileIdx(bestCS->area.lumaPos()), "Wrong tile index!");
     if (bestCS->cus[0]->predMode == MODE_PLT)
     {
       for (int i = compBegin; i < (compBegin + numComp); i++)
@@ -997,9 +1342,9 @@
   cu.cs->prevPLT = bestCS->prevPLT;
   // Assert if Best prediction mode is NONE
   // Selected mode's RD-cost must be not MAX_DOUBLE.
-  CHECK( bestCS->cus.empty()                                   , "No possible encoding found" );
-  CHECK( bestCS->cus[0]->predMode == NUMBER_OF_PREDICTION_MODES, "No possible encoding found" );
-  CHECK( bestCS->cost             == MAX_DOUBLE                , "No possible encoding found" );
+  CHECK_VTM( bestCS->cus.empty()                                   , "No possible encoding found" );
+  CHECK_VTM( bestCS->cus[0]->predMode == NUMBER_OF_PREDICTION_MODES, "No possible encoding found" );
+  CHECK_VTM( bestCS->cost             == MAX_DOUBLE                , "No possible encoding found" );
 }
 
 #if SHARP_LUMA_DELTA_QP || ENABLE_QPA_SUB_CTU
@@ -1207,7 +1552,7 @@
 }
 #endif
 
-void EncCu::xCheckModeSplit(CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &partitioner, const EncTestMode& encTestMode, const ModeType modeTypeParent, bool &skipInterPass )
+void EncCu::xCheckModeSplit(CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &partitioner, const EncTestMode& encTestMode, const ModeType modeTypeParent, bool &skipInterPass, PartitionTree *qtTree, PartitionTree *bthTree, PartitionTree *btvTree, PartitionTree *tthTree, PartitionTree *ttvTree, Mv* mvUni, int * pocRef, vector<float> * pred_vector_luma)
 {
   const int qp                = encTestMode.qp;
   const Slice &slice          = *tempCS->slice;
@@ -1222,7 +1567,7 @@
   const PartSplit split = getPartSplit( encTestMode );
   const ModeType modeTypeChild = partitioner.modeType;
 
-  CHECK( split == CU_DONT_SPLIT, "No proper split provided!" );
+  CHECK_VTM( split == CU_DONT_SPLIT, "No proper split provided!" );
 
   tempCS->initStructData( qp );
 
@@ -1241,7 +1586,7 @@
   const double factor = ( tempCS->currQP[partitioner.chType] > 30 ? 1.1 : 1.075 );
   tempCS->useDbCost = m_pcEncCfg->getUseEncDbOpt();
   if (!tempCS->useDbCost)
-    CHECK(bestCS->costDbOffset != 0, "error");
+    CHECK_VTM(bestCS->costDbOffset != 0, "error");
   const double cost   = m_pcRdCost->calcRdCost( uint64_t( m_CABACEstimator->getEstFracBits() + ( ( bestCS->fracBits ) / factor ) ), Distortion( bestCS->dist / factor ) ) + bestCS->costDbOffset / factor;
 
   m_CABACEstimator->getCtx() = SubCtx( Ctx::SplitFlag,   ctxStartSP );
@@ -1269,7 +1614,7 @@
   {
     if( chromaNotSplit )
     {
-      CHECK( partitioner.chType != CHANNEL_TYPE_LUMA, "chType must be luma" );
+      CHECK_VTM( partitioner.chType != CHANNEL_TYPE_LUMA, "chType must be luma" );
       tempCS->treeType = partitioner.treeType = TREE_L;
     }
     else
@@ -1280,6 +1625,26 @@
 
 
   partitioner.splitCurrArea( split, *tempCS );
+
+  //altissie added => choose the right tree
+  PartitionTree *tmpTree = nullptr;
+  if (split == CU_QUAD_SPLIT) {
+    qtTree->qt_split();
+    tmpTree = qtTree;
+  } else if (split == CU_HORZ_SPLIT) {
+    bthTree->bth_split();
+    tmpTree = bthTree;
+  } else if (split == CU_VERT_SPLIT) {
+    btvTree->btv_split();
+    tmpTree = btvTree;
+  } else if (split == CU_TRIH_SPLIT) {
+    tthTree->tth_split();
+    tmpTree = tthTree;
+  } else if (split == CU_TRIV_SPLIT) {
+    ttvTree->ttv_split();
+    tmpTree = ttvTree;
+  }
+
   bool qgEnableChildren = partitioner.currQgEnable(); // QG possible at children level
 
   m_CurrCtx++;
@@ -1314,12 +1679,23 @@
       tempSubCS->bestParent = bestSubCS->bestParent = bestCS;
       double newMaxCostAllowed = isLuma(partitioner.chType) ? std::min(encTestMode.maxCostAllowed, bestCS->cost - m_pcRdCost->calcRdCost(tempCS->fracBits, tempCS->dist)) : MAX_DOUBLE;
       newMaxCostAllowed = std::max(0.0, newMaxCostAllowed);
-      xCompressCU(tempSubCS, bestSubCS, partitioner, newMaxCostAllowed);
+
+      //Set current tree to the leaves we are currently exploring
+      if(param_partition->is_readPartition()){
+        load_partition->setM_cur_tree(load_partition->getM_cur_tree()->getM_leaves((partitioner.getPartStack().end() - 1)->idx));
+      }
+
+      xCompressCU(tempSubCS, bestSubCS, partitioner, tmpTree->getM_leaves((partitioner.getPartStack().end() - 1)->idx), mvUni, pocRef, newMaxCostAllowed, pred_vector_luma);
+
+      if(param_partition->is_readPartition()){
+        load_partition->setM_cur_tree(load_partition->getM_cur_tree()->getM_root());
+      }
+
       tempSubCS->bestParent = bestSubCS->bestParent = nullptr;
 
       if( bestSubCS->cost == MAX_DOUBLE )
       {
-        CHECK( split == CU_QUAD_SPLIT, "Split decision reusing cannot skip quad split" );
+        CHECK_VTM( split == CU_QUAD_SPLIT, "Split decision reusing cannot skip quad split" );
         tempCS->cost = MAX_DOUBLE;
         tempCS->costDbOffset = 0;
         tempCS->useDbCost = m_pcEncCfg->getUseEncDbOpt();
@@ -1344,14 +1720,14 @@
       {
         for( int i = 0; i < bestSubCS->cus.size(); i++ )
         {
-          CHECK( bestSubCS->cus[i]->predMode != MODE_INTER, "all CUs must be inter mode in an Inter coding region (SCIPU)" );
+          CHECK_VTM( bestSubCS->cus[i]->predMode != MODE_INTER, "all CUs must be inter mode in an Inter coding region (SCIPU)" );
         }
       }
       else if( partitioner.isConsIntra() )
       {
         for( int i = 0; i < bestSubCS->cus.size(); i++ )
         {
-          CHECK( bestSubCS->cus[i]->predMode == MODE_INTER, "all CUs must not be inter mode in an Intra coding region (SCIPU)" );
+          CHECK_VTM( bestSubCS->cus[i]->predMode == MODE_INTER, "all CUs must not be inter mode in an Intra coding region (SCIPU)" );
         }
       }
 
@@ -1397,7 +1773,7 @@
         int numParentNodeToQgCS = 0;
         while( qgCS->area.lumaPos() != partitioner.currQgPos )
         {
-          CHECK( qgCS->parent == nullptr, "parent of qgCS shall exsit" );
+          CHECK_VTM( qgCS->parent == nullptr, "parent of qgCS shall exsit" );
           qgCS = qgCS->parent;
           numParentNodeToQgCS++;
         }
@@ -1407,7 +1783,7 @@
         for( int i = 0; i < numParentNodeToQgCS; i++ )
         {
           //checking each parent
-          CHECK( parentCS == nullptr, "parentCS shall exsit" );
+          CHECK_VTM( parentCS == nullptr, "parentCS shall exsit" );
           for( const auto &cu : parentCS->cus )
           {
             if( cu->rootCbf && !isChroma( cu->chType ) )
@@ -1425,7 +1801,7 @@
       {
         //get pred QP of the QG
         const CodingUnit* cuFirst = qgCS->getCU( CHANNEL_TYPE_LUMA );
-        CHECK( cuFirst->lumaPos() != partitioner.currQgPos, "First cu of the Qg is wrong" );
+        CHECK_VTM( cuFirst->lumaPos() != partitioner.currQgPos, "First cu of the Qg is wrong" );
         int predQp = CU::predictQP( *cuFirst, qgCS->prevQP[CHANNEL_TYPE_LUMA] );
 
         //revise to predQP
@@ -1464,12 +1840,27 @@
     tempCS->initSubStructure( *tempCSChroma, partitioner.chType, partitioner.currArea(), false );
     tempCS->initSubStructure( *bestCSChroma, partitioner.chType, partitioner.currArea(), false );
     tempCS->treeType = TREE_D;
-    xCompressCU( tempCSChroma, bestCSChroma, partitioner );
+
+    //Set current tree to the leaves we are currently exploring
+    /*if(param_partition->is_readPartition() && ){
+      load_partition->setM_cur_tree(load_partition->getM_cur_tree()->getM_leaves((partitioner.getPartStack().end() - 1)->idx));
+    }*/
+
+    PartitionTree treeChroma(param_partition->ctuSize, param_partition->ctuSize, nullptr, nullptr, param_partition, false, false, MAX_DOUBLE);
+    treeChroma.set_chroma_stop(true);
+
+    xCompressCU( tempCSChroma, bestCSChroma, partitioner, &treeChroma);
+
+
+
+    /*if(param_partition->is_readPartition()){
+      load_partition->setM_cur_tree(load_partition->getM_cur_tree()->getM_root());
+    }*/
 
     //attach chromaCS to luma CS and update cost
     bool keepResi = KEEP_PRED_AND_RESI_SIGNALS;
     //bestCSChroma->treeType = tempCSChroma->treeType = TREE_C;
-    CHECK( bestCSChroma->treeType != TREE_C || tempCSChroma->treeType != TREE_C, "wrong treeType for chroma CS" );
+    CHECK_VTM( bestCSChroma->treeType != TREE_C || tempCSChroma->treeType != TREE_C, "wrong treeType for chroma CS" );
     tempCS->useSubStructure( *bestCSChroma, partitioner.chType, CS::getArea( *bestCSChroma, partitioner.currArea(), partitioner.chType ), KEEP_PRED_AND_RESI_SIGNALS, true, keepResi, true, true );
 
     //release tmp resource
@@ -1554,6 +1945,23 @@
     }
   }
 
+  // -----------------------------------------altissie added-----------------------------------------
+
+  if (split == CU_QUAD_SPLIT) {
+    qtTree->set_rd_cost(tempCS->cost);
+  } else if (split == CU_HORZ_SPLIT) {
+    bthTree->set_rd_cost(tempCS->cost);
+  } else if (split == CU_VERT_SPLIT) {
+    btvTree->set_rd_cost(tempCS->cost);
+  } else if (split == CU_TRIH_SPLIT) {
+    tthTree->set_rd_cost(tempCS->cost);
+  } else if (split == CU_TRIV_SPLIT) {
+    ttvTree->set_rd_cost(tempCS->cost);
+  }
+  tmpTree->set_rd_cost(tempCS->cost);
+
+  // --------------------------------------------end add---------------------------------------------
+
   // RD check for sub partitioned coding structure.
   xCheckBestMode( tempCS, bestCS, partitioner, encTestMode );
 
@@ -1620,9 +2028,9 @@
   bool foundZeroRootCbf = false;
   if (sps.getUseColorTrans())
   {
-    CHECK(tempCS->treeType != TREE_D || partitioner.treeType != TREE_D, "localtree should not be applied when adaptive color transform is enabled");
-    CHECK(tempCS->modeType != MODE_TYPE_ALL || partitioner.modeType != MODE_TYPE_ALL, "localtree should not be applied when adaptive color transform is enabled");
-    CHECK(adaptiveColorTrans && (CS::isDualITree(*tempCS) || partitioner.chType != CHANNEL_TYPE_LUMA), "adaptive color transform cannot be applied to dual-tree");
+    CHECK_VTM(tempCS->treeType != TREE_D || partitioner.treeType != TREE_D, "localtree should not be applied when adaptive color transform is enabled");
+    CHECK_VTM(tempCS->modeType != MODE_TYPE_ALL || partitioner.modeType != MODE_TYPE_ALL, "localtree should not be applied when adaptive color transform is enabled");
+    CHECK_VTM(adaptiveColorTrans && (CS::isDualITree(*tempCS) || partitioner.chType != CHANNEL_TYPE_LUMA), "adaptive color transform cannot be applied to dual-tree");
   }
 
   for( int trGrpIdx = 0; trGrpIdx < grpNumMax; trGrpIdx++ )
@@ -1810,7 +2218,7 @@
 
           if (isLuma(partitioner.chType) && cu.firstTU->mtsIdx[COMPONENT_Y] > MTS_SKIP)
           {
-            CHECK(!cuCtx.mtsLastScanPos, "MTS is disallowed to only contain DC coefficient");
+            CHECK_VTM(!cuCtx.mtsLastScanPos, "MTS is disallowed to only contain DC coefficient");
           }
 
           if( mtsFlag == 0 && lfnstIdx == 0 )
@@ -2043,8 +2451,8 @@
 
 void EncCu::xCheckDQP( CodingStructure& cs, Partitioner& partitioner, bool bKeepCtx )
 {
-  CHECK( bKeepCtx && cs.cus.size() <= 1 && partitioner.getImplicitSplit( cs ) == CU_DONT_SPLIT, "bKeepCtx should only be set in split case" );
-  CHECK( !bKeepCtx && cs.cus.size() > 1, "bKeepCtx should never be set for non-split case" );
+  CHECK_VTM( bKeepCtx && cs.cus.size() <= 1 && partitioner.getImplicitSplit( cs ) == CU_DONT_SPLIT, "bKeepCtx should only be set in split case" );
+  CHECK_VTM( !bKeepCtx && cs.cus.size() > 1, "bKeepCtx should never be set for non-split case" );
 
   if( !cs.pps->getUseDQP() )
   {
@@ -2064,7 +2472,7 @@
 
   CodingUnit* cuFirst = cs.getCU( partitioner.chType );
 
-  CHECK( !cuFirst, "No CU available" );
+  CHECK_VTM( !cuFirst, "No CU available" );
 
   bool hasResidual = false;
   for( const auto &cu : cs.cus )
@@ -2245,7 +2653,7 @@
 {
   const Slice &slice = *tempCS->slice;
 
-  CHECK( slice.getSliceType() == I_SLICE, "Merge modes not available for I-slices" );
+  CHECK_VTM( slice.getSliceType() == I_SLICE, "Merge modes not available for I-slices" );
 
   tempCS->initStructData( encTestMode.qp );
 
@@ -2457,7 +2865,7 @@
             swap(singleMergeTempBuffer, acMergeTempBuffer[insertPos]);
           }
         }
-        CHECK(std::min(uiMergeCand + 1, uiNumMrgSATDCand) != RdModeList.size(), "");
+        CHECK_VTM(std::min(uiMergeCand + 1, uiNumMrgSATDCand) != RdModeList.size(), "");
       }
 
       if (isIntrainterEnabled)
@@ -2541,7 +2949,7 @@
           pu.mvRefine = true;
           distParam.cur = singleMergeTempBuffer->Y();
           pu.mmvdEncOptMode = (refineStep > 2 ? 2 : 1);
-          CHECK(!pu.mmvdMergeFlag, "MMVD merge should be set");
+          CHECK_VTM(!pu.mmvdMergeFlag, "MMVD merge should be set");
           // Don't do chroma MC here
           m_pcInterSearch->motionCompensation(pu, *singleMergeTempBuffer, REF_PIC_LIST_X, true, false);
           pu.mmvdEncOptMode = 0;
@@ -2661,7 +3069,7 @@
         pu.ciipFlag = true;
         pu.regularMergeFlag = false;
         pu.intraDir[0] = PLANAR_IDX;
-        CHECK(pu.intraDir[0]<0 || pu.intraDir[0]>(NUM_LUMA_MODE - 1), "out of intra mode");
+        CHECK_VTM(pu.intraDir[0]<0 || pu.intraDir[0]>(NUM_LUMA_MODE - 1), "out of intra mode");
         pu.intraDir[1] = DM_CHROMA_IDX;
       }
       else if (RdModeList[uiMrgHADIdx].isMMVD)
@@ -2761,7 +3169,7 @@
       }
       if (!cu.mmvdSkip && !pu.ciipFlag && uiNoResidualPass != 0)
       {
-        CHECK(uiMergeCand >= mergeCtx.numValidMergeCand, "out of normal merge");
+        CHECK_VTM(uiMergeCand >= mergeCtx.numValidMergeCand, "out of normal merge");
         isTestSkipMerge[uiMergeCand] = true;
       }
 
@@ -2814,7 +3222,7 @@
 void EncCu::xCheckRDCostMergeGeo2Nx2N(CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestMode)
 {
   const Slice &slice = *tempCS->slice;
-  CHECK(slice.getSliceType() == I_SLICE, "Merge modes not available for I-slices");
+  CHECK_VTM(slice.getSliceType() == I_SLICE, "Merge modes not available for I-slices");
 
   tempCS->initStructData(encTestMode.qp);
 
@@ -3104,7 +3512,7 @@
   m_bestModeUpdated = tempCS->useDbCost = bestCS->useDbCost = false;
   const Slice &slice = *tempCS->slice;
 
-  CHECK( slice.getSliceType() == I_SLICE, "Affine Merge modes not available for I-slices" );
+  CHECK_VTM( slice.getSliceType() == I_SLICE, "Affine Merge modes not available for I-slices" );
 
   tempCS->initStructData( encTestMode.qp );
 
@@ -3242,7 +3650,7 @@
         updateCandList( uiMergeCand, cost, RdModeList, candCostList
           , uiNumMrgSATDCand );
 
-        CHECK( std::min( uiMergeCand + 1, uiNumMrgSATDCand ) != RdModeList.size(), "" );
+        CHECK_VTM( std::min( uiMergeCand + 1, uiNumMrgSATDCand ) != RdModeList.size(), "" );
       }
 
       // Try to limit number of candidates using SATD-costs
@@ -3705,7 +4113,7 @@
   // check ibc mode in encoder RD
   //////////////////////////////////////////////////////////////////////////////////////////////
 
-void EncCu::xCheckRDCostInter( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &partitioner, const EncTestMode& encTestMode )
+void EncCu::xCheckRDCostInter( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &partitioner, const EncTestMode& encTestMode, Mv* mvUni, int * pocRef, unsigned long * costRef, RefPicList * refPicList, int* pocRefIdx )
 {
   tempCS->initStructData( encTestMode.qp );
 
@@ -3774,7 +4182,7 @@
   uint8_t bcwIdx = cu.BcwIdx;
   bool  testBcw = (bcwIdx != BCW_DEFAULT);
 
-  m_pcInterSearch->predInterSearch( cu, partitioner );
+  m_pcInterSearch->predInterSearch( cu, partitioner, mvUni, pocRef, costRef, refPicList, pocRefIdx );
 
   bcwIdx = CU::getValidBcwIdx(cu);
   if( testBcw && bcwIdx == BCW_DEFAULT ) // Enabled Bcw but the search results is uni.
@@ -3782,7 +4190,7 @@
     tempCS->initStructData(encTestMode.qp);
     continue;
   }
-  CHECK(!(testBcw || (!testBcw && bcwIdx == BCW_DEFAULT)), " !( bTestBcw || (!bTestBcw && bcwIdx == BCW_DEFAULT ) )");
+  CHECK_VTM(!(testBcw || (!testBcw && bcwIdx == BCW_DEFAULT)), " !( bTestBcw || (!bTestBcw && bcwIdx == BCW_DEFAULT ) )");
 
   bool isEqualUni = false;
   if( m_pcEncCfg->getUseBcwFast() )
@@ -3836,7 +4244,7 @@
   int iIMV = int( ( encTestMode.opts & ETO_IMV ) >> ETO_IMV_SHIFT );
   m_pcInterSearch->setAffineModeSelected(false);
   // Only Half-Pel, int-Pel, 4-Pel and fast 4-Pel allowed
-  CHECK(iIMV < 1 || iIMV > 4, "Unsupported IMV Mode");
+  CHECK_VTM(iIMV < 1 || iIMV > 4, "Unsupported IMV Mode");
   const bool testAltHpelFilter = iIMV == 4;
   // Fast 4-Pel Mode
 
@@ -3948,7 +4356,7 @@
     tempCS->initStructData(encTestMode.qp);
     continue;
   }
-  CHECK(!(testBcw || (!testBcw && bcwIdx == BCW_DEFAULT)), " !( bTestBcw || (!bTestBcw && bcwIdx == BCW_DEFAULT ) )");
+  CHECK_VTM(!(testBcw || (!testBcw && bcwIdx == BCW_DEFAULT)), " !( bTestBcw || (!bTestBcw && bcwIdx == BCW_DEFAULT ) )");
 
   bool isEqualUni = false;
   if( m_pcEncCfg->getUseBcwFast() )
@@ -4591,7 +4999,7 @@
     }
     else
     {
-      CHECK( equBcwCost == NULL, "equBcwCost == NULL" );
+      CHECK_VTM( equBcwCost == NULL, "equBcwCost == NULL" );
     }
     if( tempCS->slice->getCheckLDC() && !cu->imv && cu->BcwIdx != BCW_DEFAULT && tempCS->cost < m_bestBcwCost[1] )
     {
@@ -4618,7 +5026,7 @@
 
   m_CABACEstimator->split_cu_mode( CU_DONT_SPLIT, cs, partitioner );
   if( partitioner.treeType == TREE_C )
-    CHECK( m_CABACEstimator->getEstFracBits() != 0, "must be 0 bit" );
+    CHECK_VTM( m_CABACEstimator->getEstFracBits() != 0, "must be 0 bit" );
 
   cs.fracBits += m_CABACEstimator->getEstFracBits(); // split bits
   cs.cost      = m_pcRdCost->calcRdCost( cs.fracBits, cs.dist );
@@ -4630,7 +5038,7 @@
 {
   m_pcRdCost->setChromaFormat(tempCS->sps->getChromaFormatIdc());
   BestEncInfoCache* bestEncCache = dynamic_cast<BestEncInfoCache*>( m_modeCtrl );
-  CHECK( !bestEncCache, "If this mode is chosen, mode controller has to implement the mode caching capabilities" );
+  CHECK_VTM( !bestEncCache, "If this mode is chosen, mode controller has to implement the mode caching capabilities" );
   EncTestMode cachedMode;
 
   if( bestEncCache->setCsFrom( *tempCS, cachedMode, partitioner ) )
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncCu.h ../VVCSoftware_10/source/Lib/EncoderLib/EncCu.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncCu.h	2022-09-16 14:27:06.148532600 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/EncCu.h	2022-05-13 17:45:29.592141090 +0200
@@ -55,6 +55,7 @@
 #include "InterSearch.h"
 #include "RateCtrl.h"
 #include "EncModeCtrl.h"
+#include "PartitionTree.h"
 //! \ingroup EncoderLib
 //! \{
 
@@ -225,7 +226,7 @@
   void  destroy             ();
 
   /// CTU analysis function
-  void  compressCtu         ( CodingStructure& cs, const UnitArea& area, const unsigned ctuRsAddr, const int prevQP[], const int currQP[] );
+  void  compressCtu         ( CodingStructure& cs, const UnitArea& area, const unsigned ctuRsAddr, const int prevQP[], const int currQP[], PartitionTree *luma_tree, PartitionTree *chroma_tree );
   /// CTU encoding function
   int   updateCtuDataISlice ( const CPelBuf buf );
 
@@ -247,7 +248,7 @@
   void xCalDebCost            ( CodingStructure &cs, Partitioner &partitioner, bool calDist = false );
   Distortion getDistortionDb  ( CodingStructure &cs, CPelBuf org, CPelBuf reco, ComponentID compID, const CompArea& compArea, bool afterDb );
 
-  void xCompressCU            ( CodingStructure*& tempCS, CodingStructure*& bestCS, Partitioner& pm, double maxCostAllowed = MAX_DOUBLE );
+  void xCompressCU            ( CodingStructure*& tempCS, CodingStructure*& bestCS, Partitioner& pm, PartitionTree *tree, Mv* mvUni = nullptr, int * pocRef = nullptr, double maxCostAllowed = MAX_DOUBLE, vector<float> *pred_vector_luma = nullptr);
 #if ENABLE_SPLIT_PARALLELISM
   void xCompressCUParallel    ( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm );
   void copyState              ( EncCu* other, Partitioner& pm, const UnitArea& currArea, const bool isDist );
@@ -256,7 +257,7 @@
   bool
     xCheckBestMode         ( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestmode );
 
-  void xCheckModeSplit        ( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestMode, const ModeType modeTypeParent, bool &skipInterPass );
+  void xCheckModeSplit        ( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestMode, const ModeType modeTypeParent, bool &skipInterPass, PartitionTree *qtTree, PartitionTree *bthTree, PartitionTree *btvTree, PartitionTree *tthTree, PartitionTree *ttvTree, Mv* mvUni, int * pocRef, vector<float> * pred_vector_luma = nullptr );
 
   bool xCheckRDCostIntra(CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestMode, bool adaptiveColorTrans);
 
@@ -267,7 +268,7 @@
   void xCheckRDCostHashInter  ( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestMode );
   void xCheckRDCostAffineMerge2Nx2N
                               ( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &partitioner, const EncTestMode& encTestMode );
-  void xCheckRDCostInter      ( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestMode );
+  void xCheckRDCostInter      ( CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestMode, Mv* mvUni= nullptr, int * pocRef = nullptr, unsigned long * costRef = nullptr, RefPicList * refPicList = nullptr, int * pocRefIdx = nullptr);
   bool xCheckRDCostInterIMV(CodingStructure *&tempCS, CodingStructure *&bestCS, Partitioner &pm, const EncTestMode& encTestMode, double &bestIntPelCost);
   void xEncodeDontSplit       ( CodingStructure &cs, Partitioner &partitioner);
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncGOP.cpp ../VVCSoftware_10/source/Lib/EncoderLib/EncGOP.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncGOP.cpp	2022-09-16 14:27:06.156532509 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/EncGOP.cpp	2022-05-13 17:45:29.608140910 +0200
@@ -58,6 +58,7 @@
 #include "CommonLib/ProfileLevelTier.h"
 
 #include "DecoderLib/DecLib.h"
+#include "PartitionGlobalManager.h"
 
 #define ENCODE_SUB_SET 0
 
@@ -314,7 +315,7 @@
 {
   OutputNALUnit nalu(NAL_UNIT_VPS);
   m_HLSWriter->setBitstream( &nalu.m_Bitstream );
-  CHECK( nalu.m_temporalId, "The value of TemporalId of VPS NAL units shall be equal to 0" );
+  CHECK_VTM( nalu.m_temporalId, "The value of TemporalId of VPS NAL units shall be equal to 0" );
   m_HLSWriter->codeVPS( vps );
   accessUnit.push_back(new NALUnitEBSP(nalu));
   return (int)(accessUnit.back()->m_nalUnitData.str().size()) * 8;
@@ -323,7 +324,7 @@
 {
   OutputNALUnit nalu(NAL_UNIT_DCI);
   m_HLSWriter->setBitstream(&nalu.m_Bitstream);
-  CHECK(nalu.m_temporalId, "The value of TemporalId of DCI NAL units shall be equal to 0");
+  CHECK_VTM(nalu.m_temporalId, "The value of TemporalId of DCI NAL units shall be equal to 0");
   m_HLSWriter->codeDCI(dci);
   accessUnit.push_back(new NALUnitEBSP(nalu));
   return (int)(accessUnit.back()->m_nalUnitData.str().size()) * 8;
@@ -334,7 +335,7 @@
   OutputNALUnit nalu(NAL_UNIT_SPS);
   m_HLSWriter->setBitstream( &nalu.m_Bitstream );
   nalu.m_nuhLayerId = layerId;
-  CHECK( nalu.m_temporalId, "The value of TemporalId of SPS NAL units shall be equal to 0" );
+  CHECK_VTM( nalu.m_temporalId, "The value of TemporalId of SPS NAL units shall be equal to 0" );
   m_HLSWriter->codeSPS( sps );
   accessUnit.push_back(new NALUnitEBSP(nalu));
   return (int)(accessUnit.back()->m_nalUnitData.str().size()) * 8;
@@ -346,7 +347,7 @@
   OutputNALUnit nalu(NAL_UNIT_PPS);
   m_HLSWriter->setBitstream( &nalu.m_Bitstream );
   nalu.m_nuhLayerId = layerId;
-  CHECK( nalu.m_temporalId < accessUnit.temporalId, "TemporalId shall be greater than or equal to the TemporalId of the layer access unit containing the NAL unit" );
+  CHECK_VTM( nalu.m_temporalId < accessUnit.temporalId, "TemporalId shall be greater than or equal to the TemporalId of the layer access unit containing the NAL unit" );
   m_HLSWriter->codePPS( pps );
   accessUnit.push_back(new NALUnitEBSP(nalu));
   return (int)(accessUnit.back()->m_nalUnitData.str().size()) * 8;
@@ -359,7 +360,7 @@
   nalu.m_nuhLayerId = layerId;
   nalu.m_temporalId = aps->getTemporalId();
   aps->setLayerId( layerId );
-  CHECK( nalu.m_temporalId < accessUnit.temporalId, "TemporalId shall be greater than or equal to the TemporalId of the layer access unit containing the NAL unit" );
+  CHECK_VTM( nalu.m_temporalId < accessUnit.temporalId, "TemporalId shall be greater than or equal to the TemporalId of the layer access unit containing the NAL unit" );
   m_HLSWriter->codeAPS(aps);
   accessUnit.push_back(new NALUnitEBSP(nalu));
   return (int)(accessUnit.back()->m_nalUnitData.str().size()) * 8;
@@ -384,7 +385,7 @@
     }
     if( m_pcEncLib->SPSNeedsWriting( slice->getSPS()->getSPSId() ) ) // Note this assumes that all changes to the SPS are made at the EncLib level prior to picture creation (EncLib::xGetNewPicBuffer).
     {
-      CHECK( !( bSeqFirst ), "Unspecified error" ); // Implementations that use more than 1 SPS need to be aware of activation issues.
+      CHECK_VTM( !( bSeqFirst ), "Unspecified error" ); // Implementations that use more than 1 SPS need to be aware of activation issues.
       actualTotalBits += xWriteSPS( accessUnit, slice->getSPS(), m_pcEncLib->getLayerId() );
     }
   }
@@ -422,7 +423,7 @@
   {
     nalu.m_nuhLayerId = slice->getVPS()->getLayerId(0);
   }
-  CHECK( nalu.m_temporalId != accessUnit.temporalId, "TemporalId shall be equal to the TemporalId of the AU containing the NAL unit" );
+  CHECK_VTM( nalu.m_temporalId != accessUnit.temporalId, "TemporalId shall be equal to the TemporalId of the AU containing the NAL unit" );
   int picType = slice->isIntra() ? 0 : (slice->isInterP() ? 1 : 2);
   audWriter.codeAUD(nalu.m_Bitstream, m_audIrapOrGdrAuFlag, picType);
   accessUnit.push_front(new NALUnitEBSP(nalu));
@@ -442,7 +443,7 @@
   {
     nalu.m_nuhLayerId = slice->getVPS()->getLayerId(0);
   }
-  CHECK( nalu.m_temporalId != accessUnit.temporalId, "TemporalId shall be equal to the TemporalId of the AU containing the NAL unit" );
+  CHECK_VTM( nalu.m_temporalId != accessUnit.temporalId, "TemporalId shall be equal to the TemporalId of the AU containing the NAL unit" );
   fdWriter.codeFD(nalu.m_Bitstream, fdSize);
   accessUnit.push_back(new NALUnitEBSP(nalu));
 }
@@ -518,7 +519,7 @@
 
   // Buffering period SEI must always be following active parameter sets
   currentMessages = extractSeisByType(localMessages, SEI::BUFFERING_PERIOD);
-  CHECK(!(currentMessages.size() <= 1), "Unspecified error");
+  CHECK_VTM(!(currentMessages.size() <= 1), "Unspecified error");
   xWriteSEI(NAL_UNIT_PREFIX_SEI, currentMessages, accessUnit, itNalu, temporalId);
   xClearSEIs(currentMessages, !testWrite);
 
@@ -527,7 +528,7 @@
   //       to be placed into separate NAL units. The code below conforms to the constraint even if
   //       general_same_pic_timing_in_all_ols_flag is equal to 0
   currentMessages = extractSeisByType(localMessages, SEI::PICTURE_TIMING);
-  CHECK(!(currentMessages.size() <= 1), "Unspecified error");
+  CHECK_VTM(!(currentMessages.size() <= 1), "Unspecified error");
   xWriteSEI(NAL_UNIT_PREFIX_SEI, currentMessages, accessUnit, itNalu, temporalId);
   xClearSEIs(currentMessages, !testWrite);
 
@@ -567,7 +568,7 @@
 {
   AccessUnit testAU;
   SEIMessages picTimingSEIs = getSeisByType(seiMessages, SEI::PICTURE_TIMING);
-  CHECK(!(picTimingSEIs.size() < 2), "Unspecified error");
+  CHECK_VTM(!(picTimingSEIs.size() < 2), "Unspecified error");
   SEIPictureTiming * picTiming = picTimingSEIs.empty() ? NULL : (SEIPictureTiming*) picTimingSEIs.front();
 
   // test writing
@@ -611,7 +612,7 @@
       if (duSEI == duInfoSeiMessages.end())
       {
         // if the number of generated SEIs matches the number of DUs, this should not happen
-        CHECK(!(false), "Unspecified error");
+        CHECK_VTM(!(false), "Unspecified error");
         return;
       }
       // write the next SEI
@@ -837,7 +838,7 @@
     const uint32_t cpbRemovalDelayLegth = m_HRD->getBufferingPeriodSEI()->m_cpbRemovalDelayLength;
     const uint32_t maxNumSubLayers = slice->getSPS()->getMaxTLayers();
     pictureTimingSEI->m_auCpbRemovalDelay[maxNumSubLayers-1] = std::min<int>(std::max<int>(1, m_totalCoded[maxNumSubLayers-1] - m_lastBPSEI[maxNumSubLayers-1]), static_cast<int>(pow(2, static_cast<double>(cpbRemovalDelayLegth)))); // Syntax element signalled as minus, hence the .
-    CHECK( (m_totalCoded[maxNumSubLayers-1] - m_lastBPSEI[maxNumSubLayers-1]) > pow(2, static_cast<double>(cpbRemovalDelayLegth)), " cpbRemovalDelayLegth too small for m_auCpbRemovalDelay[pt_max_sub_layers_minus1] at picture timing SEI " );
+    CHECK_VTM( (m_totalCoded[maxNumSubLayers-1] - m_lastBPSEI[maxNumSubLayers-1]) > pow(2, static_cast<double>(cpbRemovalDelayLegth)), " cpbRemovalDelayLegth too small for m_auCpbRemovalDelay[pt_max_sub_layers_minus1] at picture timing SEI " );
     const uint32_t temporalId = slice->getTLayer();
     if (maxNumSubLayers == 1)
     {
@@ -1004,7 +1005,7 @@
       {
         int scaledDistToBuffPeriod = (m_totalCoded[i] - m_lastBPSEI[i]) * static_cast<int>(pow(2, static_cast<double>(maxNumSubLayers - 1 - i)));
         pictureTimingSEI->m_auCpbRemovalDelay[i] = std::min<int>(std::max<int>(1, scaledDistToBuffPeriod), static_cast<int>(pow(2, static_cast<double>(cpbRemovalDelayLegth)))); // Syntax element signalled as minus, hence the .
-        CHECK( (scaledDistToBuffPeriod) > pow(2, static_cast<double>(cpbRemovalDelayLegth)), " cpbRemovalDelayLegth too small for m_auCpbRemovalDelay[i] at picture timing SEI " );
+        CHECK_VTM( (scaledDistToBuffPeriod) > pow(2, static_cast<double>(cpbRemovalDelayLegth)), " cpbRemovalDelayLegth too small for m_auCpbRemovalDelay[i] at picture timing SEI " );
       }
     }
     pictureTimingSEI->m_picDpbOutputDelay = slice->getSPS()->getMaxNumReorderPics(slice->getSPS()->getMaxTLayers()-1) + slice->getPOC() - m_totalCoded[maxNumSubLayers-1];
@@ -2180,7 +2181,7 @@
       {
         int pocCycle = 1 << (pcSlice->getSPS()->getBitsForPOC());
         int deltaPOC = pocCurr > pcSlice->getAssociatedIRAPPOC() ? pocCurr - pcSlice->getAssociatedIRAPPOC() : pocCurr - ( pcSlice->getAssociatedIRAPPOC() & (pocCycle -1) );
-        CHECK(deltaPOC > (pocCycle >> 1), "Use a greater value for POC wraparound to enable a POC distance between IRAP and DRAP of " << deltaPOC << ".");
+        CHECK_VTM(deltaPOC > (pocCycle >> 1), "Use a greater value for POC wraparound to enable a POC distance between IRAP and DRAP of " << deltaPOC << ".");
         m_latestDRAPPOC = pocCurr;
         pcSlice->setTLayer(0); // Force DRAP picture to have temporal layer 0
       }
@@ -2323,7 +2324,7 @@
           m_bInitAMaxBT = false;
         }
 
-        if( refLayer >= 0 && m_uiNumBlk[refLayer] != 0 )
+        if( refLayer >= 0 && m_uiNumBlk[refLayer] != 0 && !param_partition->is_readPartition())
         {
           picHeader->setSplitConsOverrideFlag(true);
           double dBlkSize = sqrt( ( double ) m_uiBlkSize[refLayer] / m_uiNumBlk[refLayer] );
@@ -2490,7 +2491,7 @@
 
       for( int refIdx = 0; refIdx < pcSlice->getNumRefIdx( REF_PIC_LIST_0 ); refIdx++ )
       {
-        CHECK( pcSlice->getRefPic( REF_PIC_LIST_0, refIdx )->unscaledPic == nullptr, "unscaledPic is not set for L0 reference picture" );
+        CHECK_VTM( pcSlice->getRefPic( REF_PIC_LIST_0, refIdx )->unscaledPic == nullptr, "unscaledPic is not set for L0 reference picture" );
 
         if( pcSlice->getRefPic( REF_PIC_LIST_0, refIdx )->isRefScaled( pcSlice->getPPS() ) == false )
         {
@@ -2503,7 +2504,7 @@
       {
         for( int refIdx = 0; refIdx < pcSlice->getNumRefIdx( REF_PIC_LIST_1 ); refIdx++ )
         {
-          CHECK( pcSlice->getRefPic( REF_PIC_LIST_1, refIdx )->unscaledPic == nullptr, "unscaledPic is not set for L1 reference picture" );
+          CHECK_VTM( pcSlice->getRefPic( REF_PIC_LIST_1, refIdx )->unscaledPic == nullptr, "unscaledPic is not set for L1 reference picture" );
 
           if( pcSlice->getRefPic( REF_PIC_LIST_1, refIdx )->isRefScaled( pcSlice->getPPS() ) == false )
           {
@@ -2527,8 +2528,8 @@
           refPicL1 = refPicL1->unscaledPic;
         }
 
-        CHECK( !refPicL0->slices.size(), "Wrong L0 reference picture" );
-        CHECK( !refPicL1->slices.size(), "Wrong L1 reference picture" );
+        CHECK_VTM( !refPicL0->slices.size(), "Wrong L0 reference picture" );
+        CHECK_VTM( !refPicL1->slices.size(), "Wrong L1 reference picture" );
 
         const uint32_t uiColFromL0 = refPicL0->slices[0]->getSliceQp() > refPicL1->slices[0]->getSliceQp();
         picHeader->setPicColFromL0Flag( uiColFromL0 );
@@ -2796,7 +2797,7 @@
               break;
             }
           }
-          CHECK( subPicIdx == NOT_VALID, "Sub-picture was not found" );
+          CHECK_VTM( subPicIdx == NOT_VALID, "Sub-picture was not found" );
 
           pcSlice->setSliceSubPicId( pcPic->cs->pps->getSubPic( subPicIdx ).getSubPicID() );
         }
@@ -2857,7 +2858,7 @@
           m_pcSliceEncoder->setSliceSegmentIdx      (uiNumSliceSegments);
           // prepare for next slice
           pcSlice = pcPic->slices[uiNumSliceSegments];
-          CHECK(!(pcSlice->getPPS() != 0), "Unspecified error");
+          CHECK_VTM(!(pcSlice->getPPS() != 0), "Unspecified error");
           pcSlice->copySliceInfo(pcPic->slices[uiNumSliceSegments - 1]);
           pcSlice->setSliceBits(0);
           independentSliceIdx++;
@@ -2985,7 +2986,7 @@
           else
           {
             pcPic->slices[s]->setSaoEnabledFlag(CHANNEL_TYPE_LUMA, sliceEnabled[COMPONENT_Y]);
-            CHECK(!(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]), "Unspecified error");
+            CHECK_VTM(!(sliceEnabled[COMPONENT_Cb] == sliceEnabled[COMPONENT_Cr]), "Unspecified error");
             pcPic->slices[s]->setSaoEnabledFlag(CHANNEL_TYPE_CHROMA, sliceEnabled[COMPONENT_Cb]);
 
         }
@@ -3192,7 +3193,7 @@
       if (writePS)
       {
         // create prefix SEI messages at the beginning of the sequence
-        CHECK(!(leadingSeiMessages.empty()), "Unspecified error");
+        CHECK_VTM(!(leadingSeiMessages.empty()), "Unspecified error");
         xCreateIRAPLeadingSEIMessages(leadingSeiMessages, pcSlice->getSPS(), pcSlice->getPPS());
 
         m_bSeqFirst = false;
@@ -3213,7 +3214,7 @@
           aps->chromaPresentFlag = pcSlice->getSPS()->getChromaFormatIdc() != CHROMA_400;
           actualTotalBits += xWriteAPS( accessUnit, aps, m_pcEncLib->getLayerId(), true );
           apsMap->clearChangedFlag((apsId << NUM_APS_TYPE_LEN) + LMCS_APS);
-          CHECK(aps != picHeader->getLmcsAPS(), "Wrong LMCS APS pointer in compressGOP");
+          CHECK_VTM(aps != picHeader->getLmcsAPS(), "Wrong LMCS APS pointer in compressGOP");
         }
       }
 
@@ -3229,7 +3230,7 @@
           aps->chromaPresentFlag = pcSlice->getSPS()->getChromaFormatIdc() != CHROMA_400;
           actualTotalBits += xWriteAPS( accessUnit, aps, m_pcEncLib->getLayerId(), true );
           apsMap->clearChangedFlag( ( apsId << NUM_APS_TYPE_LEN ) + SCALING_LIST_APS );
-          CHECK( aps != picHeader->getScalingListAPS(), "Wrong SCALING LIST APS pointer in compressGOP" );
+          CHECK_VTM( aps != picHeader->getScalingListAPS(), "Wrong SCALING LIST APS pointer in compressGOP" );
         }
       }
 
@@ -3264,7 +3265,7 @@
             aps->chromaPresentFlag = pcSlice->getSPS()->getChromaFormatIdc() != CHROMA_400;
             actualTotalBits += xWriteAPS( accessUnit, aps, m_pcEncLib->getLayerId(), true );
             apsMap->clearChangedFlag((apsId << NUM_APS_TYPE_LEN) + ALF_APS);
-            CHECK(aps != pcSlice->getAlfAPSs()[apsId] && apsId != pcSlice->getTileGroupCcAlfCbApsId() && apsId != pcSlice->getTileGroupCcAlfCrApsId(), "Wrong APS pointer in compressGOP");
+            CHECK_VTM(aps != pcSlice->getAlfAPSs()[apsId] && apsId != pcSlice->getTileGroupCcAlfCbApsId() && apsId != pcSlice->getTileGroupCcAlfCrApsId(), "Wrong APS pointer in compressGOP");
           }
         }
       }
@@ -3385,7 +3386,7 @@
           }
           if (pcSlice->getSPS()->getProfileTierLevel()->getConstraintInfo()->getPicHeaderInSliceHeaderConstraintFlag())
           {
-            CHECK(pcSlice->getPictureHeaderInSliceHeader() == false, "PH shall be present in SH, when pic_header_in_slice_header_constraint_flag is equal to 1");
+            CHECK_VTM(pcSlice->getPictureHeaderInSliceHeader() == false, "PH shall be present in SH, when pic_header_in_slice_header_constraint_flag is equal to 1");
           }
         }
         pcSlice->setPicHeader( pcPic->cs->picHeader );
@@ -3633,7 +3634,7 @@
 
   delete pcBitstreamRedirect;
 
-  CHECK( m_iNumPicCoded > 1, "Unspecified error" );
+  CHECK_VTM( m_iNumPicCoded > 1, "Unspecified error" );
 }
 
 void EncGOP::printOutSummary( uint32_t uiNumAllPicCoded, bool isField, const bool printMSEBasedSNR, const bool printSequenceMSE, const bool printHexPsnr, const bool printRprPSNR, const BitDepths &bitDepths )
@@ -3647,7 +3648,7 @@
 
   if( m_pcCfg->getDecodeBitstream(0).empty() && m_pcCfg->getDecodeBitstream(1).empty() && !m_pcCfg->useFastForwardToPOC() )
   {
-    CHECK( !( uiNumAllPicCoded == m_gcAnalyzeAll.getNumPic() ), "Unspecified error" );
+    CHECK_VTM( !( uiNumAllPicCoded == m_gcAnalyzeAll.getNumPic() ), "Unspecified error" );
   }
 
   //--CFG_KDY
@@ -3761,7 +3762,7 @@
     const ComponentID compID = ComponentID(comp);
     const uint32_t rshift = 2 * DISTORTION_PRECISION_ADJUSTMENT(cs.sps->getBitDepth(toChannelType(compID)));
 #if ENABLE_QPA
-    CHECK( rshift >= 8, "shifts greater than 7 are not supported." );
+    CHECK_VTM( rshift >= 8, "shifts greater than 7 are not supported." );
 #endif
     uiDist += xFindDistortionPlane( picOrg.get(compID), picRec.get(compID), rshift );
   }
@@ -3776,7 +3777,7 @@
   , bool isEncodeLtRef
 )
 {
-  CHECK(!( iNumPicRcvd > 0 ), "Unspecified error");
+  CHECK_VTM(!( iNumPicRcvd > 0 ), "Unspecified error");
   //  Exception for the first frames
   if ((isField && (iPOCLast == 0 || iPOCLast == 1)) || (!isField && (iPOCLast == 0)) || isEncodeLtRef)
   {
@@ -3786,7 +3787,7 @@
   {
     m_iGopSize    = m_pcCfg->getGOPSize();
   }
-  CHECK(!(m_iGopSize > 0), "Unspecified error");
+  CHECK_VTM(!(m_iGopSize > 0), "Unspecified error");
 
   return;
 }
@@ -3827,8 +3828,8 @@
     iterPic++;
   }
 
-  CHECK(!(rpcPic != NULL), "Unspecified error");
-  CHECK(!(rpcPic->getPOC() == pocCurr), "Unspecified error");
+  CHECK_VTM(!(rpcPic != NULL), "Unspecified error");
+  CHECK_VTM(!(rpcPic->getPOC() == pocCurr), "Unspecified error");
 
   (**iterPicYuvRec) = rpcPic->getRecoBuf();
   return;
@@ -3909,8 +3910,8 @@
   const  Pel*  pSrc0 = pic0.bufAt(0, 0);
   const  Pel*  pSrc1 = pic1.bufAt(0, 0);
 
-  CHECK(pic0.width  != pic1.width , "Unspecified error");
-  CHECK(pic0.height != pic1.height, "Unspecified error");
+  CHECK_VTM(pic0.width  != pic1.width , "Unspecified error");
+  CHECK_VTM(pic0.height != pic1.height, "Unspecified error");
 
   if( rshift > 0 )
   {
@@ -4004,8 +4005,8 @@
   const  Pel*  pSrc0 = pic0.bufAt(0, 0);
   const  Pel*  pSrc1 = pic1.bufAt(0, 0);
   const  Pel*  pSrcLuma = picLuma0.bufAt(0, 0);
-  CHECK(pic0.width  != pic1.width , "Unspecified error");
-  CHECK(pic0.height != pic1.height, "Unspecified error");
+  CHECK_VTM(pic0.width  != pic1.width , "Unspecified error");
+  CHECK_VTM(pic0.height != pic1.height, "Unspecified error");
 
   if( rshift > 0 )
   {
@@ -4125,7 +4126,7 @@
 {
   const SPS&         sps = *pcPic->cs->sps;
   const CPelUnitBuf& pic = cPicD;
-  CHECK(!(conversion == IPCOLOURSPACE_UNCHANGED), "Unspecified error");
+  CHECK_VTM(!(conversion == IPCOLOURSPACE_UNCHANGED), "Unspecified error");
 //  const CPelUnitBuf& org = (conversion != IPCOLOURSPACE_UNCHANGED) ? pcPic->getPicYuvTrueOrg()->getBuf() : pcPic->getPicYuvOrg()->getBuf();
   const CPelUnitBuf& org = (sps.getUseLmcs() || m_pcCfg->getGopBasedTemporalFilterEnabled()) ? pcPic->getTrueOrigBuf() : pcPic->getOrigBuf();
 #if ENABLE_QPA
@@ -4197,8 +4198,8 @@
     const CPelBuf&    p = picC.get(compID);
     const CPelBuf&    o = org.get(compID);
 
-    CHECK(!( p.width  == o.width), "Unspecified error");
-    CHECK(!( p.height == o.height), "Unspecified error");
+    CHECK_VTM(!( p.width  == o.width), "Unspecified error");
+    CHECK_VTM(!( p.height == o.height), "Unspecified error");
 
     int padX = m_pcEncLib->getPad( 0 );
     int padY = m_pcEncLib->getPad( 1 );
@@ -4658,14 +4659,14 @@
   //===== calculate PSNR =====
   double MSEyuvframe[MAX_NUM_COMPONENT] = {0, 0, 0};
 
-  CHECK(!(acPicRecFields[0].chromaFormat==acPicRecFields[1].chromaFormat), "Unspecified error");
+  CHECK_VTM(!(acPicRecFields[0].chromaFormat==acPicRecFields[1].chromaFormat), "Unspecified error");
   const uint32_t numValidComponents = ::getNumberValidComponents( acPicRecFields[0].chromaFormat );
 
   for (int chan = 0; chan < numValidComponents; chan++)
   {
     const ComponentID ch=ComponentID(chan);
-    CHECK(!(acPicRecFields[0].get(ch).width==acPicRecFields[1].get(ch).width), "Unspecified error");
-    CHECK(!(acPicRecFields[0].get(ch).height==acPicRecFields[0].get(ch).height), "Unspecified error");
+    CHECK_VTM(!(acPicRecFields[0].get(ch).width==acPicRecFields[1].get(ch).width), "Unspecified error");
+    CHECK_VTM(!(acPicRecFields[0].get(ch).height==acPicRecFields[0].get(ch).height), "Unspecified error");
 
     uint64_t uiSSDtemp=0;
     const uint32_t width    = acPicRecFields[0].get(ch).width - (m_pcEncLib->getPad(0) >> ::getComponentScaleX(ch, format));
@@ -4674,7 +4675,7 @@
 
     for(uint32_t fieldNum=0; fieldNum<2; fieldNum++)
     {
-      CHECK(!(conversion == IPCOLOURSPACE_UNCHANGED), "Unspecified error");
+      CHECK_VTM(!(conversion == IPCOLOURSPACE_UNCHANGED), "Unspecified error");
 #if ENABLE_QPA
       uiSSDtemp += xFindDistortionPlane( acPicRecFields[fieldNum].get(ch), apcPicOrgFields[fieldNum]->getOrigBuf().get(ch), useWPSNR ? bitDepth : 0, ::getComponentScaleX(ch, format), ::getComponentScaleY(ch, format) );
 #else
@@ -5073,8 +5074,8 @@
   const uint32_t minBlockArtSize = 8;
   const uint32_t noCol = (picWidth>>log2maxTB);
   const uint32_t noRows = (picHeight>>log2maxTB);
-  CHECK(!(noCol > 1), "Unspecified error");
-  CHECK(!(noRows > 1), "Unspecified error");
+  CHECK_VTM(!(noCol > 1), "Unspecified error");
+  CHECK_VTM(!(noRows > 1), "Unspecified error");
   std::vector<uint64_t> colSAD(noCol,  uint64_t(0));
   std::vector<uint64_t> rowSAD(noRows, uint64_t(0));
   uint32_t colIdx = 0;
@@ -5209,7 +5210,7 @@
   PelUnitBuf reco = pcPic->getRecoBuf();
 
   const int currQualityLayer = (!pcPic->slices[0]->isIRAP()) ? m_pcCfg->getGOPEntry(gopID).m_temporalId+1 : 0;
-  CHECK(!(currQualityLayer <MAX_ENCODER_DEBLOCKING_QUALITY_LAYERS), "Unspecified error");
+  CHECK_VTM(!(currQualityLayer <MAX_ENCODER_DEBLOCKING_QUALITY_LAYERS), "Unspecified error");
 
   CodingStructure& cs = *pcPic->cs;
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncHRD.cpp ../VVCSoftware_10/source/Lib/EncoderLib/EncHRD.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncHRD.cpp	2022-09-16 14:27:06.156532509 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/EncHRD.cpp	2022-05-13 17:45:29.592141090 +0200
@@ -61,7 +61,7 @@
   int  bitRate = encCfg->getTargetBitrate();
 # if U0132_TARGET_BITS_SATURATION
   int cpbSize = encCfg->getCpbSize();
-  CHECK(!(cpbSize != 0), "Unspecified error");  // CPB size may not be equal to zero. ToDo: have a better default and check for level constraints
+  CHECK_VTM(!(cpbSize != 0), "Unspecified error");  // CPB size may not be equal to zero. ToDo: have a better default and check for level constraints
   if (!encCfg->getHrdParametersPresentFlag() && !encCfg->getCpbSaturationEnabled())
 #else
   if (!encCfg->getHrdParametersPresentFlag())
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncLib.cpp ../VVCSoftware_10/source/Lib/EncoderLib/EncLib.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncLib.cpp	2022-09-16 14:27:06.156532509 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/EncLib.cpp	2022-05-13 17:45:29.472142450 +0200
@@ -531,7 +531,7 @@
   else if(getUseScalingListId() == SCALING_LIST_FILE_READ)
   {
     aps.getScalingList().setDefaultScalingList();
-    CHECK( aps.getScalingList().xParseScalingList( getScalingListFileName() ), "Error Parsing Scaling List Input File" );
+    CHECK_VTM( aps.getScalingList().xParseScalingList( getScalingListFileName() ), "Error Parsing Scaling List Input File" );
     aps.getScalingList().checkDcOfMatrix();
     if( aps.getScalingList().isNotDefaultScalingList() == false )
     {
@@ -952,11 +952,11 @@
 
   // At this point, the SPS and PPS can be considered activated - they are copied to the new Pic.
   const PPS *pPPS=(ppsId<0) ? m_ppsMap.getFirstPS() : m_ppsMap.getPS(ppsId);
-  CHECK(!(pPPS!=0), "Unspecified error");
+  CHECK_VTM(!(pPPS!=0), "Unspecified error");
   const PPS &pps=*pPPS;
 
   const SPS *pSPS=m_spsMap.getPS(pps.getSPSId());
-  CHECK(!(pSPS!=0), "Unspecified error");
+  CHECK_VTM(!(pSPS!=0), "Unspecified error");
   const SPS &sps=*pSPS;
 
   Slice::sortPicList(m_cListPic);
@@ -1117,7 +1117,7 @@
         m_vps->m_dpbParameters[dpbIdx].m_maxNumReorderPics[j] = m_vps->m_dpbParameters[dpbIdx].m_maxDecPicBuffering[j] - 1;
         m_vps->m_dpbParameters[dpbIdx].m_maxLatencyIncreasePlus1[j] = 0;
 
-        CHECK( m_vps->m_dpbParameters[dpbIdx].m_maxDecPicBuffering[j] > profileLevelTierFeatures.getMaxDpbSize( m_vps->getOlsDpbPicSize( i ).width * m_vps->getOlsDpbPicSize( i ).height ), "DPB size is not sufficient" );
+        CHECK_VTM( m_vps->m_dpbParameters[dpbIdx].m_maxDecPicBuffering[j] > profileLevelTierFeatures.getMaxDpbSize( m_vps->getOlsDpbPicSize( i ).width * m_vps->getOlsDpbPicSize( i ).height ), "DPB size is not sufficient" );
       }
 
       for( int j = ( m_vps->m_sublayerDpbParamsPresentFlag ? m_vps->m_dpbMaxTemporalId[dpbIdx] : 0 ); j < m_vps->m_dpbMaxTemporalId[dpbIdx]; j++ )
@@ -1304,7 +1304,7 @@
       sps.setLadfQpOffset( m_LadfQpOffset[k], k );
       sps.setLadfIntervalLowerBound( m_LadfIntervalLowerBound[k], k );
     }
-    CHECK( m_LadfIntervalLowerBound[0] != 0, "abnormal value set to LadfIntervalLowerBound[0]" );
+    CHECK_VTM( m_LadfIntervalLowerBound[0] != 0, "abnormal value set to LadfIntervalLowerBound[0]" );
   }
 #endif
 
@@ -1326,10 +1326,10 @@
   sps.setUseLmcs                            ( m_lmcsEnabled );
   sps.setUseMRL                ( m_MRL );
   sps.setUseMIP                ( m_MIP );
-  CHECK(m_log2MinCUSize > std::min(6, floorLog2(sps.getMaxCUWidth())), "sps_log2_min_luma_coding_block_size_minus2 shall be in the range of 0 to min (4, log2_ctu_size - 2)");
-  CHECK(m_uiMaxMTTHierarchyDepth > 2 * (floorLog2(sps.getCTUSize()) - sps.getLog2MinCodingBlockSize()), "sps_max_mtt_hierarchy_depth_inter_slice shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
-  CHECK(m_uiMaxMTTHierarchyDepthI > 2 * (floorLog2(sps.getCTUSize()) - sps.getLog2MinCodingBlockSize()), "sps_max_mtt_hierarchy_depth_intra_slice_luma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
-  CHECK(m_uiMaxMTTHierarchyDepthIChroma > 2 * (floorLog2(sps.getCTUSize()) - sps.getLog2MinCodingBlockSize()), "sps_max_mtt_hierarchy_depth_intra_slice_chroma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
+  CHECK_VTM(m_log2MinCUSize > std::min(6, floorLog2(sps.getMaxCUWidth())), "sps_log2_min_luma_coding_block_size_minus2 shall be in the range of 0 to min (4, log2_ctu_size - 2)");
+  CHECK_VTM(m_uiMaxMTTHierarchyDepth > 2 * (floorLog2(sps.getCTUSize()) - sps.getLog2MinCodingBlockSize()), "sps_max_mtt_hierarchy_depth_inter_slice shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
+  CHECK_VTM(m_uiMaxMTTHierarchyDepthI > 2 * (floorLog2(sps.getCTUSize()) - sps.getLog2MinCodingBlockSize()), "sps_max_mtt_hierarchy_depth_intra_slice_luma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
+  CHECK_VTM(m_uiMaxMTTHierarchyDepthIChroma > 2 * (floorLog2(sps.getCTUSize()) - sps.getLog2MinCodingBlockSize()), "sps_max_mtt_hierarchy_depth_intra_slice_chroma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
 
   sps.setTransformSkipEnabledFlag(m_useTransformSkip);
   sps.setLog2MaxTransformSkipBlockSize(m_log2MaxTransformSkipBlockSize);
@@ -1411,7 +1411,7 @@
   }
 
   sps.setNumLongTermRefPicSPS(NUM_LONG_TERM_REF_PIC_SPS);
-  CHECK(!(NUM_LONG_TERM_REF_PIC_SPS <= MAX_NUM_LONG_TERM_REF_PICS), "Unspecified error");
+  CHECK_VTM(!(NUM_LONG_TERM_REF_PIC_SPS <= MAX_NUM_LONG_TERM_REF_PICS), "Unspecified error");
   for (int k = 0; k < NUM_LONG_TERM_REF_PIC_SPS; k++)
   {
     sps.setLtRefPicPocLsbSps(k, 0);
@@ -1505,7 +1505,7 @@
   if( sps.getVirtualBoundariesEnabledFlag() )
   {
     sps.setVirtualBoundariesPresentFlag( m_virtualBoundariesPresentFlag );
-    CHECK( sps.getSubPicInfoPresentFlag() && sps.getVirtualBoundariesPresentFlag() != 1, "When subpicture signalling if present, the signalling of virtual boundaries, is present, shall be in the SPS" );
+    CHECK_VTM( sps.getSubPicInfoPresentFlag() && sps.getVirtualBoundariesPresentFlag() != 1, "When subpicture signalling if present, the signalling of virtual boundaries, is present, shall be in the SPS" );
     sps.setNumVerVirtualBoundaries            ( m_numVerVirtualBoundaries );
     sps.setNumHorVirtualBoundaries            ( m_numHorVirtualBoundaries );
     for( unsigned int i = 0; i < m_numVerVirtualBoundaries; i++ )
@@ -1519,14 +1519,14 @@
   }
 
   sps.setInterLayerPresentFlag( m_layerId > 0 && m_vps->getMaxLayers() > 1 && !m_vps->getAllIndependentLayersFlag() && !m_vps->getIndependentLayerFlag( m_vps->getGeneralLayerIdx( m_layerId ) ) );
-  CHECK( m_vps->getIndependentLayerFlag( m_vps->getGeneralLayerIdx( m_layerId ) ) && sps.getInterLayerPresentFlag(), " When vps_independent_layer_flag[GeneralLayerIdx[nuh_layer_id ]]  is equal to 1, the value of inter_layer_ref_pics_present_flag shall be equal to 0." );
+  CHECK_VTM( m_vps->getIndependentLayerFlag( m_vps->getGeneralLayerIdx( m_layerId ) ) && sps.getInterLayerPresentFlag(), " When vps_independent_layer_flag[GeneralLayerIdx[nuh_layer_id ]]  is equal to 1, the value of inter_layer_ref_pics_present_flag shall be equal to 0." );
 
   sps.setResChangeInClvsEnabledFlag(m_resChangeInClvsEnabled);
   sps.setRprEnabledFlag(m_rprEnabledFlag);
 
   sps.setLog2ParallelMergeLevelMinus2( m_log2ParallelMergeLevelMinus2 );
 
-  CHECK(sps.getResChangeInClvsEnabledFlag() && sps.getVirtualBoundariesEnabledFlag(), "when the value of sps_res_change_in_clvs_allowed_flag is equal to 1, the value of sps_virtual_boundaries_present_flag shall be equal to 0");
+  CHECK_VTM(sps.getResChangeInClvsEnabledFlag() && sps.getVirtualBoundariesEnabledFlag(), "when the value of sps_res_change_in_clvs_allowed_flag is equal to 1, the value of sps_virtual_boundaries_present_flag shall be equal to 0");
 }
 
 void EncLib::xInitHrdParameters(SPS &sps)
@@ -1572,7 +1572,7 @@
 #if ENABLE_QPA
   if (getUsePerceptQPA() && !bUseDQP)
   {
-    CHECK( m_cuQpDeltaSubdiv != 0, "max. delta-QP subdiv must be zero!" );
+    CHECK_VTM( m_cuQpDeltaSubdiv != 0, "max. delta-QP subdiv must be zero!" );
     bUseDQP = (getBaseQP() < 38) && (getSourceWidth() > 512 || getSourceHeight() > 320);
   }
 #endif
@@ -1702,8 +1702,8 @@
     pps.setPicWidthMinusWrapAroundOffset      ( 0 );
     pps.setWrapAroundOffset                   ( 0 );       
   }
-  CHECK( !sps.getWrapAroundEnabledFlag() && pps.getWrapAroundEnabledFlag(), "When sps_ref_wraparound_enabled_flag is equal to 0, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
-  CHECK( (((sps.getCTUSize() / minCbSizeY) + 1) > ((pps.getPicWidthInLumaSamples() / minCbSizeY) - 1)) && pps.getWrapAroundEnabledFlag(), "When the value of CtbSizeY / MinCbSizeY + 1 is greater than pps_pic_width_in_luma_samples / MinCbSizeY - 1, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
+  CHECK_VTM( !sps.getWrapAroundEnabledFlag() && pps.getWrapAroundEnabledFlag(), "When sps_ref_wraparound_enabled_flag is equal to 0, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
+  CHECK_VTM( (((sps.getCTUSize() / minCbSizeY) + 1) > ((pps.getPicWidthInLumaSamples() / minCbSizeY) - 1)) && pps.getWrapAroundEnabledFlag(), "When the value of CtbSizeY / MinCbSizeY + 1 is greater than pps_pic_width_in_luma_samples / MinCbSizeY - 1, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
 
   pps.setNoPicPartitionFlag( m_noPicPartitionFlag );
   if( m_noPicPartitionFlag == false )
@@ -1826,7 +1826,7 @@
   }
   for( int i = 0; i < getGOPSize(); i++)
   {
-    CHECK(!(getRPLEntry(0, i).m_numRefPicsActive >= 0 && getRPLEntry(0, i).m_numRefPicsActive <= MAX_NUM_REF), "Unspecified error");
+    CHECK_VTM(!(getRPLEntry(0, i).m_numRefPicsActive >= 0 && getRPLEntry(0, i).m_numRefPicsActive <= MAX_NUM_REF), "Unspecified error");
     histogram[getRPLEntry(0, i).m_numRefPicsActive]++;
   }
 
@@ -1840,7 +1840,7 @@
       bestPos=i;
     }
   }
-  CHECK(!(bestPos <= 15), "Unspecified error");
+  CHECK_VTM(!(bestPos <= 15), "Unspecified error");
     pps.setNumRefIdxL0DefaultActive(bestPos);
   pps.setNumRefIdxL1DefaultActive(bestPos);
   pps.setPictureHeaderExtensionPresentFlag(false);
@@ -1890,7 +1890,7 @@
 #if ENABLE_QPA
   if( getUsePerceptQPA() && !bUseDQP )
   {
-    CHECK( m_cuQpDeltaSubdiv != 0, "max. delta-QP subdiv must be zero!" );
+    CHECK_VTM( m_cuQpDeltaSubdiv != 0, "max. delta-QP subdiv must be zero!" );
     bUseDQP = (getBaseQP() < 38) && (getSourceWidth() > 512 || getSourceHeight() > 320);
   }
 #endif
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncModeCtrl.cpp ../VVCSoftware_10/source/Lib/EncoderLib/EncModeCtrl.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncModeCtrl.cpp	2022-09-16 14:27:06.156532509 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/EncModeCtrl.cpp	2022-05-13 17:45:29.832138373 +0200
@@ -83,7 +83,7 @@
 
 void EncModeCtrl::xExtractFeatures( const EncTestMode encTestmode, CodingStructure& cs )
 {
-  CHECK( cs.features.size() < NUM_ENC_FEATURES, "Features vector is not initialized" );
+  CHECK_VTM( cs.features.size() < NUM_ENC_FEATURES, "Features vector is not initialized" );
 
   cs.features[ENC_FT_DISTORTION     ] = double( cs.dist              );
   cs.features[ENC_FT_FRAC_BITS      ] = double( cs.fracBits          );
@@ -214,7 +214,7 @@
 #if !WCG_EXT
   if( m_pcEncCfg->getLumaLevelToDeltaQPMapping().mode == LUMALVL_TO_DQP_AVG_METHOD )
 #else
-  CHECK( m_pcEncCfg->getLumaLevelToDeltaQPMapping().mode != LUMALVL_TO_DQP_AVG_METHOD, "invalid delta qp mode" );
+  CHECK_VTM( m_pcEncCfg->getLumaLevelToDeltaQPMapping().mode != LUMALVL_TO_DQP_AVG_METHOD, "invalid delta qp mode" );
 #endif
   {
     // Use average luma value
@@ -1099,7 +1099,7 @@
 #endif
   SaveLoadEncInfoSbt::init( slice );
 
-  CHECK( !m_ComprCUCtxList.empty(), "Mode list is not empty at the beginning of a CTU" );
+  CHECK_VTM( !m_ComprCUCtxList.empty(), "Mode list is not empty at the beginning of a CTU" );
 
   m_slice             = &slice;
 #if ENABLE_SPLIT_PARALLELISM
@@ -1598,7 +1598,7 @@
   else if( isModeInter( encTestmode ) )
   {
     // INTER MODES (ME + MERGE/SKIP)
-    CHECK( slice.isIntra(), "Inter-mode should not be in the I-Slice mode list!" );
+    CHECK_VTM( slice.isIntra(), "Inter-mode should not be in the I-Slice mode list!" );
 
     if( getFastDeltaQp() )
     {
@@ -1852,7 +1852,7 @@
   }
   else
   {
-    CHECK( encTestmode.type != ETM_POST_DONT_SPLIT, "Unknown mode" );
+    CHECK_VTM( encTestmode.type != ETM_POST_DONT_SPLIT, "Unknown mode" );
     if ((cuECtx.get<double>(BEST_NO_IMV_COST) == (MAX_DOUBLE * .5) || cuECtx.get<bool>(IS_REUSING_CU)) && !slice.isIntra())
     {
       unsigned idx1, idx2, idx3, idx4;
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncModeCtrl.h ../VVCSoftware_10/source/Lib/EncoderLib/EncModeCtrl.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncModeCtrl.h	2022-09-16 14:27:06.156532509 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/EncModeCtrl.h	2022-05-13 17:45:29.468142494 +0200
@@ -330,7 +330,8 @@
   virtual void setBest              ( CodingStructure& cs );
   bool         anyMode              () const;
 
-  const ComprCUCtx& getComprCUCtx   () { CHECK( m_ComprCUCtxList.empty(), "Accessing empty list!"); return m_ComprCUCtxList.back(); }
+  const ComprCUCtx& getComprCUCtx   () {
+    CHECK_VTM( m_ComprCUCtxList.empty(), "Accessing empty list!"); return m_ComprCUCtxList.back(); }
 
 #if SHARP_LUMA_DELTA_QP
   void                  initLumaDeltaQpLUT();
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncReshape.cpp ../VVCSoftware_10/source/Lib/EncoderLib/EncReshape.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncReshape.cpp	2022-09-16 14:27:06.156532509 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/EncReshape.cpp	2022-05-13 17:45:29.808138644 +0200
@@ -1294,7 +1294,7 @@
 
   int sumBins = 0;
   for (i = 0; i < PIC_CODE_CW_BINS; i++) { sumBins += m_binCW[i]; }
-  CHECK(sumBins >= m_reshapeLUTSize, "SDR CW assignment is wrong!!");
+  CHECK_VTM(sumBins >= m_reshapeLUTSize, "SDR CW assignment is wrong!!");
   for (int i = 0; i < PIC_CODE_CW_BINS; i++)
   {
     m_reshapePivot[i + 1] = m_reshapePivot[i] + m_binCW[i];
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncSampleAdaptiveOffset.cpp ../VVCSoftware_10/source/Lib/EncoderLib/EncSampleAdaptiveOffset.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncSampleAdaptiveOffset.cpp	2022-09-16 14:27:06.156532509 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/EncSampleAdaptiveOffset.cpp	2022-05-13 17:45:29.832138373 +0200
@@ -833,7 +833,7 @@
 
   int ctuRsAddr = 0;
 #if ENABLE_QPA
-  CHECK ((chromaWeight > 0.0) && (cs.slice->getFirstCtuRsAddrInSlice() != 0), "incompatible start CTU address, must be 0");
+  CHECK_VTM((chromaWeight > 0.0) && (cs.slice->getFirstCtuRsAddrInSlice() != 0), "incompatible start CTU address, must be 0");
 #endif
 
   for( uint32_t yPos = 0; yPos < pcv.lumaHeight; yPos += pcv.maxCUHeight )
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncSlice.cpp ../VVCSoftware_10/source/Lib/EncoderLib/EncSlice.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/EncSlice.cpp	2022-09-16 14:27:06.156532509 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/EncSlice.cpp	2022-05-13 17:45:29.584141181 +0200
@@ -40,6 +40,8 @@
 #include "EncLib.h"
 #include "CommonLib/UnitTools.h"
 #include "CommonLib/Picture.h"
+#include "PartitionGlobalManager.h"
+
 #if K0149_BLOCK_STATISTICS
 #include "CommonLib/dtrace_blockstatistics.h"
 #endif
@@ -231,7 +233,7 @@
 
     if (chrValue > avgCompValue) chrValue = avgCompValue; // minimum of the DC offsets
   }
-  CHECK (chrValue < 0, "DC offset cannot be negative!");
+  CHECK_VTM(chrValue < 0, "DC offset cannot be negative!");
 
   chrValue = (int)avgLumaValue - chrValue;
 
@@ -347,7 +349,7 @@
     rpcSlice->setSignDataHidingEnabledFlag( m_pcCfg->getSignDataHidingEnabledFlag() );
     rpcSlice->setTSResidualCodingDisabledFlag( false );
 
-    CHECK( (m_pcCfg->getDepQuantEnabledFlag() || m_pcCfg->getSignDataHidingEnabledFlag() ) 
+    CHECK_VTM( (m_pcCfg->getDepQuantEnabledFlag() || m_pcCfg->getSignDataHidingEnabledFlag() )
            && rpcSlice->getTSResidualCodingDisabledFlag() , "TSRC cannot be bypassed if either DQ or SDH are enabled at slice level.");
   }
   else
@@ -533,9 +535,9 @@
     cbQP = Clip3( -12, 12, cbQP + rpcSlice->getPPS()->getQpOffset(COMPONENT_Cb) ) - rpcSlice->getPPS()->getQpOffset(COMPONENT_Cb);
     crQP = Clip3( -12, 12, crQP + rpcSlice->getPPS()->getQpOffset(COMPONENT_Cr) ) - rpcSlice->getPPS()->getQpOffset(COMPONENT_Cr);
     rpcSlice->setSliceChromaQpDelta(COMPONENT_Cb, Clip3( -12, 12, cbQP));
-    CHECK(!(rpcSlice->getSliceChromaQpDelta(COMPONENT_Cb)+rpcSlice->getPPS()->getQpOffset(COMPONENT_Cb)<=12 && rpcSlice->getSliceChromaQpDelta(COMPONENT_Cb)+rpcSlice->getPPS()->getQpOffset(COMPONENT_Cb)>=-12), "Unspecified error");
+    CHECK_VTM(!(rpcSlice->getSliceChromaQpDelta(COMPONENT_Cb)+rpcSlice->getPPS()->getQpOffset(COMPONENT_Cb)<=12 && rpcSlice->getSliceChromaQpDelta(COMPONENT_Cb)+rpcSlice->getPPS()->getQpOffset(COMPONENT_Cb)>=-12), "Unspecified error");
     rpcSlice->setSliceChromaQpDelta(COMPONENT_Cr, Clip3( -12, 12, crQP));
-    CHECK(!(rpcSlice->getSliceChromaQpDelta(COMPONENT_Cr)+rpcSlice->getPPS()->getQpOffset(COMPONENT_Cr)<=12 && rpcSlice->getSliceChromaQpDelta(COMPONENT_Cr)+rpcSlice->getPPS()->getQpOffset(COMPONENT_Cr)>=-12), "Unspecified error");
+    CHECK_VTM(!(rpcSlice->getSliceChromaQpDelta(COMPONENT_Cr)+rpcSlice->getPPS()->getQpOffset(COMPONENT_Cr)<=12 && rpcSlice->getSliceChromaQpDelta(COMPONENT_Cr)+rpcSlice->getPPS()->getQpOffset(COMPONENT_Cr)>=-12), "Unspecified error");
     if (rpcSlice->getSPS()->getJointCbCrEnabledFlag())
     {
       cbCrQP = Clip3(-12, 12, cbCrQP + rpcSlice->getPPS()->getQpOffset(JOINT_CbCr)) - rpcSlice->getPPS()->getQpOffset(JOINT_CbCr);
@@ -886,7 +888,7 @@
       const double  corrFactor = pow (2.0, double(iQPFixed - iQPIndex) / 3.0);
       const double  newLambdas[MAX_NUM_COMPONENT] = {oldLambdas[0] * corrFactor, oldLambdas[1] * corrFactor, oldLambdas[2] * corrFactor};
 
-      CHECK (iQPIndex != pcSlice->getSliceQpBase(), "Invalid slice QP!");
+      CHECK_VTM(iQPIndex != pcSlice->getSliceQpBase(), "Invalid slice QP!");
       pcSlice->setLambdas (newLambdas);
       pcSlice->setSliceQp (iQPFixed); // update the slice/base QPs
       pcSlice->setSliceQpBase (iQPFixed);
@@ -922,7 +924,7 @@
               && !useSharpLumaDQP
 #endif
               ) iQPAdapt = MAX_QP;
-          CHECK (meanLuma != (uint32_t)pcPic->m_iOffsetCtu[ctuRsAddr], "luma DC offsets don't match");
+          CHECK_VTM(meanLuma != (uint32_t)pcPic->m_iOffsetCtu[ctuRsAddr], "luma DC offsets don't match");
         }
 #if SHARP_LUMA_DELTA_QP
 
@@ -1044,7 +1046,7 @@
     uint32_t subMLV[16];   // individual mean luma values
 #endif
 
-    CHECK (mts * 4 < pcv.maxCUWidth || mts * 4 < pcv.maxCUHeight, "max. transform size is too small for given CTU size");
+    CHECK_VTM(mts * 4 < pcv.maxCUWidth || mts * 4 < pcv.maxCUHeight, "max. transform size is too small for given CTU size");
 
     for (unsigned h = 0; h < (pcv.maxCUHeight >> mtsLog2); h++)
     {
@@ -1334,7 +1336,7 @@
 
     pcPic->m_prevQP[0] = pcPic->m_prevQP[1] = pcSlice->getSliceQp();
 
-  CHECK( pcPic->m_prevQP[0] == std::numeric_limits<int>::max(), "Invalid previous QP" );
+    CHECK_VTM( pcPic->m_prevQP[0] == std::numeric_limits<int>::max(), "Invalid previous QP" );
 
   CodingStructure&  cs          = *pcPic->cs;
   cs.slice    = pcSlice;
@@ -1689,8 +1691,21 @@
       pcPic->mctsInfo.init( &cs, ctuRsAddr );
     }
 
+
+  //altissie added => create luma and chroma tree for the ctu
+  PartitionTree luma_tree(param_partition->ctuSize, param_partition->ctuSize, nullptr, nullptr, param_partition, false, false, cs.cost);
+  PartitionTree chroma_tree(param_partition->ctuSize, param_partition->ctuSize, nullptr, nullptr, param_partition, false, false, cs.cost);
+
   if (pCfg->getSwitchPOC() != pcPic->poc || ctuRsAddr >= pCfg->getDebugCTU())
-    m_pcCuEncoder->compressCtu( cs, ctuArea, ctuRsAddr, prevQP, currQP );
+    m_pcCuEncoder->compressCtu( cs, ctuArea, ctuRsAddr, prevQP, currQP, &luma_tree, &chroma_tree );
+
+
+  if(param_partition->is_writePartition()){
+    store_partition->store_ctu(&luma_tree, !pcSlice->isIntra());
+    if(pcSlice->isIntra()){
+      store_partition->store_ctu(&chroma_tree, !pcSlice->isIntra());
+    }
+  }
 
 #if K0149_BLOCK_STATISTICS
     getAndStoreBlockStatistics(cs, ctuArea);
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/InterSearch.cpp ../VVCSoftware_10/source/Lib/EncoderLib/InterSearch.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/InterSearch.cpp	2022-09-16 14:27:06.156532509 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/InterSearch.cpp	2022-05-13 17:45:29.588141136 +0200
@@ -123,7 +123,7 @@
 
 void InterSearch::destroy()
 {
-  CHECK(!m_isInitialized, "Not initialized");
+  CHECK_VTM(!m_isInitialized, "Not initialized");
   if ( m_pTempPel )
   {
     delete [] m_pTempPel;
@@ -207,7 +207,7 @@
                       , EncReshape*    pcReshape
 )
 {
-  CHECK(m_isInitialized, "Already initialized");
+  CHECK_VTM(m_isInitialized, "Already initialized");
   m_numBVs = 0;
   for (int i = 0; i < IBC_NUM_CANDIDATES; i++)
   {
@@ -453,7 +453,7 @@
   // 8 point search,                   //   1 2 3
   // search around the start point     //   4 0 5
   // with the required  distance       //   6 7 8
-  CHECK( iDist == 0 , "Invalid distance");
+  CHECK_VTM( iDist == 0 , "Invalid distance");
   const int iTop        = iStartY - iDist;
   const int iBottom     = iStartY + iDist;
   const int iLeft       = iStartX - iDist;
@@ -511,7 +511,7 @@
   // 8 point search,                   //   1 2 3
   // search around the start point     //   4 0 5
   // with the required  distance       //   6 7 8
-  CHECK( iDist == 0, "Invalid distance" );
+  CHECK_VTM( iDist == 0, "Invalid distance" );
   const int iTop        = iStartY - iDist;
   const int iBottom     = iStartY + iDist;
   const int iLeft       = iStartX - iDist;
@@ -1282,7 +1282,7 @@
   cStruct.pcPatternKey = pcPatternKey;
   cStruct.iRefStride = refBuf.stride;
   cStruct.piRefY = refBuf.buf;
-  CHECK(pu.cu->imv == IMV_HPEL, "IF_IBC");
+  CHECK_VTM(pu.cu->imv == IMV_HPEL, "IF_IBC");
   cStruct.imvShift = pu.cu->imv << 1;
   cStruct.subShiftMode = 0; // used by intra pattern search function
 
@@ -1437,7 +1437,7 @@
   {
     m_maxCompIDToPred = MAX_NUM_COMPONENT;
 
-    CHECK(pu.cu != &cu, "PU is contained in another CU");
+    CHECK_VTM(pu.cu != &cu, "PU is contained in another CU");
     //////////////////////////////////////////////////////////
     /// ibc search
     pu.cu->imv = 2;
@@ -1850,7 +1850,7 @@
         continue;
       }
 
-      CHECK( pu.cu->slice->getRefPic( eRefPicList, refIdx )->getHashMap() == nullptr, "Hash table is not initialized" );
+      CHECK_VTM( pu.cu->slice->getRefPic( eRefPicList, refIdx )->getHashMap() == nullptr, "Hash table is not initialized" );
 
       if (refList == 0 || pu.cu->slice->getList1IdxToList0Idx(refIdx) < 0)
       {
@@ -2049,7 +2049,7 @@
         continue;
       }
 
-      CHECK( pu.cu->slice->getRefPic( eRefPicList, refIdx )->getHashMap() == nullptr, "Hash table is not initialized" );
+      CHECK_VTM( pu.cu->slice->getRefPic( eRefPicList, refIdx )->getHashMap() == nullptr, "Hash table is not initialized" );
 
       if (refList == 0 || pu.cu->slice->getList1IdxToList0Idx(refIdx) < 0)
       {
@@ -2075,7 +2075,7 @@
         AMVPInfo currAMVPInfoQPel;
         pu.cu->imv = 0;
         PU::fillMvpCand(pu, eRefPicList, refIdx, currAMVPInfoQPel);
-        CHECK(currAMVPInfoPel.numCand <= 1, "Wrong")
+        CHECK_VTM(currAMVPInfoPel.numCand <= 1, "Wrong")
         for (int mvpIdxTemp = 0; mvpIdxTemp < 2; mvpIdxTemp++)
         {
           currAMVPInfoQPel.mvCand[mvpIdxTemp].changePrecision(MV_PRECISION_INTERNAL, MV_PRECISION_QUARTER);
@@ -2242,7 +2242,7 @@
 
 
 //! search of the best candidate for inter prediction
-void InterSearch::predInterSearch(CodingUnit& cu, Partitioner& partitioner)
+void InterSearch::predInterSearch(CodingUnit& cu, Partitioner& partitioner, Mv* mvUni, int * pocRef, unsigned long * costRef, RefPicList * refPicList, int * pocRefIdx)
 {
   CodingStructure& cs = *cu.cs;
 
@@ -2288,7 +2288,7 @@
   MergeCtx     mergeCtx;
 
   // Loop over Prediction Units
-  CHECK(!cu.firstPU, "CU does not contain any PUs");
+  CHECK_VTM(!cu.firstPU, "CU does not contain any PUs");
   uint32_t         puIdx = 0;
   auto &pu = *cu.firstPU;
   WPScalingParam *wp0;
@@ -2319,7 +2319,7 @@
     m_maxCompIDToPred = MAX_NUM_COMPONENT;
 //    m_maxCompIDToPred = COMPONENT_Y;
 
-    CHECK(pu.cu != &cu, "PU is contained in another CU");
+    CHECK_VTM(pu.cu != &cu, "PU is contained in another CU");
 
     if (cu.cs->sps->getSbTMVPEnabledFlag())
     {
@@ -2435,6 +2435,28 @@
             iRefIdx[iRefList] = iRefIdxTemp;
           }
 
+          //store the mv and poc reference frame to get the reference ctu
+          if(mvUni!= nullptr && uiCostTemp < costRef[iRefList] /*&& cu.lheight()==128 && cu.lwidth() == 128*/){
+            if(iRefList==0){
+              mvUni[iRefList] = cMvTemp[iRefList][iRefIdxTemp];
+              pocRef[iRefList] = cs.slice->getPOC()+cs.slice->getRPL0()->getRefPicIdentifier(iRefIdxTemp);
+              //std::cout<<"poc: "<<cs.slice->getPOC()<<" ref: "<<cs.slice->getRPL0()->getRefPicIdentifier(iRefIdxTemp)<<std::endl;
+              costRef[iRefList] = uiCostTemp;
+              refPicList[iRefList] = REF_PIC_LIST_0;
+              pocRefIdx[iRefList] = iRefIdxTemp;
+            }
+            else{
+              if(mvUni[0].getHor()!=cMvTemp[iRefList][iRefIdxTemp].getHor() || mvUni[0].getVer()!=cMvTemp[iRefList][iRefIdxTemp].getVer() || pocRef[0]!=cs.slice->getPOC()+cs.slice->getRPL1()->getRefPicIdentifier(iRefIdxTemp)){
+                mvUni[iRefList] = cMvTemp[iRefList][iRefIdxTemp];
+                pocRef[iRefList] = cs.slice->getPOC()+cs.slice->getRPL1()->getRefPicIdentifier(iRefIdxTemp);
+                costRef[iRefList] = uiCostTemp;
+                refPicList[iRefList] = REF_PIC_LIST_1;
+                pocRefIdx[iRefList] = iRefIdxTemp;
+              }
+            }
+            //std::cout<<uiCost[iRefList]<<std::endl;
+          }
+
           if ( iRefList == 1 && uiCostTemp < costValidList1 && cs.slice->getList1IdxToList0Idx( iRefIdxTemp ) < 0 )
           {
             costValidList1 = uiCostTemp;
@@ -2447,6 +2469,11 @@
         }
       }
 
+      /*if(cu.lheight()==128 && cu.lwidth() == 128){
+        std::cout<<"Im ref 0 : "<<iRefIdx[0]<<" // "<<cs.slice->getPOC()+cs.slice->getRPL0()->getRefPicIdentifier(iRefIdx[0])<<" / X : "<<cMv[0].getHor()<<" / Y : "<<cMv[0].getVer()<<std::endl;
+        std::cout<<"Im ref 1 : "<<iRefIdx[1]<<" // "<<cs.slice->getPOC()+cs.slice->getRPL1()->getRefPicIdentifier(iRefIdx[1])<<" / X : "<<cMv[1].getHor()<<" / Y : "<<cMv[1].getVer()<<std::endl;
+      }*/
+
       ::memcpy(cMvHevcTemp, cMvTemp, sizeof(cMvTemp));
       if (cu.imv == 0 && (!cu.slice->getSPS()->getUseBcw() || bcwIdx == BCW_DEFAULT))
       {
@@ -2664,7 +2691,7 @@
           RefPicList eCurRefList = (curRefList ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
           int refIdxCur = cs.slice->getSymRefIdx( curRefList );
           int refIdxTar = cs.slice->getSymRefIdx( tarRefList );
-          CHECK (refIdxCur==-1 || refIdxTar==-1, "Uninitialized reference index not allowed");
+          CHECK_VTM(refIdxCur==-1 || refIdxTar==-1, "Uninitialized reference index not allowed");
 
           if ( aacAMVPInfo[curRefList][refIdxCur].mvCand[0] == aacAMVPInfo[curRefList][refIdxCur].mvCand[1] )
             aacAMVPInfo[curRefList][refIdxCur].numCand = 1;
@@ -2830,8 +2857,8 @@
     uiCost [1] = costValidList1;
     if (cu.cs->pps->getWPBiPred() == true && tryBipred && (bcwIdx != BCW_DEFAULT))
     {
-      CHECK(iRefIdxBi[0]<0, "Invalid picture reference index");
-      CHECK(iRefIdxBi[1]<0, "Invalid picture reference index");
+      CHECK_VTM(iRefIdxBi[0]<0, "Invalid picture reference index");
+      CHECK_VTM(iRefIdxBi[1]<0, "Invalid picture reference index");
       wp0 = cu.cs->slice->getWpScaling(REF_PIC_LIST_0, iRefIdxBi[0]);
       wp1 = cu.cs->slice->getWpScaling(REF_PIC_LIST_1, iRefIdxBi[1]);
       if (WPScalingParam::isWeighted(wp0) || WPScalingParam::isWeighted(wp1))
@@ -3029,7 +3056,7 @@
       else
       {
         cu.smvdMode = 0;
-        CHECK( !cu.affine, "Wrong." );
+        CHECK_VTM( !cu.affine, "Wrong." );
         uiLastMode = uiLastModeTemp;
       }
     }
@@ -3129,7 +3156,7 @@
 
 uint32_t InterSearch::xGetMvpIdxBits(int iIdx, int iNum)
 {
-  CHECK(iIdx < 0 || iNum < 0 || iIdx >= iNum, "Invalid parameters");
+  CHECK_VTM(iIdx < 0 || iNum < 0 || iIdx >= iNum, "Invalid parameters");
 
   if (iNum == 1)
   {
@@ -3180,7 +3207,7 @@
 
   AMVPInfo* pcAMVPInfo = &amvpInfo;
 
-  CHECK(pcAMVPInfo->mvCand[riMVPIdx] != rcMvPred, "Invalid MV prediction candidate");
+  CHECK_VTM(pcAMVPInfo->mvCand[riMVPIdx] != rcMvPred, "Invalid MV prediction candidate");
 
   if (pcAMVPInfo->numCand < 2)
   {
@@ -3305,7 +3332,7 @@
 
   Mv cMvHalf, cMvQter;
 
-  CHECK(eRefPicList >= MAX_NUM_REF_LIST_ADAPT_SR || iRefIdxPred>=int(MAX_IDX_ADAPT_SR), "Invalid reference picture list");
+  CHECK_VTM(eRefPicList >= MAX_NUM_REF_LIST_ADAPT_SR || iRefIdxPred>=int(MAX_IDX_ADAPT_SR), "Invalid reference picture list");
   m_iSearchRange = m_aaiAdaptSR[eRefPicList][iRefIdxPred];
 
   int    iSrchRng   = (bBi ? m_bipredSearchRange : m_iSearchRange);
@@ -4171,9 +4198,8 @@
 
 void InterSearch::xPatternSearchIntRefine(PredictionUnit& pu, IntTZSearchStruct&  cStruct, Mv& rcMv, Mv& rcMvPred, int& riMVPIdx, uint32_t& ruiBits, Distortion& ruiCost, const AMVPInfo& amvpInfo, double fWeight)
 {
-
-  CHECK( pu.cu->imv == 0 || pu.cu->imv == IMV_HPEL , "xPatternSearchIntRefine(): Sub-pel MV used.");
-  CHECK( amvpInfo.mvCand[riMVPIdx] != rcMvPred, "xPatternSearchIntRefine(): MvPred issue.");
+  CHECK_VTM( pu.cu->imv == 0 || pu.cu->imv == IMV_HPEL , "xPatternSearchIntRefine(): Sub-pel MV used.");
+  CHECK_VTM( amvpInfo.mvCand[riMVPIdx] != rcMvPred, "xPatternSearchIntRefine(): MvPred issue.");
 
   const SPS &sps = *pu.cs->sps;
   m_pcRdCost->setDistParam(m_cDistParam, *cStruct.pcPatternKey, cStruct.piRefY, cStruct.iRefStride, m_lumaClpRng.bd, COMPONENT_Y, 0, 1, m_pcEncCfg->getUseHADME() && !pu.cs->slice->getDisableSATDForRD());
@@ -4195,8 +4221,8 @@
 
   cBaseMvd[0] = (rcMv - amvpInfo.mvCand[0]);
   cBaseMvd[1] = (rcMv - amvpInfo.mvCand[1]);
-  CHECK( (cBaseMvd[0].getHor() & 0x03) != 0 || (cBaseMvd[0].getVer() & 0x03) != 0 , "xPatternSearchIntRefine(): AMVP cand 0 Mvd issue.");
-  CHECK( (cBaseMvd[1].getHor() & 0x03) != 0 || (cBaseMvd[1].getVer() & 0x03) != 0 , "xPatternSearchIntRefine(): AMVP cand 1 Mvd issue.");
+  CHECK_VTM( (cBaseMvd[0].getHor() & 0x03) != 0 || (cBaseMvd[0].getVer() & 0x03) != 0 , "xPatternSearchIntRefine(): AMVP cand 0 Mvd issue.");
+  CHECK_VTM( (cBaseMvd[1].getHor() & 0x03) != 0 || (cBaseMvd[1].getVer() & 0x03) != 0 , "xPatternSearchIntRefine(): AMVP cand 1 Mvd issue.");
 
   cBaseMvd[0].roundTransPrecInternal2Amvr(pu.cu->imv);
   cBaseMvd[1].roundTransPrecInternal2Amvr(pu.cu->imv);
@@ -5122,8 +5148,8 @@
   uiCost[1]  = costValidList1;
   if (pu.cs->pps->getWPBiPred() == true && tryBipred && (bcwIdx != BCW_DEFAULT))
   {
-    CHECK(iRefIdxBi[0]<0, "Invalid picture reference index");
-    CHECK(iRefIdxBi[1]<0, "Invalid picture reference index");
+    CHECK_VTM(iRefIdxBi[0]<0, "Invalid picture reference index");
+    CHECK_VTM(iRefIdxBi[1]<0, "Invalid picture reference index");
     wp0 = pu.cs->slice->getWpScaling(REF_PIC_LIST_0, iRefIdxBi[0]);
     wp1 = pu.cs->slice->getWpScaling(REF_PIC_LIST_1, iRefIdxBi[1]);
 
@@ -5788,7 +5814,7 @@
 
   // Fill the MV Candidates
   PU::fillAffineMvpCand( pu, eRefPicList, iRefIdx, affineAMVPInfo );
-  CHECK( affineAMVPInfo.numCand == 0, "Assertion failed." );
+  CHECK_VTM( affineAMVPInfo.numCand == 0, "Assertion failed." );
 
   PelUnitBuf predBuf = m_tmpStorageLCU.getBuf( UnitAreaRelative(*pu.cu, pu) );
 
@@ -6110,18 +6136,18 @@
   {
     if( partitioner.canSplit( TU_MAX_TR_SPLIT, cs ) )
     {
-      CHECK( !bSubdiv, "Not performing the implicit TU split" );
+      CHECK_VTM( !bSubdiv, "Not performing the implicit TU split" );
     }
     else if( cu.sbtInfo && partitioner.canSplit( PartSplit( cu.getSbtTuSplit() ), cs ) )
     {
-      CHECK( !bSubdiv, "Not performing the implicit TU split - sbt" );
+      CHECK_VTM( !bSubdiv, "Not performing the implicit TU split - sbt" );
     }
     else
     {
-      CHECK( bSubdiv, "transformsplit not supported" );
+      CHECK_VTM( bSubdiv, "transformsplit not supported" );
     }
 
-    CHECK(CU::isIntra(cu), "Inter search provided with intra CU");
+    CHECK_VTM(CU::isIntra(cu), "Inter search provided with intra CU");
 
     if( cu.chromaFormat != CHROMA_400
       && (!cu.isSepTree() || isChroma(partitioner.chType))
@@ -6799,7 +6825,7 @@
           }
           if( tu.noResidual )
           {
-            CHECK( currCompFracBits > 0 || currAbsSum, "currCompFracBits > 0 when tu noResidual" );
+            CHECK_VTM( currCompFracBits > 0 || currAbsSum, "currCompFracBits > 0 when tu noResidual" );
           }
       }
 
@@ -7120,7 +7146,7 @@
     }
     if( tu.noResidual )
     {
-      CHECK( m_CABACEstimator->getEstFracBits() > 0, "no residual TU's bits shall be 0" );
+      CHECK_VTM( m_CABACEstimator->getEstFracBits() > 0, "no residual TU's bits shall be 0" );
     }
     if (colorTransFlag)
     {
@@ -7251,7 +7277,7 @@
 
   CodingUnit &cu = *cs.getCU( partitioner.chType );
   if( cu.predMode == MODE_INTER )
-    CHECK( cu.isSepTree(), "CU with Inter mode must be in single tree" );
+    CHECK_VTM( cu.isSepTree(), "CU with Inter mode must be in single tree" );
 
   const ChromaFormat format     = cs.area.chromaFormat;;
   const int  numValidComponents = getNumberValidComponents(format);
@@ -7260,8 +7286,8 @@
   bool colorTransAllowed = cs.slice->getSPS()->getUseColorTrans() && luma && chroma;
   if (cs.slice->getSPS()->getUseColorTrans())
   {
-    CHECK(cu.treeType != TREE_D || partitioner.treeType != TREE_D, "localtree should not be applied when adaptive color transform is enabled");
-    CHECK(cu.modeType != MODE_TYPE_ALL || partitioner.modeType != MODE_TYPE_ALL, "localtree should not be applied when adaptive color transform is enabled");
+    CHECK_VTM(cu.treeType != TREE_D || partitioner.treeType != TREE_D, "localtree should not be applied when adaptive color transform is enabled");
+    CHECK_VTM(cu.modeType != MODE_TYPE_ALL || partitioner.modeType != MODE_TYPE_ALL, "localtree should not be applied when adaptive color transform is enabled");
   }
 
   if( skipResidual ) //  No residual coding : SKIP mode
@@ -7269,7 +7295,7 @@
     cu.skip    = true;
     cu.rootCbf = false;
     cu.colorTransform = false;
-    CHECK( cu.sbtInfo != 0, "sbtInfo shall be 0 if CU has no residual" );
+    CHECK_VTM( cu.sbtInfo != 0, "sbtInfo shall be 0 if CU has no residual" );
     cs.getResiBuf().fill(0);
     {
       cs.getRecoBuf().copyFrom(cs.getPredBuf() );
@@ -7404,7 +7430,7 @@
     {
       if (colorSpaceOption)
       {
-        CHECK(colorSpaceOption > 2 || colorSpaceOption < 0, "invalid color space selection option");
+        CHECK_VTM(colorSpaceOption > 2 || colorSpaceOption < 0, "invalid color space selection option");
         if (colorSpaceOption == 1 && iter)
         {
           continue;
@@ -7661,7 +7687,7 @@
     }
   }
 
-  CHECK(cs.tus.size() == 0, "No TUs present");
+  CHECK_VTM(cs.tus.size() == 0, "No TUs present");
 }
 
 uint64_t InterSearch::xGetSymbolFracBitsInter(CodingStructure &cs, Partitioner &partitioner)
@@ -7674,7 +7700,7 @@
   if( cu.firstPU->mergeFlag && !cu.rootCbf )
   {
     cu.skip = true;
-    CHECK(cu.colorTransform, "ACT should not be enabled for skip mode");
+    CHECK_VTM(cu.colorTransform, "ACT should not be enabled for skip mode");
     m_CABACEstimator->cu_skip_flag  ( cu );
     if (cu.firstPU->ciipFlag)
     {
@@ -7688,7 +7714,7 @@
   }
   else
   {
-    CHECK( cu.skip, "Skip flag has to be off at this point!" );
+    CHECK_VTM( cu.skip, "Skip flag has to be off at this point!" );
 
     if (cu.Y().valid())
     m_CABACEstimator->cu_skip_flag( cu );
@@ -7821,7 +7847,7 @@
       mvpUpdated = true;
     }
   }
-  CHECK( !mvpUpdated, "xDetermineBestMvp() error" );
+  CHECK_VTM( !mvpUpdated, "xDetermineBestMvp() error" );
   return minBits;
 }
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/InterSearch.h ../VVCSoftware_10/source/Lib/EncoderLib/InterSearch.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/InterSearch.h	2022-09-16 14:27:06.156532509 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/InterSearch.h	2022-05-13 17:45:29.592141090 +0200
@@ -363,10 +363,11 @@
 
   void setModeCtrl( EncModeCtrl *modeCtrl ) { m_modeCtrl = modeCtrl;}
 
-  void predInterSearch(CodingUnit& cu, Partitioner& partitioner );
+  void predInterSearch(CodingUnit& cu, Partitioner& partitioner, Mv* mvUni = nullptr, int * pocRef = nullptr, unsigned long * costRef = nullptr, RefPicList * refPicList = nullptr, int * pocRefIdx= nullptr);
 
   /// set ME search range
-  void setAdaptiveSearchRange       ( int iDir, int iRefIdx, int iSearchRange) { CHECK(iDir >= MAX_NUM_REF_LIST_ADAPT_SR || iRefIdx>=int(MAX_IDX_ADAPT_SR), "Invalid index"); m_aaiAdaptSR[iDir][iRefIdx] = iSearchRange; }
+  void setAdaptiveSearchRange       ( int iDir, int iRefIdx, int iSearchRange) {
+    CHECK_VTM(iDir >= MAX_NUM_REF_LIST_ADAPT_SR || iRefIdx>=int(MAX_IDX_ADAPT_SR), "Invalid index"); m_aaiAdaptSR[iDir][iRefIdx] = iSearchRange; }
   bool  predIBCSearch           ( CodingUnit& cu, Partitioner& partitioner, const int localSearchRangeX, const int localSearchRangeY, IbcHashMap& ibcHashMap);
   void  xIntraPatternSearch         ( PredictionUnit& pu, IntTZSearchStruct&  cStruct, Mv& rcMv, Distortion&  ruiCost, Mv* cMvSrchRngLT, Mv* cMvSrchRngRB, Mv* pcMvPred);
   void  xSetIntraSearchRange        ( PredictionUnit& pu, int iRoiWidth, int iRoiHeight, const int localSearchRangeX, const int localSearchRangeY, Mv& rcMvSrchRngLT, Mv& rcMvSrchRngRB);
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/IntraSearch.cpp ../VVCSoftware_10/source/Lib/EncoderLib/IntraSearch.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/IntraSearch.cpp	2022-09-16 14:27:06.160532464 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/IntraSearch.cpp	2022-05-13 17:45:29.556141498 +0200
@@ -84,7 +84,7 @@
 
 void IntraSearch::destroy()
 {
-  CHECK( !m_isInitialized, "Not initialized" );
+  CHECK_VTM( !m_isInitialized, "Not initialized" );
 
   if( m_pcEncCfg )
   {
@@ -221,7 +221,7 @@
                        , const unsigned bitDepthY
 )
 {
-  CHECK(m_isInitialized, "Already initialized");
+  CHECK_VTM(m_isInitialized, "Already initialized");
   m_pcEncCfg                     = pcEncCfg;
   m_pcTrQuant                    = pcTrQuant;
   m_pcRdCost                     = pcRdCost;
@@ -386,7 +386,7 @@
   const TempCtx ctxStartIntraMode(m_CtxCache, SubCtx(Ctx::IntraLumaMpmFlag, m_CABACEstimator->getCtx()));
   const TempCtx ctxStartMrlIdx      ( m_CtxCache, SubCtx( Ctx::MultiRefLineIdx,        m_CABACEstimator->getCtx() ) );
 
-  CHECK( !cu.firstPU, "CU has no PUs" );
+  CHECK_VTM( !cu.firstPU, "CU has no PUs" );
   // variables for saving fast intra modes scan results across multiple LFNST passes
   bool LFNSTLoadFlag = sps.getUseLFNST() && cu.lfnstIdx != 0;
   bool LFNSTSaveFlag = sps.getUseLFNST() && cu.lfnstIdx == 0;
@@ -458,7 +458,7 @@
     CandCostList.clear();
     uiHadModeList.clear();
 
-    CHECK(pu.cu != &cu, "PU is not contained in the CU");
+    CHECK_VTM(pu.cu != &cu, "PU is not contained in the CU");
 
     //===== determine set of modes to be tested (using prediction signal only) =====
     int numModesAvailable = NUM_LUMA_MODE; // total number of Intra modes
@@ -496,14 +496,14 @@
       if (mtsUsageFlag != 2)
       {
         // this should always be true
-        CHECK(!pu.Y().valid(), "PU is not valid");
+        CHECK_VTM(!pu.Y().valid(), "PU is not valid");
         bool isFirstLineOfCtu     = (((pu.block(COMPONENT_Y).y) & ((pu.cs->sps)->getMaxCUWidth() - 1)) == 0);
         int  numOfPassesExtendRef = ((!sps.getUseMRL() || isFirstLineOfCtu) ? 1 : MRL_NUM_REF_LINES);
         pu.multiRefIdx            = 0;
 
         if (numModesForFullRD != numModesAvailable)
         {
-          CHECK(numModesForFullRD >= numModesAvailable, "Too many modes for full RD search");
+          CHECK_VTM(numModesForFullRD >= numModesAvailable, "Too many modes for full RD search");
 
           const CompArea &area = pu.Y();
 
@@ -899,7 +899,7 @@
         }
       }
 
-      CHECK(numModesForFullRD != uiRdModeList.size(), "Inconsistent state!");
+      CHECK_VTM(numModesForFullRD != uiRdModeList.size(), "Inconsistent state!");
 
       // after this point, don't use numModesForFullRD
 
@@ -1044,11 +1044,11 @@
       pu.multiRefIdx                 = uiOrgMode.mRefId;
       pu.intraDir[CHANNEL_TYPE_LUMA] = uiOrgMode.modeId;
 
-      CHECK(cu.mipFlag && pu.multiRefIdx, "Error: combination of MIP and MRL not supported");
-      CHECK(pu.multiRefIdx && (pu.intraDir[0] == PLANAR_IDX), "Error: combination of MRL and Planar mode not supported");
-      CHECK(cu.ispMode && cu.mipFlag, "Error: combination of ISP and MIP not supported");
-      CHECK(cu.ispMode && pu.multiRefIdx, "Error: combination of ISP and MRL not supported");
-      CHECK(cu.ispMode&& cu.colorTransform, "Error: combination of ISP and ACT not supported");
+      CHECK_VTM(cu.mipFlag && pu.multiRefIdx, "Error: combination of MIP and MRL not supported");
+      CHECK_VTM(pu.multiRefIdx && (pu.intraDir[0] == PLANAR_IDX), "Error: combination of MRL and Planar mode not supported");
+      CHECK_VTM(cu.ispMode && cu.mipFlag, "Error: combination of ISP and MIP not supported");
+      CHECK_VTM(cu.ispMode && pu.multiRefIdx, "Error: combination of ISP and MRL not supported");
+      CHECK_VTM(cu.ispMode&& cu.colorTransform, "Error: combination of ISP and ACT not supported");
 
       pu.intraDir[CHANNEL_TYPE_CHROMA] = cu.colorTransform ? DM_CHROMA_IDX : pu.intraDir[CHANNEL_TYPE_CHROMA];
 
@@ -1209,7 +1209,7 @@
       cu.bdpcmMode = bestBDPCMMode;
       if (cu.colorTransform)
       {
-        CHECK(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "chroma should use DM mode for adaptive color transform");
+        CHECK_VTM(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "chroma should use DM mode for adaptive color transform");
       }
     }
   }
@@ -1232,7 +1232,7 @@
   double    bestCostSoFar = maxCostAllowed;
   bool      lumaUsesISP   = !cu.isSepTree() && cu.ispMode;
   PartSplit ispType       = lumaUsesISP ? CU::getISPType( cu, COMPONENT_Y ) : TU_NO_ISP;
-  CHECK( cu.ispMode && bestCostSoFar < 0, "bestCostSoFar must be positive!" );
+  CHECK_VTM( cu.ispMode && bestCostSoFar < 0, "bestCostSoFar must be positive!" );
 
   auto &pu = *cu.firstPU;
 
@@ -2769,11 +2769,11 @@
 
   if( partitioner.canSplit( TU_MAX_TR_SPLIT, cs ) )
   {
-    CHECK( !subdiv, "TU split implied" );
+    CHECK_VTM( !subdiv, "TU split implied" );
   }
   else
   {
-    CHECK( subdiv && !currCU.ispMode && isLuma( compID ), "No TU subdivision is allowed with QTBT" );
+    CHECK_VTM( subdiv && !currCU.ispMode && isLuma( compID ), "No TU subdivision is allowed with QTBT" );
   }
 
   if (bChroma)
@@ -2953,7 +2953,7 @@
     m_CABACEstimator->intra_chroma_pred_mode( pu );
     //xEncIntraHeader(cs, partitioner, false, true);
   }
-  CHECK( partitioner.currTrDepth != 1, "error in the depth!" );
+  CHECK_VTM( partitioner.currTrDepth != 1, "error in the depth!" );
   const UnitArea &currArea = partitioner.currArea();
 
   TransformUnit &currTU = *cs.getTU( currArea.blocks[partitioner.chType], partitioner.chType );
@@ -3045,7 +3045,7 @@
   const uint32_t           uiChFinalMode        = PU::getFinalIntraMode(pu, chType);
 
   //===== init availability pattern =====
-  CHECK( tu.jointCbCr && compID == COMPONENT_Cr, "wrong combination of compID and jointCbCr" );
+  CHECK_VTM( tu.jointCbCr && compID == COMPONENT_Cr, "wrong combination of compID and jointCbCr" );
   bool jointCbCr = tu.jointCbCr && compID == COMPONENT_Cb;
 
   if (compID == COMPONENT_Y)
@@ -3356,7 +3356,7 @@
 {
   if (!tu.blocks[compID].valid())
   {
-    CHECK(1, "tu does not exist");
+    CHECK_VTM(1, "tu does not exist");
   }
 
   CodingStructure     &cs = *tu.cs;
@@ -3371,7 +3371,7 @@
   PelBuf              crResi = cs.getResiBuf(crArea);
   TCoeff              uiAbsSum = 0;
 
-  CHECK(tu.jointCbCr && compID == COMPONENT_Cr, "wrong combination of compID and jointCbCr");
+  CHECK_VTM(tu.jointCbCr && compID == COMPONENT_Cr, "wrong combination of compID and jointCbCr");
   bool jointCbCr = tu.jointCbCr && compID == COMPONENT_Cb;
 
   m_pcRdCost->setChromaFormat(cs.sps->getChromaFormatIdc());
@@ -3694,7 +3694,7 @@
       if (m_pcEncCfg->getCostMode() == COST_LOSSLESS_CODING && slice.isLossless())
       {
         nNumTransformCands = 1;
-        CHECK(!tsAllowed && !cu.bdpcmMode, "transform skip should be enabled for LS");
+        CHECK_VTM(!tsAllowed && !cu.bdpcmMode, "transform skip should be enabled for LS");
         if (cu.bdpcmMode)
         {
           trModes.push_back(TrMode(0, true));
@@ -3721,7 +3721,7 @@
       }
     }
 
-    CHECK( !tu.Y().valid(), "Invalid TU" );
+    CHECK_VTM( !tu.Y().valid(), "Invalid TU" );
 
     CodingStructure &saveCS = *m_pSaveCS[0];
 
@@ -4172,10 +4172,10 @@
     tu.depth = currDepth;
     const CodingUnit     &cu = *csFull->getCU(tu.Y().pos(), CHANNEL_TYPE_LUMA);
     const PredictionUnit &pu = *csFull->getPU(tu.Y().pos(), CHANNEL_TYPE_LUMA);
-    CHECK(!tu.Y().valid() || !tu.Cb().valid() || !tu.Cr().valid(), "Invalid TU");
-    CHECK(tu.cu != &cu, "wrong CU fetch");
-    CHECK(cu.ispMode, "adaptive color transform cannot be applied to ISP");
-    CHECK(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "chroma should use DM mode for adaptive color transform");
+    CHECK_VTM(!tu.Y().valid() || !tu.Cb().valid() || !tu.Cr().valid(), "Invalid TU");
+    CHECK_VTM(tu.cu != &cu, "wrong CU fetch");
+    CHECK_VTM(cu.ispMode, "adaptive color transform cannot be applied to ISP");
+    CHECK_VTM(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "chroma should use DM mode for adaptive color transform");
 
     // 1. intra prediction and forward color transform
 
@@ -4264,7 +4264,7 @@
       if (m_pcEncCfg->getCostMode() == COST_LOSSLESS_CODING && slice.isLossless())
       {
         nNumTransformCands = 1;
-        CHECK(!tsAllowed && !cu.bdpcmMode, "transform skip should be enabled for LS");
+        CHECK_VTM(!tsAllowed && !cu.bdpcmMode, "transform skip should be enabled for LS");
         if (cu.bdpcmMode)
         {
           trModes.push_back(TrMode(0, true));
@@ -4501,7 +4501,7 @@
     }
     else
     {
-      CHECK(!validReturnFull, "no transform mode was tested for luma");
+      CHECK_VTM(!validReturnFull, "no transform mode was tested for luma");
     }
 
     csFull->setDecomp(currArea.Y(), true);
@@ -4551,7 +4551,7 @@
       if (m_pcEncCfg->getCostMode() == COST_LOSSLESS_CODING && slice.isLossless())
       {
         numTransformCands = 1;
-        CHECK(!tsAllowed && !cu.bdpcmModeChroma, "transform skip should be enabled for LS");
+        CHECK_VTM(!tsAllowed && !cu.bdpcmModeChroma, "transform skip should be enabled for LS");
         if (cu.bdpcmModeChroma)
         {
           trModes.push_back(TrMode(0, true));
@@ -4877,7 +4877,7 @@
       }
       else
       {
-        CHECK(!tmpValidReturnSplit, "invalid RD of sub-TU partitions for ACT");
+        CHECK_VTM(!tmpValidReturnSplit, "invalid RD of sub-TU partitions for ACT");
       }
     } while (partitioner.nextPart(*csSplit));
 
@@ -4921,7 +4921,7 @@
     }
     else
     {
-      CHECK(!validReturnFull && !validReturnSplit, "illegal TU optimization");
+      CHECK_VTM(!validReturnFull && !validReturnSplit, "illegal TU optimization");
       retVal = true;
     }
   }
@@ -5065,7 +5065,7 @@
       if (m_pcEncCfg->getCostMode() == COST_LOSSLESS_CODING && slice.isLossless())
       {
         nNumTransformCands = 1;
-        CHECK(!tsAllowed && !currTU.cu->bdpcmModeChroma, "transform skip should be enabled for LS");
+        CHECK_VTM(!tsAllowed && !currTU.cu->bdpcmModeChroma, "transform skip should be enabled for LS");
         if (currTU.cu->bdpcmModeChroma)
         {
           trModes.push_back(TrMode(0, true));
@@ -5084,7 +5084,7 @@
           trModes.push_back(TrMode(1, true));   // TS
         }
       }
-      CHECK(!currTU.Cb().valid(), "Invalid TU");
+      CHECK_VTM(!currTU.Cb().valid(), "Invalid TU");
 
       const int  totalModesToTest            = nNumTransformCands;
       bool cbfDCT2 = true;
@@ -5249,7 +5249,7 @@
 
       if (jointCbfMasksToTest.size() && currTU.cu->bdpcmModeChroma)
       {
-        CHECK(!checkTSOnly || checkDCTOnly, "bdpcm only allows transform skip");
+        CHECK_VTM(!checkTSOnly || checkDCTOnly, "bdpcm only allows transform skip");
       }
       for( int cbfMask : jointCbfMasksToTest )
       {
@@ -5506,7 +5506,7 @@
     candNum++;
   }
 
-  CHECK(candNum > FAST_UDI_MAX_RDMODE_NUM, "exceed intra mode candidate list capacity");
+  CHECK_VTM(candNum > FAST_UDI_MAX_RDMODE_NUM, "exceed intra mode candidate list capacity");
 
   return;
 }
@@ -5646,7 +5646,7 @@
   {
     int firstModeThisSplit = ispTestedModes.getTestedIntraMode(nextISPcandSplitType, 0);
     int numSubPartsFirstModeThisSplit = ispTestedModes.getNumCompletedSubParts(nextISPcandSplitType, firstModeThisSplit);
-    CHECK(numSubPartsFirstModeThisSplit < 0, "wrong number of subpartitions!");
+    CHECK_VTM(numSubPartsFirstModeThisSplit < 0, "wrong number of subpartitions!");
     bool stopThisSplit = false;
     bool stopThisSplitAllLfnsts = false;
     if (numSubPartsFirstModeThisSplit < maxNumSubPartitions)
@@ -5790,9 +5790,9 @@
 
       if (refLfnstIdx != -1 && refLfnstIdx != curIspLfnstIdx)
       {
-        CHECK(leftIntraMode != candidate.modeId || rightIntraMode != candidate.modeId, "wrong intra mode and lfnstIdx values!");
+        CHECK_VTM(leftIntraMode != candidate.modeId || rightIntraMode != candidate.modeId, "wrong intra mode and lfnstIdx values!");
         numSubPartsRefMode = m_ispTestedModes[refLfnstIdx].getNumCompletedSubParts((ISPType)candidate.ispMod, candidate.modeId);
-        CHECK(numSubPartsRefMode <= 0, "Wrong value of the number of subpartitions completed!");
+        CHECK_VTM(numSubPartsRefMode <= 0, "Wrong value of the number of subpartitions completed!");
       }
       else
       {
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/IntraSearch.h ../VVCSoftware_10/source/Lib/EncoderLib/IntraSearch.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/IntraSearch.h	2022-09-16 14:27:06.160532464 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/IntraSearch.h	2022-05-13 17:45:29.712139731 +0200
@@ -290,8 +290,8 @@
     int getNumCompletedSubParts(ISPType splitType, int iModeIdx)
     {
       const unsigned st = splitType - 1;
-      CHECK(st < 0 || st > 1, "The split type is invalid!");
-      CHECK(iModeIdx < 0 || iModeIdx >(NUM_LUMA_MODE - 1), "The modeIdx is invalid");
+      CHECK_VTM(st < 0 || st > 1, "The split type is invalid!");
+      CHECK_VTM(iModeIdx < 0 || iModeIdx >(NUM_LUMA_MODE - 1), "The modeIdx is invalid");
       return modeHasBeenTested[iModeIdx][st] ? intraMode[iModeIdx][st].numCompSubParts : -1;
     }
 
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/NALwrite.cpp ../VVCSoftware_10/source/Lib/EncoderLib/NALwrite.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/NALwrite.cpp	2022-09-16 14:27:06.160532464 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/NALwrite.cpp	2022-05-13 17:45:29.860138055 +0200
@@ -53,7 +53,7 @@
   bsNALUHeader.write(forbiddenZero, 1);   // forbidden_zero_bit
   int nuhReservedZeroBit = 0;
   bsNALUHeader.write(nuhReservedZeroBit, 1);   // nuh_reserved_zero_bit
-  CHECK(nalu.m_nuhLayerId > 55, "The value of nuh_layer_id shall be in the range of 0 to 55, inclusive");
+  CHECK_VTM(nalu.m_nuhLayerId > 55, "The value of nuh_layer_id shall be in the range of 0 to 55, inclusive");
   bsNALUHeader.write(nalu.m_nuhLayerId, 6);       // nuh_layer_id
   bsNALUHeader.write(nalu.m_nalUnitType, 5);      // nal_unit_type
   bsNALUHeader.write(nalu.m_temporalId + 1, 3);   // nuh_temporal_id_plus1
Only in ../VVCSoftware_10/source/Lib/EncoderLib: PartitionGlobalManager.h
Only in ../VVCSoftware_10/source/Lib/EncoderLib: PartitionManager.cpp
Only in ../VVCSoftware_10/source/Lib/EncoderLib: PartitionManager.h
Only in ../VVCSoftware_10/source/Lib/EncoderLib: PartitionParam.cpp
Only in ../VVCSoftware_10/source/Lib/EncoderLib: PartitionParam.h
Only in ../VVCSoftware_10/source/Lib/EncoderLib: PartitionPrediction.cpp
Only in ../VVCSoftware_10/source/Lib/EncoderLib: PartitionPrediction.h
Only in ../VVCSoftware_10/source/Lib/EncoderLib: PartitionTree.cpp
Only in ../VVCSoftware_10/source/Lib/EncoderLib: PartitionTree.h
Only in ../VVCSoftware_10/source/Lib/EncoderLib: PartitionUtils.cpp
Only in ../VVCSoftware_10/source/Lib/EncoderLib: PartitionUtils.h
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/RateCtrl.cpp ../VVCSoftware_10/source/Lib/EncoderLib/RateCtrl.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/RateCtrl.cpp	2022-09-16 14:27:06.160532464 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/RateCtrl.cpp	2022-05-13 17:45:29.756139233 +0200
@@ -216,7 +216,7 @@
 
 void EncRCSeq::initPicPara( TRCParameter* picPara )
 {
-  CHECK( m_picPara == NULL, "Object does not exist" );
+  CHECK_VTM( m_picPara == NULL, "Object does not exist" );
 
   if ( picPara == NULL )
   {
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/RateCtrl.h ../VVCSoftware_10/source/Lib/EncoderLib/RateCtrl.h
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/RateCtrl.h	2022-09-16 14:27:06.160532464 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/RateCtrl.h	2022-05-13 17:45:29.692139958 +0200
@@ -123,23 +123,32 @@
   int  getLCUHeight()                   { return m_LCUHeight; }
   int  getNumberOfLevel()               { return m_numberOfLevel; }
   int  getAverageBits()                 { return m_averageBits; }
-  int  getLeftAverageBits()             { CHECK(!( m_framesLeft > 0 ), "No frames left"); return (int)(m_bitsLeft / m_framesLeft); }
+  int  getLeftAverageBits()             {
+    CHECK_VTM(!( m_framesLeft > 0 ), "No frames left"); return (int)(m_bitsLeft / m_framesLeft); }
   bool getUseLCUSeparateModel()         { return m_useLCUSeparateModel; }
 
   int  getNumPixel()                    { return m_numberOfPixel; }
   int64_t  getTargetBits()                { return m_targetBits; }
   int  getNumberOfLCU()                 { return m_numberOfLCU; }
   int* getBitRatio()                    { return m_bitsRatio; }
-  int  getBitRatio( int idx )           { CHECK(!( idx<m_GOPSize), "Idx exceeds GOP size"); return m_bitsRatio[idx]; }
+  int  getBitRatio( int idx )           {
+    CHECK_VTM(!( idx<m_GOPSize), "Idx exceeds GOP size"); return m_bitsRatio[idx]; }
   int* getGOPID2Level()                 { return m_GOPID2Level; }
-  int  getGOPID2Level( int ID )         { CHECK(!( ID < m_GOPSize ), "Idx exceeds GOP size"); return m_GOPID2Level[ID]; }
+  int  getGOPID2Level( int ID )         {
+    CHECK_VTM(!( ID < m_GOPSize ), "Idx exceeds GOP size"); return m_GOPID2Level[ID]; }
   TRCParameter*  getPicPara()                                   { return m_picPara; }
-  TRCParameter   getPicPara( int level )                        { CHECK(!( level < m_numberOfLevel ), "Level too big"); return m_picPara[level]; }
-  void           setPicPara( int level, TRCParameter para )     { CHECK(!( level < m_numberOfLevel ), "Level too big"); m_picPara[level] = para; }
+  TRCParameter   getPicPara( int level )                        {
+    CHECK_VTM(!( level < m_numberOfLevel ), "Level too big"); return m_picPara[level]; }
+  void           setPicPara( int level, TRCParameter para )     {
+    CHECK_VTM(!( level < m_numberOfLevel ), "Level too big"); m_picPara[level] = para; }
   TRCParameter** getLCUPara()                                   { return m_LCUPara; }
-  TRCParameter*  getLCUPara( int level )                        { CHECK(!( level < m_numberOfLevel ), "Level too big"); return m_LCUPara[level]; }
-  TRCParameter   getLCUPara( int level, int LCUIdx )            { CHECK(!( LCUIdx  < m_numberOfLCU ), "LCU id exceeds number of LCU"); return getLCUPara(level)[LCUIdx]; }
-  void           setLCUPara( int level, int LCUIdx, TRCParameter para ) { CHECK(!( level < m_numberOfLevel ), "Level too big"); CHECK(!( LCUIdx  < m_numberOfLCU ), "LCU id exceeds number of LCU"); m_LCUPara[level][LCUIdx] = para; }
+  TRCParameter*  getLCUPara( int level )                        {
+    CHECK_VTM(!( level < m_numberOfLevel ), "Level too big"); return m_LCUPara[level]; }
+  TRCParameter   getLCUPara( int level, int LCUIdx )            {
+    CHECK_VTM(!( LCUIdx  < m_numberOfLCU ), "LCU id exceeds number of LCU"); return getLCUPara(level)[LCUIdx]; }
+  void           setLCUPara( int level, int LCUIdx, TRCParameter para ) {
+    CHECK_VTM(!( level < m_numberOfLevel ), "Level too big");
+    CHECK_VTM(!( LCUIdx  < m_numberOfLCU ), "LCU id exceeds number of LCU"); m_LCUPara[level][LCUIdx] = para; }
 
   int  getFramesLeft()                  { return m_framesLeft; }
   int64_t  getBitsLeft()                  { return m_bitsLeft; }
@@ -344,9 +353,12 @@
 public:
   void       setRCQP ( int QP ) { m_RCQP = QP;   }
   int        getRCQP () const   { return m_RCQP; }
-  EncRCSeq* getRCSeq()          { CHECK( m_encRCSeq == NULL, "Object does not exist" ); return m_encRCSeq; }
-  EncRCGOP* getRCGOP()          { CHECK( m_encRCGOP == NULL, "Object does not exist" ); return m_encRCGOP; }
-  EncRCPic* getRCPic()          { CHECK( m_encRCPic == NULL, "Object does not exist" ); return m_encRCPic; }
+  EncRCSeq* getRCSeq()          {
+    CHECK_VTM( m_encRCSeq == NULL, "Object does not exist" ); return m_encRCSeq; }
+  EncRCGOP* getRCGOP()          {
+    CHECK_VTM( m_encRCGOP == NULL, "Object does not exist" ); return m_encRCGOP; }
+  EncRCPic* getRCPic()          {
+    CHECK_VTM( m_encRCPic == NULL, "Object does not exist" ); return m_encRCPic; }
   list<EncRCPic*>& getPicList() { return m_listRCPictures; }
 #if U0132_TARGET_BITS_SATURATION
   bool       getCpbSaturationEnabled()  { return m_CpbSaturationEnabled;  }
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/SEIEncoder.cpp ../VVCSoftware_10/source/Lib/EncoderLib/SEIEncoder.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/SEIEncoder.cpp	2022-09-16 14:27:06.160532464 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/SEIEncoder.cpp	2022-05-13 17:45:29.780138961 +0200
@@ -46,13 +46,13 @@
 
 void SEIEncoder::initSEIFramePacking(SEIFramePacking *seiFramePacking, int currPicNum)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(seiFramePacking!=NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(seiFramePacking!=NULL), "Unspecified error");
 
   seiFramePacking->m_arrangementId = m_pcCfg->getFramePackingArrangementSEIId();
   seiFramePacking->m_arrangementCancelFlag = 0;
   seiFramePacking->m_arrangementType = m_pcCfg->getFramePackingArrangementSEIType();
-  CHECK(!((seiFramePacking->m_arrangementType > 2) && (seiFramePacking->m_arrangementType < 6) ), "Unspecified error");
+  CHECK_VTM(!((seiFramePacking->m_arrangementType > 2) && (seiFramePacking->m_arrangementType < 6) ), "Unspecified error");
   seiFramePacking->m_quincunxSamplingFlag = m_pcCfg->getFramePackingArrangementSEIQuincunx();
   seiFramePacking->m_contentInterpretationType = m_pcCfg->getFramePackingArrangementSEIInterpretation();
   seiFramePacking->m_spatialFlippingFlag = 0;
@@ -73,16 +73,16 @@
 
 void SEIEncoder::initSEIParameterSetsInclusionIndication(SEIParameterSetsInclusionIndication* seiParameterSetsInclusionIndication)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(seiParameterSetsInclusionIndication != NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(seiParameterSetsInclusionIndication != NULL), "Unspecified error");
 
   seiParameterSetsInclusionIndication->m_selfContainedClvsFlag = m_pcCfg->getSelfContainedClvsFlag();
 }
 
 void SEIEncoder::initSEIBufferingPeriod(SEIBufferingPeriod *bufferingPeriodSEI, bool noLeadingPictures)
 {
-  CHECK(!(m_isInitialized), "bufferingPeriodSEI already initialized");
-  CHECK(!(bufferingPeriodSEI != nullptr), "Need a bufferingPeriodSEI for initialization (got nullptr)");
+  CHECK_VTM(!(m_isInitialized), "bufferingPeriodSEI already initialized");
+  CHECK_VTM(!(bufferingPeriodSEI != nullptr), "Need a bufferingPeriodSEI for initialization (got nullptr)");
 
   uint32_t uiInitialCpbRemovalDelay = (90000/2);                      // 0.5 sec
   bufferingPeriodSEI->m_bpNalCpbParamsPresentFlag = true;
@@ -212,8 +212,8 @@
 
 void SEIEncoder::initSEIErp(SEIEquirectangularProjection* seiEquirectangularProjection)
 {
-  CHECK(!(m_isInitialized), "seiEquirectangularProjection already initialized");
-  CHECK(!(seiEquirectangularProjection != nullptr), "Need a seiEquirectangularProjection for initialization (got nullptr)");
+  CHECK_VTM(!(m_isInitialized), "seiEquirectangularProjection already initialized");
+  CHECK_VTM(!(seiEquirectangularProjection != nullptr), "Need a seiEquirectangularProjection for initialization (got nullptr)");
 
   seiEquirectangularProjection->m_erpCancelFlag = m_pcCfg->getErpSEICancelFlag();
   if (!seiEquirectangularProjection->m_erpCancelFlag)
@@ -231,8 +231,8 @@
 
 void SEIEncoder::initSEISphereRotation(SEISphereRotation* seiSphereRotation)
 {
-  CHECK(!(m_isInitialized), "seiSphereRotation already initialized");
-  CHECK(!(seiSphereRotation != nullptr), "Need a seiSphereRotation for initialization (got nullptr)");
+  CHECK_VTM(!(m_isInitialized), "seiSphereRotation already initialized");
+  CHECK_VTM(!(seiSphereRotation != nullptr), "Need a seiSphereRotation for initialization (got nullptr)");
 
   seiSphereRotation->m_sphereRotationCancelFlag = m_pcCfg->getSphereRotationSEICancelFlag();
   if ( !seiSphereRotation->m_sphereRotationCancelFlag )
@@ -246,8 +246,8 @@
 
 void SEIEncoder::initSEIOmniViewport(SEIOmniViewport* seiOmniViewport)
 {
-  CHECK(!(m_isInitialized), "seiOmniViewport already initialized");
-  CHECK(!(seiOmniViewport != nullptr), "Need a seiOmniViewport for initialization (got nullptr)");
+  CHECK_VTM(!(m_isInitialized), "seiOmniViewport already initialized");
+  CHECK_VTM(!(seiOmniViewport != nullptr), "Need a seiOmniViewport for initialization (got nullptr)");
 
   seiOmniViewport->m_omniViewportId = m_pcCfg->getOmniViewportSEIId();
   seiOmniViewport->m_omniViewportCancelFlag = m_pcCfg->getOmniViewportSEICancelFlag();
@@ -271,8 +271,8 @@
 
 void SEIEncoder::initSEIRegionWisePacking(SEIRegionWisePacking *seiRegionWisePacking)
 {
-  CHECK(!(m_isInitialized), "seiRegionWisePacking already initialized");
-  CHECK(!(seiRegionWisePacking != nullptr), "Need a seiRegionWisePacking for initialization (got nullptr)");
+  CHECK_VTM(!(m_isInitialized), "seiRegionWisePacking already initialized");
+  CHECK_VTM(!(seiRegionWisePacking != nullptr), "Need a seiRegionWisePacking for initialization (got nullptr)");
 
   seiRegionWisePacking->m_rwpCancelFlag                          = m_pcCfg->getRwpSEIRwpCancelFlag();
   seiRegionWisePacking->m_rwpPersistenceFlag                     = m_pcCfg->getRwpSEIRwpPersistenceFlag();
@@ -327,8 +327,8 @@
 
 void SEIEncoder::initSEIGcmp(SEIGeneralizedCubemapProjection* seiGeneralizedCubemapProjection)
 {
-  CHECK(!(m_isInitialized), "seiGeneralizedCubemapProjection already initialized");
-  CHECK(!(seiGeneralizedCubemapProjection != nullptr), "Need a seiGeneralizedCubemapProjection for initialization (got nullptr)");
+  CHECK_VTM(!(m_isInitialized), "seiGeneralizedCubemapProjection already initialized");
+  CHECK_VTM(!(seiGeneralizedCubemapProjection != nullptr), "Need a seiGeneralizedCubemapProjection for initialization (got nullptr)");
 
   seiGeneralizedCubemapProjection->m_gcmpCancelFlag                      = m_pcCfg->getGcmpSEICancelFlag();
   if (!seiGeneralizedCubemapProjection->m_gcmpCancelFlag)
@@ -372,8 +372,8 @@
 
 void SEIEncoder::initSEISampleAspectRatioInfo(SEISampleAspectRatioInfo* seiSampleAspectRatioInfo)
 {
-  CHECK(!(m_isInitialized), "seiSampleAspectRatioInfo already initialized");
-  CHECK(!(seiSampleAspectRatioInfo != nullptr), "Need a seiSampleAspectRatioInfo for initialization (got nullptr)");
+  CHECK_VTM(!(m_isInitialized), "seiSampleAspectRatioInfo already initialized");
+  CHECK_VTM(!(seiSampleAspectRatioInfo != nullptr), "Need a seiSampleAspectRatioInfo for initialization (got nullptr)");
 
   seiSampleAspectRatioInfo->m_sariCancelFlag = m_pcCfg->getSariCancelFlag();
   if (!seiSampleAspectRatioInfo->m_sariCancelFlag)
@@ -399,9 +399,9 @@
 //  either targetOLS or targetLayer should be active, call with empty vector for the inactive mode
 void SEIEncoder::initSEIScalableNesting(SEIScalableNesting *scalableNestingSEI, SEIMessages &nestedSEIs, const std::vector<int> &targetOLSs, const std::vector<int> &targetLayers, const std::vector<uint16_t> &subpictureIDs)
 {
-  CHECK(!(m_isInitialized), "Scalable Nesting SEI already initialized ");
-  CHECK(!(scalableNestingSEI != NULL), "No Scalable Nesting SEI object passed");
-  CHECK (targetOLSs.size() > 0 && targetLayers.size() > 0, "Scalable Nesting SEI can apply to either OLS or layer(s), not both");
+  CHECK_VTM(!(m_isInitialized), "Scalable Nesting SEI already initialized ");
+  CHECK_VTM(!(scalableNestingSEI != NULL), "No Scalable Nesting SEI object passed");
+  CHECK_VTM(targetOLSs.size() > 0 && targetLayers.size() > 0, "Scalable Nesting SEI can apply to either OLS or layer(s), not both");
 
   scalableNestingSEI->m_snOlsFlag = (targetOLSs.size() > 0) ? 1 : 0;  // If the nested SEI messages are picture buffering SEI messages, picture timing SEI messages or sub-picture timing SEI messages, nesting_ols_flag shall be equal to 1, by default case
   if (scalableNestingSEI->m_snOlsFlag)
@@ -417,13 +417,13 @@
     {
       if (i == 0)
       {
-        CHECK (scalableNestingSEI->m_snOlsIdx[i] < 0, "OLS indexes must be  equal to or greater than 0");
+        CHECK_VTM(scalableNestingSEI->m_snOlsIdx[i] < 0, "OLS indexes must be  equal to or greater than 0");
         // no "-1" operation for the first index although the name implies one
         scalableNestingSEI->m_snOlsIdxDeltaMinus1[i] = scalableNestingSEI->m_snOlsIdx[i];
       }
       else
       {
-        CHECK (scalableNestingSEI->m_snOlsIdx[i] <= scalableNestingSEI->m_snOlsIdx[i - 1], "OLS indexes must be in ascending order");
+        CHECK_VTM(scalableNestingSEI->m_snOlsIdx[i] <= scalableNestingSEI->m_snOlsIdx[i - 1], "OLS indexes must be in ascending order");
         scalableNestingSEI->m_snOlsIdxDeltaMinus1[i] = scalableNestingSEI->m_snOlsIdx[i] - scalableNestingSEI->m_snOlsIdx[i - 1] - 1;
       }
     }
@@ -443,7 +443,7 @@
     scalableNestingSEI->m_snNumSubpics = (uint32_t) subpictureIDs.size();
     scalableNestingSEI->m_snSubpicId   = subpictureIDs;
     scalableNestingSEI->m_snSubpicIdLen = max(1, ceilLog2((*std::max_element(subpictureIDs.begin(), subpictureIDs.end())) + 1));
-    CHECK ( scalableNestingSEI->m_snSubpicIdLen > 15, "Subpicture ID too large. Length must be <= 15 bits");
+    CHECK_VTM( scalableNestingSEI->m_snSubpicIdLen > 15, "Subpicture ID too large. Length must be <= 15 bits");
   }
   scalableNestingSEI->m_nestedSEIs.clear();
   for (SEIMessages::iterator it = nestedSEIs.begin(); it != nestedSEIs.end(); it++)
@@ -456,8 +456,8 @@
 //! calculate hashes for entire reconstructed picture
 void SEIEncoder::initDecodedPictureHashSEI(SEIDecodedPictureHash *decodedPictureHashSEI, PelUnitBuf& pic, std::string &rHashString, const BitDepths &bitDepths)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(decodedPictureHashSEI!=NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(decodedPictureHashSEI!=NULL), "Unspecified error");
 
   decodedPictureHashSEI->method = m_pcCfg->getDecodedPictureHashSEIType();
   switch (m_pcCfg->getDecodedPictureHashSEIType())
@@ -486,8 +486,8 @@
 
 void SEIEncoder::initSEIDependentRAPIndication(SEIDependentRAPIndication *seiDependentRAPIndication)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(seiDependentRAPIndication!=NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(seiDependentRAPIndication!=NULL), "Unspecified error");
 }
 
 
@@ -562,16 +562,16 @@
 #if U0033_ALTERNATIVE_TRANSFER_CHARACTERISTICS_SEI
 void SEIEncoder::initSEIAlternativeTransferCharacteristics(SEIAlternativeTransferCharacteristics *seiAltTransCharacteristics)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(seiAltTransCharacteristics!=NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(seiAltTransCharacteristics!=NULL), "Unspecified error");
   //  Set SEI message parameters read from command line options
   seiAltTransCharacteristics->m_preferredTransferCharacteristics = m_pcCfg->getSEIPreferredTransferCharacteristics();
 }
 #endif
 void SEIEncoder::initSEIFilmGrainCharacteristics(SEIFilmGrainCharacteristics *seiFilmGrain)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(seiFilmGrain != NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(seiFilmGrain != NULL), "Unspecified error");
   //  Set SEI message parameters read from command line options
   seiFilmGrain->m_filmGrainCharacteristicsCancelFlag      = m_pcCfg->getFilmGrainCharactersticsSEICancelFlag();
   seiFilmGrain->m_filmGrainCharacteristicsPersistenceFlag = m_pcCfg->getFilmGrainCharactersticsSEIPersistenceFlag();
@@ -587,8 +587,8 @@
 
 void SEIEncoder::initSEIMasteringDisplayColourVolume(SEIMasteringDisplayColourVolume *seiMDCV)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(seiMDCV != NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(seiMDCV != NULL), "Unspecified error");
   //  Set SEI message parameters read from command line options
   for (int j = 0; j <= 1; j++)
   {
@@ -604,8 +604,8 @@
 
 void SEIEncoder::initSEIContentLightLevel(SEIContentLightLevelInfo *seiCLL)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(seiCLL != NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(seiCLL != NULL), "Unspecified error");
   //  Set SEI message parameters read from command line options
   seiCLL->m_maxContentLightLevel    = m_pcCfg->getCLLSEIMaxContentLightLevel();
   seiCLL->m_maxPicAverageLightLevel = m_pcCfg->getCLLSEIMaxPicAvgLightLevel();
@@ -613,8 +613,8 @@
 
 void SEIEncoder::initSEIAmbientViewingEnvironment(SEIAmbientViewingEnvironment *seiAmbViewEnvironment)
 {
-  CHECK(!(m_isInitialized), "Unspecified error");
-  CHECK(!(seiAmbViewEnvironment != NULL), "Unspecified error");
+  CHECK_VTM(!(m_isInitialized), "Unspecified error");
+  CHECK_VTM(!(seiAmbViewEnvironment != NULL), "Unspecified error");
   //  Set SEI message parameters read from command line options
   seiAmbViewEnvironment->m_ambientIlluminance = m_pcCfg->getAmbientViewingEnvironmentSEIIlluminance();
   seiAmbViewEnvironment->m_ambientLightX      = m_pcCfg->getAmbientViewingEnvironmentSEIAmbientLightX();
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/SEIwrite.cpp ../VVCSoftware_10/source/Lib/EncoderLib/SEIwrite.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/SEIwrite.cpp	2022-09-16 14:27:06.160532464 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/SEIwrite.cpp	2022-05-13 17:45:29.668140230 +0200
@@ -51,7 +51,7 @@
     break;
   case SEI::DECODING_UNIT_INFO:
     bp = hrd.getBufferingPeriodSEI();
-    CHECK (bp == nullptr, "Buffering Period need to be initialized in HRD to allow writing of Decoding Unit Information SEI");
+    CHECK_VTM(bp == nullptr, "Buffering Period need to be initialized in HRD to allow writing of Decoding Unit Information SEI");
     xWriteSEIDecodingUnitInfo(*static_cast<const SEIDecodingUnitInfo*>(& sei), *bp, temporalId);
     break;
   case SEI::SCALABLE_NESTING:
@@ -67,7 +67,7 @@
   case SEI::PICTURE_TIMING:
     {
       bp = hrd.getBufferingPeriodSEI();
-      CHECK (bp == nullptr, "Buffering Period need to be initialized in HRD to allow writing of Picture Timing SEI");
+      CHECK_VTM(bp == nullptr, "Buffering Period need to be initialized in HRD to allow writing of Picture Timing SEI");
       xWriteSEIPictureTiming(*static_cast<const SEIPictureTiming*>(&sei), *bp, temporalId);
     }
     break;
@@ -162,7 +162,7 @@
     g_HLSTraceEnable = traceEnable;
 #endif
     uint32_t payload_data_num_bits = bs_count.getNumberOfWrittenBits();
-    CHECK(0 != payload_data_num_bits % 8, "Invalid number of payload data bits");
+    CHECK_VTM(0 != payload_data_num_bits % 8, "Invalid number of payload data bits");
 
     setBitstream(&bs);
     uint32_t payloadType = (*sei)->payloadType();
@@ -265,19 +265,19 @@
 {
   WRITE_FLAG( sei.m_bpNalCpbParamsPresentFlag, "bp_nal_hrd_parameters_present_flag");
   WRITE_FLAG( sei.m_bpVclCpbParamsPresentFlag, "bp_vcl_hrd_parameters_present_flag");
-  CHECK(!sei.m_bpNalCpbParamsPresentFlag && !sei.m_bpVclCpbParamsPresentFlag, "bp_nal_hrd_parameters_present_flag and/or bp_vcl_hrd_parameters_present_flag must be true");
-  CHECK (sei.m_initialCpbRemovalDelayLength < 1, "sei.m_initialCpbRemovalDelayLength must be > 0");
+  CHECK_VTM(!sei.m_bpNalCpbParamsPresentFlag && !sei.m_bpVclCpbParamsPresentFlag, "bp_nal_hrd_parameters_present_flag and/or bp_vcl_hrd_parameters_present_flag must be true");
+  CHECK_VTM(sei.m_initialCpbRemovalDelayLength < 1, "sei.m_initialCpbRemovalDelayLength must be > 0");
   WRITE_CODE( sei.m_initialCpbRemovalDelayLength - 1, 5, "initial_cpb_removal_delay_length_minus1" );
-  CHECK (sei.m_cpbRemovalDelayLength < 1, "sei.m_cpbRemovalDelayLength must be > 0");
+  CHECK_VTM(sei.m_cpbRemovalDelayLength < 1, "sei.m_cpbRemovalDelayLength must be > 0");
   WRITE_CODE( sei.m_cpbRemovalDelayLength - 1,        5, "cpb_removal_delay_length_minus1" );
-  CHECK (sei.m_dpbOutputDelayLength < 1, "sei.m_dpbOutputDelayLength must be > 0");
+  CHECK_VTM(sei.m_dpbOutputDelayLength < 1, "sei.m_dpbOutputDelayLength must be > 0");
   WRITE_CODE( sei.m_dpbOutputDelayLength - 1,         5, "dpb_output_delay_length_minus1" );
   WRITE_FLAG( sei.m_bpDecodingUnitHrdParamsPresentFlag, "bp_decoding_unit_hrd_params_present_flag"  );
   if( sei.m_bpDecodingUnitHrdParamsPresentFlag )
   {
-    CHECK (sei.m_duCpbRemovalDelayIncrementLength < 1, "sei.m_duCpbRemovalDelayIncrementLength must be > 0");
+    CHECK_VTM(sei.m_duCpbRemovalDelayIncrementLength < 1, "sei.m_duCpbRemovalDelayIncrementLength must be > 0");
     WRITE_CODE( sei.m_duCpbRemovalDelayIncrementLength - 1, 5, "du_cpb_removal_delay_increment_length_minus1" );
-    CHECK (sei.m_dpbOutputDelayDuLength < 1, "sei.m_dpbOutputDelayDuLength must be > 0");
+    CHECK_VTM(sei.m_dpbOutputDelayDuLength < 1, "sei.m_dpbOutputDelayDuLength must be > 0");
     WRITE_CODE( sei.m_dpbOutputDelayDuLength - 1, 5, "dpb_output_delay_du_length_minus1" );
     WRITE_FLAG( sei.m_decodingUnitCpbParamsInPicTimingSeiFlag, "decoding_unit_cpb_params_in_pic_timing_sei_flag" );
     WRITE_FLAG(sei.m_decodingUnitDpbDuParamsInPicTimingSeiFlag, "decoding_unit_dpb_du_params_in_pic_timing_sei_flag");
@@ -290,10 +290,10 @@
     WRITE_CODE( sei.m_maxInitialRemovalDelayForConcatenation, sei.m_initialCpbRemovalDelayLength, "max_initial_removal_delay_for_concatenation" );
   }
 
-  CHECK (sei.m_auCpbRemovalDelayDelta < 1, "sei.m_auCpbRemovalDelayDelta must be > 0");
+  CHECK_VTM(sei.m_auCpbRemovalDelayDelta < 1, "sei.m_auCpbRemovalDelayDelta must be > 0");
   WRITE_CODE( sei.m_auCpbRemovalDelayDelta - 1, sei.m_cpbRemovalDelayLength, "au_cpb_removal_delay_delta_minus1" );
 
-  CHECK(sei.m_bpMaxSubLayers < 1, "bp_max_sub_layers_minus1 must be > 0");
+  CHECK_VTM(sei.m_bpMaxSubLayers < 1, "bp_max_sub_layers_minus1 must be > 0");
   WRITE_CODE(sei.m_bpMaxSubLayers - 1, 3, "bp_max_sub_layers_minus1");
   if (sei.m_bpMaxSubLayers - 1 > 0)
   {
@@ -302,14 +302,14 @@
 
   if (sei.m_cpbRemovalDelayDeltasPresentFlag)
   {
-    CHECK (sei.m_numCpbRemovalDelayDeltas < 1, "m_numCpbRemovalDelayDeltas must be > 0");
+    CHECK_VTM(sei.m_numCpbRemovalDelayDeltas < 1, "m_numCpbRemovalDelayDeltas must be > 0");
     WRITE_UVLC( sei.m_numCpbRemovalDelayDeltas - 1, "num_cpb_removal_delay_deltas_minus1" );
     for( int i = 0; i < sei.m_numCpbRemovalDelayDeltas; i ++ )
     {
       WRITE_CODE( sei.m_cpbRemovalDelayDelta[i],        sei.m_cpbRemovalDelayLength, "cpb_removal_delay_delta[i]" );
     }
   }
-  CHECK (sei.m_bpCpbCnt < 1, "sei.m_bpCpbCnt must be > 0");
+  CHECK_VTM(sei.m_bpCpbCnt < 1, "sei.m_bpCpbCnt must be > 0");
   WRITE_UVLC( sei.m_bpCpbCnt - 1, "bp_cpb_cnt_minus1");
   if (sei.m_bpMaxSubLayers - 1 > 0)
   {
@@ -484,7 +484,7 @@
 
 void SEIWriter::xWriteSEIScalableNesting(OutputBitstream& bs, const SEIScalableNesting& sei)
 {
-  CHECK (sei.m_nestedSEIs.size()<1, "There must be at lease one SEI message nested in the scalable nesting SEI.")
+  CHECK_VTM(sei.m_nestedSEIs.size()<1, "There must be at lease one SEI message nested in the scalable nesting SEI.")
 
   WRITE_FLAG(sei.m_snOlsFlag, "sn_ols_flag");
   WRITE_FLAG(sei.m_snSubpicFlag, "sn_subpic_flag");
@@ -511,7 +511,7 @@
   if (sei.m_snSubpicFlag)
   {
     WRITE_UVLC( sei.m_snNumSubpics - 1, "sn_num_subpics_minus1");
-    CHECK(sei.m_snSubpicIdLen < 1, "sn_subpic_id_len_minus1 must be >= 0");
+    CHECK_VTM(sei.m_snSubpicIdLen < 1, "sn_subpic_id_len_minus1 must be >= 0");
     WRITE_UVLC( sei.m_snSubpicIdLen - 1, "sn_subpic_id_len_minus1");
     for (uint32_t i = 0; i < sei.m_snNumSubpics; i++)
     {
@@ -742,11 +742,11 @@
 
 void SEIWriter::xWriteSEISubpictureLevelInfo(const SEISubpicureLevelInfo &sei)
 {
-  CHECK(sei.m_numRefLevels < 1, "SEISubpicureLevelInfo: numRefLevels must be greater than zero");
-  CHECK(sei.m_numRefLevels != (int)sei.m_refLevelIdc.size(), "SEISubpicureLevelInfo: numRefLevels must be equal to the number of levels");
+  CHECK_VTM(sei.m_numRefLevels < 1, "SEISubpicureLevelInfo: numRefLevels must be greater than zero");
+  CHECK_VTM(sei.m_numRefLevels != (int)sei.m_refLevelIdc.size(), "SEISubpicureLevelInfo: numRefLevels must be equal to the number of levels");
   if (sei.m_explicitFractionPresentFlag)
   {
-    CHECK(sei.m_numRefLevels != (int)sei.m_refLevelFraction.size(), "SEISubpicureLevelInfo: numRefLevels must be equal to the number of fractions");
+    CHECK_VTM(sei.m_numRefLevels != (int)sei.m_refLevelFraction.size(), "SEISubpicureLevelInfo: numRefLevels must be equal to the number of fractions");
   }
   WRITE_CODE( (uint32_t)sei.m_numRefLevels - 1, 3,                            "sli_num_ref_levels_minus1");
   WRITE_FLAG(           sei.m_cbrConstraintFlag,                              "sli_cbr_constraint_flag");
@@ -770,7 +770,7 @@
       WRITE_CODE((uint32_t)sei.m_refLevelIdc[i][k], 8, "sli_ref_level_idc[i][k]");
       if (sei.m_explicitFractionPresentFlag)
       {
-        CHECK(sei.m_numSubpics != (int)sei.m_refLevelFraction[i].size(), "SEISubpicureLevelInfo: number of fractions differs from number of subpictures");
+        CHECK_VTM(sei.m_numSubpics != (int)sei.m_refLevelFraction[i].size(), "SEISubpicureLevelInfo: number of fractions differs from number of subpictures");
         for (int j = 0; j < sei.m_numSubpics; j++)
         {
           WRITE_CODE((uint32_t)sei.m_refLevelFraction[i][j][k], 8, "sli_ref_level_fraction_minus1[i][j][k]");
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/VLCWriter.cpp ../VVCSoftware_10/source/Lib/EncoderLib/VLCWriter.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/VLCWriter.cpp	2022-09-16 14:27:06.160532464 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/VLCWriter.cpp	2022-05-13 17:45:29.508142042 +0200
@@ -124,7 +124,7 @@
 
 void VLCWriter::xWriteCode     ( uint32_t uiCode, uint32_t uiLength )
 {
-  CHECK( uiLength == 0, "Code of length '0' not supported" );
+  CHECK_VTM( uiLength == 0, "Code of length '0' not supported" );
   m_pcBitIf->write( uiCode, uiLength );
 }
 
@@ -133,7 +133,7 @@
   uint32_t uiLength = 1;
   uint32_t uiTemp = ++uiCode;
 
-  CHECK( !uiTemp, "Integer overflow" );
+  CHECK_VTM( !uiTemp, "Integer overflow" );
 
   while( 1 != uiTemp )
   {
@@ -165,7 +165,7 @@
     WRITE_FLAG( 0, "rbsp_alignment_zero_bit");
     cnt++;
   }
-  CHECK(cnt>=8, "More than '8' alignment bytes read");
+  CHECK_VTM(cnt>=8, "More than '8' alignment bytes read");
 }
 
 void AUDWriter::codeAUD(OutputBitstream& bs, const bool audIrapOrGdrAuFlag, const int pictureType)
@@ -174,7 +174,7 @@
   xTraceAccessUnitDelimiter();
 #endif
 
-  CHECK(pictureType >= 3, "Invalid picture type");
+  CHECK_VTM(pictureType >= 3, "Invalid picture type");
   setBitstream(&bs);
   WRITE_FLAG(audIrapOrGdrAuFlag, "aud_irap_or_gdr_au_flag");
   WRITE_CODE(pictureType, 3, "pic_type");
@@ -216,7 +216,7 @@
 
       if( rpl->isInterLayerRefPic( ii ) )
       {
-        CHECK( rpl->getInterLayerRefPicIdx( ii ) < 0, "Wrong inter-layer reference index" );
+        CHECK_VTM( rpl->getInterLayerRefPicIdx( ii ) < 0, "Wrong inter-layer reference index" );
         WRITE_UVLC( rpl->getInterLayerRefPicIdx( ii ), "ilrp_idx[ listIdx ][ rplsIdx ][ i ]" );
       }
     }
@@ -243,7 +243,7 @@
       unsigned int absDeltaValue = (deltaValue < 0) ? 0 - deltaValue : deltaValue;
       if (isForbiddenZeroDeltaPoc || ii == 0)
       {
-        CHECK(!absDeltaValue, "Zero delta POC is not used without WP or is the 0-th entry");
+        CHECK_VTM(!absDeltaValue, "Zero delta POC is not used without WP or is the 0-th entry");
         WRITE_UVLC( absDeltaValue - 1, "abs_delta_poc_st[ listIdx ][ rplsIdx ][ i ]" );
       }
       else
@@ -299,15 +299,15 @@
   WRITE_FLAG( pcPPS->getSubPicIdMappingInPpsFlag() ? 1 : 0, "pps_subpic_id_mapping_present_flag" );
   if( pcPPS->getSubPicIdMappingInPpsFlag() )
   {
-    CHECK(pcPPS->getNumSubPics() < 1, "PPS: NumSubPics cannot be less than 1");
+    CHECK_VTM(pcPPS->getNumSubPics() < 1, "PPS: NumSubPics cannot be less than 1");
     if( !pcPPS->getNoPicPartitionFlag() )
     {
       WRITE_UVLC(pcPPS->getNumSubPics() - 1, "pps_num_subpics_minus1");
     }
-    CHECK(pcPPS->getSubPicIdLen() < 1, "PPS: SubPicIdLen cannot be less than 1");
+    CHECK_VTM(pcPPS->getSubPicIdLen() < 1, "PPS: SubPicIdLen cannot be less than 1");
     WRITE_UVLC( pcPPS->getSubPicIdLen() - 1, "pps_subpic_id_len_minus1" );
 
-    CHECK((1 << pcPPS->getSubPicIdLen()) < pcPPS->getNumSubPics(), "pps_subpic_id_len exceeds valid range");
+    CHECK_VTM((1 << pcPPS->getSubPicIdLen()) < pcPPS->getNumSubPics(), "pps_subpic_id_len exceeds valid range");
     for( int picIdx = 0; picIdx < pcPPS->getNumSubPics( ); picIdx++ )
     {
       WRITE_CODE( pcPPS->getSubPicId(picIdx), pcPPS->getSubPicIdLen( ), "pps_subpic_id[i]" );
@@ -389,7 +389,7 @@
             expSliceHeightSum += pcPPS->getSliceHeightInCtu(i + j);
           }
 
-          CHECK( expSliceHeightSum > pcPPS->getTileRowHeight(pcPPS->getSliceTileIdx(i) / pcPPS->getNumTileColumns()), "The sum of expressed slice heights is larger than the height of the tile containing the slices.");
+          CHECK_VTM( expSliceHeightSum > pcPPS->getTileRowHeight(pcPPS->getSliceTileIdx(i) / pcPPS->getNumTileColumns()), "The sum of expressed slice heights is larger than the height of the tile containing the slices.");
           i += (pcPPS->getNumSlicesInTile(i) - 1);
         }
 
@@ -569,8 +569,8 @@
     if (paramCcAlf.newCcAlfFilter[ccIdx])
     {
       const int filterCount = paramCcAlf.ccAlfFilterCount[ccIdx];
-      CHECK(filterCount > MAX_NUM_CC_ALF_FILTERS, "CC ALF Filter count is too large");
-      CHECK(filterCount == 0, "CC ALF Filter count is too small");
+      CHECK_VTM(filterCount > MAX_NUM_CC_ALF_FILTERS, "CC ALF Filter count is too large");
+      CHECK_VTM(filterCount == 0, "CC ALF Filter count is too small");
 
       if (MAX_NUM_CC_ALF_FILTERS > 1)
       {
@@ -774,7 +774,7 @@
 {
   for (uint32_t i = (subLayerInfoFlag ? 0 : maxSubLayersMinus1); i <= maxSubLayersMinus1; i++)
   {
-    CHECK(pcSPS->getMaxDecPicBuffering(i) < 1, "MaxDecPicBuffering must be greater than 0");
+    CHECK_VTM(pcSPS->getMaxDecPicBuffering(i) < 1, "MaxDecPicBuffering must be greater than 0");
     WRITE_UVLC(pcSPS->getMaxDecPicBuffering(i) - 1, "dpb_max_dec_pic_buffering_minus1[i]");
     WRITE_UVLC(pcSPS->getMaxNumReorderPics(i), "dpb_max_num_reorder_pics[i]");
     WRITE_UVLC(pcSPS->getMaxLatencyIncreasePlus1(i), "dpb_max_latency_increase_plus1[i]");
@@ -788,7 +788,7 @@
 #endif
   WRITE_CODE(pcSPS->getSPSId(), 4, "sps_seq_parameter_set_id");
   WRITE_CODE( pcSPS->getVPSId(), 4, "sps_video_parameter_set_id" );
-  CHECK(pcSPS->getMaxTLayers() == 0, "Maximum number of temporal sub-layers is '0'");
+  CHECK_VTM(pcSPS->getMaxTLayers() == 0, "Maximum number of temporal sub-layers is '0'");
 
   WRITE_CODE(pcSPS->getMaxTLayers() - 1, 3, "sps_max_sub_layers_minus1");
   WRITE_CODE(int(pcSPS->getChromaFormatIdc()), 2, "sps_chroma_format_idc");
@@ -797,7 +797,7 @@
 
   if( !pcSPS->getVPSId() )
   {
-    CHECK( !pcSPS->getPtlDpbHrdParamsPresentFlag(), "When sps_video_parameter_set_id is equal to 0, the value of sps_ptl_dpb_hrd_params_present_flag shall be equal to 1" );
+    CHECK_VTM( !pcSPS->getPtlDpbHrdParamsPresentFlag(), "When sps_video_parameter_set_id is equal to 0, the value of sps_ptl_dpb_hrd_params_present_flag shall be equal to 1" );
   }
 
   if (pcSPS->getPtlDpbHrdParamsPresentFlag())
@@ -813,7 +813,7 @@
   {
     WRITE_FLAG(pcSPS->getResChangeInClvsEnabledFlag(), "sps_res_change_in_clvs_allowed_flag");
   }
-  CHECK(!pcSPS->getRprEnabledFlag() && pcSPS->getResChangeInClvsEnabledFlag(), "When sps_ref_pic_resampling_enabled_flag is equal to 0, sps_res_change_in_clvs_allowed_flag shall be equal to 0");
+  CHECK_VTM(!pcSPS->getRprEnabledFlag() && pcSPS->getResChangeInClvsEnabledFlag(), "When sps_ref_pic_resampling_enabled_flag is equal to 0, sps_res_change_in_clvs_allowed_flag shall be equal to 0");
 
   WRITE_UVLC( pcSPS->getMaxPicWidthInLumaSamples(), "sps_pic_width_max_in_luma_samples" );
   WRITE_UVLC( pcSPS->getMaxPicHeightInLumaSamples(), "sps_pic_height_max_in_luma_samples" );
@@ -832,7 +832,7 @@
 
   if (pcSPS->getSubPicInfoPresentFlag())
   {
-    CHECK(pcSPS->getNumSubPics() < 1, "SPS: NumSubPics cannot be less than 1");
+    CHECK_VTM(pcSPS->getNumSubPics() < 1, "SPS: NumSubPics cannot be less than 1");
     WRITE_UVLC(pcSPS->getNumSubPics() - 1, "sps_num_subpics_minus1");
     if( pcSPS->getNumSubPics() > 1 )
     {
@@ -869,7 +869,7 @@
       }
     }
 
-    CHECK(pcSPS->getSubPicIdLen() < 1, "SPS: SubPicIdLen cannot be less than 1");
+    CHECK_VTM(pcSPS->getSubPicIdLen() < 1, "SPS: SubPicIdLen cannot be less than 1");
     WRITE_UVLC(pcSPS->getSubPicIdLen() - 1, "sps_subpic_id_len_minus1");
     WRITE_FLAG(pcSPS->getSubPicIdMappingExplicitlySignalledFlag(), "sps_subpic_id_mapping_explicitly_signalled_flag");
     if (pcSPS->getSubPicIdMappingExplicitlySignalledFlag())
@@ -888,7 +888,7 @@
   const Profile::Name profile = pcSPS->getProfileTierLevel()->getProfileIdc();
   if (profile != Profile::NONE)
   {
-    CHECK(pcSPS->getBitDepth(CHANNEL_TYPE_LUMA) > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "sps_bitdepth_minus8 exceeds range supported by signalled profile");
+    CHECK_VTM(pcSPS->getBitDepth(CHANNEL_TYPE_LUMA) > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "sps_bitdepth_minus8 exceeds range supported by signalled profile");
   }
   WRITE_UVLC(pcSPS->getBitDepth(CHANNEL_TYPE_LUMA) - 8, "sps_bitdepth_minus8");
   WRITE_FLAG( pcSPS->getEntropyCodingSyncEnabledFlag() ? 1 : 0, "sps_entropy_coding_sync_enabled_flag" );
@@ -916,7 +916,7 @@
     }
     dpb_parameters(pcSPS->getMaxTLayers() - 1, pcSPS->getSubLayerDpbParamsFlag(), pcSPS);
   }
-  CHECK( pcSPS->getMaxCUWidth() != pcSPS->getMaxCUHeight(),                          "Rectangular CTUs not supported" );
+  CHECK_VTM( pcSPS->getMaxCUWidth() != pcSPS->getMaxCUHeight(),                          "Rectangular CTUs not supported" );
   WRITE_UVLC(pcSPS->getLog2MinCodingBlockSize() - 2, "sps_log2_min_luma_coding_block_size_minus2");
   WRITE_FLAG(pcSPS->getSplitConsOverrideEnabledFlag(), "sps_partition_constraints_override_enabled_flag");
   WRITE_UVLC(floorLog2(pcSPS->getMinQTSize(I_SLICE)) - pcSPS->getLog2MinCodingBlockSize(), "sps_log2_diff_min_qt_min_cb_intra_slice_luma");
@@ -958,7 +958,7 @@
   }
   else
   {
-    CHECK(pcSPS->getBDPCMEnabledFlag(), "BDPCM cannot be used when transform skip is disabled");
+    CHECK_VTM(pcSPS->getBDPCMEnabledFlag(), "BDPCM cannot be used when transform skip is disabled");
   }
   WRITE_FLAG(pcSPS->getUseMTS() ? 1 : 0, "sps_mts_enabled_flag");
   if (pcSPS->getUseMTS())
@@ -974,7 +974,7 @@
     const ChromaQpMappingTable& chromaQpMappingTable = pcSPS->getChromaQpMappingTable();
     WRITE_FLAG(chromaQpMappingTable.getSameCQPTableForAllChromaFlag(), "sps_same_qp_table_for_chroma_flag");
     int numQpTables = chromaQpMappingTable.getSameCQPTableForAllChromaFlag() ? 1 : (pcSPS->getJointCbCrEnabledFlag() ? 3 : 2);
-    CHECK(numQpTables != chromaQpMappingTable.getNumQpTables(), " numQpTables does not match at encoder side ");
+    CHECK_VTM(numQpTables != chromaQpMappingTable.getNumQpTables(), " numQpTables does not match at encoder side ");
     for (int i = 0; i < numQpTables; i++)
     {
       WRITE_SVLC(chromaQpMappingTable.getQpTableStartMinus26(i), "sps_qp_table_starts_minus26");
@@ -1084,9 +1084,9 @@
     WRITE_FLAG(pcSPS->getUseGeo() ? 1 : 0, "sps_gpm_enabled_flag");
     if (pcSPS->getUseGeo())
     {
-      CHECK(pcSPS->getMaxNumMergeCand() < pcSPS->getMaxNumGeoCand(),
+      CHECK_VTM(pcSPS->getMaxNumMergeCand() < pcSPS->getMaxNumGeoCand(),
             "The number of GPM candidates must not be greater than the number of merge candidates");
-      CHECK(2 > pcSPS->getMaxNumGeoCand(),
+      CHECK_VTM(2 > pcSPS->getMaxNumGeoCand(),
             "The number of GPM candidates must not be smaller than 2");
       if (pcSPS->getMaxNumMergeCand() >= 3)
       {
@@ -1112,10 +1112,10 @@
   }
   else
   {
-    CHECK(pcSPS->getHorCollocatedChromaFlag() != 1, "Invalid value for horizontal collocated chroma flag");
-    CHECK(pcSPS->getVerCollocatedChromaFlag() != 1, "Invalid value for vertical collocated chroma flag");
+    CHECK_VTM(pcSPS->getHorCollocatedChromaFlag() != 1, "Invalid value for horizontal collocated chroma flag");
+    CHECK_VTM(pcSPS->getVerCollocatedChromaFlag() != 1, "Invalid value for vertical collocated chroma flag");
   }
-  CHECK(pcSPS->getMaxNumMergeCand() > MRG_MAX_NUM_CANDS, "More merge candidates signalled than supported");
+  CHECK_VTM(pcSPS->getMaxNumMergeCand() > MRG_MAX_NUM_CANDS, "More merge candidates signalled than supported");
   WRITE_FLAG(pcSPS->getPLTMode() ? 1 : 0,                                                    "sps_palette_enabled_flag" );
   if (pcSPS->getChromaFormatIdc() == CHROMA_444 && pcSPS->getLog2MaxTbSize() != 6)
   {
@@ -1128,7 +1128,7 @@
   WRITE_FLAG(pcSPS->getIBCFlag() ? 1 : 0,                                                      "sps_ibc_enabled_flag");
   if (pcSPS->getIBCFlag())
   {
-    CHECK(pcSPS->getMaxNumIBCMergeCand() > IBC_MRG_MAX_NUM_CANDS, "More IBC merge candidates signalled than supported");
+    CHECK_VTM(pcSPS->getMaxNumIBCMergeCand() > IBC_MRG_MAX_NUM_CANDS, "More IBC merge candidates signalled than supported");
     WRITE_UVLC(IBC_MRG_MAX_NUM_CANDS - pcSPS->getMaxNumIBCMergeCand(), "sps_six_minus_max_num_ibc_merge_cand");
   }
 #if LUMA_ADAPTIVE_DEBLOCKING_FILTER_QP_OFFSET
@@ -1175,30 +1175,30 @@
       WRITE_UVLC( pcSPS->getNumVerVirtualBoundaries(), "sps_num_ver_virtual_boundaries");
       if (pcSPS->getMaxPicWidthInLumaSamples() <= 8)
       {
-        CHECK(pcSPS->getNumVerVirtualBoundaries() != 0, "SPS: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
+        CHECK_VTM(pcSPS->getNumVerVirtualBoundaries() != 0, "SPS: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
       }
       else
       {
-        CHECK(pcSPS->getNumVerVirtualBoundaries() > 3, "SPS: The number of vertical virtual boundaries shall be in the range of 0 to 3");
+        CHECK_VTM(pcSPS->getNumVerVirtualBoundaries() > 3, "SPS: The number of vertical virtual boundaries shall be in the range of 0 to 3");
       }
       for( unsigned i = 0; i < pcSPS->getNumVerVirtualBoundaries(); i++ )
       {
         WRITE_UVLC((pcSPS->getVirtualBoundariesPosX(i)>>3) - 1, "sps_virtual_boundary_pos_x_minus1[i]");
-        CHECK(((pcSPS->getVirtualBoundariesPosX(i)>>3) - 1) > (((pcSPS->getMaxPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_width_max_in_luma_samples / 8 ) - 2, inclusive.");
+        CHECK_VTM(((pcSPS->getVirtualBoundariesPosX(i)>>3) - 1) > (((pcSPS->getMaxPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_width_max_in_luma_samples / 8 ) - 2, inclusive.");
       }
       WRITE_UVLC(pcSPS->getNumHorVirtualBoundaries(), "sps_num_hor_virtual_boundaries");
       if (pcSPS->getMaxPicHeightInLumaSamples() <= 8)
       {
-        CHECK(pcSPS->getNumHorVirtualBoundaries() != 0, "SPS: When picture height is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
+        CHECK_VTM(pcSPS->getNumHorVirtualBoundaries() != 0, "SPS: When picture height is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
       }
       else
       {
-        CHECK(pcSPS->getNumHorVirtualBoundaries() > 3, "SPS: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
+        CHECK_VTM(pcSPS->getNumHorVirtualBoundaries() > 3, "SPS: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
       }
       for( unsigned i = 0; i < pcSPS->getNumHorVirtualBoundaries(); i++ )
       {
         WRITE_UVLC((pcSPS->getVirtualBoundariesPosY(i)>>3) - 1, "sps_virtual_boundary_pos_y_minus1[i]");
-        CHECK(((pcSPS->getVirtualBoundariesPosY(i)>>3) - 1) > (((pcSPS->getMaxPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_height_max_in_luma_samples / 8 ) - 2, inclusive.");
+        CHECK_VTM(((pcSPS->getVirtualBoundariesPosY(i)>>3) - 1) > (((pcSPS->getMaxPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_height_max_in_luma_samples / 8 ) - 2, inclusive.");
       }
     }
   }
@@ -1233,7 +1233,7 @@
     g_HLSTraceEnable = traceEnable;
 #endif
     unsigned vui_payload_data_num_bits = bs_count.getNumberOfWrittenBits();
-    CHECK( vui_payload_data_num_bits % 8 != 0, "Invalid number of VUI payload data bits" );
+    CHECK_VTM( vui_payload_data_num_bits % 8 != 0, "Invalid number of VUI payload data bits" );
     setBitstream(bs);
     WRITE_UVLC((vui_payload_data_num_bits >> 3) - 1, "sps_vui_payload_size_minus1");
     while (!isByteAligned())
@@ -1295,7 +1295,7 @@
           break;
         }
         default:
-          CHECK(sps_extension_flags[i]!=false, "Unknown PPS extension signalled"); // Should never get here with an active SPS extension flag.
+          CHECK_VTM(sps_extension_flags[i]!=false, "Unknown PPS extension signalled"); // Should never get here with an active SPS extension flag.
           break;
         }
       }
@@ -1310,7 +1310,7 @@
 #endif
   WRITE_CODE(0, 4, "dci_reserved_zero_4bits");
   uint32_t numPTLs = (uint32_t)dci->getNumPTLs();
-  CHECK( (numPTLs < 1) || ( numPTLs > 15), "dci_num_plts_minus1 shall be in the range of 0 - 14");
+  CHECK_VTM( (numPTLs < 1) || ( numPTLs > 15), "dci_num_plts_minus1 shall be in the range of 0 - 14");
 
   WRITE_CODE(numPTLs - 1, 4, "dci_num_ptls_minus1");
 
@@ -1383,7 +1383,7 @@
         }
       }
     }
-    CHECK(pcVPS->getNumPtls() - 1 >= pcVPS->getTotalNumOLSs(), "vps_num_ptls_minus1 shall be less than TotalNumOlss");
+    CHECK_VTM(pcVPS->getNumPtls() - 1 >= pcVPS->getTotalNumOLSs(), "vps_num_ptls_minus1 shall be less than TotalNumOlss");
     WRITE_CODE(pcVPS->getNumPtls() - 1, 8, "vps_num_ptls_minus1");
   }
 
@@ -1398,7 +1398,7 @@
     }
     else 
     {
-      CHECK(pcVPS->getPtlMaxTemporalId(i) != pcVPS->getMaxSubLayers() - 1, "When vps_default_ptl_dpb_hrd_max_tid_flag is equal to 1, the value of vps_ptl_max_tid[ i ] is inferred to be equal to vps_max_sublayers_minus1");
+      CHECK_VTM(pcVPS->getPtlMaxTemporalId(i) != pcVPS->getMaxSubLayers() - 1, "When vps_default_ptl_dpb_hrd_max_tid_flag is equal to 1, the value of vps_ptl_max_tid[ i ] is inferred to be equal to vps_max_sublayers_minus1");
     }
   }
   int cnt = 0;
@@ -1407,7 +1407,7 @@
     WRITE_FLAG( 0, "vps_ptl_reserved_zero_bit");
     cnt++;
   }
-  CHECK(cnt>=8, "More than '8' alignment bytes written");
+  CHECK_VTM(cnt>=8, "More than '8' alignment bytes written");
   for (int i = 0; i < pcVPS->getNumPtls(); i++)
   {
     codeProfileTierLevel(&pcVPS->getProfileTierLevel(i), pcVPS->getPtPresentFlag(i), pcVPS->getPtlMaxTemporalId(i) - 1);
@@ -1435,12 +1435,12 @@
       }
       else
       {
-        CHECK(pcVPS->m_dpbMaxTemporalId[i] != pcVPS->getMaxSubLayers() - 1, "When vps_default_ptl_dpb_hrd_max_tid_flag is equal to 1, the value of vps_dpb_max_tid[ i ] is inferred to be equal to vps_max_sublayers_minus1");
+        CHECK_VTM(pcVPS->m_dpbMaxTemporalId[i] != pcVPS->getMaxSubLayers() - 1, "When vps_default_ptl_dpb_hrd_max_tid_flag is equal to 1, the value of vps_dpb_max_tid[ i ] is inferred to be equal to vps_max_sublayers_minus1");
       }
 
       for( int j = ( pcVPS->m_sublayerDpbParamsPresentFlag ? 0 : pcVPS->m_dpbMaxTemporalId[i] ); j <= pcVPS->m_dpbMaxTemporalId[i]; j++ )
       {
-        CHECK(pcVPS->m_dpbParameters[i].m_maxDecPicBuffering[j] < 1, "MaxDecPicBuffering must be greater than 0");
+        CHECK_VTM(pcVPS->m_dpbParameters[i].m_maxDecPicBuffering[j] < 1, "MaxDecPicBuffering must be greater than 0");
         WRITE_UVLC(pcVPS->m_dpbParameters[i].m_maxDecPicBuffering[j] - 1, "dpb_max_dec_pic_buffering_minus1[i]");
         WRITE_UVLC( pcVPS->m_dpbParameters[i].m_maxNumReorderPics[j], "dpb_max_num_reorder_pics[i]" );
         WRITE_UVLC( pcVPS->m_dpbParameters[i].m_maxLatencyIncreasePlus1[j], "dpb_max_latency_increase_plus1[i]" );
@@ -1457,7 +1457,7 @@
         const Profile::Name profile = pcVPS->getProfileTierLevel(pcVPS->getOlsPtlIdx(i)).getProfileIdc();
         if (profile != Profile::NONE)
         {
-          CHECK(pcVPS->m_olsDpbBitDepthMinus8[i] + 8 > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "vps_ols_dpb_bitdepth_minus8[ i ] exceeds range supported by signalled profile");
+          CHECK_VTM(pcVPS->m_olsDpbBitDepthMinus8[i] + 8 > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "vps_ols_dpb_bitdepth_minus8[ i ] exceeds range supported by signalled profile");
         }
         WRITE_UVLC( pcVPS->m_olsDpbBitDepthMinus8[i], "vps_ols_dpb_bitdepth_minus8[i]");
         if( (pcVPS->m_numDpbParams > 1) && (pcVPS->m_numDpbParams != pcVPS->m_numMultiLayeredOlss) )
@@ -1487,7 +1487,7 @@
       }
       else 
       {
-        CHECK(pcVPS->getHrdMaxTid(i) != pcVPS->getMaxSubLayers() - 1, "When vps_default_ptl_dpb_hrd_max_tid_flag is equal to 1, the value of vps_hrd_max_tid[ i ] is inferred to be equal to vps_max_sublayers_minus1");
+        CHECK_VTM(pcVPS->getHrdMaxTid(i) != pcVPS->getMaxSubLayers() - 1, "When vps_default_ptl_dpb_hrd_max_tid_flag is equal to 1, the value of vps_hrd_max_tid[ i ] is inferred to be equal to vps_max_sublayers_minus1");
       }
       uint32_t firstSublayer = pcVPS->getVPSSublayerCpbParamsPresentFlag() ? 0 : pcVPS->getHrdMaxTid(i);
       codeOlsHrdParameters(pcVPS->getGeneralHrdParameters(), pcVPS->getOlsHrdParameters(i),firstSublayer, pcVPS->getHrdMaxTid(i));
@@ -1535,9 +1535,9 @@
   // parameter sets
   WRITE_UVLC(picHeader->getPPSId(), "ph_pic_parameter_set_id");
   pps = slice->getPPS();
-  CHECK(pps == 0, "Invalid PPS");
+  CHECK_VTM(pps == 0, "Invalid PPS");
   sps = slice->getSPS();
-  CHECK(sps == 0, "Invalid SPS");
+  CHECK_VTM(sps == 0, "Invalid SPS");
   int pocBits = slice->getSPS()->getBitsForPOC();
   int pocMask = (1 << pocBits) - 1;
   WRITE_CODE(slice->getPOC() & pocMask, pocBits, "ph_pic_order_cnt_lsb");
@@ -1670,30 +1670,30 @@
       WRITE_UVLC(picHeader->getNumVerVirtualBoundaries(), "ph_num_ver_virtual_boundaries");
       if (pps->getPicWidthInLumaSamples() <= 8)
       {
-        CHECK(picHeader->getNumVerVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
+        CHECK_VTM(picHeader->getNumVerVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
       }
       else
       {
-        CHECK(picHeader->getNumVerVirtualBoundaries() > 3, "PH: The number of vertical virtual boundaries shall be in the range of 0 to 3");
+        CHECK_VTM(picHeader->getNumVerVirtualBoundaries() > 3, "PH: The number of vertical virtual boundaries shall be in the range of 0 to 3");
       }
       for( unsigned i = 0; i < picHeader->getNumVerVirtualBoundaries(); i++ )
       {
         WRITE_UVLC((picHeader->getVirtualBoundariesPosX(i) >> 3) - 1, "ph_virtual_boundary_pos_x_minus1[i]");
-        CHECK(((picHeader->getVirtualBoundariesPosX(i)>>3) - 1) > (((pps->getPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_width_in_luma_samples / 8 ) - 2, inclusive.");
+        CHECK_VTM(((picHeader->getVirtualBoundariesPosX(i)>>3) - 1) > (((pps->getPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_width_in_luma_samples / 8 ) - 2, inclusive.");
       }
       WRITE_UVLC(picHeader->getNumHorVirtualBoundaries(), "ph_num_hor_virtual_boundaries");
       if (pps->getPicHeightInLumaSamples() <= 8)
       {
-        CHECK(picHeader->getNumHorVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
+        CHECK_VTM(picHeader->getNumHorVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
       }
       else
       {
-        CHECK(picHeader->getNumHorVirtualBoundaries() > 3, "PH: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
+        CHECK_VTM(picHeader->getNumHorVirtualBoundaries() > 3, "PH: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
       }
       for( unsigned i = 0; i < picHeader->getNumHorVirtualBoundaries(); i++ )
       {
         WRITE_UVLC((picHeader->getVirtualBoundariesPosY(i)>>3) - 1, "ph_virtual_boundary_pos_y_minus1[i]");
-        CHECK(((picHeader->getVirtualBoundariesPosY(i)>>3) - 1) > (((pps->getPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_height_in_luma_samples / 8 ) - 2, inclusive.");
+        CHECK_VTM(((picHeader->getVirtualBoundariesPosY(i)>>3) - 1) > (((pps->getPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_height_in_luma_samples / 8 ) - 2, inclusive.");
       }
     }
     else
@@ -1742,13 +1742,13 @@
       }
       else if(sps->getNumRPL(listIdx) == 0)
       {
-        CHECK(picHeader->getRPLIdx(listIdx) != -1, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
+        CHECK_VTM(picHeader->getRPLIdx(listIdx) != -1, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
       }
       else if(listIdx == 1)
       {
         auto rplsSpsFlag0 = picHeader->getRPLIdx(0) != -1 ? 1 : 0;
         auto rplsSpsFlag1 = picHeader->getRPLIdx(1) != -1 ? 1 : 0;
-        CHECK(rplsSpsFlag1 != rplsSpsFlag0, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
+        CHECK_VTM(rplsSpsFlag1 != rplsSpsFlag0, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
       }
 
       if(picHeader->getRPLIdx(listIdx) != -1)
@@ -1761,11 +1761,11 @@
         }
         else if(sps->getNumRPL(listIdx) == 1)
         {
-          CHECK(picHeader->getRPLIdx(listIdx) != 0, "RPL1Idx is not signalled but it is not equal to 0");
+          CHECK_VTM(picHeader->getRPLIdx(listIdx) != 0, "RPL1Idx is not signalled but it is not equal to 0");
         }
         else
         {
-          CHECK(picHeader->getRPL1idx() != picHeader->getRPL0idx(), "RPL1Idx is not signalled but it is not the same as RPL0Idx");
+          CHECK_VTM(picHeader->getRPL1idx() != picHeader->getRPL0idx(), "RPL1Idx is not signalled but it is not the same as RPL0Idx");
         }
       }
       // explicit RPL in picture header
@@ -2152,7 +2152,7 @@
   }
   if (!picHeader->getPicIntraSliceAllowedFlag())
   {
-    CHECK(pcSlice->getSliceType() == I_SLICE, "when ph_intra_slice_allowed_flag = 0, no I_Slice is allowed");
+    CHECK_VTM(pcSlice->getSliceType() == I_SLICE, "when ph_intra_slice_allowed_flag = 0, no I_Slice is allowed");
   }
 
   if (pcSlice->getSPS()->getALFEnabledFlag() && !pcSlice->getPPS()->getAlfInfoInPhFlag())
@@ -2260,13 +2260,13 @@
       }
       else if (pcSlice->getSPS()->getNumRPL1() == 0)
       {
-        CHECK(pcSlice->getRPL1idx() != -1, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
+        CHECK_VTM(pcSlice->getRPL1idx() != -1, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
       }
       else
       {
         auto rplsSpsFlag0 = pcSlice->getRPL0idx() != -1 ? 1 : 0;
         auto rplsSpsFlag1 = pcSlice->getRPL1idx() != -1 ? 1 : 0;
-        CHECK(rplsSpsFlag1 != rplsSpsFlag0, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
+        CHECK_VTM(rplsSpsFlag1 != rplsSpsFlag0, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
       }
 
       if (pcSlice->getRPL1idx() != -1)
@@ -2282,11 +2282,11 @@
         }
         else if (pcSlice->getSPS()->getNumRPL1() == 1)
         {
-          CHECK(pcSlice->getRPL1idx() != 0, "RPL1Idx is not signalled but it is not equal to 0");
+          CHECK_VTM(pcSlice->getRPL1idx() != 0, "RPL1Idx is not signalled but it is not equal to 0");
         }
         else
         {
-          CHECK(pcSlice->getRPL1idx() != pcSlice->getRPL0idx(), "RPL1Idx is not signalled but it is not the same as RPL0Idx");
+          CHECK_VTM(pcSlice->getRPL1idx() != pcSlice->getRPL0idx(), "RPL1Idx is not signalled but it is not the same as RPL0Idx");
         }
       }
       else
@@ -2413,7 +2413,7 @@
           WRITE_SVLC( pcSlice->getSliceChromaQpDelta(JOINT_CbCr), "sh_joint_cbcr_qp_offset");
         }
       }
-      CHECK(numberValidComponents < COMPONENT_Cr+1, "Too many valid components");
+      CHECK_VTM(numberValidComponents < COMPONENT_Cr+1, "Too many valid components");
     }
 
     if (pcSlice->getPPS()->getCuChromaQpOffsetListEnabledFlag())
@@ -2690,7 +2690,7 @@
   while (maxOffset >= (1u << (offsetLenMinus1 + 1)))
   {
     offsetLenMinus1++;
-    CHECK(offsetLenMinus1 + 1 >= 32, "Invalid offset length minus 1");
+    CHECK_VTM(offsetLenMinus1 + 1 >= 32, "Invalid offset length minus 1");
   }
 
   if (pSlice->getNumberOfSubstreamSizes()>0)
@@ -2737,7 +2737,7 @@
 
           if( bChroma )
           {
-            CHECK(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
+            CHECK_VTM(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
                   "Chroma blocks of different size not supported");
             iDeltaDenom = (wp[COMPONENT_Cb].log2WeightDenom - wp[COMPONENT_Y].log2WeightDenom);
             WRITE_SVLC( iDeltaDenom, "delta_chroma_log2_weight_denom" );
@@ -2752,7 +2752,7 @@
         for ( int iRefIdx=0 ; iRefIdx<pcSlice->getNumRefIdx(eRefPicList) ; iRefIdx++ )
         {
           wp = pcSlice->getWpScaling(eRefPicList, iRefIdx);
-          CHECK(wp[COMPONENT_Cb].presentFlag != wp[COMPONENT_Cr].presentFlag,
+          CHECK_VTM(wp[COMPONENT_Cb].presentFlag != wp[COMPONENT_Cr].presentFlag,
                 "Inconsistent settings for chroma channels");
           WRITE_FLAG(wp[COMPONENT_Cb].presentFlag,
                      iNumRef == 0 ? "chroma_weight_l0_flag[i]" : "chroma_weight_l1_flag[i]");
@@ -2776,7 +2776,7 @@
           {
             for ( int j = COMPONENT_Cb ; j < numberValidComponents ; j++ )
             {
-              CHECK(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
+              CHECK_VTM(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
                     "Chroma blocks of different size not supported");
               int iDeltaWeight = (wp[j].codedWeight - (1 << wp[COMPONENT_Cb].log2WeightDenom));
               WRITE_SVLC( iDeltaWeight, iNumRef==0?"delta_chroma_weight_l0[i]":"delta_chroma_weight_l1[i]" );
@@ -2790,7 +2790,7 @@
         }
       }
     }
-    CHECK(uiTotalSignalledWeightFlags>24, "Too many signalled weight flags");
+    CHECK_VTM(uiTotalSignalledWeightFlags>24, "Too many signalled weight flags");
   }
 }
 
@@ -2820,7 +2820,7 @@
 
         if (chroma)
         {
-          CHECK(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
+          CHECK_VTM(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
                 "Chroma blocks of different size not supported");
           deltaDenom = (wp[COMPONENT_Cb].log2WeightDenom - wp[COMPONENT_Y].log2WeightDenom);
           WRITE_SVLC(deltaDenom, "delta_chroma_log2_weight_denom");
@@ -2835,7 +2835,7 @@
       for (int refIdx = 0; refIdx < numLxWeights; refIdx++)
       {
         wp = picHeader->getWpScaling(refPicList, refIdx);
-        CHECK(wp[COMPONENT_Cb].presentFlag != wp[COMPONENT_Cr].presentFlag,
+        CHECK_VTM(wp[COMPONENT_Cb].presentFlag != wp[COMPONENT_Cr].presentFlag,
               "Inconsistent settings for chroma channels");
         WRITE_FLAG(wp[COMPONENT_Cb].presentFlag, numRef == 0 ? "chroma_weight_l0_flag[i]" : "chroma_weight_l1_flag[i]");
         totalSignalledWeightFlags += 2 * wp[COMPONENT_Cb].presentFlag;
@@ -2858,7 +2858,7 @@
         {
           for (int j = COMPONENT_Cb; j < numberValidComponents; j++)
           {
-            CHECK(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
+            CHECK_VTM(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
                   "Chroma blocks of different size not supported");
             int deltaWeight = (wp[j].codedWeight - (1 << wp[COMPONENT_Cb].log2WeightDenom));
             WRITE_SVLC(deltaWeight, numRef == 0 ? "delta_chroma_weight_l0[i]" : "delta_chroma_weight_l1[i]");
@@ -2881,7 +2881,7 @@
       moreSyntaxToBeParsed = (numLxWeights == 0) ? false : true;
     }
   }
-  CHECK(totalSignalledWeightFlags > 24, "Too many signalled weight flags");
+  CHECK_VTM(totalSignalledWeightFlags > 24, "Too many signalled weight flags");
 }
 
 /** code quantization matrix
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/WeightPredAnalysis.cpp ../VVCSoftware_10/source/Lib/EncoderLib/WeightPredAnalysis.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/EncoderLib/WeightPredAnalysis.cpp	2022-09-16 14:27:06.160532464 +0200
+++ ../VVCSoftware_10/source/Lib/EncoderLib/WeightPredAnalysis.cpp	2022-05-13 17:45:29.424142993 +0200
@@ -108,7 +108,7 @@
                      const int               offset,
                      const bool              bHighPrecision)
 {
-  CHECK(&histogramInput == &histogramOutput, "Input and output histogram are the same");
+  CHECK_VTM(&histogramInput == &histogramOutput, "Input and output histogram are the same");
   const int numElements=int(histogramInput.size());
   histogramOutput.clear();
   histogramOutput.resize(numElements);
@@ -133,7 +133,7 @@
   const std::vector<int>& histogram1)
 {
   Distortion distortion = 0;
-  CHECK(histogram0.size() != histogram1.size(), "Different histogram sizes");
+  CHECK_VTM(histogram0.size() != histogram1.size(), "Different histogram sizes");
   const int numElements = int(histogram0.size());
 
   int64_t  cumul = 0;
@@ -408,7 +408,7 @@
   const bool bUseHighPrecisionWeighting = slice->getSPS()->getSpsRangeExtension().getHighPrecisionOffsetsEnabledFlag();
   const int numPredDir                  = slice->isInterP() ? 1 : 2;
 
-  CHECK(numPredDir > int(NUM_REF_PIC_LIST_01), "Invalid reference picture list");
+  CHECK_VTM(numPredDir > int(NUM_REF_PIC_LIST_01), "Invalid reference picture list");
 
   for ( int refList = 0; refList < numPredDir; refList++ )
   {
@@ -486,7 +486,7 @@
   const int               numPredDir       = slice->isInterP() ? 1 : 2;
   const bool              useHighPrecision = slice->getSPS()->getSpsRangeExtension().getHighPrecisionOffsetsEnabledFlag();
 
-  CHECK(numPredDir > int(NUM_REF_PIC_LIST_01), "Invalid reference picture list");
+  CHECK_VTM(numPredDir > int(NUM_REF_PIC_LIST_01), "Invalid reference picture list");
 
   for ( int refList = 0; refList < numPredDir; refList++ )
   {
@@ -649,7 +649,7 @@
   const int               numPredDir                          = slice->isInterP() ? 1 : 2;
   const bool              useHighPrecisionPredictionWeighting = slice->getSPS()->getSpsRangeExtension().getHighPrecisionOffsetsEnabledFlag();
 
-  CHECK(numPredDir > int(NUM_REF_PIC_LIST_01), "Invalid reference picture list");
+  CHECK_VTM(numPredDir > int(NUM_REF_PIC_LIST_01), "Invalid reference picture list");
 
   for ( int refList = 0; refList < numPredDir; refList++ )
   {
diff -rwu ../vtm10_original/VVCSoftware_VTM/source/Lib/Utilities/VideoIOYuv.cpp ../VVCSoftware_10/source/Lib/Utilities/VideoIOYuv.cpp
--- ../vtm10_original/VVCSoftware_VTM/source/Lib/Utilities/VideoIOYuv.cpp	2022-09-16 14:27:06.160532464 +0200
+++ ../VVCSoftware_10/source/Lib/Utilities/VideoIOYuv.cpp	2022-05-13 17:45:28.600152325 +0200
@@ -472,7 +472,7 @@
   const uint32_t height_file = height444 >> csy_file;
   const bool     writePYUV   = (packedYUVOutputMode > 0) && (fileBitDepth == 10 || fileBitDepth == 12) && ((width_file & (1 + (fileBitDepth & 3))) == 0);
 
-  CHECK( csx_file != csx_src, "Not supported" );
+  CHECK_VTM( csx_file != csx_src, "Not supported" );
   const uint32_t stride_file = writePYUV ? ( orgWidth * fileBitDepth ) >> ( csx_file + 3 ) : ( orgWidth * ( is16bit ? 2 : 1 ) ) >> csx_file;
 
   std::vector<uint8_t> bufVec(stride_file);
@@ -1142,7 +1142,7 @@
   const CPelUnitBuf& picBottomO  = nonZeroBitDepthShift ? picBottomZ : picBottomC;
 
   bool retval = true;
-  CHECK( picTopO.chromaFormat != picBottomO.chromaFormat, "Incompatible formats of bottom and top fields" );
+  CHECK_VTM( picTopO.chromaFormat != picBottomO.chromaFormat, "Incompatible formats of bottom and top fields" );
 
   const ChromaFormat dstChrFormat = picTopO.chromaFormat;
   for (uint32_t comp = 0; retval && comp < ::getNumberValidComponents(dstChrFormat); comp++)
@@ -1155,9 +1155,9 @@
     const uint32_t    width444   = areaTopY.width  - (confLeft + confRight);
     const uint32_t    height444  = areaTopY.height - (confTop + confBottom);
 
-    CHECK(areaTop.width  != areaBottom.width , "Incompatible formats");
-    CHECK(areaTop.height != areaBottom.height, "Incompatible formats");
-    CHECK(areaTop.stride != areaBottom.stride, "Incompatible formats");
+    CHECK_VTM(areaTop.width  != areaBottom.width , "Incompatible formats");
+    CHECK_VTM(areaTop.height != areaBottom.height, "Incompatible formats");
+    CHECK_VTM(areaTop.stride != areaBottom.stride, "Incompatible formats");
 
     if ((width444 == 0) || (height444 == 0))
     {
@@ -1196,7 +1196,7 @@
       if (format!=CHROMA_444)
       {
         // only 444 is handled.
-        CHECK( format != CHROMA_444, "Chroma format other than 444 not supported" );
+        CHECK_VTM( format != CHROMA_444, "Chroma format other than 444 not supported" );
       }
 
       {
@@ -1220,7 +1220,7 @@
         if (format!=CHROMA_444)
         {
           // only 444 is handled.
-          CHECK(format!=CHROMA_444, "Chroma format other than 444 not supported");
+          CHECK_VTM(format!=CHROMA_444, "Chroma format other than 444 not supported");
         }
 
         // channel re-mapping
